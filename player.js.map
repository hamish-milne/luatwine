{
  "version": 3,
  "sources": ["pnp:/home/runner/work/moontale/moontale/.yarn/cache/markdown-it-npm-13.0.1-dcb1a8675c-faf5891d38.zip/node_modules/markdown-it/lib/token.js", "pnp:/home/runner/work/moontale/moontale/.yarn/cache/markdown-it-npm-13.0.1-dcb1a8675c-faf5891d38.zip/node_modules/markdown-it/lib/ruler.js", "pnp:/home/runner/work/moontale/moontale/.yarn/cache/markdown-it-npm-13.0.1-dcb1a8675c-faf5891d38.zip/node_modules/markdown-it/lib/rules_inline/text.js", "pnp:/home/runner/work/moontale/moontale/.yarn/cache/markdown-it-npm-13.0.1-dcb1a8675c-faf5891d38.zip/node_modules/markdown-it/lib/rules_inline/linkify.js", "pnp:/home/runner/work/moontale/moontale/.yarn/cache/markdown-it-npm-13.0.1-dcb1a8675c-faf5891d38.zip/node_modules/markdown-it/lib/common/entities.js", "pnp:/home/runner/work/moontale/moontale/.yarn/cache/uc.micro-npm-1.0.6-36f3dc2fc4-6898bb5563.zip/node_modules/uc.micro/categories/P/regex.js", "pnp:/home/runner/work/moontale/moontale/.yarn/cache/mdurl-npm-1.0.1-054d974269-71731ecba9.zip/node_modules/mdurl/index.js", "pnp:/home/runner/work/moontale/moontale/.yarn/cache/uc.micro-npm-1.0.6-36f3dc2fc4-6898bb5563.zip/node_modules/uc.micro/properties/Any/regex.js", "pnp:/home/runner/work/moontale/moontale/.yarn/cache/uc.micro-npm-1.0.6-36f3dc2fc4-6898bb5563.zip/node_modules/uc.micro/categories/Cc/regex.js", "pnp:/home/runner/work/moontale/moontale/.yarn/cache/uc.micro-npm-1.0.6-36f3dc2fc4-6898bb5563.zip/node_modules/uc.micro/categories/Cf/regex.js", "pnp:/home/runner/work/moontale/moontale/.yarn/cache/uc.micro-npm-1.0.6-36f3dc2fc4-6898bb5563.zip/node_modules/uc.micro/categories/Z/regex.js", "pnp:/home/runner/work/moontale/moontale/.yarn/cache/uc.micro-npm-1.0.6-36f3dc2fc4-6898bb5563.zip/node_modules/uc.micro/index.js", "pnp:/home/runner/work/moontale/moontale/.yarn/cache/markdown-it-npm-13.0.1-dcb1a8675c-faf5891d38.zip/node_modules/markdown-it/lib/common/utils.js", "pnp:/home/runner/work/moontale/moontale/.yarn/cache/markdown-it-npm-13.0.1-dcb1a8675c-faf5891d38.zip/node_modules/markdown-it/lib/rules_inline/newline.js", "pnp:/home/runner/work/moontale/moontale/.yarn/cache/markdown-it-npm-13.0.1-dcb1a8675c-faf5891d38.zip/node_modules/markdown-it/lib/rules_inline/escape.js", "pnp:/home/runner/work/moontale/moontale/.yarn/cache/markdown-it-npm-13.0.1-dcb1a8675c-faf5891d38.zip/node_modules/markdown-it/lib/rules_inline/backticks.js", "pnp:/home/runner/work/moontale/moontale/.yarn/cache/markdown-it-npm-13.0.1-dcb1a8675c-faf5891d38.zip/node_modules/markdown-it/lib/rules_inline/strikethrough.js", "pnp:/home/runner/work/moontale/moontale/.yarn/cache/markdown-it-npm-13.0.1-dcb1a8675c-faf5891d38.zip/node_modules/markdown-it/lib/rules_inline/emphasis.js", "pnp:/home/runner/work/moontale/moontale/.yarn/cache/markdown-it-npm-13.0.1-dcb1a8675c-faf5891d38.zip/node_modules/markdown-it/lib/rules_inline/link.js", "pnp:/home/runner/work/moontale/moontale/.yarn/cache/markdown-it-npm-13.0.1-dcb1a8675c-faf5891d38.zip/node_modules/markdown-it/lib/rules_inline/image.js", "pnp:/home/runner/work/moontale/moontale/.yarn/cache/markdown-it-npm-13.0.1-dcb1a8675c-faf5891d38.zip/node_modules/markdown-it/lib/rules_inline/autolink.js", "pnp:/home/runner/work/moontale/moontale/.yarn/cache/markdown-it-npm-13.0.1-dcb1a8675c-faf5891d38.zip/node_modules/markdown-it/lib/common/html_re.js", "pnp:/home/runner/work/moontale/moontale/.yarn/cache/markdown-it-npm-13.0.1-dcb1a8675c-faf5891d38.zip/node_modules/markdown-it/lib/rules_inline/html_inline.js", "pnp:/home/runner/work/moontale/moontale/.yarn/cache/markdown-it-npm-13.0.1-dcb1a8675c-faf5891d38.zip/node_modules/markdown-it/lib/rules_inline/entity.js", "pnp:/home/runner/work/moontale/moontale/.yarn/cache/markdown-it-npm-13.0.1-dcb1a8675c-faf5891d38.zip/node_modules/markdown-it/lib/rules_inline/balance_pairs.js", "pnp:/home/runner/work/moontale/moontale/.yarn/cache/markdown-it-npm-13.0.1-dcb1a8675c-faf5891d38.zip/node_modules/markdown-it/lib/rules_inline/fragments_join.js", "pnp:/home/runner/work/moontale/moontale/.yarn/cache/markdown-it-npm-13.0.1-dcb1a8675c-faf5891d38.zip/node_modules/markdown-it/lib/rules_inline/state_inline.js", "pnp:/home/runner/work/moontale/moontale/.yarn/cache/markdown-it-npm-13.0.1-dcb1a8675c-faf5891d38.zip/node_modules/markdown-it/lib/parser_inline.js", "pnp:/home/runner/work/moontale/moontale/.yarn/cache/markdown-it-npm-13.0.1-dcb1a8675c-faf5891d38.zip/node_modules/markdown-it/lib/rules_block/table.js", "pnp:/home/runner/work/moontale/moontale/.yarn/cache/markdown-it-npm-13.0.1-dcb1a8675c-faf5891d38.zip/node_modules/markdown-it/lib/rules_block/code.js", "pnp:/home/runner/work/moontale/moontale/.yarn/cache/markdown-it-npm-13.0.1-dcb1a8675c-faf5891d38.zip/node_modules/markdown-it/lib/rules_block/fence.js", "pnp:/home/runner/work/moontale/moontale/.yarn/cache/markdown-it-npm-13.0.1-dcb1a8675c-faf5891d38.zip/node_modules/markdown-it/lib/rules_block/blockquote.js", "pnp:/home/runner/work/moontale/moontale/.yarn/cache/markdown-it-npm-13.0.1-dcb1a8675c-faf5891d38.zip/node_modules/markdown-it/lib/rules_block/hr.js", "pnp:/home/runner/work/moontale/moontale/.yarn/cache/markdown-it-npm-13.0.1-dcb1a8675c-faf5891d38.zip/node_modules/markdown-it/lib/rules_block/list.js", "pnp:/home/runner/work/moontale/moontale/.yarn/cache/markdown-it-npm-13.0.1-dcb1a8675c-faf5891d38.zip/node_modules/markdown-it/lib/rules_block/reference.js", "pnp:/home/runner/work/moontale/moontale/.yarn/cache/markdown-it-npm-13.0.1-dcb1a8675c-faf5891d38.zip/node_modules/markdown-it/lib/common/html_blocks.js", "pnp:/home/runner/work/moontale/moontale/.yarn/cache/markdown-it-npm-13.0.1-dcb1a8675c-faf5891d38.zip/node_modules/markdown-it/lib/rules_block/html_block.js", "pnp:/home/runner/work/moontale/moontale/.yarn/cache/markdown-it-npm-13.0.1-dcb1a8675c-faf5891d38.zip/node_modules/markdown-it/lib/rules_block/heading.js", "pnp:/home/runner/work/moontale/moontale/.yarn/cache/markdown-it-npm-13.0.1-dcb1a8675c-faf5891d38.zip/node_modules/markdown-it/lib/rules_block/lheading.js", "pnp:/home/runner/work/moontale/moontale/.yarn/cache/markdown-it-npm-13.0.1-dcb1a8675c-faf5891d38.zip/node_modules/markdown-it/lib/rules_block/paragraph.js", "pnp:/home/runner/work/moontale/moontale/.yarn/cache/markdown-it-npm-13.0.1-dcb1a8675c-faf5891d38.zip/node_modules/markdown-it/lib/rules_block/state_block.js", "pnp:/home/runner/work/moontale/moontale/.yarn/cache/markdown-it-npm-13.0.1-dcb1a8675c-faf5891d38.zip/node_modules/markdown-it/lib/parser_block.js", "pnp:/home/runner/work/moontale/moontale/.yarn/cache/markdown-it-npm-13.0.1-dcb1a8675c-faf5891d38.zip/node_modules/markdown-it/lib/rules_core/normalize.js", "pnp:/home/runner/work/moontale/moontale/.yarn/cache/markdown-it-npm-13.0.1-dcb1a8675c-faf5891d38.zip/node_modules/markdown-it/lib/rules_core/block.js", "pnp:/home/runner/work/moontale/moontale/.yarn/cache/markdown-it-npm-13.0.1-dcb1a8675c-faf5891d38.zip/node_modules/markdown-it/lib/rules_core/inline.js", "pnp:/home/runner/work/moontale/moontale/.yarn/cache/markdown-it-npm-13.0.1-dcb1a8675c-faf5891d38.zip/node_modules/markdown-it/lib/rules_core/linkify.js", "pnp:/home/runner/work/moontale/moontale/.yarn/cache/markdown-it-npm-13.0.1-dcb1a8675c-faf5891d38.zip/node_modules/markdown-it/lib/rules_core/replacements.js", "pnp:/home/runner/work/moontale/moontale/.yarn/cache/markdown-it-npm-13.0.1-dcb1a8675c-faf5891d38.zip/node_modules/markdown-it/lib/rules_core/smartquotes.js", "pnp:/home/runner/work/moontale/moontale/.yarn/cache/markdown-it-npm-13.0.1-dcb1a8675c-faf5891d38.zip/node_modules/markdown-it/lib/rules_core/text_join.js", "pnp:/home/runner/work/moontale/moontale/.yarn/cache/markdown-it-npm-13.0.1-dcb1a8675c-faf5891d38.zip/node_modules/markdown-it/lib/rules_core/state_core.js", "pnp:/home/runner/work/moontale/moontale/.yarn/cache/markdown-it-npm-13.0.1-dcb1a8675c-faf5891d38.zip/node_modules/markdown-it/lib/parser_core.js", "pnp:/home/runner/work/moontale/moontale/.yarn/cache/fengari-npm-0.1.4-f367acc87f-bd6b04f973.zip/node_modules/fengari/src/luaconf.js", "pnp:/home/runner/work/moontale/moontale/.yarn/cache/fengari-npm-0.1.4-f367acc87f-bd6b04f973.zip/node_modules/fengari/src/defs.js", "pnp:/home/runner/work/moontale/moontale/.yarn/cache/fengari-npm-0.1.4-f367acc87f-bd6b04f973.zip/node_modules/fengari/src/fengaricore.js", "pnp:/home/runner/work/moontale/moontale/.yarn/cache/fengari-npm-0.1.4-f367acc87f-bd6b04f973.zip/node_modules/fengari/src/llimits.js", "pnp:/home/runner/work/moontale/moontale/.yarn/cache/fengari-npm-0.1.4-f367acc87f-bd6b04f973.zip/node_modules/fengari/src/ljstype.js", "pnp:/home/runner/work/moontale/moontale/.yarn/cache/fengari-npm-0.1.4-f367acc87f-bd6b04f973.zip/node_modules/fengari/src/lstring.js", "pnp:/home/runner/work/moontale/moontale/.yarn/cache/fengari-npm-0.1.4-f367acc87f-bd6b04f973.zip/node_modules/fengari/src/ltable.js", "pnp:/home/runner/work/moontale/moontale/.yarn/cache/fengari-npm-0.1.4-f367acc87f-bd6b04f973.zip/node_modules/fengari/src/lopcodes.js", "pnp:/home/runner/work/moontale/moontale/.yarn/cache/fengari-npm-0.1.4-f367acc87f-bd6b04f973.zip/node_modules/fengari/src/lvm.js", "pnp:/home/runner/work/moontale/moontale/.yarn/cache/fengari-npm-0.1.4-f367acc87f-bd6b04f973.zip/node_modules/fengari/src/ltm.js", "pnp:/home/runner/work/moontale/moontale/.yarn/cache/fengari-npm-0.1.4-f367acc87f-bd6b04f973.zip/node_modules/fengari/src/lstate.js", "pnp:/home/runner/work/moontale/moontale/.yarn/cache/fengari-npm-0.1.4-f367acc87f-bd6b04f973.zip/node_modules/fengari/src/lobject.js", "pnp:/home/runner/work/moontale/moontale/.yarn/cache/fengari-npm-0.1.4-f367acc87f-bd6b04f973.zip/node_modules/fengari/src/lfunc.js", "pnp:/home/runner/work/moontale/moontale/.yarn/cache/fengari-npm-0.1.4-f367acc87f-bd6b04f973.zip/node_modules/fengari/src/lzio.js", "pnp:/home/runner/work/moontale/moontale/.yarn/cache/fengari-npm-0.1.4-f367acc87f-bd6b04f973.zip/node_modules/fengari/src/llex.js", "pnp:/home/runner/work/moontale/moontale/.yarn/cache/fengari-npm-0.1.4-f367acc87f-bd6b04f973.zip/node_modules/fengari/src/lcode.js", "pnp:/home/runner/work/moontale/moontale/.yarn/cache/fengari-npm-0.1.4-f367acc87f-bd6b04f973.zip/node_modules/fengari/src/lparser.js", "pnp:/home/runner/work/moontale/moontale/.yarn/cache/fengari-npm-0.1.4-f367acc87f-bd6b04f973.zip/node_modules/fengari/src/lundump.js", "pnp:/home/runner/work/moontale/moontale/.yarn/cache/fengari-npm-0.1.4-f367acc87f-bd6b04f973.zip/node_modules/fengari/src/ldo.js", "pnp:/home/runner/work/moontale/moontale/.yarn/cache/fengari-npm-0.1.4-f367acc87f-bd6b04f973.zip/node_modules/fengari/src/ldebug.js", "pnp:/home/runner/work/moontale/moontale/.yarn/cache/fengari-npm-0.1.4-f367acc87f-bd6b04f973.zip/node_modules/fengari/src/ldump.js", "pnp:/home/runner/work/moontale/moontale/.yarn/cache/fengari-npm-0.1.4-f367acc87f-bd6b04f973.zip/node_modules/fengari/src/lapi.js", "pnp:/home/runner/work/moontale/moontale/.yarn/cache/fengari-npm-0.1.4-f367acc87f-bd6b04f973.zip/node_modules/fengari/src/lua.js", "pnp:/home/runner/work/moontale/moontale/.yarn/cache/fengari-npm-0.1.4-f367acc87f-bd6b04f973.zip/node_modules/fengari/src/lauxlib.js", "pnp:/home/runner/work/moontale/moontale/.yarn/cache/fengari-npm-0.1.4-f367acc87f-bd6b04f973.zip/node_modules/fengari/src/lbaselib.js", "pnp:/home/runner/work/moontale/moontale/.yarn/cache/fengari-npm-0.1.4-f367acc87f-bd6b04f973.zip/node_modules/fengari/src/lcorolib.js", "pnp:/home/runner/work/moontale/moontale/.yarn/cache/fengari-npm-0.1.4-f367acc87f-bd6b04f973.zip/node_modules/fengari/src/ltablib.js", "pnp:/home/runner/work/moontale/moontale/.yarn/cache/fengari-npm-0.1.4-f367acc87f-bd6b04f973.zip/node_modules/fengari/src/loslib.js", "pnp:/home/runner/work/moontale/moontale/.yarn/cache/sprintf-js-npm-1.1.2-ea16269a6d-d4bb464646.zip/node_modules/sprintf-js/src/sprintf.js", "pnp:/home/runner/work/moontale/moontale/.yarn/cache/fengari-npm-0.1.4-f367acc87f-bd6b04f973.zip/node_modules/fengari/src/lstrlib.js", "pnp:/home/runner/work/moontale/moontale/.yarn/cache/fengari-npm-0.1.4-f367acc87f-bd6b04f973.zip/node_modules/fengari/src/lutf8lib.js", "pnp:/home/runner/work/moontale/moontale/.yarn/cache/fengari-npm-0.1.4-f367acc87f-bd6b04f973.zip/node_modules/fengari/src/lmathlib.js", "pnp:/home/runner/work/moontale/moontale/.yarn/cache/fengari-npm-0.1.4-f367acc87f-bd6b04f973.zip/node_modules/fengari/src/ldblib.js", "pnp:/home/runner/work/moontale/moontale/.yarn/cache/fengari-npm-0.1.4-f367acc87f-bd6b04f973.zip/node_modules/fengari/src/loadlib.js", "pnp:/home/runner/work/moontale/moontale/.yarn/cache/fengari-npm-0.1.4-f367acc87f-bd6b04f973.zip/node_modules/fengari/src/fengarilib.js", "pnp:/home/runner/work/moontale/moontale/.yarn/cache/fengari-npm-0.1.4-f367acc87f-bd6b04f973.zip/node_modules/fengari/src/linit.js", "pnp:/home/runner/work/moontale/moontale/.yarn/cache/fengari-npm-0.1.4-f367acc87f-bd6b04f973.zip/node_modules/fengari/src/lualib.js", "pnp:/home/runner/work/moontale/moontale/.yarn/cache/fengari-npm-0.1.4-f367acc87f-bd6b04f973.zip/node_modules/fengari/src/fengari.js", "pnp:/home/runner/work/moontale/moontale/src/rules/content_block.ts", "pnp:/home/runner/work/moontale/moontale/src/rules/expression.ts", "pnp:/home/runner/work/moontale/moontale/src/rules/passage_link.ts", "pnp:/home/runner/work/moontale/moontale/src/rules/variable.ts", "pnp:/home/runner/work/moontale/moontale/src/rules/script_block.ts", "pnp:/home/runner/work/moontale/moontale/src/common/convert.ts", "pnp:/home/runner/work/moontale/moontale/src/common/runtime.ts", "pnp:/home/runner/work/moontale/moontale/src/player/index.ts"],
  "sourcesContent": ["// Token class\n\n;\n\n\n/**\n * class Token\n **/\n\n/**\n * new Token(type, tag, nesting)\n *\n * Create new token and fill passed properties.\n **/\nfunction Token(type, tag, nesting) {\n  /**\n   * Token#type -> String\n   *\n   * Type of the token (string, e.g. \"paragraph_open\")\n   **/\n  this.type     = type;\n\n  /**\n   * Token#tag -> String\n   *\n   * html tag name, e.g. \"p\"\n   **/\n  this.tag      = tag;\n\n  /**\n   * Token#attrs -> Array\n   *\n   * Html attributes. Format: `[ [ name1, value1 ], [ name2, value2 ] ]`\n   **/\n  this.attrs    = null;\n\n  /**\n   * Token#map -> Array\n   *\n   * Source map info. Format: `[ line_begin, line_end ]`\n   **/\n  this.map      = null;\n\n  /**\n   * Token#nesting -> Number\n   *\n   * Level change (number in {-1, 0, 1} set), where:\n   *\n   * -  `1` means the tag is opening\n   * -  `0` means the tag is self-closing\n   * - `-1` means the tag is closing\n   **/\n  this.nesting  = nesting;\n\n  /**\n   * Token#level -> Number\n   *\n   * nesting level, the same as `state.level`\n   **/\n  this.level    = 0;\n\n  /**\n   * Token#children -> Array\n   *\n   * An array of child nodes (inline and img tokens)\n   **/\n  this.children = null;\n\n  /**\n   * Token#content -> String\n   *\n   * In a case of self-closing tag (code, html, fence, etc.),\n   * it has contents of this tag.\n   **/\n  this.content  = '';\n\n  /**\n   * Token#markup -> String\n   *\n   * '*' or '_' for emphasis, fence string for fence, etc.\n   **/\n  this.markup   = '';\n\n  /**\n   * Token#info -> String\n   *\n   * Additional information:\n   *\n   * - Info string for \"fence\" tokens\n   * - The value \"auto\" for autolink \"link_open\" and \"link_close\" tokens\n   * - The string value of the item marker for ordered-list \"list_item_open\" tokens\n   **/\n  this.info     = '';\n\n  /**\n   * Token#meta -> Object\n   *\n   * A place for plugins to store an arbitrary data\n   **/\n  this.meta     = null;\n\n  /**\n   * Token#block -> Boolean\n   *\n   * True for block-level tokens, false for inline tokens.\n   * Used in renderer to calculate line breaks\n   **/\n  this.block    = false;\n\n  /**\n   * Token#hidden -> Boolean\n   *\n   * If it's true, ignore this element when rendering. Used for tight lists\n   * to hide paragraphs.\n   **/\n  this.hidden   = false;\n}\n\n\n/**\n * Token.attrIndex(name) -> Number\n *\n * Search attribute index by name.\n **/\nToken.prototype.attrIndex = function attrIndex(name) {\n  var attrs, i, len;\n\n  if (!this.attrs) { return -1; }\n\n  attrs = this.attrs;\n\n  for (i = 0, len = attrs.length; i < len; i++) {\n    if (attrs[i][0] === name) { return i; }\n  }\n  return -1;\n};\n\n\n/**\n * Token.attrPush(attrData)\n *\n * Add `[ name, value ]` attribute to list. Init attrs if necessary\n **/\nToken.prototype.attrPush = function attrPush(attrData) {\n  if (this.attrs) {\n    this.attrs.push(attrData);\n  } else {\n    this.attrs = [ attrData ];\n  }\n};\n\n\n/**\n * Token.attrSet(name, value)\n *\n * Set `name` attribute to `value`. Override old value if exists.\n **/\nToken.prototype.attrSet = function attrSet(name, value) {\n  var idx = this.attrIndex(name),\n      attrData = [ name, value ];\n\n  if (idx < 0) {\n    this.attrPush(attrData);\n  } else {\n    this.attrs[idx] = attrData;\n  }\n};\n\n\n/**\n * Token.attrGet(name)\n *\n * Get the value of attribute `name`, or null if it does not exist.\n **/\nToken.prototype.attrGet = function attrGet(name) {\n  var idx = this.attrIndex(name), value = null;\n  if (idx >= 0) {\n    value = this.attrs[idx][1];\n  }\n  return value;\n};\n\n\n/**\n * Token.attrJoin(name, value)\n *\n * Join value to existing attribute via space. Or create new attribute if not\n * exists. Useful to operate with token classes.\n **/\nToken.prototype.attrJoin = function attrJoin(name, value) {\n  var idx = this.attrIndex(name);\n\n  if (idx < 0) {\n    this.attrPush([ name, value ]);\n  } else {\n    this.attrs[idx][1] = this.attrs[idx][1] + ' ' + value;\n  }\n};\n\n\nmodule.exports = Token;\n", "/**\n * class Ruler\n *\n * Helper class, used by [[MarkdownIt#core]], [[MarkdownIt#block]] and\n * [[MarkdownIt#inline]] to manage sequences of functions (rules):\n *\n * - keep rules in defined order\n * - assign the name to each rule\n * - enable/disable rules\n * - add/replace rules\n * - allow assign rules to additional named chains (in the same)\n * - cacheing lists of active rules\n *\n * You will not need use this class directly until write plugins. For simple\n * rules control use [[MarkdownIt.disable]], [[MarkdownIt.enable]] and\n * [[MarkdownIt.use]].\n **/\n;\n\n\n/**\n * new Ruler()\n **/\nfunction Ruler() {\n  // List of added rules. Each element is:\n  //\n  // {\n  //   name: XXX,\n  //   enabled: Boolean,\n  //   fn: Function(),\n  //   alt: [ name2, name3 ]\n  // }\n  //\n  this.__rules__ = [];\n\n  // Cached rule chains.\n  //\n  // First level - chain name, '' for default.\n  // Second level - diginal anchor for fast filtering by charcodes.\n  //\n  this.__cache__ = null;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Helper methods, should not be used directly\n\n\n// Find rule index by name\n//\nRuler.prototype.__find__ = function (name) {\n  for (var i = 0; i < this.__rules__.length; i++) {\n    if (this.__rules__[i].name === name) {\n      return i;\n    }\n  }\n  return -1;\n};\n\n\n// Build rules lookup cache\n//\nRuler.prototype.__compile__ = function () {\n  var self = this;\n  var chains = [ '' ];\n\n  // collect unique names\n  self.__rules__.forEach(function (rule) {\n    if (!rule.enabled) { return; }\n\n    rule.alt.forEach(function (altName) {\n      if (chains.indexOf(altName) < 0) {\n        chains.push(altName);\n      }\n    });\n  });\n\n  self.__cache__ = {};\n\n  chains.forEach(function (chain) {\n    self.__cache__[chain] = [];\n    self.__rules__.forEach(function (rule) {\n      if (!rule.enabled) { return; }\n\n      if (chain && rule.alt.indexOf(chain) < 0) { return; }\n\n      self.__cache__[chain].push(rule.fn);\n    });\n  });\n};\n\n\n/**\n * Ruler.at(name, fn [, options])\n * - name (String): rule name to replace.\n * - fn (Function): new rule function.\n * - options (Object): new rule options (not mandatory).\n *\n * Replace rule by name with new function & options. Throws error if name not\n * found.\n *\n * ##### Options:\n *\n * - __alt__ - array with names of \"alternate\" chains.\n *\n * ##### Example\n *\n * Replace existing typographer replacement rule with new one:\n *\n * ```javascript\n * var md = require('markdown-it')();\n *\n * md.core.ruler.at('replacements', function replace(state) {\n *   //...\n * });\n * ```\n **/\nRuler.prototype.at = function (name, fn, options) {\n  var index = this.__find__(name);\n  var opt = options || {};\n\n  if (index === -1) { throw new Error('Parser rule not found: ' + name); }\n\n  this.__rules__[index].fn = fn;\n  this.__rules__[index].alt = opt.alt || [];\n  this.__cache__ = null;\n};\n\n\n/**\n * Ruler.before(beforeName, ruleName, fn [, options])\n * - beforeName (String): new rule will be added before this one.\n * - ruleName (String): name of added rule.\n * - fn (Function): rule function.\n * - options (Object): rule options (not mandatory).\n *\n * Add new rule to chain before one with given name. See also\n * [[Ruler.after]], [[Ruler.push]].\n *\n * ##### Options:\n *\n * - __alt__ - array with names of \"alternate\" chains.\n *\n * ##### Example\n *\n * ```javascript\n * var md = require('markdown-it')();\n *\n * md.block.ruler.before('paragraph', 'my_rule', function replace(state) {\n *   //...\n * });\n * ```\n **/\nRuler.prototype.before = function (beforeName, ruleName, fn, options) {\n  var index = this.__find__(beforeName);\n  var opt = options || {};\n\n  if (index === -1) { throw new Error('Parser rule not found: ' + beforeName); }\n\n  this.__rules__.splice(index, 0, {\n    name: ruleName,\n    enabled: true,\n    fn: fn,\n    alt: opt.alt || []\n  });\n\n  this.__cache__ = null;\n};\n\n\n/**\n * Ruler.after(afterName, ruleName, fn [, options])\n * - afterName (String): new rule will be added after this one.\n * - ruleName (String): name of added rule.\n * - fn (Function): rule function.\n * - options (Object): rule options (not mandatory).\n *\n * Add new rule to chain after one with given name. See also\n * [[Ruler.before]], [[Ruler.push]].\n *\n * ##### Options:\n *\n * - __alt__ - array with names of \"alternate\" chains.\n *\n * ##### Example\n *\n * ```javascript\n * var md = require('markdown-it')();\n *\n * md.inline.ruler.after('text', 'my_rule', function replace(state) {\n *   //...\n * });\n * ```\n **/\nRuler.prototype.after = function (afterName, ruleName, fn, options) {\n  var index = this.__find__(afterName);\n  var opt = options || {};\n\n  if (index === -1) { throw new Error('Parser rule not found: ' + afterName); }\n\n  this.__rules__.splice(index + 1, 0, {\n    name: ruleName,\n    enabled: true,\n    fn: fn,\n    alt: opt.alt || []\n  });\n\n  this.__cache__ = null;\n};\n\n/**\n * Ruler.push(ruleName, fn [, options])\n * - ruleName (String): name of added rule.\n * - fn (Function): rule function.\n * - options (Object): rule options (not mandatory).\n *\n * Push new rule to the end of chain. See also\n * [[Ruler.before]], [[Ruler.after]].\n *\n * ##### Options:\n *\n * - __alt__ - array with names of \"alternate\" chains.\n *\n * ##### Example\n *\n * ```javascript\n * var md = require('markdown-it')();\n *\n * md.core.ruler.push('my_rule', function replace(state) {\n *   //...\n * });\n * ```\n **/\nRuler.prototype.push = function (ruleName, fn, options) {\n  var opt = options || {};\n\n  this.__rules__.push({\n    name: ruleName,\n    enabled: true,\n    fn: fn,\n    alt: opt.alt || []\n  });\n\n  this.__cache__ = null;\n};\n\n\n/**\n * Ruler.enable(list [, ignoreInvalid]) -> Array\n * - list (String|Array): list of rule names to enable.\n * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.\n *\n * Enable rules with given names. If any rule name not found - throw Error.\n * Errors can be disabled by second param.\n *\n * Returns list of found rule names (if no exception happened).\n *\n * See also [[Ruler.disable]], [[Ruler.enableOnly]].\n **/\nRuler.prototype.enable = function (list, ignoreInvalid) {\n  if (!Array.isArray(list)) { list = [ list ]; }\n\n  var result = [];\n\n  // Search by name and enable\n  list.forEach(function (name) {\n    var idx = this.__find__(name);\n\n    if (idx < 0) {\n      if (ignoreInvalid) { return; }\n      throw new Error('Rules manager: invalid rule name ' + name);\n    }\n    this.__rules__[idx].enabled = true;\n    result.push(name);\n  }, this);\n\n  this.__cache__ = null;\n  return result;\n};\n\n\n/**\n * Ruler.enableOnly(list [, ignoreInvalid])\n * - list (String|Array): list of rule names to enable (whitelist).\n * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.\n *\n * Enable rules with given names, and disable everything else. If any rule name\n * not found - throw Error. Errors can be disabled by second param.\n *\n * See also [[Ruler.disable]], [[Ruler.enable]].\n **/\nRuler.prototype.enableOnly = function (list, ignoreInvalid) {\n  if (!Array.isArray(list)) { list = [ list ]; }\n\n  this.__rules__.forEach(function (rule) { rule.enabled = false; });\n\n  this.enable(list, ignoreInvalid);\n};\n\n\n/**\n * Ruler.disable(list [, ignoreInvalid]) -> Array\n * - list (String|Array): list of rule names to disable.\n * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.\n *\n * Disable rules with given names. If any rule name not found - throw Error.\n * Errors can be disabled by second param.\n *\n * Returns list of found rule names (if no exception happened).\n *\n * See also [[Ruler.enable]], [[Ruler.enableOnly]].\n **/\nRuler.prototype.disable = function (list, ignoreInvalid) {\n  if (!Array.isArray(list)) { list = [ list ]; }\n\n  var result = [];\n\n  // Search by name and disable\n  list.forEach(function (name) {\n    var idx = this.__find__(name);\n\n    if (idx < 0) {\n      if (ignoreInvalid) { return; }\n      throw new Error('Rules manager: invalid rule name ' + name);\n    }\n    this.__rules__[idx].enabled = false;\n    result.push(name);\n  }, this);\n\n  this.__cache__ = null;\n  return result;\n};\n\n\n/**\n * Ruler.getRules(chainName) -> Array\n *\n * Return array of active functions (rules) for given chain name. It analyzes\n * rules configuration, compiles caches if not exists and returns result.\n *\n * Default chain name is `''` (empty string). It can't be skipped. That's\n * done intentionally, to keep signature monomorphic for high speed.\n **/\nRuler.prototype.getRules = function (chainName) {\n  if (this.__cache__ === null) {\n    this.__compile__();\n  }\n\n  // Chain can be empty, if rules disabled. But we still have to return Array.\n  return this.__cache__[chainName] || [];\n};\n\nmodule.exports = Ruler;\n", "// Skip text characters for text token, place those to pending buffer\n// and increment current pos\n\n;\n\n\n// Rule to skip pure text\n// '{}$%@~+=:' reserved for extentions\n\n// !, \", #, $, %, &, ', (, ), *, +, ,, -, ., /, :, ;, <, =, >, ?, @, [, \\, ], ^, _, `, {, |, }, or ~\n\n// !!!! Don't confuse with \"Markdown ASCII Punctuation\" chars\n// http://spec.commonmark.org/0.15/#ascii-punctuation-character\nfunction isTerminatorChar(ch) {\n  switch (ch) {\n    case 0x0A/* \\n */:\n    case 0x21/* ! */:\n    case 0x23/* # */:\n    case 0x24/* $ */:\n    case 0x25/* % */:\n    case 0x26/* & */:\n    case 0x2A/* * */:\n    case 0x2B/* + */:\n    case 0x2D/* - */:\n    case 0x3A/* : */:\n    case 0x3C/* < */:\n    case 0x3D/* = */:\n    case 0x3E/* > */:\n    case 0x40/* @ */:\n    case 0x5B/* [ */:\n    case 0x5C/* \\ */:\n    case 0x5D/* ] */:\n    case 0x5E/* ^ */:\n    case 0x5F/* _ */:\n    case 0x60/* ` */:\n    case 0x7B/* { */:\n    case 0x7D/* } */:\n    case 0x7E/* ~ */:\n      return true;\n    default:\n      return false;\n  }\n}\n\nmodule.exports = function text(state, silent) {\n  var pos = state.pos;\n\n  while (pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))) {\n    pos++;\n  }\n\n  if (pos === state.pos) { return false; }\n\n  if (!silent) { state.pending += state.src.slice(state.pos, pos); }\n\n  state.pos = pos;\n\n  return true;\n};\n\n// Alternative implementation, for memory.\n//\n// It costs 10% of performance, but allows extend terminators list, if place it\n// to `ParcerInline` property. Probably, will switch to it sometime, such\n// flexibility required.\n\n/*\nvar TERMINATOR_RE = /[\\n!#$%&*+\\-:<=>@[\\\\\\]^_`{}~]/;\n\nmodule.exports = function text(state, silent) {\n  var pos = state.pos,\n      idx = state.src.slice(pos).search(TERMINATOR_RE);\n\n  // first char is terminator -> empty text\n  if (idx === 0) { return false; }\n\n  // no terminator -> text till end of string\n  if (idx < 0) {\n    if (!silent) { state.pending += state.src.slice(pos); }\n    state.pos = state.src.length;\n    return true;\n  }\n\n  if (!silent) { state.pending += state.src.slice(pos, pos + idx); }\n\n  state.pos += idx;\n\n  return true;\n};*/\n", "// Process links like https://example.org/\n\n;\n\n\n// RFC3986: scheme = ALPHA *( ALPHA / DIGIT / \"+\" / \"-\" / \".\" )\nvar SCHEME_RE = /(?:^|[^a-z0-9.+-])([a-z][a-z0-9.+-]*)$/i;\n\n\nmodule.exports = function linkify(state, silent) {\n  var pos, max, match, proto, link, url, fullUrl, token;\n\n  if (!state.md.options.linkify) return false;\n  if (state.linkLevel > 0) return false;\n\n  pos = state.pos;\n  max = state.posMax;\n\n  if (pos + 3 > max) return false;\n  if (state.src.charCodeAt(pos) !== 0x3A/* : */) return false;\n  if (state.src.charCodeAt(pos + 1) !== 0x2F/* / */) return false;\n  if (state.src.charCodeAt(pos + 2) !== 0x2F/* / */) return false;\n\n  match = state.pending.match(SCHEME_RE);\n  if (!match) return false;\n\n  proto = match[1];\n\n  link = state.md.linkify.matchAtStart(state.src.slice(pos - proto.length));\n  if (!link) return false;\n\n  url = link.url;\n\n  // disallow '*' at the end of the link (conflicts with emphasis)\n  url = url.replace(/\\*+$/, '');\n\n  fullUrl = state.md.normalizeLink(url);\n  if (!state.md.validateLink(fullUrl)) return false;\n\n  if (!silent) {\n    state.pending = state.pending.slice(0, -proto.length);\n\n    token         = state.push('link_open', 'a', 1);\n    token.attrs   = [ [ 'href', fullUrl ] ];\n    token.markup  = 'linkify';\n    token.info    = 'auto';\n\n    token         = state.push('text', '', 0);\n    token.content = state.md.normalizeLinkText(url);\n\n    token         = state.push('link_close', 'a', -1);\n    token.markup  = 'linkify';\n    token.info    = 'auto';\n  }\n\n  state.pos += url.length - proto.length;\n  return true;\n};\n", "// HTML5 entities map: { name -> utf16string }\n//\n;\n\n/*eslint quotes:0*/\nmodule.exports = require('entities/lib/maps/entities.json');\n", "module.exports=/[!-#%-\\*,-\\/:;\\?@\\[-\\]_\\{\\}\\xA1\\xA7\\xAB\\xB6\\xB7\\xBB\\xBF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u09FD\\u0A76\\u0AF0\\u0C84\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166D\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2308-\\u230B\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E4E\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA8FC\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]|\\uD800[\\uDD00-\\uDD02\\uDF9F\\uDFD0]|\\uD801\\uDD6F|\\uD802[\\uDC57\\uDD1F\\uDD3F\\uDE50-\\uDE58\\uDE7F\\uDEF0-\\uDEF6\\uDF39-\\uDF3F\\uDF99-\\uDF9C]|\\uD803[\\uDF55-\\uDF59]|\\uD804[\\uDC47-\\uDC4D\\uDCBB\\uDCBC\\uDCBE-\\uDCC1\\uDD40-\\uDD43\\uDD74\\uDD75\\uDDC5-\\uDDC8\\uDDCD\\uDDDB\\uDDDD-\\uDDDF\\uDE38-\\uDE3D\\uDEA9]|\\uD805[\\uDC4B-\\uDC4F\\uDC5B\\uDC5D\\uDCC6\\uDDC1-\\uDDD7\\uDE41-\\uDE43\\uDE60-\\uDE6C\\uDF3C-\\uDF3E]|\\uD806[\\uDC3B\\uDE3F-\\uDE46\\uDE9A-\\uDE9C\\uDE9E-\\uDEA2]|\\uD807[\\uDC41-\\uDC45\\uDC70\\uDC71\\uDEF7\\uDEF8]|\\uD809[\\uDC70-\\uDC74]|\\uD81A[\\uDE6E\\uDE6F\\uDEF5\\uDF37-\\uDF3B\\uDF44]|\\uD81B[\\uDE97-\\uDE9A]|\\uD82F\\uDC9F|\\uD836[\\uDE87-\\uDE8B]|\\uD83A[\\uDD5E\\uDD5F]/", "", "module.exports=/[\\0-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/", "module.exports=/[\\0-\\x1F\\x7F-\\x9F]/", "module.exports=/[\\xAD\\u0600-\\u0605\\u061C\\u06DD\\u070F\\u08E2\\u180E\\u200B-\\u200F\\u202A-\\u202E\\u2060-\\u2064\\u2066-\\u206F\\uFEFF\\uFFF9-\\uFFFB]|\\uD804[\\uDCBD\\uDCCD]|\\uD82F[\\uDCA0-\\uDCA3]|\\uD834[\\uDD73-\\uDD7A]|\\uDB40[\\uDC01\\uDC20-\\uDC7F]/", "module.exports=/[ \\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000]/", ";\n\nexports.Any = require('./properties/Any/regex');\nexports.Cc  = require('./categories/Cc/regex');\nexports.Cf  = require('./categories/Cf/regex');\nexports.P   = require('./categories/P/regex');\nexports.Z   = require('./categories/Z/regex');\n", "// Utilities\n//\n;\n\n\nfunction _class(obj) { return Object.prototype.toString.call(obj); }\n\nfunction isString(obj) { return _class(obj) === '[object String]'; }\n\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction has(object, key) {\n  return _hasOwnProperty.call(object, key);\n}\n\n// Merge objects\n//\nfunction assign(obj /*from1, from2, from3, ...*/) {\n  var sources = Array.prototype.slice.call(arguments, 1);\n\n  sources.forEach(function (source) {\n    if (!source) { return; }\n\n    if (typeof source !== 'object') {\n      throw new TypeError(source + 'must be object');\n    }\n\n    Object.keys(source).forEach(function (key) {\n      obj[key] = source[key];\n    });\n  });\n\n  return obj;\n}\n\n// Remove element from array and put another array at those position.\n// Useful for some operations with tokens\nfunction arrayReplaceAt(src, pos, newElements) {\n  return [].concat(src.slice(0, pos), newElements, src.slice(pos + 1));\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nfunction isValidEntityCode(c) {\n  /*eslint no-bitwise:0*/\n  // broken sequence\n  if (c >= 0xD800 && c <= 0xDFFF) { return false; }\n  // never used\n  if (c >= 0xFDD0 && c <= 0xFDEF) { return false; }\n  if ((c & 0xFFFF) === 0xFFFF || (c & 0xFFFF) === 0xFFFE) { return false; }\n  // control codes\n  if (c >= 0x00 && c <= 0x08) { return false; }\n  if (c === 0x0B) { return false; }\n  if (c >= 0x0E && c <= 0x1F) { return false; }\n  if (c >= 0x7F && c <= 0x9F) { return false; }\n  // out of range\n  if (c > 0x10FFFF) { return false; }\n  return true;\n}\n\nfunction fromCodePoint(c) {\n  /*eslint no-bitwise:0*/\n  if (c > 0xffff) {\n    c -= 0x10000;\n    var surrogate1 = 0xd800 + (c >> 10),\n        surrogate2 = 0xdc00 + (c & 0x3ff);\n\n    return String.fromCharCode(surrogate1, surrogate2);\n  }\n  return String.fromCharCode(c);\n}\n\n\nvar UNESCAPE_MD_RE  = /\\\\([!\"#$%&'()*+,\\-.\\/:;<=>?@[\\\\\\]^_`{|}~])/g;\nvar ENTITY_RE       = /&([a-z#][a-z0-9]{1,31});/gi;\nvar UNESCAPE_ALL_RE = new RegExp(UNESCAPE_MD_RE.source + '|' + ENTITY_RE.source, 'gi');\n\nvar DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))/i;\n\nvar entities = require('./entities');\n\nfunction replaceEntityPattern(match, name) {\n  var code = 0;\n\n  if (has(entities, name)) {\n    return entities[name];\n  }\n\n  if (name.charCodeAt(0) === 0x23/* # */ && DIGITAL_ENTITY_TEST_RE.test(name)) {\n    code = name[1].toLowerCase() === 'x' ?\n      parseInt(name.slice(2), 16) : parseInt(name.slice(1), 10);\n\n    if (isValidEntityCode(code)) {\n      return fromCodePoint(code);\n    }\n  }\n\n  return match;\n}\n\n/*function replaceEntities(str) {\n  if (str.indexOf('&') < 0) { return str; }\n\n  return str.replace(ENTITY_RE, replaceEntityPattern);\n}*/\n\nfunction unescapeMd(str) {\n  if (str.indexOf('\\\\') < 0) { return str; }\n  return str.replace(UNESCAPE_MD_RE, '$1');\n}\n\nfunction unescapeAll(str) {\n  if (str.indexOf('\\\\') < 0 && str.indexOf('&') < 0) { return str; }\n\n  return str.replace(UNESCAPE_ALL_RE, function (match, escaped, entity) {\n    if (escaped) { return escaped; }\n    return replaceEntityPattern(match, entity);\n  });\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvar HTML_ESCAPE_TEST_RE = /[&<>\"]/;\nvar HTML_ESCAPE_REPLACE_RE = /[&<>\"]/g;\nvar HTML_REPLACEMENTS = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;'\n};\n\nfunction replaceUnsafeChar(ch) {\n  return HTML_REPLACEMENTS[ch];\n}\n\nfunction escapeHtml(str) {\n  if (HTML_ESCAPE_TEST_RE.test(str)) {\n    return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);\n  }\n  return str;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvar REGEXP_ESCAPE_RE = /[.?*+^$[\\]\\\\(){}|-]/g;\n\nfunction escapeRE(str) {\n  return str.replace(REGEXP_ESCAPE_RE, '\\\\$&');\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nfunction isSpace(code) {\n  switch (code) {\n    case 0x09:\n    case 0x20:\n      return true;\n  }\n  return false;\n}\n\n// Zs (unicode class) || [\\t\\f\\v\\r\\n]\nfunction isWhiteSpace(code) {\n  if (code >= 0x2000 && code <= 0x200A) { return true; }\n  switch (code) {\n    case 0x09: // \\t\n    case 0x0A: // \\n\n    case 0x0B: // \\v\n    case 0x0C: // \\f\n    case 0x0D: // \\r\n    case 0x20:\n    case 0xA0:\n    case 0x1680:\n    case 0x202F:\n    case 0x205F:\n    case 0x3000:\n      return true;\n  }\n  return false;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/*eslint-disable max-len*/\nvar UNICODE_PUNCT_RE = require('uc.micro/categories/P/regex');\n\n// Currently without astral characters support.\nfunction isPunctChar(ch) {\n  return UNICODE_PUNCT_RE.test(ch);\n}\n\n\n// Markdown ASCII punctuation characters.\n//\n// !, \", #, $, %, &, ', (, ), *, +, ,, -, ., /, :, ;, <, =, >, ?, @, [, \\, ], ^, _, `, {, |, }, or ~\n// http://spec.commonmark.org/0.15/#ascii-punctuation-character\n//\n// Don't confuse with unicode punctuation !!! It lacks some chars in ascii range.\n//\nfunction isMdAsciiPunct(ch) {\n  switch (ch) {\n    case 0x21/* ! */:\n    case 0x22/* \" */:\n    case 0x23/* # */:\n    case 0x24/* $ */:\n    case 0x25/* % */:\n    case 0x26/* & */:\n    case 0x27/* ' */:\n    case 0x28/* ( */:\n    case 0x29/* ) */:\n    case 0x2A/* * */:\n    case 0x2B/* + */:\n    case 0x2C/* , */:\n    case 0x2D/* - */:\n    case 0x2E/* . */:\n    case 0x2F/* / */:\n    case 0x3A/* : */:\n    case 0x3B/* ; */:\n    case 0x3C/* < */:\n    case 0x3D/* = */:\n    case 0x3E/* > */:\n    case 0x3F/* ? */:\n    case 0x40/* @ */:\n    case 0x5B/* [ */:\n    case 0x5C/* \\ */:\n    case 0x5D/* ] */:\n    case 0x5E/* ^ */:\n    case 0x5F/* _ */:\n    case 0x60/* ` */:\n    case 0x7B/* { */:\n    case 0x7C/* | */:\n    case 0x7D/* } */:\n    case 0x7E/* ~ */:\n      return true;\n    default:\n      return false;\n  }\n}\n\n// Hepler to unify [reference labels].\n//\nfunction normalizeReference(str) {\n  // Trim and collapse whitespace\n  //\n  str = str.trim().replace(/\\s+/g, ' ');\n\n  // In node v10 '\u1E9E'.toLowerCase() === '\u1E7E', which is presumed to be a bug\n  // fixed in v12 (couldn't find any details).\n  //\n  // So treat this one as a special case\n  // (remove this when node v10 is no longer supported).\n  //\n  if ('\u1E9E'.toLowerCase() === '\u1E7E') {\n    str = str.replace(/\u1E9E/g, '\u00DF');\n  }\n\n  // .toLowerCase().toUpperCase() should get rid of all differences\n  // between letter variants.\n  //\n  // Simple .toLowerCase() doesn't normalize 125 code points correctly,\n  // and .toUpperCase doesn't normalize 6 of them (list of exceptions:\n  // \u0130, \u03F4, \u1E9E, \u2126, \u212A, \u212B - those are already uppercased, but have differently\n  // uppercased versions).\n  //\n  // Here's an example showing how it happens. Lets take greek letter omega:\n  // uppercase U+0398 (\u0398), U+03f4 (\u03F4) and lowercase U+03b8 (\u03B8), U+03d1 (\u03D1)\n  //\n  // Unicode entries:\n  // 0398;GREEK CAPITAL LETTER THETA;Lu;0;L;;;;;N;;;;03B8;\n  // 03B8;GREEK SMALL LETTER THETA;Ll;0;L;;;;;N;;;0398;;0398\n  // 03D1;GREEK THETA SYMBOL;Ll;0;L;<compat> 03B8;;;;N;GREEK SMALL LETTER SCRIPT THETA;;0398;;0398\n  // 03F4;GREEK CAPITAL THETA SYMBOL;Lu;0;L;<compat> 0398;;;;N;;;;03B8;\n  //\n  // Case-insensitive comparison should treat all of them as equivalent.\n  //\n  // But .toLowerCase() doesn't change \u03D1 (it's already lowercase),\n  // and .toUpperCase() doesn't change \u03F4 (already uppercase).\n  //\n  // Applying first lower then upper case normalizes any character:\n  // '\\u0398\\u03f4\\u03b8\\u03d1'.toLowerCase().toUpperCase() === '\\u0398\\u0398\\u0398\\u0398'\n  //\n  // Note: this is equivalent to unicode case folding; unicode normalization\n  // is a different step that is not required here.\n  //\n  // Final result should be uppercased, because it's later stored in an object\n  // (this avoid a conflict with Object.prototype members,\n  // most notably, `__proto__`)\n  //\n  return str.toLowerCase().toUpperCase();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n// Re-export libraries commonly used in both markdown-it and its plugins,\n// so plugins won't have to depend on them explicitly, which reduces their\n// bundled size (e.g. a browser build).\n//\nexports.lib                 = {};\nexports.lib.mdurl           = require('mdurl');\nexports.lib.ucmicro         = require('uc.micro');\n\nexports.assign              = assign;\nexports.isString            = isString;\nexports.has                 = has;\nexports.unescapeMd          = unescapeMd;\nexports.unescapeAll         = unescapeAll;\nexports.isValidEntityCode   = isValidEntityCode;\nexports.fromCodePoint       = fromCodePoint;\n// exports.replaceEntities     = replaceEntities;\nexports.escapeHtml          = escapeHtml;\nexports.arrayReplaceAt      = arrayReplaceAt;\nexports.isSpace             = isSpace;\nexports.isWhiteSpace        = isWhiteSpace;\nexports.isMdAsciiPunct      = isMdAsciiPunct;\nexports.isPunctChar         = isPunctChar;\nexports.escapeRE            = escapeRE;\nexports.normalizeReference  = normalizeReference;\n", "// Proceess '\\n'\n\n;\n\nvar isSpace = require('../common/utils').isSpace;\n\n\nmodule.exports = function newline(state, silent) {\n  var pmax, max, ws, pos = state.pos;\n\n  if (state.src.charCodeAt(pos) !== 0x0A/* \\n */) { return false; }\n\n  pmax = state.pending.length - 1;\n  max = state.posMax;\n\n  // '  \\n' -> hardbreak\n  // Lookup in pending chars is bad practice! Don't copy to other rules!\n  // Pending string is stored in concat mode, indexed lookups will cause\n  // convertion to flat mode.\n  if (!silent) {\n    if (pmax >= 0 && state.pending.charCodeAt(pmax) === 0x20) {\n      if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 0x20) {\n        // Find whitespaces tail of pending chars.\n        ws = pmax - 1;\n        while (ws >= 1 && state.pending.charCodeAt(ws - 1) === 0x20) ws--;\n\n        state.pending = state.pending.slice(0, ws);\n        state.push('hardbreak', 'br', 0);\n      } else {\n        state.pending = state.pending.slice(0, -1);\n        state.push('softbreak', 'br', 0);\n      }\n\n    } else {\n      state.push('softbreak', 'br', 0);\n    }\n  }\n\n  pos++;\n\n  // skip heading spaces for next line\n  while (pos < max && isSpace(state.src.charCodeAt(pos))) { pos++; }\n\n  state.pos = pos;\n  return true;\n};\n", "// Process escaped chars and hardbreaks\n\n;\n\nvar isSpace = require('../common/utils').isSpace;\n\nvar ESCAPED = [];\n\nfor (var i = 0; i < 256; i++) { ESCAPED.push(0); }\n\n'\\\\!\"#$%&\\'()*+,./:;<=>?@[]^_`{|}~-'\n  .split('').forEach(function (ch) { ESCAPED[ch.charCodeAt(0)] = 1; });\n\n\nmodule.exports = function escape(state, silent) {\n  var ch1, ch2, origStr, escapedStr, token, pos = state.pos, max = state.posMax;\n\n  if (state.src.charCodeAt(pos) !== 0x5C/* \\ */) return false;\n  pos++;\n\n  // '\\' at the end of the inline block\n  if (pos >= max) return false;\n\n  ch1 = state.src.charCodeAt(pos);\n\n  if (ch1 === 0x0A) {\n    if (!silent) {\n      state.push('hardbreak', 'br', 0);\n    }\n\n    pos++;\n    // skip leading whitespaces from next line\n    while (pos < max) {\n      ch1 = state.src.charCodeAt(pos);\n      if (!isSpace(ch1)) break;\n      pos++;\n    }\n\n    state.pos = pos;\n    return true;\n  }\n\n  escapedStr = state.src[pos];\n\n  if (ch1 >= 0xD800 && ch1 <= 0xDBFF && pos + 1 < max) {\n    ch2 = state.src.charCodeAt(pos + 1);\n\n    if (ch2 >= 0xDC00 && ch2 <= 0xDFFF) {\n      escapedStr += state.src[pos + 1];\n      pos++;\n    }\n  }\n\n  origStr = '\\\\' + escapedStr;\n\n  if (!silent) {\n    token = state.push('text_special', '', 0);\n\n    if (ch1 < 256 && ESCAPED[ch1] !== 0) {\n      token.content = escapedStr;\n    } else {\n      token.content = origStr;\n    }\n\n    token.markup = origStr;\n    token.info   = 'escape';\n  }\n\n  state.pos = pos + 1;\n  return true;\n};\n", "// Parse backticks\n\n;\n\n\nmodule.exports = function backtick(state, silent) {\n  var start, max, marker, token, matchStart, matchEnd, openerLength, closerLength,\n      pos = state.pos,\n      ch = state.src.charCodeAt(pos);\n\n  if (ch !== 0x60/* ` */) { return false; }\n\n  start = pos;\n  pos++;\n  max = state.posMax;\n\n  // scan marker length\n  while (pos < max && state.src.charCodeAt(pos) === 0x60/* ` */) { pos++; }\n\n  marker = state.src.slice(start, pos);\n  openerLength = marker.length;\n\n  if (state.backticksScanned && (state.backticks[openerLength] || 0) <= start) {\n    if (!silent) state.pending += marker;\n    state.pos += openerLength;\n    return true;\n  }\n\n  matchStart = matchEnd = pos;\n\n  // Nothing found in the cache, scan until the end of the line (or until marker is found)\n  while ((matchStart = state.src.indexOf('`', matchEnd)) !== -1) {\n    matchEnd = matchStart + 1;\n\n    // scan marker length\n    while (matchEnd < max && state.src.charCodeAt(matchEnd) === 0x60/* ` */) { matchEnd++; }\n\n    closerLength = matchEnd - matchStart;\n\n    if (closerLength === openerLength) {\n      // Found matching closer length.\n      if (!silent) {\n        token     = state.push('code_inline', 'code', 0);\n        token.markup  = marker;\n        token.content = state.src.slice(pos, matchStart)\n          .replace(/\\n/g, ' ')\n          .replace(/^ (.+) $/, '$1');\n      }\n      state.pos = matchEnd;\n      return true;\n    }\n\n    // Some different length found, put it in cache as upper limit of where closer can be found\n    state.backticks[closerLength] = matchStart;\n  }\n\n  // Scanned through the end, didn't find anything\n  state.backticksScanned = true;\n\n  if (!silent) state.pending += marker;\n  state.pos += openerLength;\n  return true;\n};\n", "// ~~strike through~~\n//\n;\n\n\n// Insert each marker as a separate text token, and add it to delimiter list\n//\nmodule.exports.tokenize = function strikethrough(state, silent) {\n  var i, scanned, token, len, ch,\n      start = state.pos,\n      marker = state.src.charCodeAt(start);\n\n  if (silent) { return false; }\n\n  if (marker !== 0x7E/* ~ */) { return false; }\n\n  scanned = state.scanDelims(state.pos, true);\n  len = scanned.length;\n  ch = String.fromCharCode(marker);\n\n  if (len < 2) { return false; }\n\n  if (len % 2) {\n    token         = state.push('text', '', 0);\n    token.content = ch;\n    len--;\n  }\n\n  for (i = 0; i < len; i += 2) {\n    token         = state.push('text', '', 0);\n    token.content = ch + ch;\n\n    state.delimiters.push({\n      marker: marker,\n      length: 0,     // disable \"rule of 3\" length checks meant for emphasis\n      token:  state.tokens.length - 1,\n      end:    -1,\n      open:   scanned.can_open,\n      close:  scanned.can_close\n    });\n  }\n\n  state.pos += scanned.length;\n\n  return true;\n};\n\n\nfunction postProcess(state, delimiters) {\n  var i, j,\n      startDelim,\n      endDelim,\n      token,\n      loneMarkers = [],\n      max = delimiters.length;\n\n  for (i = 0; i < max; i++) {\n    startDelim = delimiters[i];\n\n    if (startDelim.marker !== 0x7E/* ~ */) {\n      continue;\n    }\n\n    if (startDelim.end === -1) {\n      continue;\n    }\n\n    endDelim = delimiters[startDelim.end];\n\n    token         = state.tokens[startDelim.token];\n    token.type    = 's_open';\n    token.tag     = 's';\n    token.nesting = 1;\n    token.markup  = '~~';\n    token.content = '';\n\n    token         = state.tokens[endDelim.token];\n    token.type    = 's_close';\n    token.tag     = 's';\n    token.nesting = -1;\n    token.markup  = '~~';\n    token.content = '';\n\n    if (state.tokens[endDelim.token - 1].type === 'text' &&\n        state.tokens[endDelim.token - 1].content === '~') {\n\n      loneMarkers.push(endDelim.token - 1);\n    }\n  }\n\n  // If a marker sequence has an odd number of characters, it's splitted\n  // like this: `~~~~~` -> `~` + `~~` + `~~`, leaving one marker at the\n  // start of the sequence.\n  //\n  // So, we have to move all those markers after subsequent s_close tags.\n  //\n  while (loneMarkers.length) {\n    i = loneMarkers.pop();\n    j = i + 1;\n\n    while (j < state.tokens.length && state.tokens[j].type === 's_close') {\n      j++;\n    }\n\n    j--;\n\n    if (i !== j) {\n      token = state.tokens[j];\n      state.tokens[j] = state.tokens[i];\n      state.tokens[i] = token;\n    }\n  }\n}\n\n\n// Walk through delimiter list and replace text tokens with tags\n//\nmodule.exports.postProcess = function strikethrough(state) {\n  var curr,\n      tokens_meta = state.tokens_meta,\n      max = state.tokens_meta.length;\n\n  postProcess(state, state.delimiters);\n\n  for (curr = 0; curr < max; curr++) {\n    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {\n      postProcess(state, tokens_meta[curr].delimiters);\n    }\n  }\n};\n", "// Process *this* and _that_\n//\n;\n\n\n// Insert each marker as a separate text token, and add it to delimiter list\n//\nmodule.exports.tokenize = function emphasis(state, silent) {\n  var i, scanned, token,\n      start = state.pos,\n      marker = state.src.charCodeAt(start);\n\n  if (silent) { return false; }\n\n  if (marker !== 0x5F /* _ */ && marker !== 0x2A /* * */) { return false; }\n\n  scanned = state.scanDelims(state.pos, marker === 0x2A);\n\n  for (i = 0; i < scanned.length; i++) {\n    token         = state.push('text', '', 0);\n    token.content = String.fromCharCode(marker);\n\n    state.delimiters.push({\n      // Char code of the starting marker (number).\n      //\n      marker: marker,\n\n      // Total length of these series of delimiters.\n      //\n      length: scanned.length,\n\n      // A position of the token this delimiter corresponds to.\n      //\n      token:  state.tokens.length - 1,\n\n      // If this delimiter is matched as a valid opener, `end` will be\n      // equal to its position, otherwise it's `-1`.\n      //\n      end:    -1,\n\n      // Boolean flags that determine if this delimiter could open or close\n      // an emphasis.\n      //\n      open:   scanned.can_open,\n      close:  scanned.can_close\n    });\n  }\n\n  state.pos += scanned.length;\n\n  return true;\n};\n\n\nfunction postProcess(state, delimiters) {\n  var i,\n      startDelim,\n      endDelim,\n      token,\n      ch,\n      isStrong,\n      max = delimiters.length;\n\n  for (i = max - 1; i >= 0; i--) {\n    startDelim = delimiters[i];\n\n    if (startDelim.marker !== 0x5F/* _ */ && startDelim.marker !== 0x2A/* * */) {\n      continue;\n    }\n\n    // Process only opening markers\n    if (startDelim.end === -1) {\n      continue;\n    }\n\n    endDelim = delimiters[startDelim.end];\n\n    // If the previous delimiter has the same marker and is adjacent to this one,\n    // merge those into one strong delimiter.\n    //\n    // `<em><em>whatever</em></em>` -> `<strong>whatever</strong>`\n    //\n    isStrong = i > 0 &&\n               delimiters[i - 1].end === startDelim.end + 1 &&\n               // check that first two markers match and adjacent\n               delimiters[i - 1].marker === startDelim.marker &&\n               delimiters[i - 1].token === startDelim.token - 1 &&\n               // check that last two markers are adjacent (we can safely assume they match)\n               delimiters[startDelim.end + 1].token === endDelim.token + 1;\n\n    ch = String.fromCharCode(startDelim.marker);\n\n    token         = state.tokens[startDelim.token];\n    token.type    = isStrong ? 'strong_open' : 'em_open';\n    token.tag     = isStrong ? 'strong' : 'em';\n    token.nesting = 1;\n    token.markup  = isStrong ? ch + ch : ch;\n    token.content = '';\n\n    token         = state.tokens[endDelim.token];\n    token.type    = isStrong ? 'strong_close' : 'em_close';\n    token.tag     = isStrong ? 'strong' : 'em';\n    token.nesting = -1;\n    token.markup  = isStrong ? ch + ch : ch;\n    token.content = '';\n\n    if (isStrong) {\n      state.tokens[delimiters[i - 1].token].content = '';\n      state.tokens[delimiters[startDelim.end + 1].token].content = '';\n      i--;\n    }\n  }\n}\n\n\n// Walk through delimiter list and replace text tokens with tags\n//\nmodule.exports.postProcess = function emphasis(state) {\n  var curr,\n      tokens_meta = state.tokens_meta,\n      max = state.tokens_meta.length;\n\n  postProcess(state, state.delimiters);\n\n  for (curr = 0; curr < max; curr++) {\n    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {\n      postProcess(state, tokens_meta[curr].delimiters);\n    }\n  }\n};\n", "// Process [link](<to> \"stuff\")\n\n;\n\nvar normalizeReference   = require('../common/utils').normalizeReference;\nvar isSpace              = require('../common/utils').isSpace;\n\n\nmodule.exports = function link(state, silent) {\n  var attrs,\n      code,\n      label,\n      labelEnd,\n      labelStart,\n      pos,\n      res,\n      ref,\n      token,\n      href = '',\n      title = '',\n      oldPos = state.pos,\n      max = state.posMax,\n      start = state.pos,\n      parseReference = true;\n\n  if (state.src.charCodeAt(state.pos) !== 0x5B/* [ */) { return false; }\n\n  labelStart = state.pos + 1;\n  labelEnd = state.md.helpers.parseLinkLabel(state, state.pos, true);\n\n  // parser failed to find ']', so it's not a valid link\n  if (labelEnd < 0) { return false; }\n\n  pos = labelEnd + 1;\n  if (pos < max && state.src.charCodeAt(pos) === 0x28/* ( */) {\n    //\n    // Inline link\n    //\n\n    // might have found a valid shortcut link, disable reference parsing\n    parseReference = false;\n\n    // [link](  <href>  \"title\"  )\n    //        ^^ skipping these spaces\n    pos++;\n    for (; pos < max; pos++) {\n      code = state.src.charCodeAt(pos);\n      if (!isSpace(code) && code !== 0x0A) { break; }\n    }\n    if (pos >= max) { return false; }\n\n    // [link](  <href>  \"title\"  )\n    //          ^^^^^^ parsing link destination\n    start = pos;\n    res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);\n    if (res.ok) {\n      href = state.md.normalizeLink(res.str);\n      if (state.md.validateLink(href)) {\n        pos = res.pos;\n      } else {\n        href = '';\n      }\n\n      // [link](  <href>  \"title\"  )\n      //                ^^ skipping these spaces\n      start = pos;\n      for (; pos < max; pos++) {\n        code = state.src.charCodeAt(pos);\n        if (!isSpace(code) && code !== 0x0A) { break; }\n      }\n\n      // [link](  <href>  \"title\"  )\n      //                  ^^^^^^^ parsing link title\n      res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);\n      if (pos < max && start !== pos && res.ok) {\n        title = res.str;\n        pos = res.pos;\n\n        // [link](  <href>  \"title\"  )\n        //                         ^^ skipping these spaces\n        for (; pos < max; pos++) {\n          code = state.src.charCodeAt(pos);\n          if (!isSpace(code) && code !== 0x0A) { break; }\n        }\n      }\n    }\n\n    if (pos >= max || state.src.charCodeAt(pos) !== 0x29/* ) */) {\n      // parsing a valid shortcut link failed, fallback to reference\n      parseReference = true;\n    }\n    pos++;\n  }\n\n  if (parseReference) {\n    //\n    // Link reference\n    //\n    if (typeof state.env.references === 'undefined') { return false; }\n\n    if (pos < max && state.src.charCodeAt(pos) === 0x5B/* [ */) {\n      start = pos + 1;\n      pos = state.md.helpers.parseLinkLabel(state, pos);\n      if (pos >= 0) {\n        label = state.src.slice(start, pos++);\n      } else {\n        pos = labelEnd + 1;\n      }\n    } else {\n      pos = labelEnd + 1;\n    }\n\n    // covers label === '' and label === undefined\n    // (collapsed reference link and shortcut reference link respectively)\n    if (!label) { label = state.src.slice(labelStart, labelEnd); }\n\n    ref = state.env.references[normalizeReference(label)];\n    if (!ref) {\n      state.pos = oldPos;\n      return false;\n    }\n    href = ref.href;\n    title = ref.title;\n  }\n\n  //\n  // We found the end of the link, and know for a fact it's a valid link;\n  // so all that's left to do is to call tokenizer.\n  //\n  if (!silent) {\n    state.pos = labelStart;\n    state.posMax = labelEnd;\n\n    token        = state.push('link_open', 'a', 1);\n    token.attrs  = attrs = [ [ 'href', href ] ];\n    if (title) {\n      attrs.push([ 'title', title ]);\n    }\n\n    state.linkLevel++;\n    state.md.inline.tokenize(state);\n    state.linkLevel--;\n\n    token        = state.push('link_close', 'a', -1);\n  }\n\n  state.pos = pos;\n  state.posMax = max;\n  return true;\n};\n", "// Process ![image](<src> \"title\")\n\n;\n\nvar normalizeReference   = require('../common/utils').normalizeReference;\nvar isSpace              = require('../common/utils').isSpace;\n\n\nmodule.exports = function image(state, silent) {\n  var attrs,\n      code,\n      content,\n      label,\n      labelEnd,\n      labelStart,\n      pos,\n      ref,\n      res,\n      title,\n      token,\n      tokens,\n      start,\n      href = '',\n      oldPos = state.pos,\n      max = state.posMax;\n\n  if (state.src.charCodeAt(state.pos) !== 0x21/* ! */) { return false; }\n  if (state.src.charCodeAt(state.pos + 1) !== 0x5B/* [ */) { return false; }\n\n  labelStart = state.pos + 2;\n  labelEnd = state.md.helpers.parseLinkLabel(state, state.pos + 1, false);\n\n  // parser failed to find ']', so it's not a valid link\n  if (labelEnd < 0) { return false; }\n\n  pos = labelEnd + 1;\n  if (pos < max && state.src.charCodeAt(pos) === 0x28/* ( */) {\n    //\n    // Inline link\n    //\n\n    // [link](  <href>  \"title\"  )\n    //        ^^ skipping these spaces\n    pos++;\n    for (; pos < max; pos++) {\n      code = state.src.charCodeAt(pos);\n      if (!isSpace(code) && code !== 0x0A) { break; }\n    }\n    if (pos >= max) { return false; }\n\n    // [link](  <href>  \"title\"  )\n    //          ^^^^^^ parsing link destination\n    start = pos;\n    res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);\n    if (res.ok) {\n      href = state.md.normalizeLink(res.str);\n      if (state.md.validateLink(href)) {\n        pos = res.pos;\n      } else {\n        href = '';\n      }\n    }\n\n    // [link](  <href>  \"title\"  )\n    //                ^^ skipping these spaces\n    start = pos;\n    for (; pos < max; pos++) {\n      code = state.src.charCodeAt(pos);\n      if (!isSpace(code) && code !== 0x0A) { break; }\n    }\n\n    // [link](  <href>  \"title\"  )\n    //                  ^^^^^^^ parsing link title\n    res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);\n    if (pos < max && start !== pos && res.ok) {\n      title = res.str;\n      pos = res.pos;\n\n      // [link](  <href>  \"title\"  )\n      //                         ^^ skipping these spaces\n      for (; pos < max; pos++) {\n        code = state.src.charCodeAt(pos);\n        if (!isSpace(code) && code !== 0x0A) { break; }\n      }\n    } else {\n      title = '';\n    }\n\n    if (pos >= max || state.src.charCodeAt(pos) !== 0x29/* ) */) {\n      state.pos = oldPos;\n      return false;\n    }\n    pos++;\n  } else {\n    //\n    // Link reference\n    //\n    if (typeof state.env.references === 'undefined') { return false; }\n\n    if (pos < max && state.src.charCodeAt(pos) === 0x5B/* [ */) {\n      start = pos + 1;\n      pos = state.md.helpers.parseLinkLabel(state, pos);\n      if (pos >= 0) {\n        label = state.src.slice(start, pos++);\n      } else {\n        pos = labelEnd + 1;\n      }\n    } else {\n      pos = labelEnd + 1;\n    }\n\n    // covers label === '' and label === undefined\n    // (collapsed reference link and shortcut reference link respectively)\n    if (!label) { label = state.src.slice(labelStart, labelEnd); }\n\n    ref = state.env.references[normalizeReference(label)];\n    if (!ref) {\n      state.pos = oldPos;\n      return false;\n    }\n    href = ref.href;\n    title = ref.title;\n  }\n\n  //\n  // We found the end of the link, and know for a fact it's a valid link;\n  // so all that's left to do is to call tokenizer.\n  //\n  if (!silent) {\n    content = state.src.slice(labelStart, labelEnd);\n\n    state.md.inline.parse(\n      content,\n      state.md,\n      state.env,\n      tokens = []\n    );\n\n    token          = state.push('image', 'img', 0);\n    token.attrs    = attrs = [ [ 'src', href ], [ 'alt', '' ] ];\n    token.children = tokens;\n    token.content  = content;\n\n    if (title) {\n      attrs.push([ 'title', title ]);\n    }\n  }\n\n  state.pos = pos;\n  state.posMax = max;\n  return true;\n};\n", "// Process autolinks '<protocol:...>'\n\n;\n\n\n/*eslint max-len:0*/\nvar EMAIL_RE    = /^([a-zA-Z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/;\nvar AUTOLINK_RE = /^([a-zA-Z][a-zA-Z0-9+.\\-]{1,31}):([^<>\\x00-\\x20]*)$/;\n\n\nmodule.exports = function autolink(state, silent) {\n  var url, fullUrl, token, ch, start, max,\n      pos = state.pos;\n\n  if (state.src.charCodeAt(pos) !== 0x3C/* < */) { return false; }\n\n  start = state.pos;\n  max = state.posMax;\n\n  for (;;) {\n    if (++pos >= max) return false;\n\n    ch = state.src.charCodeAt(pos);\n\n    if (ch === 0x3C /* < */) return false;\n    if (ch === 0x3E /* > */) break;\n  }\n\n  url = state.src.slice(start + 1, pos);\n\n  if (AUTOLINK_RE.test(url)) {\n    fullUrl = state.md.normalizeLink(url);\n    if (!state.md.validateLink(fullUrl)) { return false; }\n\n    if (!silent) {\n      token         = state.push('link_open', 'a', 1);\n      token.attrs   = [ [ 'href', fullUrl ] ];\n      token.markup  = 'autolink';\n      token.info    = 'auto';\n\n      token         = state.push('text', '', 0);\n      token.content = state.md.normalizeLinkText(url);\n\n      token         = state.push('link_close', 'a', -1);\n      token.markup  = 'autolink';\n      token.info    = 'auto';\n    }\n\n    state.pos += url.length + 2;\n    return true;\n  }\n\n  if (EMAIL_RE.test(url)) {\n    fullUrl = state.md.normalizeLink('mailto:' + url);\n    if (!state.md.validateLink(fullUrl)) { return false; }\n\n    if (!silent) {\n      token         = state.push('link_open', 'a', 1);\n      token.attrs   = [ [ 'href', fullUrl ] ];\n      token.markup  = 'autolink';\n      token.info    = 'auto';\n\n      token         = state.push('text', '', 0);\n      token.content = state.md.normalizeLinkText(url);\n\n      token         = state.push('link_close', 'a', -1);\n      token.markup  = 'autolink';\n      token.info    = 'auto';\n    }\n\n    state.pos += url.length + 2;\n    return true;\n  }\n\n  return false;\n};\n", "// Regexps to match html elements\n\n;\n\nvar attr_name     = '[a-zA-Z_:][a-zA-Z0-9:._-]*';\n\nvar unquoted      = '[^\"\\'=<>`\\\\x00-\\\\x20]+';\nvar single_quoted = \"'[^']*'\";\nvar double_quoted = '\"[^\"]*\"';\n\nvar attr_value  = '(?:' + unquoted + '|' + single_quoted + '|' + double_quoted + ')';\n\nvar attribute   = '(?:\\\\s+' + attr_name + '(?:\\\\s*=\\\\s*' + attr_value + ')?)';\n\nvar open_tag    = '<[A-Za-z][A-Za-z0-9\\\\-]*' + attribute + '*\\\\s*\\\\/?>';\n\nvar close_tag   = '<\\\\/[A-Za-z][A-Za-z0-9\\\\-]*\\\\s*>';\nvar comment     = '<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->';\nvar processing  = '<[?][\\\\s\\\\S]*?[?]>';\nvar declaration = '<![A-Z]+\\\\s+[^>]*>';\nvar cdata       = '<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>';\n\nvar HTML_TAG_RE = new RegExp('^(?:' + open_tag + '|' + close_tag + '|' + comment +\n                        '|' + processing + '|' + declaration + '|' + cdata + ')');\nvar HTML_OPEN_CLOSE_TAG_RE = new RegExp('^(?:' + open_tag + '|' + close_tag + ')');\n\nmodule.exports.HTML_TAG_RE = HTML_TAG_RE;\nmodule.exports.HTML_OPEN_CLOSE_TAG_RE = HTML_OPEN_CLOSE_TAG_RE;\n", "// Process html tags\n\n;\n\n\nvar HTML_TAG_RE = require('../common/html_re').HTML_TAG_RE;\n\n\nfunction isLinkOpen(str) {\n  return /^<a[>\\s]/i.test(str);\n}\nfunction isLinkClose(str) {\n  return /^<\\/a\\s*>/i.test(str);\n}\n\n\nfunction isLetter(ch) {\n  /*eslint no-bitwise:0*/\n  var lc = ch | 0x20; // to lower case\n  return (lc >= 0x61/* a */) && (lc <= 0x7a/* z */);\n}\n\n\nmodule.exports = function html_inline(state, silent) {\n  var ch, match, max, token,\n      pos = state.pos;\n\n  if (!state.md.options.html) { return false; }\n\n  // Check start\n  max = state.posMax;\n  if (state.src.charCodeAt(pos) !== 0x3C/* < */ ||\n      pos + 2 >= max) {\n    return false;\n  }\n\n  // Quick fail on second char\n  ch = state.src.charCodeAt(pos + 1);\n  if (ch !== 0x21/* ! */ &&\n      ch !== 0x3F/* ? */ &&\n      ch !== 0x2F/* / */ &&\n      !isLetter(ch)) {\n    return false;\n  }\n\n  match = state.src.slice(pos).match(HTML_TAG_RE);\n  if (!match) { return false; }\n\n  if (!silent) {\n    token         = state.push('html_inline', '', 0);\n    token.content = state.src.slice(pos, pos + match[0].length);\n\n    if (isLinkOpen(token.content))  state.linkLevel++;\n    if (isLinkClose(token.content)) state.linkLevel--;\n  }\n  state.pos += match[0].length;\n  return true;\n};\n", "// Process html entity - &#123;, &#xAF;, &quot;, ...\n\n;\n\nvar entities          = require('../common/entities');\nvar has               = require('../common/utils').has;\nvar isValidEntityCode = require('../common/utils').isValidEntityCode;\nvar fromCodePoint     = require('../common/utils').fromCodePoint;\n\n\nvar DIGITAL_RE = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i;\nvar NAMED_RE   = /^&([a-z][a-z0-9]{1,31});/i;\n\n\nmodule.exports = function entity(state, silent) {\n  var ch, code, match, token, pos = state.pos, max = state.posMax;\n\n  if (state.src.charCodeAt(pos) !== 0x26/* & */) return false;\n\n  if (pos + 1 >= max) return false;\n\n  ch = state.src.charCodeAt(pos + 1);\n\n  if (ch === 0x23 /* # */) {\n    match = state.src.slice(pos).match(DIGITAL_RE);\n    if (match) {\n      if (!silent) {\n        code = match[1][0].toLowerCase() === 'x' ? parseInt(match[1].slice(1), 16) : parseInt(match[1], 10);\n\n        token         = state.push('text_special', '', 0);\n        token.content = isValidEntityCode(code) ? fromCodePoint(code) : fromCodePoint(0xFFFD);\n        token.markup  = match[0];\n        token.info    = 'entity';\n      }\n      state.pos += match[0].length;\n      return true;\n    }\n  } else {\n    match = state.src.slice(pos).match(NAMED_RE);\n    if (match) {\n      if (has(entities, match[1])) {\n        if (!silent) {\n          token         = state.push('text_special', '', 0);\n          token.content = entities[match[1]];\n          token.markup  = match[0];\n          token.info    = 'entity';\n        }\n        state.pos += match[0].length;\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\n", "// For each opening emphasis-like marker find a matching closing one\n//\n;\n\n\nfunction processDelimiters(state, delimiters) {\n  var closerIdx, openerIdx, closer, opener, minOpenerIdx, newMinOpenerIdx,\n      isOddMatch, lastJump,\n      openersBottom = {},\n      max = delimiters.length;\n\n  if (!max) return;\n\n  // headerIdx is the first delimiter of the current (where closer is) delimiter run\n  var headerIdx = 0;\n  var lastTokenIdx = -2; // needs any value lower than -1\n  var jumps = [];\n\n  for (closerIdx = 0; closerIdx < max; closerIdx++) {\n    closer = delimiters[closerIdx];\n\n    jumps.push(0);\n\n    // markers belong to same delimiter run if:\n    //  - they have adjacent tokens\n    //  - AND markers are the same\n    //\n    if (delimiters[headerIdx].marker !== closer.marker || lastTokenIdx !== closer.token - 1) {\n      headerIdx = closerIdx;\n    }\n\n    lastTokenIdx = closer.token;\n\n    // Length is only used for emphasis-specific \"rule of 3\",\n    // if it's not defined (in strikethrough or 3rd party plugins),\n    // we can default it to 0 to disable those checks.\n    //\n    closer.length = closer.length || 0;\n\n    if (!closer.close) continue;\n\n    // Previously calculated lower bounds (previous fails)\n    // for each marker, each delimiter length modulo 3,\n    // and for whether this closer can be an opener;\n    // https://github.com/commonmark/cmark/commit/34250e12ccebdc6372b8b49c44fab57c72443460\n    if (!openersBottom.hasOwnProperty(closer.marker)) {\n      openersBottom[closer.marker] = [ -1, -1, -1, -1, -1, -1 ];\n    }\n\n    minOpenerIdx = openersBottom[closer.marker][(closer.open ? 3 : 0) + (closer.length % 3)];\n\n    openerIdx = headerIdx - jumps[headerIdx] - 1;\n\n    newMinOpenerIdx = openerIdx;\n\n    for (; openerIdx > minOpenerIdx; openerIdx -= jumps[openerIdx] + 1) {\n      opener = delimiters[openerIdx];\n\n      if (opener.marker !== closer.marker) continue;\n\n      if (opener.open && opener.end < 0) {\n\n        isOddMatch = false;\n\n        // from spec:\n        //\n        // If one of the delimiters can both open and close emphasis, then the\n        // sum of the lengths of the delimiter runs containing the opening and\n        // closing delimiters must not be a multiple of 3 unless both lengths\n        // are multiples of 3.\n        //\n        if (opener.close || closer.open) {\n          if ((opener.length + closer.length) % 3 === 0) {\n            if (opener.length % 3 !== 0 || closer.length % 3 !== 0) {\n              isOddMatch = true;\n            }\n          }\n        }\n\n        if (!isOddMatch) {\n          // If previous delimiter cannot be an opener, we can safely skip\n          // the entire sequence in future checks. This is required to make\n          // sure algorithm has linear complexity (see *_*_*_*_*_... case).\n          //\n          lastJump = openerIdx > 0 && !delimiters[openerIdx - 1].open ?\n            jumps[openerIdx - 1] + 1 :\n            0;\n\n          jumps[closerIdx] = closerIdx - openerIdx + lastJump;\n          jumps[openerIdx] = lastJump;\n\n          closer.open  = false;\n          opener.end   = closerIdx;\n          opener.close = false;\n          newMinOpenerIdx = -1;\n          // treat next token as start of run,\n          // it optimizes skips in **<...>**a**<...>** pathological case\n          lastTokenIdx = -2;\n          break;\n        }\n      }\n    }\n\n    if (newMinOpenerIdx !== -1) {\n      // If match for this delimiter run failed, we want to set lower bound for\n      // future lookups. This is required to make sure algorithm has linear\n      // complexity.\n      //\n      // See details here:\n      // https://github.com/commonmark/cmark/issues/178#issuecomment-270417442\n      //\n      openersBottom[closer.marker][(closer.open ? 3 : 0) + ((closer.length || 0) % 3)] = newMinOpenerIdx;\n    }\n  }\n}\n\n\nmodule.exports = function link_pairs(state) {\n  var curr,\n      tokens_meta = state.tokens_meta,\n      max = state.tokens_meta.length;\n\n  processDelimiters(state, state.delimiters);\n\n  for (curr = 0; curr < max; curr++) {\n    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {\n      processDelimiters(state, tokens_meta[curr].delimiters);\n    }\n  }\n};\n", "// Clean up tokens after emphasis and strikethrough postprocessing:\n// merge adjacent text nodes into one and re-calculate all token levels\n//\n// This is necessary because initially emphasis delimiter markers (*, _, ~)\n// are treated as their own separate text tokens. Then emphasis rule either\n// leaves them as text (needed to merge with adjacent text) or turns them\n// into opening/closing tags (which messes up levels inside).\n//\n;\n\n\nmodule.exports = function fragments_join(state) {\n  var curr, last,\n      level = 0,\n      tokens = state.tokens,\n      max = state.tokens.length;\n\n  for (curr = last = 0; curr < max; curr++) {\n    // re-calculate levels after emphasis/strikethrough turns some text nodes\n    // into opening/closing tags\n    if (tokens[curr].nesting < 0) level--; // closing tag\n    tokens[curr].level = level;\n    if (tokens[curr].nesting > 0) level++; // opening tag\n\n    if (tokens[curr].type === 'text' &&\n        curr + 1 < max &&\n        tokens[curr + 1].type === 'text') {\n\n      // collapse two adjacent text nodes\n      tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;\n    } else {\n      if (curr !== last) { tokens[last] = tokens[curr]; }\n\n      last++;\n    }\n  }\n\n  if (curr !== last) {\n    tokens.length = last;\n  }\n};\n", "// Inline parser state\n\n;\n\n\nvar Token          = require('../token');\nvar isWhiteSpace   = require('../common/utils').isWhiteSpace;\nvar isPunctChar    = require('../common/utils').isPunctChar;\nvar isMdAsciiPunct = require('../common/utils').isMdAsciiPunct;\n\n\nfunction StateInline(src, md, env, outTokens) {\n  this.src = src;\n  this.env = env;\n  this.md = md;\n  this.tokens = outTokens;\n  this.tokens_meta = Array(outTokens.length);\n\n  this.pos = 0;\n  this.posMax = this.src.length;\n  this.level = 0;\n  this.pending = '';\n  this.pendingLevel = 0;\n\n  // Stores { start: end } pairs. Useful for backtrack\n  // optimization of pairs parse (emphasis, strikes).\n  this.cache = {};\n\n  // List of emphasis-like delimiters for current tag\n  this.delimiters = [];\n\n  // Stack of delimiter lists for upper level tags\n  this._prev_delimiters = [];\n\n  // backtick length => last seen position\n  this.backticks = {};\n  this.backticksScanned = false;\n\n  // Counter used to disable inline linkify-it execution\n  // inside <a> and markdown links\n  this.linkLevel = 0;\n}\n\n\n// Flush pending text\n//\nStateInline.prototype.pushPending = function () {\n  var token = new Token('text', '', 0);\n  token.content = this.pending;\n  token.level = this.pendingLevel;\n  this.tokens.push(token);\n  this.pending = '';\n  return token;\n};\n\n\n// Push new token to \"stream\".\n// If pending text exists - flush it as text token\n//\nStateInline.prototype.push = function (type, tag, nesting) {\n  if (this.pending) {\n    this.pushPending();\n  }\n\n  var token = new Token(type, tag, nesting);\n  var token_meta = null;\n\n  if (nesting < 0) {\n    // closing tag\n    this.level--;\n    this.delimiters = this._prev_delimiters.pop();\n  }\n\n  token.level = this.level;\n\n  if (nesting > 0) {\n    // opening tag\n    this.level++;\n    this._prev_delimiters.push(this.delimiters);\n    this.delimiters = [];\n    token_meta = { delimiters: this.delimiters };\n  }\n\n  this.pendingLevel = this.level;\n  this.tokens.push(token);\n  this.tokens_meta.push(token_meta);\n  return token;\n};\n\n\n// Scan a sequence of emphasis-like markers, and determine whether\n// it can start an emphasis sequence or end an emphasis sequence.\n//\n//  - start - position to scan from (it should point at a valid marker);\n//  - canSplitWord - determine if these markers can be found inside a word\n//\nStateInline.prototype.scanDelims = function (start, canSplitWord) {\n  var pos = start, lastChar, nextChar, count, can_open, can_close,\n      isLastWhiteSpace, isLastPunctChar,\n      isNextWhiteSpace, isNextPunctChar,\n      left_flanking = true,\n      right_flanking = true,\n      max = this.posMax,\n      marker = this.src.charCodeAt(start);\n\n  // treat beginning of the line as a whitespace\n  lastChar = start > 0 ? this.src.charCodeAt(start - 1) : 0x20;\n\n  while (pos < max && this.src.charCodeAt(pos) === marker) { pos++; }\n\n  count = pos - start;\n\n  // treat end of the line as a whitespace\n  nextChar = pos < max ? this.src.charCodeAt(pos) : 0x20;\n\n  isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));\n  isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));\n\n  isLastWhiteSpace = isWhiteSpace(lastChar);\n  isNextWhiteSpace = isWhiteSpace(nextChar);\n\n  if (isNextWhiteSpace) {\n    left_flanking = false;\n  } else if (isNextPunctChar) {\n    if (!(isLastWhiteSpace || isLastPunctChar)) {\n      left_flanking = false;\n    }\n  }\n\n  if (isLastWhiteSpace) {\n    right_flanking = false;\n  } else if (isLastPunctChar) {\n    if (!(isNextWhiteSpace || isNextPunctChar)) {\n      right_flanking = false;\n    }\n  }\n\n  if (!canSplitWord) {\n    can_open  = left_flanking  && (!right_flanking || isLastPunctChar);\n    can_close = right_flanking && (!left_flanking  || isNextPunctChar);\n  } else {\n    can_open  = left_flanking;\n    can_close = right_flanking;\n  }\n\n  return {\n    can_open:  can_open,\n    can_close: can_close,\n    length:    count\n  };\n};\n\n\n// re-export Token class to use in block rules\nStateInline.prototype.Token = Token;\n\n\nmodule.exports = StateInline;\n", "/** internal\n * class ParserInline\n *\n * Tokenizes paragraph content.\n **/\n;\n\n\nvar Ruler           = require('./ruler');\n\n\n////////////////////////////////////////////////////////////////////////////////\n// Parser rules\n\nvar _rules = [\n  [ 'text',            require('./rules_inline/text') ],\n  [ 'linkify',         require('./rules_inline/linkify') ],\n  [ 'newline',         require('./rules_inline/newline') ],\n  [ 'escape',          require('./rules_inline/escape') ],\n  [ 'backticks',       require('./rules_inline/backticks') ],\n  [ 'strikethrough',   require('./rules_inline/strikethrough').tokenize ],\n  [ 'emphasis',        require('./rules_inline/emphasis').tokenize ],\n  [ 'link',            require('./rules_inline/link') ],\n  [ 'image',           require('./rules_inline/image') ],\n  [ 'autolink',        require('./rules_inline/autolink') ],\n  [ 'html_inline',     require('./rules_inline/html_inline') ],\n  [ 'entity',          require('./rules_inline/entity') ]\n];\n\n// `rule2` ruleset was created specifically for emphasis/strikethrough\n// post-processing and may be changed in the future.\n//\n// Don't use this for anything except pairs (plugins working with `balance_pairs`).\n//\nvar _rules2 = [\n  [ 'balance_pairs',   require('./rules_inline/balance_pairs') ],\n  [ 'strikethrough',   require('./rules_inline/strikethrough').postProcess ],\n  [ 'emphasis',        require('./rules_inline/emphasis').postProcess ],\n  // rules for pairs separate '**' into its own text tokens, which may be left unused,\n  // rule below merges unused segments back with the rest of the text\n  [ 'fragments_join',  require('./rules_inline/fragments_join') ]\n];\n\n\n/**\n * new ParserInline()\n **/\nfunction ParserInline() {\n  var i;\n\n  /**\n   * ParserInline#ruler -> Ruler\n   *\n   * [[Ruler]] instance. Keep configuration of inline rules.\n   **/\n  this.ruler = new Ruler();\n\n  for (i = 0; i < _rules.length; i++) {\n    this.ruler.push(_rules[i][0], _rules[i][1]);\n  }\n\n  /**\n   * ParserInline#ruler2 -> Ruler\n   *\n   * [[Ruler]] instance. Second ruler used for post-processing\n   * (e.g. in emphasis-like rules).\n   **/\n  this.ruler2 = new Ruler();\n\n  for (i = 0; i < _rules2.length; i++) {\n    this.ruler2.push(_rules2[i][0], _rules2[i][1]);\n  }\n}\n\n\n// Skip single token by running all rules in validation mode;\n// returns `true` if any rule reported success\n//\nParserInline.prototype.skipToken = function (state) {\n  var ok, i, pos = state.pos,\n      rules = this.ruler.getRules(''),\n      len = rules.length,\n      maxNesting = state.md.options.maxNesting,\n      cache = state.cache;\n\n\n  if (typeof cache[pos] !== 'undefined') {\n    state.pos = cache[pos];\n    return;\n  }\n\n  if (state.level < maxNesting) {\n    for (i = 0; i < len; i++) {\n      // Increment state.level and decrement it later to limit recursion.\n      // It's harmless to do here, because no tokens are created. But ideally,\n      // we'd need a separate private state variable for this purpose.\n      //\n      state.level++;\n      ok = rules[i](state, true);\n      state.level--;\n\n      if (ok) { break; }\n    }\n  } else {\n    // Too much nesting, just skip until the end of the paragraph.\n    //\n    // NOTE: this will cause links to behave incorrectly in the following case,\n    //       when an amount of `[` is exactly equal to `maxNesting + 1`:\n    //\n    //       [[[[[[[[[[[[[[[[[[[[[foo]()\n    //\n    // TODO: remove this workaround when CM standard will allow nested links\n    //       (we can replace it by preventing links from being parsed in\n    //       validation mode)\n    //\n    state.pos = state.posMax;\n  }\n\n  if (!ok) { state.pos++; }\n  cache[pos] = state.pos;\n};\n\n\n// Generate tokens for input range\n//\nParserInline.prototype.tokenize = function (state) {\n  var ok, i,\n      rules = this.ruler.getRules(''),\n      len = rules.length,\n      end = state.posMax,\n      maxNesting = state.md.options.maxNesting;\n\n  while (state.pos < end) {\n    // Try all possible rules.\n    // On success, rule should:\n    //\n    // - update `state.pos`\n    // - update `state.tokens`\n    // - return true\n\n    if (state.level < maxNesting) {\n      for (i = 0; i < len; i++) {\n        ok = rules[i](state, false);\n        if (ok) { break; }\n      }\n    }\n\n    if (ok) {\n      if (state.pos >= end) { break; }\n      continue;\n    }\n\n    state.pending += state.src[state.pos++];\n  }\n\n  if (state.pending) {\n    state.pushPending();\n  }\n};\n\n\n/**\n * ParserInline.parse(str, md, env, outTokens)\n *\n * Process input string and push inline tokens into `outTokens`\n **/\nParserInline.prototype.parse = function (str, md, env, outTokens) {\n  var i, rules, len;\n  var state = new this.State(str, md, env, outTokens);\n\n  this.tokenize(state);\n\n  rules = this.ruler2.getRules('');\n  len = rules.length;\n\n  for (i = 0; i < len; i++) {\n    rules[i](state);\n  }\n};\n\n\nParserInline.prototype.State = require('./rules_inline/state_inline');\n\n\nmodule.exports = ParserInline;\n", "// GFM table, https://github.github.com/gfm/#tables-extension-\n\n;\n\nvar isSpace = require('../common/utils').isSpace;\n\n\nfunction getLine(state, line) {\n  var pos = state.bMarks[line] + state.tShift[line],\n      max = state.eMarks[line];\n\n  return state.src.slice(pos, max);\n}\n\nfunction escapedSplit(str) {\n  var result = [],\n      pos = 0,\n      max = str.length,\n      ch,\n      isEscaped = false,\n      lastPos = 0,\n      current = '';\n\n  ch  = str.charCodeAt(pos);\n\n  while (pos < max) {\n    if (ch === 0x7c/* | */) {\n      if (!isEscaped) {\n        // pipe separating cells, '|'\n        result.push(current + str.substring(lastPos, pos));\n        current = '';\n        lastPos = pos + 1;\n      } else {\n        // escaped pipe, '\\|'\n        current += str.substring(lastPos, pos - 1);\n        lastPos = pos;\n      }\n    }\n\n    isEscaped = (ch === 0x5c/* \\ */);\n    pos++;\n\n    ch = str.charCodeAt(pos);\n  }\n\n  result.push(current + str.substring(lastPos));\n\n  return result;\n}\n\n\nmodule.exports = function table(state, startLine, endLine, silent) {\n  var ch, lineText, pos, i, l, nextLine, columns, columnCount, token,\n      aligns, t, tableLines, tbodyLines, oldParentType, terminate,\n      terminatorRules, firstCh, secondCh;\n\n  // should have at least two lines\n  if (startLine + 2 > endLine) { return false; }\n\n  nextLine = startLine + 1;\n\n  if (state.sCount[nextLine] < state.blkIndent) { return false; }\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[nextLine] - state.blkIndent >= 4) { return false; }\n\n  // first character of the second line should be '|', '-', ':',\n  // and no other characters are allowed but spaces;\n  // basically, this is the equivalent of /^[-:|][-:|\\s]*$/ regexp\n\n  pos = state.bMarks[nextLine] + state.tShift[nextLine];\n  if (pos >= state.eMarks[nextLine]) { return false; }\n\n  firstCh = state.src.charCodeAt(pos++);\n  if (firstCh !== 0x7C/* | */ && firstCh !== 0x2D/* - */ && firstCh !== 0x3A/* : */) { return false; }\n\n  if (pos >= state.eMarks[nextLine]) { return false; }\n\n  secondCh = state.src.charCodeAt(pos++);\n  if (secondCh !== 0x7C/* | */ && secondCh !== 0x2D/* - */ && secondCh !== 0x3A/* : */ && !isSpace(secondCh)) {\n    return false;\n  }\n\n  // if first character is '-', then second character must not be a space\n  // (due to parsing ambiguity with list)\n  if (firstCh === 0x2D/* - */ && isSpace(secondCh)) { return false; }\n\n  while (pos < state.eMarks[nextLine]) {\n    ch = state.src.charCodeAt(pos);\n\n    if (ch !== 0x7C/* | */ && ch !== 0x2D/* - */ && ch !== 0x3A/* : */ && !isSpace(ch)) { return false; }\n\n    pos++;\n  }\n\n  lineText = getLine(state, startLine + 1);\n\n  columns = lineText.split('|');\n  aligns = [];\n  for (i = 0; i < columns.length; i++) {\n    t = columns[i].trim();\n    if (!t) {\n      // allow empty columns before and after table, but not in between columns;\n      // e.g. allow ` |---| `, disallow ` ---||--- `\n      if (i === 0 || i === columns.length - 1) {\n        continue;\n      } else {\n        return false;\n      }\n    }\n\n    if (!/^:?-+:?$/.test(t)) { return false; }\n    if (t.charCodeAt(t.length - 1) === 0x3A/* : */) {\n      aligns.push(t.charCodeAt(0) === 0x3A/* : */ ? 'center' : 'right');\n    } else if (t.charCodeAt(0) === 0x3A/* : */) {\n      aligns.push('left');\n    } else {\n      aligns.push('');\n    }\n  }\n\n  lineText = getLine(state, startLine).trim();\n  if (lineText.indexOf('|') === -1) { return false; }\n  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }\n  columns = escapedSplit(lineText);\n  if (columns.length && columns[0] === '') columns.shift();\n  if (columns.length && columns[columns.length - 1] === '') columns.pop();\n\n  // header row will define an amount of columns in the entire table,\n  // and align row should be exactly the same (the rest of the rows can differ)\n  columnCount = columns.length;\n  if (columnCount === 0 || columnCount !== aligns.length) { return false; }\n\n  if (silent) { return true; }\n\n  oldParentType = state.parentType;\n  state.parentType = 'table';\n\n  // use 'blockquote' lists for termination because it's\n  // the most similar to tables\n  terminatorRules = state.md.block.ruler.getRules('blockquote');\n\n  token     = state.push('table_open', 'table', 1);\n  token.map = tableLines = [ startLine, 0 ];\n\n  token     = state.push('thead_open', 'thead', 1);\n  token.map = [ startLine, startLine + 1 ];\n\n  token     = state.push('tr_open', 'tr', 1);\n  token.map = [ startLine, startLine + 1 ];\n\n  for (i = 0; i < columns.length; i++) {\n    token          = state.push('th_open', 'th', 1);\n    if (aligns[i]) {\n      token.attrs  = [ [ 'style', 'text-align:' + aligns[i] ] ];\n    }\n\n    token          = state.push('inline', '', 0);\n    token.content  = columns[i].trim();\n    token.children = [];\n\n    token          = state.push('th_close', 'th', -1);\n  }\n\n  token     = state.push('tr_close', 'tr', -1);\n  token     = state.push('thead_close', 'thead', -1);\n\n  for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {\n    if (state.sCount[nextLine] < state.blkIndent) { break; }\n\n    terminate = false;\n    for (i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n\n    if (terminate) { break; }\n    lineText = getLine(state, nextLine).trim();\n    if (!lineText) { break; }\n    if (state.sCount[nextLine] - state.blkIndent >= 4) { break; }\n    columns = escapedSplit(lineText);\n    if (columns.length && columns[0] === '') columns.shift();\n    if (columns.length && columns[columns.length - 1] === '') columns.pop();\n\n    if (nextLine === startLine + 2) {\n      token     = state.push('tbody_open', 'tbody', 1);\n      token.map = tbodyLines = [ startLine + 2, 0 ];\n    }\n\n    token     = state.push('tr_open', 'tr', 1);\n    token.map = [ nextLine, nextLine + 1 ];\n\n    for (i = 0; i < columnCount; i++) {\n      token          = state.push('td_open', 'td', 1);\n      if (aligns[i]) {\n        token.attrs  = [ [ 'style', 'text-align:' + aligns[i] ] ];\n      }\n\n      token          = state.push('inline', '', 0);\n      token.content  = columns[i] ? columns[i].trim() : '';\n      token.children = [];\n\n      token          = state.push('td_close', 'td', -1);\n    }\n    token = state.push('tr_close', 'tr', -1);\n  }\n\n  if (tbodyLines) {\n    token = state.push('tbody_close', 'tbody', -1);\n    tbodyLines[1] = nextLine;\n  }\n\n  token = state.push('table_close', 'table', -1);\n  tableLines[1] = nextLine;\n\n  state.parentType = oldParentType;\n  state.line = nextLine;\n  return true;\n};\n", "// Code block (4 spaces padded)\n\n;\n\n\nmodule.exports = function code(state, startLine, endLine/*, silent*/) {\n  var nextLine, last, token;\n\n  if (state.sCount[startLine] - state.blkIndent < 4) { return false; }\n\n  last = nextLine = startLine + 1;\n\n  while (nextLine < endLine) {\n    if (state.isEmpty(nextLine)) {\n      nextLine++;\n      continue;\n    }\n\n    if (state.sCount[nextLine] - state.blkIndent >= 4) {\n      nextLine++;\n      last = nextLine;\n      continue;\n    }\n    break;\n  }\n\n  state.line = last;\n\n  token         = state.push('code_block', 'code', 0);\n  token.content = state.getLines(startLine, last, 4 + state.blkIndent, false) + '\\n';\n  token.map     = [ startLine, state.line ];\n\n  return true;\n};\n", "// fences (``` lang, ~~~ lang)\n\n;\n\n\nmodule.exports = function fence(state, startLine, endLine, silent) {\n  var marker, len, params, nextLine, mem, token, markup,\n      haveEndMarker = false,\n      pos = state.bMarks[startLine] + state.tShift[startLine],\n      max = state.eMarks[startLine];\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }\n\n  if (pos + 3 > max) { return false; }\n\n  marker = state.src.charCodeAt(pos);\n\n  if (marker !== 0x7E/* ~ */ && marker !== 0x60 /* ` */) {\n    return false;\n  }\n\n  // scan marker length\n  mem = pos;\n  pos = state.skipChars(pos, marker);\n\n  len = pos - mem;\n\n  if (len < 3) { return false; }\n\n  markup = state.src.slice(mem, pos);\n  params = state.src.slice(pos, max);\n\n  if (marker === 0x60 /* ` */) {\n    if (params.indexOf(String.fromCharCode(marker)) >= 0) {\n      return false;\n    }\n  }\n\n  // Since start is found, we can report success here in validation mode\n  if (silent) { return true; }\n\n  // search end of block\n  nextLine = startLine;\n\n  for (;;) {\n    nextLine++;\n    if (nextLine >= endLine) {\n      // unclosed block should be autoclosed by end of document.\n      // also block seems to be autoclosed by end of parent\n      break;\n    }\n\n    pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];\n    max = state.eMarks[nextLine];\n\n    if (pos < max && state.sCount[nextLine] < state.blkIndent) {\n      // non-empty line with negative indent should stop the list:\n      // - ```\n      //  test\n      break;\n    }\n\n    if (state.src.charCodeAt(pos) !== marker) { continue; }\n\n    if (state.sCount[nextLine] - state.blkIndent >= 4) {\n      // closing fence should be indented less than 4 spaces\n      continue;\n    }\n\n    pos = state.skipChars(pos, marker);\n\n    // closing code fence must be at least as long as the opening one\n    if (pos - mem < len) { continue; }\n\n    // make sure tail has spaces only\n    pos = state.skipSpaces(pos);\n\n    if (pos < max) { continue; }\n\n    haveEndMarker = true;\n    // found!\n    break;\n  }\n\n  // If a fence has heading spaces, they should be removed from its inner block\n  len = state.sCount[startLine];\n\n  state.line = nextLine + (haveEndMarker ? 1 : 0);\n\n  token         = state.push('fence', 'code', 0);\n  token.info    = params;\n  token.content = state.getLines(startLine + 1, nextLine, len, true);\n  token.markup  = markup;\n  token.map     = [ startLine, state.line ];\n\n  return true;\n};\n", "// Block quotes\n\n;\n\nvar isSpace = require('../common/utils').isSpace;\n\n\nmodule.exports = function blockquote(state, startLine, endLine, silent) {\n  var adjustTab,\n      ch,\n      i,\n      initial,\n      l,\n      lastLineEmpty,\n      lines,\n      nextLine,\n      offset,\n      oldBMarks,\n      oldBSCount,\n      oldIndent,\n      oldParentType,\n      oldSCount,\n      oldTShift,\n      spaceAfterMarker,\n      terminate,\n      terminatorRules,\n      token,\n      isOutdented,\n      oldLineMax = state.lineMax,\n      pos = state.bMarks[startLine] + state.tShift[startLine],\n      max = state.eMarks[startLine];\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }\n\n  // check the block quote marker\n  if (state.src.charCodeAt(pos++) !== 0x3E/* > */) { return false; }\n\n  // we know that it's going to be a valid blockquote,\n  // so no point trying to find the end of it in silent mode\n  if (silent) { return true; }\n\n  // set offset past spaces and \">\"\n  initial = offset = state.sCount[startLine] + 1;\n\n  // skip one optional space after '>'\n  if (state.src.charCodeAt(pos) === 0x20 /* space */) {\n    // ' >   test '\n    //     ^ -- position start of line here:\n    pos++;\n    initial++;\n    offset++;\n    adjustTab = false;\n    spaceAfterMarker = true;\n  } else if (state.src.charCodeAt(pos) === 0x09 /* tab */) {\n    spaceAfterMarker = true;\n\n    if ((state.bsCount[startLine] + offset) % 4 === 3) {\n      // '  >\\t  test '\n      //       ^ -- position start of line here (tab has width===1)\n      pos++;\n      initial++;\n      offset++;\n      adjustTab = false;\n    } else {\n      // ' >\\t  test '\n      //    ^ -- position start of line here + shift bsCount slightly\n      //         to make extra space appear\n      adjustTab = true;\n    }\n  } else {\n    spaceAfterMarker = false;\n  }\n\n  oldBMarks = [ state.bMarks[startLine] ];\n  state.bMarks[startLine] = pos;\n\n  while (pos < max) {\n    ch = state.src.charCodeAt(pos);\n\n    if (isSpace(ch)) {\n      if (ch === 0x09) {\n        offset += 4 - (offset + state.bsCount[startLine] + (adjustTab ? 1 : 0)) % 4;\n      } else {\n        offset++;\n      }\n    } else {\n      break;\n    }\n\n    pos++;\n  }\n\n  oldBSCount = [ state.bsCount[startLine] ];\n  state.bsCount[startLine] = state.sCount[startLine] + 1 + (spaceAfterMarker ? 1 : 0);\n\n  lastLineEmpty = pos >= max;\n\n  oldSCount = [ state.sCount[startLine] ];\n  state.sCount[startLine] = offset - initial;\n\n  oldTShift = [ state.tShift[startLine] ];\n  state.tShift[startLine] = pos - state.bMarks[startLine];\n\n  terminatorRules = state.md.block.ruler.getRules('blockquote');\n\n  oldParentType = state.parentType;\n  state.parentType = 'blockquote';\n\n  // Search the end of the block\n  //\n  // Block ends with either:\n  //  1. an empty line outside:\n  //     ```\n  //     > test\n  //\n  //     ```\n  //  2. an empty line inside:\n  //     ```\n  //     >\n  //     test\n  //     ```\n  //  3. another tag:\n  //     ```\n  //     > test\n  //      - - -\n  //     ```\n  for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {\n    // check if it's outdented, i.e. it's inside list item and indented\n    // less than said list item:\n    //\n    // ```\n    // 1. anything\n    //    > current blockquote\n    // 2. checking this line\n    // ```\n    isOutdented = state.sCount[nextLine] < state.blkIndent;\n\n    pos = state.bMarks[nextLine] + state.tShift[nextLine];\n    max = state.eMarks[nextLine];\n\n    if (pos >= max) {\n      // Case 1: line is not inside the blockquote, and this line is empty.\n      break;\n    }\n\n    if (state.src.charCodeAt(pos++) === 0x3E/* > */ && !isOutdented) {\n      // This line is inside the blockquote.\n\n      // set offset past spaces and \">\"\n      initial = offset = state.sCount[nextLine] + 1;\n\n      // skip one optional space after '>'\n      if (state.src.charCodeAt(pos) === 0x20 /* space */) {\n        // ' >   test '\n        //     ^ -- position start of line here:\n        pos++;\n        initial++;\n        offset++;\n        adjustTab = false;\n        spaceAfterMarker = true;\n      } else if (state.src.charCodeAt(pos) === 0x09 /* tab */) {\n        spaceAfterMarker = true;\n\n        if ((state.bsCount[nextLine] + offset) % 4 === 3) {\n          // '  >\\t  test '\n          //       ^ -- position start of line here (tab has width===1)\n          pos++;\n          initial++;\n          offset++;\n          adjustTab = false;\n        } else {\n          // ' >\\t  test '\n          //    ^ -- position start of line here + shift bsCount slightly\n          //         to make extra space appear\n          adjustTab = true;\n        }\n      } else {\n        spaceAfterMarker = false;\n      }\n\n      oldBMarks.push(state.bMarks[nextLine]);\n      state.bMarks[nextLine] = pos;\n\n      while (pos < max) {\n        ch = state.src.charCodeAt(pos);\n\n        if (isSpace(ch)) {\n          if (ch === 0x09) {\n            offset += 4 - (offset + state.bsCount[nextLine] + (adjustTab ? 1 : 0)) % 4;\n          } else {\n            offset++;\n          }\n        } else {\n          break;\n        }\n\n        pos++;\n      }\n\n      lastLineEmpty = pos >= max;\n\n      oldBSCount.push(state.bsCount[nextLine]);\n      state.bsCount[nextLine] = state.sCount[nextLine] + 1 + (spaceAfterMarker ? 1 : 0);\n\n      oldSCount.push(state.sCount[nextLine]);\n      state.sCount[nextLine] = offset - initial;\n\n      oldTShift.push(state.tShift[nextLine]);\n      state.tShift[nextLine] = pos - state.bMarks[nextLine];\n      continue;\n    }\n\n    // Case 2: line is not inside the blockquote, and the last line was empty.\n    if (lastLineEmpty) { break; }\n\n    // Case 3: another tag found.\n    terminate = false;\n    for (i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n\n    if (terminate) {\n      // Quirk to enforce \"hard termination mode\" for paragraphs;\n      // normally if you call `tokenize(state, startLine, nextLine)`,\n      // paragraphs will look below nextLine for paragraph continuation,\n      // but if blockquote is terminated by another tag, they shouldn't\n      state.lineMax = nextLine;\n\n      if (state.blkIndent !== 0) {\n        // state.blkIndent was non-zero, we now set it to zero,\n        // so we need to re-calculate all offsets to appear as\n        // if indent wasn't changed\n        oldBMarks.push(state.bMarks[nextLine]);\n        oldBSCount.push(state.bsCount[nextLine]);\n        oldTShift.push(state.tShift[nextLine]);\n        oldSCount.push(state.sCount[nextLine]);\n        state.sCount[nextLine] -= state.blkIndent;\n      }\n\n      break;\n    }\n\n    oldBMarks.push(state.bMarks[nextLine]);\n    oldBSCount.push(state.bsCount[nextLine]);\n    oldTShift.push(state.tShift[nextLine]);\n    oldSCount.push(state.sCount[nextLine]);\n\n    // A negative indentation means that this is a paragraph continuation\n    //\n    state.sCount[nextLine] = -1;\n  }\n\n  oldIndent = state.blkIndent;\n  state.blkIndent = 0;\n\n  token        = state.push('blockquote_open', 'blockquote', 1);\n  token.markup = '>';\n  token.map    = lines = [ startLine, 0 ];\n\n  state.md.block.tokenize(state, startLine, nextLine);\n\n  token        = state.push('blockquote_close', 'blockquote', -1);\n  token.markup = '>';\n\n  state.lineMax = oldLineMax;\n  state.parentType = oldParentType;\n  lines[1] = state.line;\n\n  // Restore original tShift; this might not be necessary since the parser\n  // has already been here, but just to make sure we can do that.\n  for (i = 0; i < oldTShift.length; i++) {\n    state.bMarks[i + startLine] = oldBMarks[i];\n    state.tShift[i + startLine] = oldTShift[i];\n    state.sCount[i + startLine] = oldSCount[i];\n    state.bsCount[i + startLine] = oldBSCount[i];\n  }\n  state.blkIndent = oldIndent;\n\n  return true;\n};\n", "// Horizontal rule\n\n;\n\nvar isSpace = require('../common/utils').isSpace;\n\n\nmodule.exports = function hr(state, startLine, endLine, silent) {\n  var marker, cnt, ch, token,\n      pos = state.bMarks[startLine] + state.tShift[startLine],\n      max = state.eMarks[startLine];\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }\n\n  marker = state.src.charCodeAt(pos++);\n\n  // Check hr marker\n  if (marker !== 0x2A/* * */ &&\n      marker !== 0x2D/* - */ &&\n      marker !== 0x5F/* _ */) {\n    return false;\n  }\n\n  // markers can be mixed with spaces, but there should be at least 3 of them\n\n  cnt = 1;\n  while (pos < max) {\n    ch = state.src.charCodeAt(pos++);\n    if (ch !== marker && !isSpace(ch)) { return false; }\n    if (ch === marker) { cnt++; }\n  }\n\n  if (cnt < 3) { return false; }\n\n  if (silent) { return true; }\n\n  state.line = startLine + 1;\n\n  token        = state.push('hr', 'hr', 0);\n  token.map    = [ startLine, state.line ];\n  token.markup = Array(cnt + 1).join(String.fromCharCode(marker));\n\n  return true;\n};\n", "// Lists\n\n;\n\nvar isSpace = require('../common/utils').isSpace;\n\n\n// Search `[-+*][\\n ]`, returns next pos after marker on success\n// or -1 on fail.\nfunction skipBulletListMarker(state, startLine) {\n  var marker, pos, max, ch;\n\n  pos = state.bMarks[startLine] + state.tShift[startLine];\n  max = state.eMarks[startLine];\n\n  marker = state.src.charCodeAt(pos++);\n  // Check bullet\n  if (marker !== 0x2A/* * */ &&\n      marker !== 0x2D/* - */ &&\n      marker !== 0x2B/* + */) {\n    return -1;\n  }\n\n  if (pos < max) {\n    ch = state.src.charCodeAt(pos);\n\n    if (!isSpace(ch)) {\n      // \" -test \" - is not a list item\n      return -1;\n    }\n  }\n\n  return pos;\n}\n\n// Search `\\d+[.)][\\n ]`, returns next pos after marker on success\n// or -1 on fail.\nfunction skipOrderedListMarker(state, startLine) {\n  var ch,\n      start = state.bMarks[startLine] + state.tShift[startLine],\n      pos = start,\n      max = state.eMarks[startLine];\n\n  // List marker should have at least 2 chars (digit + dot)\n  if (pos + 1 >= max) { return -1; }\n\n  ch = state.src.charCodeAt(pos++);\n\n  if (ch < 0x30/* 0 */ || ch > 0x39/* 9 */) { return -1; }\n\n  for (;;) {\n    // EOL -> fail\n    if (pos >= max) { return -1; }\n\n    ch = state.src.charCodeAt(pos++);\n\n    if (ch >= 0x30/* 0 */ && ch <= 0x39/* 9 */) {\n\n      // List marker should have no more than 9 digits\n      // (prevents integer overflow in browsers)\n      if (pos - start >= 10) { return -1; }\n\n      continue;\n    }\n\n    // found valid marker\n    if (ch === 0x29/* ) */ || ch === 0x2e/* . */) {\n      break;\n    }\n\n    return -1;\n  }\n\n\n  if (pos < max) {\n    ch = state.src.charCodeAt(pos);\n\n    if (!isSpace(ch)) {\n      // \" 1.test \" - is not a list item\n      return -1;\n    }\n  }\n  return pos;\n}\n\nfunction markTightParagraphs(state, idx) {\n  var i, l,\n      level = state.level + 2;\n\n  for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {\n    if (state.tokens[i].level === level && state.tokens[i].type === 'paragraph_open') {\n      state.tokens[i + 2].hidden = true;\n      state.tokens[i].hidden = true;\n      i += 2;\n    }\n  }\n}\n\n\nmodule.exports = function list(state, startLine, endLine, silent) {\n  var ch,\n      contentStart,\n      i,\n      indent,\n      indentAfterMarker,\n      initial,\n      isOrdered,\n      itemLines,\n      l,\n      listLines,\n      listTokIdx,\n      markerCharCode,\n      markerValue,\n      max,\n      nextLine,\n      offset,\n      oldListIndent,\n      oldParentType,\n      oldSCount,\n      oldTShift,\n      oldTight,\n      pos,\n      posAfterMarker,\n      prevEmptyEnd,\n      start,\n      terminate,\n      terminatorRules,\n      token,\n      isTerminatingParagraph = false,\n      tight = true;\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }\n\n  // Special case:\n  //  - item 1\n  //   - item 2\n  //    - item 3\n  //     - item 4\n  //      - this one is a paragraph continuation\n  if (state.listIndent >= 0 &&\n      state.sCount[startLine] - state.listIndent >= 4 &&\n      state.sCount[startLine] < state.blkIndent) {\n    return false;\n  }\n\n  // limit conditions when list can interrupt\n  // a paragraph (validation mode only)\n  if (silent && state.parentType === 'paragraph') {\n    // Next list item should still terminate previous list item;\n    //\n    // This code can fail if plugins use blkIndent as well as lists,\n    // but I hope the spec gets fixed long before that happens.\n    //\n    if (state.sCount[startLine] >= state.blkIndent) {\n      isTerminatingParagraph = true;\n    }\n  }\n\n  // Detect list type and position after marker\n  if ((posAfterMarker = skipOrderedListMarker(state, startLine)) >= 0) {\n    isOrdered = true;\n    start = state.bMarks[startLine] + state.tShift[startLine];\n    markerValue = Number(state.src.slice(start, posAfterMarker - 1));\n\n    // If we're starting a new ordered list right after\n    // a paragraph, it should start with 1.\n    if (isTerminatingParagraph && markerValue !== 1) return false;\n\n  } else if ((posAfterMarker = skipBulletListMarker(state, startLine)) >= 0) {\n    isOrdered = false;\n\n  } else {\n    return false;\n  }\n\n  // If we're starting a new unordered list right after\n  // a paragraph, first line should not be empty.\n  if (isTerminatingParagraph) {\n    if (state.skipSpaces(posAfterMarker) >= state.eMarks[startLine]) return false;\n  }\n\n  // We should terminate list on style change. Remember first one to compare.\n  markerCharCode = state.src.charCodeAt(posAfterMarker - 1);\n\n  // For validation mode we can terminate immediately\n  if (silent) { return true; }\n\n  // Start list\n  listTokIdx = state.tokens.length;\n\n  if (isOrdered) {\n    token       = state.push('ordered_list_open', 'ol', 1);\n    if (markerValue !== 1) {\n      token.attrs = [ [ 'start', markerValue ] ];\n    }\n\n  } else {\n    token       = state.push('bullet_list_open', 'ul', 1);\n  }\n\n  token.map    = listLines = [ startLine, 0 ];\n  token.markup = String.fromCharCode(markerCharCode);\n\n  //\n  // Iterate list items\n  //\n\n  nextLine = startLine;\n  prevEmptyEnd = false;\n  terminatorRules = state.md.block.ruler.getRules('list');\n\n  oldParentType = state.parentType;\n  state.parentType = 'list';\n\n  while (nextLine < endLine) {\n    pos = posAfterMarker;\n    max = state.eMarks[nextLine];\n\n    initial = offset = state.sCount[nextLine] + posAfterMarker - (state.bMarks[startLine] + state.tShift[startLine]);\n\n    while (pos < max) {\n      ch = state.src.charCodeAt(pos);\n\n      if (ch === 0x09) {\n        offset += 4 - (offset + state.bsCount[nextLine]) % 4;\n      } else if (ch === 0x20) {\n        offset++;\n      } else {\n        break;\n      }\n\n      pos++;\n    }\n\n    contentStart = pos;\n\n    if (contentStart >= max) {\n      // trimming space in \"-    \\n  3\" case, indent is 1 here\n      indentAfterMarker = 1;\n    } else {\n      indentAfterMarker = offset - initial;\n    }\n\n    // If we have more than 4 spaces, the indent is 1\n    // (the rest is just indented code block)\n    if (indentAfterMarker > 4) { indentAfterMarker = 1; }\n\n    // \"  -  test\"\n    //  ^^^^^ - calculating total length of this thing\n    indent = initial + indentAfterMarker;\n\n    // Run subparser & write tokens\n    token        = state.push('list_item_open', 'li', 1);\n    token.markup = String.fromCharCode(markerCharCode);\n    token.map    = itemLines = [ startLine, 0 ];\n    if (isOrdered) {\n      token.info = state.src.slice(start, posAfterMarker - 1);\n    }\n\n    // change current state, then restore it after parser subcall\n    oldTight = state.tight;\n    oldTShift = state.tShift[startLine];\n    oldSCount = state.sCount[startLine];\n\n    //  - example list\n    // ^ listIndent position will be here\n    //   ^ blkIndent position will be here\n    //\n    oldListIndent = state.listIndent;\n    state.listIndent = state.blkIndent;\n    state.blkIndent = indent;\n\n    state.tight = true;\n    state.tShift[startLine] = contentStart - state.bMarks[startLine];\n    state.sCount[startLine] = offset;\n\n    if (contentStart >= max && state.isEmpty(startLine + 1)) {\n      // workaround for this case\n      // (list item is empty, list terminates before \"foo\"):\n      // ~~~~~~~~\n      //   -\n      //\n      //     foo\n      // ~~~~~~~~\n      state.line = Math.min(state.line + 2, endLine);\n    } else {\n      state.md.block.tokenize(state, startLine, endLine, true);\n    }\n\n    // If any of list item is tight, mark list as tight\n    if (!state.tight || prevEmptyEnd) {\n      tight = false;\n    }\n    // Item become loose if finish with empty line,\n    // but we should filter last element, because it means list finish\n    prevEmptyEnd = (state.line - startLine) > 1 && state.isEmpty(state.line - 1);\n\n    state.blkIndent = state.listIndent;\n    state.listIndent = oldListIndent;\n    state.tShift[startLine] = oldTShift;\n    state.sCount[startLine] = oldSCount;\n    state.tight = oldTight;\n\n    token        = state.push('list_item_close', 'li', -1);\n    token.markup = String.fromCharCode(markerCharCode);\n\n    nextLine = startLine = state.line;\n    itemLines[1] = nextLine;\n    contentStart = state.bMarks[startLine];\n\n    if (nextLine >= endLine) { break; }\n\n    //\n    // Try to check if list is terminated or continued.\n    //\n    if (state.sCount[nextLine] < state.blkIndent) { break; }\n\n    // if it's indented more than 3 spaces, it should be a code block\n    if (state.sCount[startLine] - state.blkIndent >= 4) { break; }\n\n    // fail if terminating block found\n    terminate = false;\n    for (i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n    if (terminate) { break; }\n\n    // fail if list has another type\n    if (isOrdered) {\n      posAfterMarker = skipOrderedListMarker(state, nextLine);\n      if (posAfterMarker < 0) { break; }\n      start = state.bMarks[nextLine] + state.tShift[nextLine];\n    } else {\n      posAfterMarker = skipBulletListMarker(state, nextLine);\n      if (posAfterMarker < 0) { break; }\n    }\n\n    if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) { break; }\n  }\n\n  // Finalize list\n  if (isOrdered) {\n    token = state.push('ordered_list_close', 'ol', -1);\n  } else {\n    token = state.push('bullet_list_close', 'ul', -1);\n  }\n  token.markup = String.fromCharCode(markerCharCode);\n\n  listLines[1] = nextLine;\n  state.line = nextLine;\n\n  state.parentType = oldParentType;\n\n  // mark paragraphs tight if needed\n  if (tight) {\n    markTightParagraphs(state, listTokIdx);\n  }\n\n  return true;\n};\n", ";\n\n\nvar normalizeReference   = require('../common/utils').normalizeReference;\nvar isSpace              = require('../common/utils').isSpace;\n\n\nmodule.exports = function reference(state, startLine, _endLine, silent) {\n  var ch,\n      destEndPos,\n      destEndLineNo,\n      endLine,\n      href,\n      i,\n      l,\n      label,\n      labelEnd,\n      oldParentType,\n      res,\n      start,\n      str,\n      terminate,\n      terminatorRules,\n      title,\n      lines = 0,\n      pos = state.bMarks[startLine] + state.tShift[startLine],\n      max = state.eMarks[startLine],\n      nextLine = startLine + 1;\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }\n\n  if (state.src.charCodeAt(pos) !== 0x5B/* [ */) { return false; }\n\n  // Simple check to quickly interrupt scan on [link](url) at the start of line.\n  // Can be useful on practice: https://github.com/markdown-it/markdown-it/issues/54\n  while (++pos < max) {\n    if (state.src.charCodeAt(pos) === 0x5D /* ] */ &&\n        state.src.charCodeAt(pos - 1) !== 0x5C/* \\ */) {\n      if (pos + 1 === max) { return false; }\n      if (state.src.charCodeAt(pos + 1) !== 0x3A/* : */) { return false; }\n      break;\n    }\n  }\n\n  endLine = state.lineMax;\n\n  // jump line-by-line until empty one or EOF\n  terminatorRules = state.md.block.ruler.getRules('reference');\n\n  oldParentType = state.parentType;\n  state.parentType = 'reference';\n\n  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {\n    // this would be a code block normally, but after paragraph\n    // it's considered a lazy continuation regardless of what's there\n    if (state.sCount[nextLine] - state.blkIndent > 3) { continue; }\n\n    // quirk for blockquotes, this line should already be checked by that rule\n    if (state.sCount[nextLine] < 0) { continue; }\n\n    // Some tags can terminate paragraph without empty line.\n    terminate = false;\n    for (i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n    if (terminate) { break; }\n  }\n\n  str = state.getLines(startLine, nextLine, state.blkIndent, false).trim();\n  max = str.length;\n\n  for (pos = 1; pos < max; pos++) {\n    ch = str.charCodeAt(pos);\n    if (ch === 0x5B /* [ */) {\n      return false;\n    } else if (ch === 0x5D /* ] */) {\n      labelEnd = pos;\n      break;\n    } else if (ch === 0x0A /* \\n */) {\n      lines++;\n    } else if (ch === 0x5C /* \\ */) {\n      pos++;\n      if (pos < max && str.charCodeAt(pos) === 0x0A) {\n        lines++;\n      }\n    }\n  }\n\n  if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 0x3A/* : */) { return false; }\n\n  // [label]:   destination   'title'\n  //         ^^^ skip optional whitespace here\n  for (pos = labelEnd + 2; pos < max; pos++) {\n    ch = str.charCodeAt(pos);\n    if (ch === 0x0A) {\n      lines++;\n    } else if (isSpace(ch)) {\n      /*eslint no-empty:0*/\n    } else {\n      break;\n    }\n  }\n\n  // [label]:   destination   'title'\n  //            ^^^^^^^^^^^ parse this\n  res = state.md.helpers.parseLinkDestination(str, pos, max);\n  if (!res.ok) { return false; }\n\n  href = state.md.normalizeLink(res.str);\n  if (!state.md.validateLink(href)) { return false; }\n\n  pos = res.pos;\n  lines += res.lines;\n\n  // save cursor state, we could require to rollback later\n  destEndPos = pos;\n  destEndLineNo = lines;\n\n  // [label]:   destination   'title'\n  //                       ^^^ skipping those spaces\n  start = pos;\n  for (; pos < max; pos++) {\n    ch = str.charCodeAt(pos);\n    if (ch === 0x0A) {\n      lines++;\n    } else if (isSpace(ch)) {\n      /*eslint no-empty:0*/\n    } else {\n      break;\n    }\n  }\n\n  // [label]:   destination   'title'\n  //                          ^^^^^^^ parse this\n  res = state.md.helpers.parseLinkTitle(str, pos, max);\n  if (pos < max && start !== pos && res.ok) {\n    title = res.str;\n    pos = res.pos;\n    lines += res.lines;\n  } else {\n    title = '';\n    pos = destEndPos;\n    lines = destEndLineNo;\n  }\n\n  // skip trailing spaces until the rest of the line\n  while (pos < max) {\n    ch = str.charCodeAt(pos);\n    if (!isSpace(ch)) { break; }\n    pos++;\n  }\n\n  if (pos < max && str.charCodeAt(pos) !== 0x0A) {\n    if (title) {\n      // garbage at the end of the line after title,\n      // but it could still be a valid reference if we roll back\n      title = '';\n      pos = destEndPos;\n      lines = destEndLineNo;\n      while (pos < max) {\n        ch = str.charCodeAt(pos);\n        if (!isSpace(ch)) { break; }\n        pos++;\n      }\n    }\n  }\n\n  if (pos < max && str.charCodeAt(pos) !== 0x0A) {\n    // garbage at the end of the line\n    return false;\n  }\n\n  label = normalizeReference(str.slice(1, labelEnd));\n  if (!label) {\n    // CommonMark 0.20 disallows empty labels\n    return false;\n  }\n\n  // Reference can not terminate anything. This check is for safety only.\n  /*istanbul ignore if*/\n  if (silent) { return true; }\n\n  if (typeof state.env.references === 'undefined') {\n    state.env.references = {};\n  }\n  if (typeof state.env.references[label] === 'undefined') {\n    state.env.references[label] = { title: title, href: href };\n  }\n\n  state.parentType = oldParentType;\n\n  state.line = startLine + lines + 1;\n  return true;\n};\n", "// List of valid html blocks names, accorting to commonmark spec\n// http://jgm.github.io/CommonMark/spec.html#html-blocks\n\n;\n\n\nmodule.exports = [\n  'address',\n  'article',\n  'aside',\n  'base',\n  'basefont',\n  'blockquote',\n  'body',\n  'caption',\n  'center',\n  'col',\n  'colgroup',\n  'dd',\n  'details',\n  'dialog',\n  'dir',\n  'div',\n  'dl',\n  'dt',\n  'fieldset',\n  'figcaption',\n  'figure',\n  'footer',\n  'form',\n  'frame',\n  'frameset',\n  'h1',\n  'h2',\n  'h3',\n  'h4',\n  'h5',\n  'h6',\n  'head',\n  'header',\n  'hr',\n  'html',\n  'iframe',\n  'legend',\n  'li',\n  'link',\n  'main',\n  'menu',\n  'menuitem',\n  'nav',\n  'noframes',\n  'ol',\n  'optgroup',\n  'option',\n  'p',\n  'param',\n  'section',\n  'source',\n  'summary',\n  'table',\n  'tbody',\n  'td',\n  'tfoot',\n  'th',\n  'thead',\n  'title',\n  'tr',\n  'track',\n  'ul'\n];\n", "// HTML block\n\n;\n\n\nvar block_names = require('../common/html_blocks');\nvar HTML_OPEN_CLOSE_TAG_RE = require('../common/html_re').HTML_OPEN_CLOSE_TAG_RE;\n\n// An array of opening and corresponding closing sequences for html tags,\n// last argument defines whether it can terminate a paragraph or not\n//\nvar HTML_SEQUENCES = [\n  [ /^<(script|pre|style|textarea)(?=(\\s|>|$))/i, /<\\/(script|pre|style|textarea)>/i, true ],\n  [ /^<!--/,        /-->/,   true ],\n  [ /^<\\?/,         /\\?>/,   true ],\n  [ /^<![A-Z]/,     />/,     true ],\n  [ /^<!\\[CDATA\\[/, /\\]\\]>/, true ],\n  [ new RegExp('^</?(' + block_names.join('|') + ')(?=(\\\\s|/?>|$))', 'i'), /^$/, true ],\n  [ new RegExp(HTML_OPEN_CLOSE_TAG_RE.source + '\\\\s*$'),  /^$/, false ]\n];\n\n\nmodule.exports = function html_block(state, startLine, endLine, silent) {\n  var i, nextLine, token, lineText,\n      pos = state.bMarks[startLine] + state.tShift[startLine],\n      max = state.eMarks[startLine];\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }\n\n  if (!state.md.options.html) { return false; }\n\n  if (state.src.charCodeAt(pos) !== 0x3C/* < */) { return false; }\n\n  lineText = state.src.slice(pos, max);\n\n  for (i = 0; i < HTML_SEQUENCES.length; i++) {\n    if (HTML_SEQUENCES[i][0].test(lineText)) { break; }\n  }\n\n  if (i === HTML_SEQUENCES.length) { return false; }\n\n  if (silent) {\n    // true if this sequence can be a terminator, false otherwise\n    return HTML_SEQUENCES[i][2];\n  }\n\n  nextLine = startLine + 1;\n\n  // If we are here - we detected HTML block.\n  // Let's roll down till block end.\n  if (!HTML_SEQUENCES[i][1].test(lineText)) {\n    for (; nextLine < endLine; nextLine++) {\n      if (state.sCount[nextLine] < state.blkIndent) { break; }\n\n      pos = state.bMarks[nextLine] + state.tShift[nextLine];\n      max = state.eMarks[nextLine];\n      lineText = state.src.slice(pos, max);\n\n      if (HTML_SEQUENCES[i][1].test(lineText)) {\n        if (lineText.length !== 0) { nextLine++; }\n        break;\n      }\n    }\n  }\n\n  state.line = nextLine;\n\n  token         = state.push('html_block', '', 0);\n  token.map     = [ startLine, nextLine ];\n  token.content = state.getLines(startLine, nextLine, state.blkIndent, true);\n\n  return true;\n};\n", "// heading (#, ##, ...)\n\n;\n\nvar isSpace = require('../common/utils').isSpace;\n\n\nmodule.exports = function heading(state, startLine, endLine, silent) {\n  var ch, level, tmp, token,\n      pos = state.bMarks[startLine] + state.tShift[startLine],\n      max = state.eMarks[startLine];\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }\n\n  ch  = state.src.charCodeAt(pos);\n\n  if (ch !== 0x23/* # */ || pos >= max) { return false; }\n\n  // count heading level\n  level = 1;\n  ch = state.src.charCodeAt(++pos);\n  while (ch === 0x23/* # */ && pos < max && level <= 6) {\n    level++;\n    ch = state.src.charCodeAt(++pos);\n  }\n\n  if (level > 6 || (pos < max && !isSpace(ch))) { return false; }\n\n  if (silent) { return true; }\n\n  // Let's cut tails like '    ###  ' from the end of string\n\n  max = state.skipSpacesBack(max, pos);\n  tmp = state.skipCharsBack(max, 0x23, pos); // #\n  if (tmp > pos && isSpace(state.src.charCodeAt(tmp - 1))) {\n    max = tmp;\n  }\n\n  state.line = startLine + 1;\n\n  token        = state.push('heading_open', 'h' + String(level), 1);\n  token.markup = '########'.slice(0, level);\n  token.map    = [ startLine, state.line ];\n\n  token          = state.push('inline', '', 0);\n  token.content  = state.src.slice(pos, max).trim();\n  token.map      = [ startLine, state.line ];\n  token.children = [];\n\n  token        = state.push('heading_close', 'h' + String(level), -1);\n  token.markup = '########'.slice(0, level);\n\n  return true;\n};\n", "// lheading (---, ===)\n\n;\n\n\nmodule.exports = function lheading(state, startLine, endLine/*, silent*/) {\n  var content, terminate, i, l, token, pos, max, level, marker,\n      nextLine = startLine + 1, oldParentType,\n      terminatorRules = state.md.block.ruler.getRules('paragraph');\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }\n\n  oldParentType = state.parentType;\n  state.parentType = 'paragraph'; // use paragraph to match terminatorRules\n\n  // jump line-by-line until empty one or EOF\n  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {\n    // this would be a code block normally, but after paragraph\n    // it's considered a lazy continuation regardless of what's there\n    if (state.sCount[nextLine] - state.blkIndent > 3) { continue; }\n\n    //\n    // Check for underline in setext header\n    //\n    if (state.sCount[nextLine] >= state.blkIndent) {\n      pos = state.bMarks[nextLine] + state.tShift[nextLine];\n      max = state.eMarks[nextLine];\n\n      if (pos < max) {\n        marker = state.src.charCodeAt(pos);\n\n        if (marker === 0x2D/* - */ || marker === 0x3D/* = */) {\n          pos = state.skipChars(pos, marker);\n          pos = state.skipSpaces(pos);\n\n          if (pos >= max) {\n            level = (marker === 0x3D/* = */ ? 1 : 2);\n            break;\n          }\n        }\n      }\n    }\n\n    // quirk for blockquotes, this line should already be checked by that rule\n    if (state.sCount[nextLine] < 0) { continue; }\n\n    // Some tags can terminate paragraph without empty line.\n    terminate = false;\n    for (i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n    if (terminate) { break; }\n  }\n\n  if (!level) {\n    // Didn't find valid underline\n    return false;\n  }\n\n  content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();\n\n  state.line = nextLine + 1;\n\n  token          = state.push('heading_open', 'h' + String(level), 1);\n  token.markup   = String.fromCharCode(marker);\n  token.map      = [ startLine, state.line ];\n\n  token          = state.push('inline', '', 0);\n  token.content  = content;\n  token.map      = [ startLine, state.line - 1 ];\n  token.children = [];\n\n  token          = state.push('heading_close', 'h' + String(level), -1);\n  token.markup   = String.fromCharCode(marker);\n\n  state.parentType = oldParentType;\n\n  return true;\n};\n", "// Paragraph\n\n;\n\n\nmodule.exports = function paragraph(state, startLine/*, endLine*/) {\n  var content, terminate, i, l, token, oldParentType,\n      nextLine = startLine + 1,\n      terminatorRules = state.md.block.ruler.getRules('paragraph'),\n      endLine = state.lineMax;\n\n  oldParentType = state.parentType;\n  state.parentType = 'paragraph';\n\n  // jump line-by-line until empty one or EOF\n  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {\n    // this would be a code block normally, but after paragraph\n    // it's considered a lazy continuation regardless of what's there\n    if (state.sCount[nextLine] - state.blkIndent > 3) { continue; }\n\n    // quirk for blockquotes, this line should already be checked by that rule\n    if (state.sCount[nextLine] < 0) { continue; }\n\n    // Some tags can terminate paragraph without empty line.\n    terminate = false;\n    for (i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n    if (terminate) { break; }\n  }\n\n  content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();\n\n  state.line = nextLine;\n\n  token          = state.push('paragraph_open', 'p', 1);\n  token.map      = [ startLine, state.line ];\n\n  token          = state.push('inline', '', 0);\n  token.content  = content;\n  token.map      = [ startLine, state.line ];\n  token.children = [];\n\n  token          = state.push('paragraph_close', 'p', -1);\n\n  state.parentType = oldParentType;\n\n  return true;\n};\n", "// Parser state class\n\n;\n\nvar Token = require('../token');\nvar isSpace = require('../common/utils').isSpace;\n\n\nfunction StateBlock(src, md, env, tokens) {\n  var ch, s, start, pos, len, indent, offset, indent_found;\n\n  this.src = src;\n\n  // link to parser instance\n  this.md     = md;\n\n  this.env = env;\n\n  //\n  // Internal state vartiables\n  //\n\n  this.tokens = tokens;\n\n  this.bMarks = [];  // line begin offsets for fast jumps\n  this.eMarks = [];  // line end offsets for fast jumps\n  this.tShift = [];  // offsets of the first non-space characters (tabs not expanded)\n  this.sCount = [];  // indents for each line (tabs expanded)\n\n  // An amount of virtual spaces (tabs expanded) between beginning\n  // of each line (bMarks) and real beginning of that line.\n  //\n  // It exists only as a hack because blockquotes override bMarks\n  // losing information in the process.\n  //\n  // It's used only when expanding tabs, you can think about it as\n  // an initial tab length, e.g. bsCount=21 applied to string `\\t123`\n  // means first tab should be expanded to 4-21%4 === 3 spaces.\n  //\n  this.bsCount = [];\n\n  // block parser variables\n  this.blkIndent  = 0; // required block content indent (for example, if we are\n                       // inside a list, it would be positioned after list marker)\n  this.line       = 0; // line index in src\n  this.lineMax    = 0; // lines count\n  this.tight      = false;  // loose/tight mode for lists\n  this.ddIndent   = -1; // indent of the current dd block (-1 if there isn't any)\n  this.listIndent = -1; // indent of the current list block (-1 if there isn't any)\n\n  // can be 'blockquote', 'list', 'root', 'paragraph' or 'reference'\n  // used in lists to determine if they interrupt a paragraph\n  this.parentType = 'root';\n\n  this.level = 0;\n\n  // renderer\n  this.result = '';\n\n  // Create caches\n  // Generate markers.\n  s = this.src;\n  indent_found = false;\n\n  for (start = pos = indent = offset = 0, len = s.length; pos < len; pos++) {\n    ch = s.charCodeAt(pos);\n\n    if (!indent_found) {\n      if (isSpace(ch)) {\n        indent++;\n\n        if (ch === 0x09) {\n          offset += 4 - offset % 4;\n        } else {\n          offset++;\n        }\n        continue;\n      } else {\n        indent_found = true;\n      }\n    }\n\n    if (ch === 0x0A || pos === len - 1) {\n      if (ch !== 0x0A) { pos++; }\n      this.bMarks.push(start);\n      this.eMarks.push(pos);\n      this.tShift.push(indent);\n      this.sCount.push(offset);\n      this.bsCount.push(0);\n\n      indent_found = false;\n      indent = 0;\n      offset = 0;\n      start = pos + 1;\n    }\n  }\n\n  // Push fake entry to simplify cache bounds checks\n  this.bMarks.push(s.length);\n  this.eMarks.push(s.length);\n  this.tShift.push(0);\n  this.sCount.push(0);\n  this.bsCount.push(0);\n\n  this.lineMax = this.bMarks.length - 1; // don't count last fake line\n}\n\n// Push new token to \"stream\".\n//\nStateBlock.prototype.push = function (type, tag, nesting) {\n  var token = new Token(type, tag, nesting);\n  token.block = true;\n\n  if (nesting < 0) this.level--; // closing tag\n  token.level = this.level;\n  if (nesting > 0) this.level++; // opening tag\n\n  this.tokens.push(token);\n  return token;\n};\n\nStateBlock.prototype.isEmpty = function isEmpty(line) {\n  return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];\n};\n\nStateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {\n  for (var max = this.lineMax; from < max; from++) {\n    if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {\n      break;\n    }\n  }\n  return from;\n};\n\n// Skip spaces from given position.\nStateBlock.prototype.skipSpaces = function skipSpaces(pos) {\n  var ch;\n\n  for (var max = this.src.length; pos < max; pos++) {\n    ch = this.src.charCodeAt(pos);\n    if (!isSpace(ch)) { break; }\n  }\n  return pos;\n};\n\n// Skip spaces from given position in reverse.\nStateBlock.prototype.skipSpacesBack = function skipSpacesBack(pos, min) {\n  if (pos <= min) { return pos; }\n\n  while (pos > min) {\n    if (!isSpace(this.src.charCodeAt(--pos))) { return pos + 1; }\n  }\n  return pos;\n};\n\n// Skip char codes from given position\nStateBlock.prototype.skipChars = function skipChars(pos, code) {\n  for (var max = this.src.length; pos < max; pos++) {\n    if (this.src.charCodeAt(pos) !== code) { break; }\n  }\n  return pos;\n};\n\n// Skip char codes reverse from given position - 1\nStateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code, min) {\n  if (pos <= min) { return pos; }\n\n  while (pos > min) {\n    if (code !== this.src.charCodeAt(--pos)) { return pos + 1; }\n  }\n  return pos;\n};\n\n// cut lines range from source.\nStateBlock.prototype.getLines = function getLines(begin, end, indent, keepLastLF) {\n  var i, lineIndent, ch, first, last, queue, lineStart,\n      line = begin;\n\n  if (begin >= end) {\n    return '';\n  }\n\n  queue = new Array(end - begin);\n\n  for (i = 0; line < end; line++, i++) {\n    lineIndent = 0;\n    lineStart = first = this.bMarks[line];\n\n    if (line + 1 < end || keepLastLF) {\n      // No need for bounds check because we have fake entry on tail.\n      last = this.eMarks[line] + 1;\n    } else {\n      last = this.eMarks[line];\n    }\n\n    while (first < last && lineIndent < indent) {\n      ch = this.src.charCodeAt(first);\n\n      if (isSpace(ch)) {\n        if (ch === 0x09) {\n          lineIndent += 4 - (lineIndent + this.bsCount[line]) % 4;\n        } else {\n          lineIndent++;\n        }\n      } else if (first - lineStart < this.tShift[line]) {\n        // patched tShift masked characters to look like spaces (blockquotes, list markers)\n        lineIndent++;\n      } else {\n        break;\n      }\n\n      first++;\n    }\n\n    if (lineIndent > indent) {\n      // partially expanding tabs in code blocks, e.g '\\t\\tfoobar'\n      // with indent=2 becomes '  \\tfoobar'\n      queue[i] = new Array(lineIndent - indent + 1).join(' ') + this.src.slice(first, last);\n    } else {\n      queue[i] = this.src.slice(first, last);\n    }\n  }\n\n  return queue.join('');\n};\n\n// re-export Token class to use in block rules\nStateBlock.prototype.Token = Token;\n\n\nmodule.exports = StateBlock;\n", "/** internal\n * class ParserBlock\n *\n * Block-level tokenizer.\n **/\n;\n\n\nvar Ruler           = require('./ruler');\n\n\nvar _rules = [\n  // First 2 params - rule name & source. Secondary array - list of rules,\n  // which can be terminated by this one.\n  [ 'table',      require('./rules_block/table'),      [ 'paragraph', 'reference' ] ],\n  [ 'code',       require('./rules_block/code') ],\n  [ 'fence',      require('./rules_block/fence'),      [ 'paragraph', 'reference', 'blockquote', 'list' ] ],\n  [ 'blockquote', require('./rules_block/blockquote'), [ 'paragraph', 'reference', 'blockquote', 'list' ] ],\n  [ 'hr',         require('./rules_block/hr'),         [ 'paragraph', 'reference', 'blockquote', 'list' ] ],\n  [ 'list',       require('./rules_block/list'),       [ 'paragraph', 'reference', 'blockquote' ] ],\n  [ 'reference',  require('./rules_block/reference') ],\n  [ 'html_block', require('./rules_block/html_block'), [ 'paragraph', 'reference', 'blockquote' ] ],\n  [ 'heading',    require('./rules_block/heading'),    [ 'paragraph', 'reference', 'blockquote' ] ],\n  [ 'lheading',   require('./rules_block/lheading') ],\n  [ 'paragraph',  require('./rules_block/paragraph') ]\n];\n\n\n/**\n * new ParserBlock()\n **/\nfunction ParserBlock() {\n  /**\n   * ParserBlock#ruler -> Ruler\n   *\n   * [[Ruler]] instance. Keep configuration of block rules.\n   **/\n  this.ruler = new Ruler();\n\n  for (var i = 0; i < _rules.length; i++) {\n    this.ruler.push(_rules[i][0], _rules[i][1], { alt: (_rules[i][2] || []).slice() });\n  }\n}\n\n\n// Generate tokens for input range\n//\nParserBlock.prototype.tokenize = function (state, startLine, endLine) {\n  var ok, i,\n      rules = this.ruler.getRules(''),\n      len = rules.length,\n      line = startLine,\n      hasEmptyLines = false,\n      maxNesting = state.md.options.maxNesting;\n\n  while (line < endLine) {\n    state.line = line = state.skipEmptyLines(line);\n    if (line >= endLine) { break; }\n\n    // Termination condition for nested calls.\n    // Nested calls currently used for blockquotes & lists\n    if (state.sCount[line] < state.blkIndent) { break; }\n\n    // If nesting level exceeded - skip tail to the end. That's not ordinary\n    // situation and we should not care about content.\n    if (state.level >= maxNesting) {\n      state.line = endLine;\n      break;\n    }\n\n    // Try all possible rules.\n    // On success, rule should:\n    //\n    // - update `state.line`\n    // - update `state.tokens`\n    // - return true\n\n    for (i = 0; i < len; i++) {\n      ok = rules[i](state, line, endLine, false);\n      if (ok) { break; }\n    }\n\n    // set state.tight if we had an empty line before current tag\n    // i.e. latest empty line should not count\n    state.tight = !hasEmptyLines;\n\n    // paragraph might \"eat\" one newline after it in nested lists\n    if (state.isEmpty(state.line - 1)) {\n      hasEmptyLines = true;\n    }\n\n    line = state.line;\n\n    if (line < endLine && state.isEmpty(line)) {\n      hasEmptyLines = true;\n      line++;\n      state.line = line;\n    }\n  }\n};\n\n\n/**\n * ParserBlock.parse(str, md, env, outTokens)\n *\n * Process input string and push block tokens into `outTokens`\n **/\nParserBlock.prototype.parse = function (src, md, env, outTokens) {\n  var state;\n\n  if (!src) { return; }\n\n  state = new this.State(src, md, env, outTokens);\n\n  this.tokenize(state, state.line, state.lineMax);\n};\n\n\nParserBlock.prototype.State = require('./rules_block/state_block');\n\n\nmodule.exports = ParserBlock;\n", "// Normalize input string\n\n;\n\n\n// https://spec.commonmark.org/0.29/#line-ending\nvar NEWLINES_RE  = /\\r\\n?|\\n/g;\nvar NULL_RE      = /\\0/g;\n\n\nmodule.exports = function normalize(state) {\n  var str;\n\n  // Normalize newlines\n  str = state.src.replace(NEWLINES_RE, '\\n');\n\n  // Replace NULL characters\n  str = str.replace(NULL_RE, '\\uFFFD');\n\n  state.src = str;\n};\n", ";\n\n\nmodule.exports = function block(state) {\n  var token;\n\n  if (state.inlineMode) {\n    token          = new state.Token('inline', '', 0);\n    token.content  = state.src;\n    token.map      = [ 0, 1 ];\n    token.children = [];\n    state.tokens.push(token);\n  } else {\n    state.md.block.parse(state.src, state.md, state.env, state.tokens);\n  }\n};\n", ";\n\nmodule.exports = function inline(state) {\n  var tokens = state.tokens, tok, i, l;\n\n  // Parse inlines\n  for (i = 0, l = tokens.length; i < l; i++) {\n    tok = tokens[i];\n    if (tok.type === 'inline') {\n      state.md.inline.parse(tok.content, state.md, state.env, tok.children);\n    }\n  }\n};\n", "// Replace link-like texts with link nodes.\n//\n// Currently restricted by `md.validateLink()` to http/https/ftp\n//\n;\n\n\nvar arrayReplaceAt = require('../common/utils').arrayReplaceAt;\n\n\nfunction isLinkOpen(str) {\n  return /^<a[>\\s]/i.test(str);\n}\nfunction isLinkClose(str) {\n  return /^<\\/a\\s*>/i.test(str);\n}\n\n\nmodule.exports = function linkify(state) {\n  var i, j, l, tokens, token, currentToken, nodes, ln, text, pos, lastPos,\n      level, htmlLinkLevel, url, fullUrl, urlText,\n      blockTokens = state.tokens,\n      links;\n\n  if (!state.md.options.linkify) { return; }\n\n  for (j = 0, l = blockTokens.length; j < l; j++) {\n    if (blockTokens[j].type !== 'inline' ||\n        !state.md.linkify.pretest(blockTokens[j].content)) {\n      continue;\n    }\n\n    tokens = blockTokens[j].children;\n\n    htmlLinkLevel = 0;\n\n    // We scan from the end, to keep position when new tags added.\n    // Use reversed logic in links start/end match\n    for (i = tokens.length - 1; i >= 0; i--) {\n      currentToken = tokens[i];\n\n      // Skip content of markdown links\n      if (currentToken.type === 'link_close') {\n        i--;\n        while (tokens[i].level !== currentToken.level && tokens[i].type !== 'link_open') {\n          i--;\n        }\n        continue;\n      }\n\n      // Skip content of html tag links\n      if (currentToken.type === 'html_inline') {\n        if (isLinkOpen(currentToken.content) && htmlLinkLevel > 0) {\n          htmlLinkLevel--;\n        }\n        if (isLinkClose(currentToken.content)) {\n          htmlLinkLevel++;\n        }\n      }\n      if (htmlLinkLevel > 0) { continue; }\n\n      if (currentToken.type === 'text' && state.md.linkify.test(currentToken.content)) {\n\n        text = currentToken.content;\n        links = state.md.linkify.match(text);\n\n        // Now split string to nodes\n        nodes = [];\n        level = currentToken.level;\n        lastPos = 0;\n\n        // forbid escape sequence at the start of the string,\n        // this avoids http\\://example.com/ from being linkified as\n        // http:<a href=\"//example.com/\">//example.com/</a>\n        if (links.length > 0 &&\n            links[0].index === 0 &&\n            i > 0 &&\n            tokens[i - 1].type === 'text_special') {\n          links = links.slice(1);\n        }\n\n        for (ln = 0; ln < links.length; ln++) {\n          url = links[ln].url;\n          fullUrl = state.md.normalizeLink(url);\n          if (!state.md.validateLink(fullUrl)) { continue; }\n\n          urlText = links[ln].text;\n\n          // Linkifier might send raw hostnames like \"example.com\", where url\n          // starts with domain name. So we prepend http:// in those cases,\n          // and remove it afterwards.\n          //\n          if (!links[ln].schema) {\n            urlText = state.md.normalizeLinkText('http://' + urlText).replace(/^http:\\/\\//, '');\n          } else if (links[ln].schema === 'mailto:' && !/^mailto:/i.test(urlText)) {\n            urlText = state.md.normalizeLinkText('mailto:' + urlText).replace(/^mailto:/, '');\n          } else {\n            urlText = state.md.normalizeLinkText(urlText);\n          }\n\n          pos = links[ln].index;\n\n          if (pos > lastPos) {\n            token         = new state.Token('text', '', 0);\n            token.content = text.slice(lastPos, pos);\n            token.level   = level;\n            nodes.push(token);\n          }\n\n          token         = new state.Token('link_open', 'a', 1);\n          token.attrs   = [ [ 'href', fullUrl ] ];\n          token.level   = level++;\n          token.markup  = 'linkify';\n          token.info    = 'auto';\n          nodes.push(token);\n\n          token         = new state.Token('text', '', 0);\n          token.content = urlText;\n          token.level   = level;\n          nodes.push(token);\n\n          token         = new state.Token('link_close', 'a', -1);\n          token.level   = --level;\n          token.markup  = 'linkify';\n          token.info    = 'auto';\n          nodes.push(token);\n\n          lastPos = links[ln].lastIndex;\n        }\n        if (lastPos < text.length) {\n          token         = new state.Token('text', '', 0);\n          token.content = text.slice(lastPos);\n          token.level   = level;\n          nodes.push(token);\n        }\n\n        // replace current node\n        blockTokens[j].children = tokens = arrayReplaceAt(tokens, i, nodes);\n      }\n    }\n  }\n};\n", "// Simple typographic replacements\n//\n// (c) (C) \u2192 \u00A9\n// (tm) (TM) \u2192 \u2122\n// (r) (R) \u2192 \u00AE\n// +- \u2192 \u00B1\n// (p) (P) -> \u00A7\n// ... \u2192 \u2026 (also ?.... \u2192 ?.., !.... \u2192 !..)\n// ???????? \u2192 ???, !!!!! \u2192 !!!, `,,` \u2192 `,`\n// -- \u2192 &ndash;, --- \u2192 &mdash;\n//\n;\n\n// TODO:\n// - fractionals 1/2, 1/4, 3/4 -> \u00BD, \u00BC, \u00BE\n// - multiplications 2 x 4 -> 2 \u00D7 4\n\nvar RARE_RE = /\\+-|\\.\\.|\\?\\?\\?\\?|!!!!|,,|--/;\n\n// Workaround for phantomjs - need regex without /g flag,\n// or root check will fail every second time\nvar SCOPED_ABBR_TEST_RE = /\\((c|tm|r)\\)/i;\n\nvar SCOPED_ABBR_RE = /\\((c|tm|r)\\)/ig;\nvar SCOPED_ABBR = {\n  c: '\u00A9',\n  r: '\u00AE',\n  tm: '\u2122'\n};\n\nfunction replaceFn(match, name) {\n  return SCOPED_ABBR[name.toLowerCase()];\n}\n\nfunction replace_scoped(inlineTokens) {\n  var i, token, inside_autolink = 0;\n\n  for (i = inlineTokens.length - 1; i >= 0; i--) {\n    token = inlineTokens[i];\n\n    if (token.type === 'text' && !inside_autolink) {\n      token.content = token.content.replace(SCOPED_ABBR_RE, replaceFn);\n    }\n\n    if (token.type === 'link_open' && token.info === 'auto') {\n      inside_autolink--;\n    }\n\n    if (token.type === 'link_close' && token.info === 'auto') {\n      inside_autolink++;\n    }\n  }\n}\n\nfunction replace_rare(inlineTokens) {\n  var i, token, inside_autolink = 0;\n\n  for (i = inlineTokens.length - 1; i >= 0; i--) {\n    token = inlineTokens[i];\n\n    if (token.type === 'text' && !inside_autolink) {\n      if (RARE_RE.test(token.content)) {\n        token.content = token.content\n          .replace(/\\+-/g, '\u00B1')\n          // .., ..., ....... -> \u2026\n          // but ?..... & !..... -> ?.. & !..\n          .replace(/\\.{2,}/g, '\u2026').replace(/([?!])\u2026/g, '$1..')\n          .replace(/([?!]){4,}/g, '$1$1$1').replace(/,{2,}/g, ',')\n          // em-dash\n          .replace(/(^|[^-])---(?=[^-]|$)/mg, '$1\\u2014')\n          // en-dash\n          .replace(/(^|\\s)--(?=\\s|$)/mg, '$1\\u2013')\n          .replace(/(^|[^-\\s])--(?=[^-\\s]|$)/mg, '$1\\u2013');\n      }\n    }\n\n    if (token.type === 'link_open' && token.info === 'auto') {\n      inside_autolink--;\n    }\n\n    if (token.type === 'link_close' && token.info === 'auto') {\n      inside_autolink++;\n    }\n  }\n}\n\n\nmodule.exports = function replace(state) {\n  var blkIdx;\n\n  if (!state.md.options.typographer) { return; }\n\n  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {\n\n    if (state.tokens[blkIdx].type !== 'inline') { continue; }\n\n    if (SCOPED_ABBR_TEST_RE.test(state.tokens[blkIdx].content)) {\n      replace_scoped(state.tokens[blkIdx].children);\n    }\n\n    if (RARE_RE.test(state.tokens[blkIdx].content)) {\n      replace_rare(state.tokens[blkIdx].children);\n    }\n\n  }\n};\n", "// Convert straight quotation marks to typographic ones\n//\n;\n\n\nvar isWhiteSpace   = require('../common/utils').isWhiteSpace;\nvar isPunctChar    = require('../common/utils').isPunctChar;\nvar isMdAsciiPunct = require('../common/utils').isMdAsciiPunct;\n\nvar QUOTE_TEST_RE = /['\"]/;\nvar QUOTE_RE = /['\"]/g;\nvar APOSTROPHE = '\\u2019'; /* \u2019 */\n\n\nfunction replaceAt(str, index, ch) {\n  return str.slice(0, index) + ch + str.slice(index + 1);\n}\n\nfunction process_inlines(tokens, state) {\n  var i, token, text, t, pos, max, thisLevel, item, lastChar, nextChar,\n      isLastPunctChar, isNextPunctChar, isLastWhiteSpace, isNextWhiteSpace,\n      canOpen, canClose, j, isSingle, stack, openQuote, closeQuote;\n\n  stack = [];\n\n  for (i = 0; i < tokens.length; i++) {\n    token = tokens[i];\n\n    thisLevel = tokens[i].level;\n\n    for (j = stack.length - 1; j >= 0; j--) {\n      if (stack[j].level <= thisLevel) { break; }\n    }\n    stack.length = j + 1;\n\n    if (token.type !== 'text') { continue; }\n\n    text = token.content;\n    pos = 0;\n    max = text.length;\n\n    /*eslint no-labels:0,block-scoped-var:0*/\n    OUTER:\n    while (pos < max) {\n      QUOTE_RE.lastIndex = pos;\n      t = QUOTE_RE.exec(text);\n      if (!t) { break; }\n\n      canOpen = canClose = true;\n      pos = t.index + 1;\n      isSingle = (t[0] === \"'\");\n\n      // Find previous character,\n      // default to space if it's the beginning of the line\n      //\n      lastChar = 0x20;\n\n      if (t.index - 1 >= 0) {\n        lastChar = text.charCodeAt(t.index - 1);\n      } else {\n        for (j = i - 1; j >= 0; j--) {\n          if (tokens[j].type === 'softbreak' || tokens[j].type === 'hardbreak') break; // lastChar defaults to 0x20\n          if (!tokens[j].content) continue; // should skip all tokens except 'text', 'html_inline' or 'code_inline'\n\n          lastChar = tokens[j].content.charCodeAt(tokens[j].content.length - 1);\n          break;\n        }\n      }\n\n      // Find next character,\n      // default to space if it's the end of the line\n      //\n      nextChar = 0x20;\n\n      if (pos < max) {\n        nextChar = text.charCodeAt(pos);\n      } else {\n        for (j = i + 1; j < tokens.length; j++) {\n          if (tokens[j].type === 'softbreak' || tokens[j].type === 'hardbreak') break; // nextChar defaults to 0x20\n          if (!tokens[j].content) continue; // should skip all tokens except 'text', 'html_inline' or 'code_inline'\n\n          nextChar = tokens[j].content.charCodeAt(0);\n          break;\n        }\n      }\n\n      isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));\n      isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));\n\n      isLastWhiteSpace = isWhiteSpace(lastChar);\n      isNextWhiteSpace = isWhiteSpace(nextChar);\n\n      if (isNextWhiteSpace) {\n        canOpen = false;\n      } else if (isNextPunctChar) {\n        if (!(isLastWhiteSpace || isLastPunctChar)) {\n          canOpen = false;\n        }\n      }\n\n      if (isLastWhiteSpace) {\n        canClose = false;\n      } else if (isLastPunctChar) {\n        if (!(isNextWhiteSpace || isNextPunctChar)) {\n          canClose = false;\n        }\n      }\n\n      if (nextChar === 0x22 /* \" */ && t[0] === '\"') {\n        if (lastChar >= 0x30 /* 0 */ && lastChar <= 0x39 /* 9 */) {\n          // special case: 1\"\" - count first quote as an inch\n          canClose = canOpen = false;\n        }\n      }\n\n      if (canOpen && canClose) {\n        // Replace quotes in the middle of punctuation sequence, but not\n        // in the middle of the words, i.e.:\n        //\n        // 1. foo \" bar \" baz - not replaced\n        // 2. foo-\"-bar-\"-baz - replaced\n        // 3. foo\"bar\"baz     - not replaced\n        //\n        canOpen = isLastPunctChar;\n        canClose = isNextPunctChar;\n      }\n\n      if (!canOpen && !canClose) {\n        // middle of word\n        if (isSingle) {\n          token.content = replaceAt(token.content, t.index, APOSTROPHE);\n        }\n        continue;\n      }\n\n      if (canClose) {\n        // this could be a closing quote, rewind the stack to get a match\n        for (j = stack.length - 1; j >= 0; j--) {\n          item = stack[j];\n          if (stack[j].level < thisLevel) { break; }\n          if (item.single === isSingle && stack[j].level === thisLevel) {\n            item = stack[j];\n\n            if (isSingle) {\n              openQuote = state.md.options.quotes[2];\n              closeQuote = state.md.options.quotes[3];\n            } else {\n              openQuote = state.md.options.quotes[0];\n              closeQuote = state.md.options.quotes[1];\n            }\n\n            // replace token.content *before* tokens[item.token].content,\n            // because, if they are pointing at the same token, replaceAt\n            // could mess up indices when quote length != 1\n            token.content = replaceAt(token.content, t.index, closeQuote);\n            tokens[item.token].content = replaceAt(\n              tokens[item.token].content, item.pos, openQuote);\n\n            pos += closeQuote.length - 1;\n            if (item.token === i) { pos += openQuote.length - 1; }\n\n            text = token.content;\n            max = text.length;\n\n            stack.length = j;\n            continue OUTER;\n          }\n        }\n      }\n\n      if (canOpen) {\n        stack.push({\n          token: i,\n          pos: t.index,\n          single: isSingle,\n          level: thisLevel\n        });\n      } else if (canClose && isSingle) {\n        token.content = replaceAt(token.content, t.index, APOSTROPHE);\n      }\n    }\n  }\n}\n\n\nmodule.exports = function smartquotes(state) {\n  /*eslint max-depth:0*/\n  var blkIdx;\n\n  if (!state.md.options.typographer) { return; }\n\n  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {\n\n    if (state.tokens[blkIdx].type !== 'inline' ||\n        !QUOTE_TEST_RE.test(state.tokens[blkIdx].content)) {\n      continue;\n    }\n\n    process_inlines(state.tokens[blkIdx].children, state);\n  }\n};\n", "// Join raw text tokens with the rest of the text\n//\n// This is set as a separate rule to provide an opportunity for plugins\n// to run text replacements after text join, but before escape join.\n//\n// For example, `\\:)` shouldn't be replaced with an emoji.\n//\n;\n\n\nmodule.exports = function text_join(state) {\n  var j, l, tokens, curr, max, last,\n      blockTokens = state.tokens;\n\n  for (j = 0, l = blockTokens.length; j < l; j++) {\n    if (blockTokens[j].type !== 'inline') continue;\n\n    tokens = blockTokens[j].children;\n    max = tokens.length;\n\n    for (curr = 0; curr < max; curr++) {\n      if (tokens[curr].type === 'text_special') {\n        tokens[curr].type = 'text';\n      }\n    }\n\n    for (curr = last = 0; curr < max; curr++) {\n      if (tokens[curr].type === 'text' &&\n          curr + 1 < max &&\n          tokens[curr + 1].type === 'text') {\n\n        // collapse two adjacent text nodes\n        tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;\n      } else {\n        if (curr !== last) { tokens[last] = tokens[curr]; }\n\n        last++;\n      }\n    }\n\n    if (curr !== last) {\n      tokens.length = last;\n    }\n  }\n};\n", "// Core state object\n//\n;\n\nvar Token = require('../token');\n\n\nfunction StateCore(src, md, env) {\n  this.src = src;\n  this.env = env;\n  this.tokens = [];\n  this.inlineMode = false;\n  this.md = md; // link to parser instance\n}\n\n// re-export Token class to use in core rules\nStateCore.prototype.Token = Token;\n\n\nmodule.exports = StateCore;\n", "/** internal\n * class Core\n *\n * Top-level rules executor. Glues block/inline parsers and does intermediate\n * transformations.\n **/\n;\n\n\nvar Ruler  = require('./ruler');\n\n\nvar _rules = [\n  [ 'normalize',      require('./rules_core/normalize')      ],\n  [ 'block',          require('./rules_core/block')          ],\n  [ 'inline',         require('./rules_core/inline')         ],\n  [ 'linkify',        require('./rules_core/linkify')        ],\n  [ 'replacements',   require('./rules_core/replacements')   ],\n  [ 'smartquotes',    require('./rules_core/smartquotes')    ],\n  // `text_join` finds `text_special` tokens (for escape sequences)\n  // and joins them with the rest of the text\n  [ 'text_join',      require('./rules_core/text_join')      ]\n];\n\n\n/**\n * new Core()\n **/\nfunction Core() {\n  /**\n   * Core#ruler -> Ruler\n   *\n   * [[Ruler]] instance. Keep configuration of core rules.\n   **/\n  this.ruler = new Ruler();\n\n  for (var i = 0; i < _rules.length; i++) {\n    this.ruler.push(_rules[i][0], _rules[i][1]);\n  }\n}\n\n\n/**\n * Core.process(state)\n *\n * Executes core chain rules.\n **/\nCore.prototype.process = function (state) {\n  var i, l, rules;\n\n  rules = this.ruler.getRules('');\n\n  for (i = 0, l = rules.length; i < l; i++) {\n    rules[i](state);\n  }\n};\n\nCore.prototype.State = require('./rules_core/state_core');\n\n\nmodule.exports = Core;\n", ";\n\nconst conf = (process.env.FENGARICONF ? JSON.parse(process.env.FENGARICONF) : {});\n\nconst {\n    LUA_VERSION_MAJOR,\n    LUA_VERSION_MINOR,\n    to_luastring\n} = require('./defs.js');\n\n/*\n** LUA_PATH_SEP is the character that separates templates in a path.\n** LUA_PATH_MARK is the string that marks the substitution points in a\n** template.\n** LUA_EXEC_DIR in a Windows path is replaced by the executable's\n** directory.\n*/\nconst LUA_PATH_SEP  = \";\";\nmodule.exports.LUA_PATH_SEP = LUA_PATH_SEP;\n\nconst LUA_PATH_MARK = \"?\";\nmodule.exports.LUA_PATH_MARK = LUA_PATH_MARK;\n\nconst LUA_EXEC_DIR  = \"!\";\nmodule.exports.LUA_EXEC_DIR = LUA_EXEC_DIR;\n\n/*\n@@ LUA_PATH_DEFAULT is the default path that Lua uses to look for\n** Lua libraries.\n@@ LUA_JSPATH_DEFAULT is the default path that Lua uses to look for\n** JS libraries.\n** CHANGE them if your machine has a non-conventional directory\n** hierarchy or if you want to install your libraries in\n** non-conventional directories.\n*/\nconst LUA_VDIR = LUA_VERSION_MAJOR + \".\" + LUA_VERSION_MINOR;\nmodule.exports.LUA_VDIR = LUA_VDIR;\n\nif (typeof process === \"undefined\") {\n    const LUA_DIRSEP = \"/\";\n    module.exports.LUA_DIRSEP = LUA_DIRSEP;\n\n    const LUA_LDIR = \"./lua/\" + LUA_VDIR + \"/\";\n    module.exports.LUA_LDIR = LUA_LDIR;\n\n    const LUA_JSDIR = LUA_LDIR;\n    module.exports.LUA_JSDIR = LUA_JSDIR;\n\n    const LUA_PATH_DEFAULT = to_luastring(\n        LUA_LDIR + \"?.lua;\" + LUA_LDIR + \"?/init.lua;\" +\n        /* LUA_JSDIR excluded as it is equal to LUA_LDIR */\n        \"./?.lua;./?/init.lua\"\n    );\n    module.exports.LUA_PATH_DEFAULT = LUA_PATH_DEFAULT;\n\n    const LUA_JSPATH_DEFAULT = to_luastring(\n        LUA_JSDIR + \"?.js;\" + LUA_JSDIR + \"loadall.js;./?.js\"\n    );\n    module.exports.LUA_JSPATH_DEFAULT = LUA_JSPATH_DEFAULT;\n} else if (require('os').platform() === 'win32') {\n    const LUA_DIRSEP = \"\\\\\";\n    module.exports.LUA_DIRSEP = LUA_DIRSEP;\n\n    /*\n    ** In Windows, any exclamation mark ('!') in the path is replaced by the\n    ** path of the directory of the executable file of the current process.\n    */\n    const LUA_LDIR = \"!\\\\lua\\\\\";\n    module.exports.LUA_LDIR = LUA_LDIR;\n\n    const LUA_JSDIR = \"!\\\\\";\n    module.exports.LUA_JSDIR = LUA_JSDIR;\n\n    const LUA_SHRDIR = \"!\\\\..\\\\share\\\\lua\\\\\" + LUA_VDIR + \"\\\\\";\n    module.exports.LUA_SHRDIR = LUA_SHRDIR;\n\n    const LUA_PATH_DEFAULT = to_luastring(\n        LUA_LDIR + \"?.lua;\" + LUA_LDIR + \"?\\\\init.lua;\" +\n        LUA_JSDIR + \"?.lua;\" + LUA_JSDIR + \"?\\\\init.lua;\" +\n        LUA_SHRDIR + \"?.lua;\" + LUA_SHRDIR + \"?\\\\init.lua;\" +\n        \".\\\\?.lua;.\\\\?\\\\init.lua\"\n    );\n    module.exports.LUA_PATH_DEFAULT = LUA_PATH_DEFAULT;\n\n    const LUA_JSPATH_DEFAULT = to_luastring(\n        LUA_JSDIR + \"?.js;\" +\n        LUA_JSDIR + \"..\\\\share\\\\lua\\\\\" + LUA_VDIR + \"\\\\?.js;\" +\n        LUA_JSDIR + \"loadall.js;.\\\\?.js\"\n    );\n    module.exports.LUA_JSPATH_DEFAULT = LUA_JSPATH_DEFAULT;\n} else {\n    const LUA_DIRSEP = \"/\";\n    module.exports.LUA_DIRSEP = LUA_DIRSEP;\n\n    const LUA_ROOT = \"/usr/local/\";\n    module.exports.LUA_ROOT = LUA_ROOT;\n    const LUA_ROOT2 = \"/usr/\";\n\n    const LUA_LDIR = LUA_ROOT + \"share/lua/\" + LUA_VDIR + \"/\";\n    const LUA_LDIR2 = LUA_ROOT2 + \"share/lua/\" + LUA_VDIR + \"/\";\n    module.exports.LUA_LDIR = LUA_LDIR;\n\n    const LUA_JSDIR = LUA_LDIR;\n    module.exports.LUA_JSDIR = LUA_JSDIR;\n    const LUA_JSDIR2 = LUA_LDIR2;\n\n    const LUA_PATH_DEFAULT = to_luastring(\n        LUA_LDIR + \"?.lua;\" + LUA_LDIR + \"?/init.lua;\" +\n        LUA_LDIR2 + \"?.lua;\" + LUA_LDIR2 + \"?/init.lua;\" +\n        /* LUA_JSDIR(2) excluded as it is equal to LUA_LDIR(2) */\n        \"./?.lua;./?/init.lua\"\n    );\n    module.exports.LUA_PATH_DEFAULT = LUA_PATH_DEFAULT;\n\n    const LUA_JSPATH_DEFAULT = to_luastring(\n        LUA_JSDIR + \"?.js;\" + LUA_JSDIR + \"loadall.js;\" +\n        LUA_JSDIR2 + \"?.js;\" + LUA_JSDIR2 + \"loadall.js;\" +\n        \"./?.js\"\n    );\n    module.exports.LUA_JSPATH_DEFAULT = LUA_JSPATH_DEFAULT;\n}\n\n/*\n@@ LUA_COMPAT_FLOATSTRING makes Lua format integral floats without a\n@@ a float mark ('.0').\n** This macro is not on by default even in compatibility mode,\n** because this is not really an incompatibility.\n*/\nconst LUA_COMPAT_FLOATSTRING = conf.LUA_COMPAT_FLOATSTRING || false;\n\nconst LUA_MAXINTEGER = 2147483647;\nconst LUA_MININTEGER = -2147483648;\n\n/*\n@@ LUAI_MAXSTACK limits the size of the Lua stack.\n** CHANGE it if you need a different limit. This limit is arbitrary;\n** its only purpose is to stop Lua from consuming unlimited stack\n** space (and to reserve some numbers for pseudo-indices).\n*/\nconst LUAI_MAXSTACK = conf.LUAI_MAXSTACK || 1000000;\n\n/*\n@@ LUA_IDSIZE gives the maximum size for the description of the source\n@@ of a function in debug information.\n** CHANGE it if you want a different size.\n*/\nconst LUA_IDSIZE = conf.LUA_IDSIZE || (60-1); /* fengari uses 1 less than lua as we don't embed the null byte */\n\nconst lua_integer2str = function(n) {\n    return String(n); /* should match behaviour of LUA_INTEGER_FMT */\n};\n\nconst lua_number2str = function(n) {\n    return String(Number(n.toPrecision(14))); /* should match behaviour of LUA_NUMBER_FMT */\n};\n\nconst lua_numbertointeger = function(n) {\n    return n >= LUA_MININTEGER && n < -LUA_MININTEGER ? n : false;\n};\n\nconst LUA_INTEGER_FRMLEN = \"\";\nconst LUA_NUMBER_FRMLEN = \"\";\n\nconst LUA_INTEGER_FMT = `%${LUA_INTEGER_FRMLEN}d`;\nconst LUA_NUMBER_FMT  = \"%.14g\";\n\nconst lua_getlocaledecpoint = function() {\n    /* we hard-code the decimal point to '.' as a user cannot change the\n       locale in most JS environments, and in that you can, a multi-byte\n       locale is common.\n    */\n    return 46 /* '.'.charCodeAt(0) */;\n};\n\nconst luai_apicheck = function(l, e) {\n    if (!e) throw Error(e);\n};\n\n/*\n@@ LUAL_BUFFERSIZE is the buffer size used by the lauxlib buffer system.\n*/\nconst LUAL_BUFFERSIZE = conf.LUAL_BUFFERSIZE || 8192;\n\n// See: http://croquetweak.blogspot.fr/2014/08/deconstructing-floats-frexp-and-ldexp.html\nconst frexp = function(value) {\n    if (value === 0) return [value, 0];\n    var data = new DataView(new ArrayBuffer(8));\n    data.setFloat64(0, value);\n    var bits = (data.getUint32(0) >>> 20) & 0x7FF;\n    if (bits === 0) { // denormal\n        data.setFloat64(0, value * Math.pow(2, 64));  // exp + 64\n        bits = ((data.getUint32(0) >>> 20) & 0x7FF) - 64;\n    }\n    var exponent = bits - 1022;\n    var mantissa = ldexp(value, -exponent);\n    return [mantissa, exponent];\n};\n\nconst ldexp = function(mantissa, exponent) {\n    var steps = Math.min(3, Math.ceil(Math.abs(exponent) / 1023));\n    var result = mantissa;\n    for (var i = 0; i < steps; i++)\n        result *= Math.pow(2, Math.floor((exponent + i) / steps));\n    return result;\n};\n\nmodule.exports.LUAI_MAXSTACK          = LUAI_MAXSTACK;\nmodule.exports.LUA_COMPAT_FLOATSTRING = LUA_COMPAT_FLOATSTRING;\nmodule.exports.LUA_IDSIZE             = LUA_IDSIZE;\nmodule.exports.LUA_INTEGER_FMT        = LUA_INTEGER_FMT;\nmodule.exports.LUA_INTEGER_FRMLEN     = LUA_INTEGER_FRMLEN;\nmodule.exports.LUA_MAXINTEGER         = LUA_MAXINTEGER;\nmodule.exports.LUA_MININTEGER         = LUA_MININTEGER;\nmodule.exports.LUA_NUMBER_FMT         = LUA_NUMBER_FMT;\nmodule.exports.LUA_NUMBER_FRMLEN      = LUA_NUMBER_FRMLEN;\nmodule.exports.LUAL_BUFFERSIZE        = LUAL_BUFFERSIZE;\nmodule.exports.frexp                  = frexp;\nmodule.exports.ldexp                  = ldexp;\nmodule.exports.lua_getlocaledecpoint  = lua_getlocaledecpoint;\nmodule.exports.lua_integer2str        = lua_integer2str;\nmodule.exports.lua_number2str         = lua_number2str;\nmodule.exports.lua_numbertointeger    = lua_numbertointeger;\nmodule.exports.luai_apicheck          = luai_apicheck;\n", ";\n\n/*\n * Fengari specific string conversion functions\n */\n\nlet luastring_from;\nif (typeof Uint8Array.from === \"function\") {\n    luastring_from = Uint8Array.from.bind(Uint8Array);\n} else {\n    luastring_from = function(a) {\n        let i = 0;\n        let len = a.length;\n        let r = new Uint8Array(len);\n        while (len > i) r[i] = a[i++];\n        return r;\n    };\n}\n\nlet luastring_indexOf;\nif (typeof (new Uint8Array().indexOf) === \"function\") {\n    luastring_indexOf = function(s, v, i) {\n        return s.indexOf(v, i);\n    };\n} else {\n    /* Browsers that don't support Uint8Array.indexOf seem to allow using Array.indexOf on Uint8Array objects e.g. IE11 */\n    let array_indexOf = [].indexOf;\n    if (array_indexOf.call(new Uint8Array(1), 0) !== 0) throw Error(\"missing .indexOf\");\n    luastring_indexOf = function(s, v, i) {\n        return array_indexOf.call(s, v, i);\n    };\n}\n\nlet luastring_of;\nif (typeof Uint8Array.of === \"function\") {\n    luastring_of = Uint8Array.of.bind(Uint8Array);\n} else {\n    luastring_of = function() {\n        return luastring_from(arguments);\n    };\n}\n\nconst is_luastring = function(s) {\n    return s instanceof Uint8Array;\n};\n\n/* test two lua strings for equality */\nconst luastring_eq = function(a, b) {\n    if (a !== b) {\n        let len = a.length;\n        if (len !== b.length) return false;\n        /* XXX: Should this be a constant time algorithm? */\n        for (let i=0; i<len; i++)\n            if (a[i] !== b[i]) return false;\n    }\n    return true;\n};\n\nconst unicode_error_message = \"cannot convert invalid utf8 to javascript string\";\nconst to_jsstring = function(value, from, to, replacement_char) {\n    if (!is_luastring(value)) throw new TypeError(\"to_jsstring expects a Uint8Array\");\n\n    if (to === void 0) {\n        to = value.length;\n    } else {\n        to = Math.min(value.length, to);\n    }\n\n    let str = \"\";\n    for (let i = (from!==void 0?from:0); i < to;) {\n        let u0 = value[i++];\n        if (u0 < 0x80) {\n            /* single byte sequence */\n            str += String.fromCharCode(u0);\n        } else if (u0 < 0xC2 || u0 > 0xF4) {\n            if (!replacement_char) throw RangeError(unicode_error_message);\n            str += \"\uFFFD\";\n        } else if (u0 <= 0xDF) {\n            /* two byte sequence */\n            if (i >= to) {\n                if (!replacement_char) throw RangeError(unicode_error_message);\n                str += \"\uFFFD\";\n                continue;\n            }\n            let u1 = value[i++];\n            if ((u1&0xC0) !== 0x80) {\n                if (!replacement_char) throw RangeError(unicode_error_message);\n                str += \"\uFFFD\";\n                continue;\n            }\n            str += String.fromCharCode(((u0 & 0x1F) << 6) + (u1 & 0x3F));\n        } else if (u0 <= 0xEF) {\n            /* three byte sequence */\n            if (i+1 >= to) {\n                if (!replacement_char) throw RangeError(unicode_error_message);\n                str += \"\uFFFD\";\n                continue;\n            }\n            let u1 = value[i++];\n            if ((u1&0xC0) !== 0x80) {\n                if (!replacement_char) throw RangeError(unicode_error_message);\n                str += \"\uFFFD\";\n                continue;\n            }\n            let u2 = value[i++];\n            if ((u2&0xC0) !== 0x80) {\n                if (!replacement_char) throw RangeError(unicode_error_message);\n                str += \"\uFFFD\";\n                continue;\n            }\n            let u = ((u0 & 0x0F) << 12) + ((u1 & 0x3F) << 6) + (u2 & 0x3F);\n            if (u <= 0xFFFF) { /* BMP codepoint */\n                str += String.fromCharCode(u);\n            } else { /* Astral codepoint */\n                u -= 0x10000;\n                let s1 = (u >> 10) + 0xD800;\n                let s2 = (u % 0x400) + 0xDC00;\n                str += String.fromCharCode(s1, s2);\n            }\n        } else {\n            /* four byte sequence */\n            if (i+2 >= to) {\n                if (!replacement_char) throw RangeError(unicode_error_message);\n                str += \"\uFFFD\";\n                continue;\n            }\n            let u1 = value[i++];\n            if ((u1&0xC0) !== 0x80) {\n                if (!replacement_char) throw RangeError(unicode_error_message);\n                str += \"\uFFFD\";\n                continue;\n            }\n            let u2 = value[i++];\n            if ((u2&0xC0) !== 0x80) {\n                if (!replacement_char) throw RangeError(unicode_error_message);\n                str += \"\uFFFD\";\n                continue;\n            }\n            let u3 = value[i++];\n            if ((u3&0xC0) !== 0x80) {\n                if (!replacement_char) throw RangeError(unicode_error_message);\n                str += \"\uFFFD\";\n                continue;\n            }\n            /* Has to be astral codepoint */\n            let u = ((u0 & 0x07) << 18) + ((u1 & 0x3F) << 12) + ((u2 & 0x3F) << 6) + (u3 & 0x3F);\n            u -= 0x10000;\n            let s1 = (u >> 10) + 0xD800;\n            let s2 = (u % 0x400) + 0xDC00;\n            str += String.fromCharCode(s1, s2);\n        }\n    }\n    return str;\n};\n\n/* bytes allowed unescaped in a uri */\nconst uri_allowed = (\";,/?:@&=+$abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789,-_.!~*'()#\").split('').reduce(function(uri_allowed, c) {\n    uri_allowed[c.charCodeAt(0)] = true;\n    return uri_allowed;\n}, {});\n\n/* utility function to convert a lua string to a js string with uri escaping */\nconst to_uristring = function(a) {\n    if (!is_luastring(a)) throw new TypeError(\"to_uristring expects a Uint8Array\");\n    let s = \"\";\n    for (let i=0; i<a.length; i++) {\n        let v = a[i];\n        if (uri_allowed[v]) {\n            s += String.fromCharCode(v);\n        } else {\n            s += \"%\" + (v<0x10?\"0\":\"\") + v.toString(16);\n        }\n    }\n    return s;\n};\n\nconst to_luastring_cache = {};\n\nconst to_luastring = function(str, cache) {\n    if (typeof str !== \"string\") throw new TypeError(\"to_luastring expects a javascript string\");\n\n    if (cache) {\n        let cached = to_luastring_cache[str];\n        if (is_luastring(cached)) return cached;\n    }\n\n    let len = str.length;\n    let outU8Array = Array(len); /* array is at *least* going to be length of string */\n    let outIdx = 0;\n    for (let i = 0; i < len; ++i) {\n        let u = str.charCodeAt(i);\n        if (u <= 0x7F) {\n            outU8Array[outIdx++] = u;\n        } else if (u <= 0x7FF) {\n            outU8Array[outIdx++] = 0xC0 | (u >> 6);\n            outU8Array[outIdx++] = 0x80 | (u & 63);\n        } else {\n            /* This part is to work around possible lack of String.codePointAt */\n            if (u >= 0xD800 && u <= 0xDBFF && (i+1) < len) {\n                /* is first half of surrogate pair */\n                let v = str.charCodeAt(i+1);\n                if (v >= 0xDC00 && v <= 0xDFFF) {\n                    /* is valid low surrogate */\n                    i++;\n                    u = (u - 0xD800) * 0x400 + v + 0x2400;\n                }\n            }\n            if (u <= 0xFFFF) {\n                outU8Array[outIdx++] = 0xE0 | (u >> 12);\n                outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);\n                outU8Array[outIdx++] = 0x80 | (u & 63);\n            } else {\n                outU8Array[outIdx++] = 0xF0 | (u >> 18);\n                outU8Array[outIdx++] = 0x80 | ((u >> 12) & 63);\n                outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);\n                outU8Array[outIdx++] = 0x80 | (u & 63);\n            }\n        }\n    }\n    outU8Array = luastring_from(outU8Array);\n\n    if (cache) to_luastring_cache[str] = outU8Array;\n\n    return outU8Array;\n};\n\nconst from_userstring = function(str) {\n    if (!is_luastring(str)) {\n        if (typeof str === \"string\") {\n            str = to_luastring(str);\n        } else {\n            throw new TypeError(\"expects an array of bytes or javascript string\");\n        }\n    }\n    return str;\n};\n\nmodule.exports.luastring_from    = luastring_from;\nmodule.exports.luastring_indexOf = luastring_indexOf;\nmodule.exports.luastring_of      = luastring_of;\nmodule.exports.is_luastring      = is_luastring;\nmodule.exports.luastring_eq      = luastring_eq;\nmodule.exports.to_jsstring       = to_jsstring;\nmodule.exports.to_uristring      = to_uristring;\nmodule.exports.to_luastring      = to_luastring;\nmodule.exports.from_userstring   = from_userstring;\n\n\n/* mark for precompiled code ('<esc>Lua') */\nconst LUA_SIGNATURE = to_luastring(\"\\x1bLua\");\n\nconst LUA_VERSION_MAJOR   = \"5\";\nconst LUA_VERSION_MINOR   = \"3\";\nconst LUA_VERSION_NUM     = 503;\nconst LUA_VERSION_RELEASE = \"4\";\n\nconst LUA_VERSION         = \"Lua \" + LUA_VERSION_MAJOR + \".\" + LUA_VERSION_MINOR;\nconst LUA_RELEASE         = LUA_VERSION + \".\" + LUA_VERSION_RELEASE;\nconst LUA_COPYRIGHT       = LUA_RELEASE + \"  Copyright (C) 1994-2017 Lua.org, PUC-Rio\";\nconst LUA_AUTHORS         = \"R. Ierusalimschy, L. H. de Figueiredo, W. Celes\";\n\nmodule.exports.LUA_SIGNATURE       = LUA_SIGNATURE;\nmodule.exports.LUA_VERSION_MAJOR   = LUA_VERSION_MAJOR;\nmodule.exports.LUA_VERSION_MINOR   = LUA_VERSION_MINOR;\nmodule.exports.LUA_VERSION_NUM     = LUA_VERSION_NUM;\nmodule.exports.LUA_VERSION_RELEASE = LUA_VERSION_RELEASE;\nmodule.exports.LUA_VERSION         = LUA_VERSION;\nmodule.exports.LUA_RELEASE         = LUA_RELEASE;\nmodule.exports.LUA_COPYRIGHT       = LUA_COPYRIGHT;\nmodule.exports.LUA_AUTHORS         = LUA_AUTHORS;\n\n\nconst thread_status = {\n    LUA_OK:        0,\n    LUA_YIELD:     1,\n    LUA_ERRRUN:    2,\n    LUA_ERRSYNTAX: 3,\n    LUA_ERRMEM:    4,\n    LUA_ERRGCMM:   5,\n    LUA_ERRERR:    6\n};\n\nconst constant_types = {\n    LUA_TNONE:          -1,\n    LUA_TNIL:           0,\n    LUA_TBOOLEAN:       1,\n    LUA_TLIGHTUSERDATA: 2,\n    LUA_TNUMBER:        3,\n    LUA_TSTRING:        4,\n    LUA_TTABLE:         5,\n    LUA_TFUNCTION:      6,\n    LUA_TUSERDATA:      7,\n    LUA_TTHREAD:        8,\n    LUA_NUMTAGS:        9\n};\n\nconstant_types.LUA_TSHRSTR = constant_types.LUA_TSTRING | (0 << 4);  /* short strings */\nconstant_types.LUA_TLNGSTR = constant_types.LUA_TSTRING | (1 << 4);  /* long strings */\n\nconstant_types.LUA_TNUMFLT = constant_types.LUA_TNUMBER | (0 << 4);  /* float numbers */\nconstant_types.LUA_TNUMINT = constant_types.LUA_TNUMBER | (1 << 4);  /* integer numbers */\n\nconstant_types.LUA_TLCL = constant_types.LUA_TFUNCTION | (0 << 4);  /* Lua closure */\nconstant_types.LUA_TLCF = constant_types.LUA_TFUNCTION | (1 << 4);  /* light C function */\nconstant_types.LUA_TCCL = constant_types.LUA_TFUNCTION | (2 << 4);  /* C closure */\n\n/*\n** Comparison and arithmetic functions\n*/\n\nconst LUA_OPADD  = 0;   /* ORDER TM, ORDER OP */\nconst LUA_OPSUB  = 1;\nconst LUA_OPMUL  = 2;\nconst LUA_OPMOD  = 3;\nconst LUA_OPPOW  = 4;\nconst LUA_OPDIV  = 5;\nconst LUA_OPIDIV = 6;\nconst LUA_OPBAND = 7;\nconst LUA_OPBOR  = 8;\nconst LUA_OPBXOR = 9;\nconst LUA_OPSHL  = 10;\nconst LUA_OPSHR  = 11;\nconst LUA_OPUNM  = 12;\nconst LUA_OPBNOT = 13;\n\nconst LUA_OPEQ = 0;\nconst LUA_OPLT = 1;\nconst LUA_OPLE = 2;\n\nconst LUA_MINSTACK = 20;\n\nconst { LUAI_MAXSTACK } = require('./luaconf.js');\nconst LUA_REGISTRYINDEX = -LUAI_MAXSTACK - 1000;\n\nconst lua_upvalueindex = function(i) {\n    return LUA_REGISTRYINDEX - i;\n};\n\n/* predefined values in the registry */\nconst LUA_RIDX_MAINTHREAD = 1;\nconst LUA_RIDX_GLOBALS    = 2;\nconst LUA_RIDX_LAST       = LUA_RIDX_GLOBALS;\n\nclass lua_Debug {\n    constructor() {\n        this.event = NaN;\n        this.name = null;           /* (n) */\n        this.namewhat = null;       /* (n) 'global', 'local', 'field', 'method' */\n        this.what = null;           /* (S) 'Lua', 'C', 'main', 'tail' */\n        this.source = null;         /* (S) */\n        this.currentline = NaN;     /* (l) */\n        this.linedefined = NaN;     /* (S) */\n        this.lastlinedefined = NaN; /* (S) */\n        this.nups = NaN;            /* (u) number of upvalues */\n        this.nparams = NaN;         /* (u) number of parameters */\n        this.isvararg = NaN;        /* (u) */\n        this.istailcall = NaN;      /* (t) */\n        this.short_src = null;      /* (S) */\n        /* private part */\n        this.i_ci = null;           /* active function */\n    }\n}\n\n/*\n** Event codes\n*/\nconst LUA_HOOKCALL     = 0;\nconst LUA_HOOKRET      = 1;\nconst LUA_HOOKLINE     = 2;\nconst LUA_HOOKCOUNT    = 3;\nconst LUA_HOOKTAILCALL = 4;\n\n\n/*\n** Event masks\n*/\nconst LUA_MASKCALL  = (1 << LUA_HOOKCALL);\nconst LUA_MASKRET   = (1 << LUA_HOOKRET);\nconst LUA_MASKLINE  = (1 << LUA_HOOKLINE);\nconst LUA_MASKCOUNT = (1 << LUA_HOOKCOUNT);\n\nmodule.exports.LUA_HOOKCALL            = LUA_HOOKCALL;\nmodule.exports.LUA_HOOKCOUNT           = LUA_HOOKCOUNT;\nmodule.exports.LUA_HOOKLINE            = LUA_HOOKLINE;\nmodule.exports.LUA_HOOKRET             = LUA_HOOKRET;\nmodule.exports.LUA_HOOKTAILCALL        = LUA_HOOKTAILCALL;\nmodule.exports.LUA_MASKCALL            = LUA_MASKCALL;\nmodule.exports.LUA_MASKCOUNT           = LUA_MASKCOUNT;\nmodule.exports.LUA_MASKLINE            = LUA_MASKLINE;\nmodule.exports.LUA_MASKRET             = LUA_MASKRET;\nmodule.exports.LUA_MINSTACK            = LUA_MINSTACK;\nmodule.exports.LUA_MULTRET             = -1;\nmodule.exports.LUA_OPADD               = LUA_OPADD;\nmodule.exports.LUA_OPBAND              = LUA_OPBAND;\nmodule.exports.LUA_OPBNOT              = LUA_OPBNOT;\nmodule.exports.LUA_OPBOR               = LUA_OPBOR;\nmodule.exports.LUA_OPBXOR              = LUA_OPBXOR;\nmodule.exports.LUA_OPDIV               = LUA_OPDIV;\nmodule.exports.LUA_OPEQ                = LUA_OPEQ;\nmodule.exports.LUA_OPIDIV              = LUA_OPIDIV;\nmodule.exports.LUA_OPLE                = LUA_OPLE;\nmodule.exports.LUA_OPLT                = LUA_OPLT;\nmodule.exports.LUA_OPMOD               = LUA_OPMOD;\nmodule.exports.LUA_OPMUL               = LUA_OPMUL;\nmodule.exports.LUA_OPPOW               = LUA_OPPOW;\nmodule.exports.LUA_OPSHL               = LUA_OPSHL;\nmodule.exports.LUA_OPSHR               = LUA_OPSHR;\nmodule.exports.LUA_OPSUB               = LUA_OPSUB;\nmodule.exports.LUA_OPUNM               = LUA_OPUNM;\nmodule.exports.LUA_REGISTRYINDEX       = LUA_REGISTRYINDEX;\nmodule.exports.LUA_RIDX_GLOBALS        = LUA_RIDX_GLOBALS;\nmodule.exports.LUA_RIDX_LAST           = LUA_RIDX_LAST;\nmodule.exports.LUA_RIDX_MAINTHREAD     = LUA_RIDX_MAINTHREAD;\nmodule.exports.constant_types          = constant_types;\nmodule.exports.lua_Debug               = lua_Debug;\nmodule.exports.lua_upvalueindex        = lua_upvalueindex;\nmodule.exports.thread_status           = thread_status;\n", "/* Fengari specific functions\n *\n * This file includes fengari-specific data or and functionality for users to\n * manipulate fengari's string type.\n * The fields are exposed to the user on the 'fengari' entry point; however to\n * avoid a dependency on defs.js from lauxlib.js they are defined in this file.\n */\n\nconst defs = require(\"./defs.js\");\n\nconst FENGARI_VERSION_MAJOR   = \"0\";\nconst FENGARI_VERSION_MINOR   = \"1\";\nconst FENGARI_VERSION_NUM     = 1;\nconst FENGARI_VERSION_RELEASE = \"4\";\nconst FENGARI_VERSION         = \"Fengari \" + FENGARI_VERSION_MAJOR + \".\" + FENGARI_VERSION_MINOR;\nconst FENGARI_RELEASE         = FENGARI_VERSION + \".\" + FENGARI_VERSION_RELEASE;\nconst FENGARI_AUTHORS         = \"B. Giannangeli, Daurnimator\";\nconst FENGARI_COPYRIGHT       = FENGARI_RELEASE + \"  Copyright (C) 2017-2018 \" + FENGARI_AUTHORS + \"\\nBased on: \" + defs.LUA_COPYRIGHT;\n\nmodule.exports.FENGARI_AUTHORS         = FENGARI_AUTHORS;\nmodule.exports.FENGARI_COPYRIGHT       = FENGARI_COPYRIGHT;\nmodule.exports.FENGARI_RELEASE         = FENGARI_RELEASE;\nmodule.exports.FENGARI_VERSION         = FENGARI_VERSION;\nmodule.exports.FENGARI_VERSION_MAJOR   = FENGARI_VERSION_MAJOR;\nmodule.exports.FENGARI_VERSION_MINOR   = FENGARI_VERSION_MINOR;\nmodule.exports.FENGARI_VERSION_NUM     = FENGARI_VERSION_NUM;\nmodule.exports.FENGARI_VERSION_RELEASE = FENGARI_VERSION_RELEASE;\nmodule.exports.is_luastring            = defs.is_luastring;\nmodule.exports.luastring_eq            = defs.luastring_eq;\nmodule.exports.luastring_from          = defs.luastring_from;\nmodule.exports.luastring_indexOf       = defs.luastring_indexOf;\nmodule.exports.luastring_of            = defs.luastring_of;\nmodule.exports.to_jsstring             = defs.to_jsstring;\nmodule.exports.to_luastring            = defs.to_luastring;\nmodule.exports.to_uristring            = defs.to_uristring;\nmodule.exports.from_userstring         = defs.from_userstring;\n", ";\n\nconst { luai_apicheck } = require(\"./luaconf.js\");\n\nconst lua_assert = function(c) {\n    if (!c) throw Error(\"assertion failed\");\n};\nmodule.exports.lua_assert = lua_assert;\n\nmodule.exports.luai_apicheck = luai_apicheck || function(l, e) { return lua_assert(e); };\n\nconst api_check = function(l, e, msg) {\n    return luai_apicheck(l, e && msg);\n};\nmodule.exports.api_check = api_check;\n\nconst LUAI_MAXCCALLS = 200;\nmodule.exports.LUAI_MAXCCALLS = LUAI_MAXCCALLS;\n\n/* minimum size for string buffer */\nconst LUA_MINBUFFER = 32;\nmodule.exports.LUA_MINBUFFER = LUA_MINBUFFER;\n\nconst luai_nummod = function(L, a, b) {\n    let m = a % b;\n    if ((m*b) < 0)\n        m += b;\n    return m;\n};\nmodule.exports.luai_nummod = luai_nummod;\n\n// If later integers are more than 32bit, LUA_MAXINTEGER will then be != MAX_INT\nconst MAX_INT = 2147483647;\nmodule.exports.MAX_INT = MAX_INT;\nconst MIN_INT = -2147483648;\nmodule.exports.MIN_INT = MIN_INT;\n", ";\n\nconst { luastring_of } = require('./defs.js');\n\nconst luai_ctype_ = luastring_of(\n    0x00,  /* EOZ */\n    0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,        /* 0. */\n    0x00,  0x08,  0x08,  0x08,  0x08,  0x08,  0x00,  0x00,\n    0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,        /* 1. */\n    0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,\n    0x0c,  0x04,  0x04,  0x04,  0x04,  0x04,  0x04,  0x04,        /* 2. */\n    0x04,  0x04,  0x04,  0x04,  0x04,  0x04,  0x04,  0x04,\n    0x16,  0x16,  0x16,  0x16,  0x16,  0x16,  0x16,  0x16,        /* 3. */\n    0x16,  0x16,  0x04,  0x04,  0x04,  0x04,  0x04,  0x04,\n    0x04,  0x15,  0x15,  0x15,  0x15,  0x15,  0x15,  0x05,        /* 4. */\n    0x05,  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,\n    0x05,  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,        /* 5. */\n    0x05,  0x05,  0x05,  0x04,  0x04,  0x04,  0x04,  0x05,\n    0x04,  0x15,  0x15,  0x15,  0x15,  0x15,  0x15,  0x05,        /* 6. */\n    0x05,  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,\n    0x05,  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,        /* 7. */\n    0x05,  0x05,  0x05,  0x04,  0x04,  0x04,  0x04,  0x00,\n    0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,        /* 8. */\n    0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,\n    0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,        /* 9. */\n    0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,\n    0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,        /* a. */\n    0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,\n    0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,        /* b. */\n    0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,\n    0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,        /* c. */\n    0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,\n    0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,        /* d. */\n    0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,\n    0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,        /* e. */\n    0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,\n    0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,        /* f. */\n    0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00\n);\n\nconst ALPHABIT = 0;\nconst DIGITBIT = 1;\nconst PRINTBIT = 2;\nconst SPACEBIT = 3;\nconst XDIGITBIT = 4;\n\nconst lisdigit = function(c) {\n    return (luai_ctype_[c+1] & (1<<DIGITBIT)) !== 0;\n};\n\nconst lisxdigit = function(c) {\n    return (luai_ctype_[c+1] & (1<<XDIGITBIT)) !== 0;\n};\n\nconst lisprint = function(c) {\n    return (luai_ctype_[c+1] & (1<<PRINTBIT)) !== 0;\n};\n\nconst lisspace = function(c) {\n    return (luai_ctype_[c+1] & (1<<SPACEBIT)) !== 0;\n};\n\nconst lislalpha = function(c) {\n    return (luai_ctype_[c+1] & (1<<ALPHABIT)) !== 0;\n};\n\nconst lislalnum = function(c) {\n    return (luai_ctype_[c+1] & ((1<<ALPHABIT)|(1<<DIGITBIT))) !== 0;\n};\n\nmodule.exports.lisdigit   = lisdigit;\nmodule.exports.lislalnum  = lislalnum;\nmodule.exports.lislalpha  = lislalpha;\nmodule.exports.lisprint   = lisprint;\nmodule.exports.lisspace   = lisspace;\nmodule.exports.lisxdigit  = lisxdigit;\n", ";\n\nconst {\n    is_luastring,\n    luastring_eq,\n    luastring_from,\n    to_luastring\n} = require('./defs.js');\nconst { lua_assert } = require(\"./llimits.js\");\n\nclass TString {\n\n    constructor(L, str) {\n        this.hash = null;\n        this.realstring = str;\n    }\n\n    getstr() {\n        return this.realstring;\n    }\n\n    tsslen() {\n        return this.realstring.length;\n    }\n\n}\n\nconst luaS_eqlngstr = function(a, b) {\n    lua_assert(a instanceof TString);\n    lua_assert(b instanceof TString);\n    return a == b || luastring_eq(a.realstring, b.realstring);\n};\n\n/* converts strings (arrays) to a consistent map key\n   make sure this doesn't conflict with any of the anti-collision strategies in ltable */\nconst luaS_hash = function(str) {\n    lua_assert(is_luastring(str));\n    let len = str.length;\n    let s = \"|\";\n    for (let i=0; i<len; i++)\n        s += str[i].toString(16);\n    return s;\n};\n\nconst luaS_hashlongstr = function(ts) {\n    lua_assert(ts instanceof TString);\n    if(ts.hash === null) {\n        ts.hash = luaS_hash(ts.getstr());\n    }\n    return ts.hash;\n};\n\n/* variant that takes ownership of array */\nconst luaS_bless = function(L, str) {\n    lua_assert(str instanceof Uint8Array);\n    return new TString(L, str);\n};\n\n/* makes a copy */\nconst luaS_new = function(L, str) {\n    return luaS_bless(L, luastring_from(str));\n};\n\n/* takes a js string */\nconst luaS_newliteral = function(L, str) {\n    return luaS_bless(L, to_luastring(str));\n};\n\nmodule.exports.luaS_eqlngstr    = luaS_eqlngstr;\nmodule.exports.luaS_hash        = luaS_hash;\nmodule.exports.luaS_hashlongstr = luaS_hashlongstr;\nmodule.exports.luaS_bless       = luaS_bless;\nmodule.exports.luaS_new         = luaS_new;\nmodule.exports.luaS_newliteral  = luaS_newliteral;\nmodule.exports.TString          = TString;\n", ";\n\nconst {\n    constant_types: {\n        LUA_TBOOLEAN,\n        LUA_TCCL,\n        LUA_TLCF,\n        LUA_TLCL,\n        LUA_TLIGHTUSERDATA,\n        LUA_TLNGSTR,\n        LUA_TNIL,\n        LUA_TNUMFLT,\n        LUA_TNUMINT,\n        LUA_TSHRSTR,\n        LUA_TTABLE,\n        LUA_TTHREAD,\n        LUA_TUSERDATA\n    },\n    to_luastring\n} = require('./defs.js');\nconst { lua_assert } = require('./llimits.js');\nconst ldebug  = require('./ldebug.js');\nconst lobject = require('./lobject.js');\nconst {\n    luaS_hashlongstr,\n    TString\n} = require('./lstring.js');\nconst lstate  = require('./lstate.js');\n\n/* used to prevent conflicts with lightuserdata keys */\nlet lightuserdata_hashes = new WeakMap();\nconst get_lightuserdata_hash = function(v) {\n    let hash = lightuserdata_hashes.get(v);\n    if (!hash) {\n        /* Hash should be something unique that is a valid WeakMap key\n           so that it ends up in dead_weak when removed from a table */\n        hash = {};\n        lightuserdata_hashes.set(v, hash);\n    }\n    return hash;\n};\n\nconst table_hash = function(L, key) {\n    switch(key.type) {\n        case LUA_TNIL:\n            return ldebug.luaG_runerror(L, to_luastring(\"table index is nil\", true));\n        case LUA_TNUMFLT:\n            if (isNaN(key.value))\n                return ldebug.luaG_runerror(L, to_luastring(\"table index is NaN\", true));\n            /* fall through */\n        case LUA_TNUMINT: /* takes advantage of floats and integers being same in JS */\n        case LUA_TBOOLEAN:\n        case LUA_TTABLE:\n        case LUA_TLCL:\n        case LUA_TLCF:\n        case LUA_TCCL:\n        case LUA_TUSERDATA:\n        case LUA_TTHREAD:\n            return key.value;\n        case LUA_TSHRSTR:\n        case LUA_TLNGSTR:\n            return luaS_hashlongstr(key.tsvalue());\n        case LUA_TLIGHTUSERDATA: {\n            let v = key.value;\n            switch(typeof v) {\n                case \"string\":\n                    /* possible conflict with LUA_TSTRING.\n                       prefix this string with \"*\" so they don't clash */\n                    return \"*\" + v;\n                case \"number\":\n                    /* possible conflict with LUA_TNUMBER.\n                       turn into string and prefix with \"#\" to avoid clash with other strings */\n                    return \"#\" + v;\n                case \"boolean\":\n                    /* possible conflict with LUA_TBOOLEAN. use strings ?true and ?false instead */\n                    return v?\"?true\":\"?false\";\n                case \"function\":\n                    /* possible conflict with LUA_TLCF.\n                       indirect via a weakmap */\n                    return get_lightuserdata_hash(v);\n                case \"object\":\n                    /* v could be a lua_State, CClosure, LClosure, Table or Userdata from this state as returned by lua_topointer */\n                    if ((v instanceof lstate.lua_State && v.l_G === L.l_G) ||\n                        v instanceof Table ||\n                        v instanceof lobject.Udata ||\n                        v instanceof lobject.LClosure ||\n                        v instanceof lobject.CClosure) {\n                        /* indirect via a weakmap */\n                        return get_lightuserdata_hash(v);\n                    }\n                    /* fall through */\n                default:\n                    return v;\n            }\n        }\n        default:\n            throw new Error(\"unknown key type: \" + key.type);\n    }\n};\n\nclass Table {\n    constructor(L) {\n        this.id = L.l_G.id_counter++;\n        this.strong = new Map();\n        this.dead_strong = new Map();\n        this.dead_weak = void 0; /* initialised when needed */\n        this.f = void 0; /* first entry */\n        this.l = void 0; /* last entry */\n        this.metatable = null;\n        this.flags = ~0;\n    }\n}\n\nconst invalidateTMcache = function(t) {\n    t.flags = 0;\n};\n\nconst add = function(t, hash, key, value) {\n    t.dead_strong.clear();\n    t.dead_weak = void 0;\n    let prev = null;\n    let entry = {\n        key: key,\n        value: value,\n        p: prev = t.l,\n        n: void 0\n    };\n    if (!t.f) t.f = entry;\n    if (prev) prev.n = entry;\n    t.strong.set(hash, entry);\n    t.l = entry;\n};\n\nconst is_valid_weakmap_key = function(k) {\n    return typeof k === 'object' ? k !== null : typeof k === 'function';\n};\n\n/* Move out of 'strong' part and into 'dead' part. */\nconst mark_dead = function(t, hash) {\n    let e = t.strong.get(hash);\n    if (e) {\n        e.key.setdeadvalue();\n        e.value = void 0;\n        let next = e.n;\n        let prev = e.p;\n        e.p = void 0; /* no need to know previous item any more */\n        if(prev) prev.n = next;\n        if(next) next.p = prev;\n        if(t.f === e) t.f = next;\n        if(t.l === e) t.l = prev;\n        t.strong.delete(hash);\n        if (is_valid_weakmap_key(hash)) {\n            if (!t.dead_weak) t.dead_weak = new WeakMap();\n            t.dead_weak.set(hash, e);\n        } else {\n            /* can't be used as key in weakmap */\n            t.dead_strong.set(hash, e);\n        }\n    }\n};\n\nconst luaH_new = function(L) {\n    return new Table(L);\n};\n\nconst getgeneric = function(t, hash) {\n    let v = t.strong.get(hash);\n    return v ? v.value : lobject.luaO_nilobject;\n};\n\nconst luaH_getint = function(t, key) {\n    lua_assert(typeof key == \"number\" && (key|0) === key);\n    return getgeneric(t, key);\n};\n\nconst luaH_getstr = function(t, key) {\n    lua_assert(key instanceof TString);\n    return getgeneric(t, luaS_hashlongstr(key));\n};\n\nconst luaH_get = function(L, t, key) {\n    lua_assert(key instanceof lobject.TValue);\n    if (key.ttisnil() || (key.ttisfloat() && isNaN(key.value)))\n        return lobject.luaO_nilobject;\n    return getgeneric(t, table_hash(L, key));\n};\n\nconst luaH_setint = function(t, key, value) {\n    lua_assert(typeof key == \"number\" && (key|0) === key && value instanceof lobject.TValue);\n    let hash = key; /* table_hash known result */\n    if (value.ttisnil()) {\n        mark_dead(t, hash);\n        return;\n    }\n    let e = t.strong.get(hash);\n    if (e) {\n        let tv = e.value;\n        tv.setfrom(value);\n    } else {\n        let k = new lobject.TValue(LUA_TNUMINT, key);\n        let v = new lobject.TValue(value.type, value.value);\n        add(t, hash, k, v);\n    }\n};\n\nconst luaH_setfrom = function(L, t, key, value) {\n    lua_assert(key instanceof lobject.TValue);\n    let hash = table_hash(L, key);\n    if (value.ttisnil()) { /* delete */\n        mark_dead(t, hash);\n        return;\n    }\n\n    let e = t.strong.get(hash);\n    if (e) {\n        e.value.setfrom(value);\n    } else {\n        let k;\n        let kv = key.value;\n        if ((key.ttisfloat() && (kv|0) === kv)) { /* does index fit in an integer? */\n            /* insert it as an integer */\n            k = new lobject.TValue(LUA_TNUMINT, kv);\n        } else {\n            k = new lobject.TValue(key.type, kv);\n        }\n        let v = new lobject.TValue(value.type, value.value);\n        add(t, hash, k, v);\n    }\n};\n\n/*\n** Try to find a boundary in table 't'. A 'boundary' is an integer index\n** such that t[i] is non-nil and t[i+1] is nil (and 0 if t[1] is nil).\n*/\nconst luaH_getn = function(t) {\n    let i = 0;\n    let j = t.strong.size + 1; /* use known size of Map to bound search */\n    /* now do a binary search between them */\n    while (j - i > 1) {\n        let m = Math.floor((i+j)/2);\n        if (luaH_getint(t, m).ttisnil()) j = m;\n        else i = m;\n    }\n    return i;\n};\n\nconst luaH_next = function(L, table, keyI) {\n    let keyO = L.stack[keyI];\n\n    let entry;\n    if (keyO.type === LUA_TNIL) {\n        entry = table.f;\n        if (!entry)\n            return false;\n    } else {\n        /* First find current key */\n        let hash = table_hash(L, keyO);\n        /* Look in main part of table */\n        entry = table.strong.get(hash);\n        if (entry) {\n            entry = entry.n;\n            if (!entry)\n                return false;\n        } else {\n            /* Try dead keys */\n            entry = (table.dead_weak && table.dead_weak.get(hash)) || table.dead_strong.get(hash);\n            if (!entry)\n                /* item not in table */\n                return ldebug.luaG_runerror(L, to_luastring(\"invalid key to 'next'\"));\n            /* Iterate until either out of keys, or until finding a non-dead key */\n            do {\n                entry = entry.n;\n                if (!entry)\n                    return false;\n            } while (entry.key.ttisdeadkey());\n        }\n    }\n    lobject.setobj2s(L, keyI, entry.key);\n    lobject.setobj2s(L, keyI+1, entry.value);\n    return true;\n};\n\nmodule.exports.invalidateTMcache = invalidateTMcache;\nmodule.exports.luaH_get     = luaH_get;\nmodule.exports.luaH_getint  = luaH_getint;\nmodule.exports.luaH_getn    = luaH_getn;\nmodule.exports.luaH_getstr  = luaH_getstr;\nmodule.exports.luaH_setfrom = luaH_setfrom;\nmodule.exports.luaH_setint  = luaH_setint;\nmodule.exports.luaH_new     = luaH_new;\nmodule.exports.luaH_next    = luaH_next;\nmodule.exports.Table        = Table;\n", ";\n\nconst OpCodes = [\n    \"MOVE\",\n    \"LOADK\",\n    \"LOADKX\",\n    \"LOADBOOL\",\n    \"LOADNIL\",\n    \"GETUPVAL\",\n    \"GETTABUP\",\n    \"GETTABLE\",\n    \"SETTABUP\",\n    \"SETUPVAL\",\n    \"SETTABLE\",\n    \"NEWTABLE\",\n    \"SELF\",\n    \"ADD\",\n    \"SUB\",\n    \"MUL\",\n    \"MOD\",\n    \"POW\",\n    \"DIV\",\n    \"IDIV\",\n    \"BAND\",\n    \"BOR\",\n    \"BXOR\",\n    \"SHL\",\n    \"SHR\",\n    \"UNM\",\n    \"BNOT\",\n    \"NOT\",\n    \"LEN\",\n    \"CONCAT\",\n    \"JMP\",\n    \"EQ\",\n    \"LT\",\n    \"LE\",\n    \"TEST\",\n    \"TESTSET\",\n    \"CALL\",\n    \"TAILCALL\",\n    \"RETURN\",\n    \"FORLOOP\",\n    \"FORPREP\",\n    \"TFORCALL\",\n    \"TFORLOOP\",\n    \"SETLIST\",\n    \"CLOSURE\",\n    \"VARARG\",\n    \"EXTRAARG\"\n];\n\nconst OpCodesI = {\n    OP_MOVE:     0,\n    OP_LOADK:    1,\n    OP_LOADKX:   2,\n    OP_LOADBOOL: 3,\n    OP_LOADNIL:  4,\n    OP_GETUPVAL: 5,\n    OP_GETTABUP: 6,\n    OP_GETTABLE: 7,\n    OP_SETTABUP: 8,\n    OP_SETUPVAL: 9,\n    OP_SETTABLE: 10,\n    OP_NEWTABLE: 11,\n    OP_SELF:     12,\n    OP_ADD:      13,\n    OP_SUB:      14,\n    OP_MUL:      15,\n    OP_MOD:      16,\n    OP_POW:      17,\n    OP_DIV:      18,\n    OP_IDIV:     19,\n    OP_BAND:     20,\n    OP_BOR:      21,\n    OP_BXOR:     22,\n    OP_SHL:      23,\n    OP_SHR:      24,\n    OP_UNM:      25,\n    OP_BNOT:     26,\n    OP_NOT:      27,\n    OP_LEN:      28,\n    OP_CONCAT:   29,\n    OP_JMP:      30,\n    OP_EQ:       31,\n    OP_LT:       32,\n    OP_LE:       33,\n    OP_TEST:     34,\n    OP_TESTSET:  35,\n    OP_CALL:     36,\n    OP_TAILCALL: 37,\n    OP_RETURN:   38,\n    OP_FORLOOP:  39,\n    OP_FORPREP:  40,\n    OP_TFORCALL: 41,\n    OP_TFORLOOP: 42,\n    OP_SETLIST:  43,\n    OP_CLOSURE:  44,\n    OP_VARARG:   45,\n    OP_EXTRAARG: 46\n};\n\n/*\n** masks for instruction properties. The format is:\n** bits 0-1: op mode\n** bits 2-3: C arg mode\n** bits 4-5: B arg mode\n** bit 6: instruction set register A\n** bit 7: operator is a test (next instruction must be a jump)\n*/\nconst OpArgN = 0;  /* argument is not used */\nconst OpArgU = 1;  /* argument is used */\nconst OpArgR = 2;  /* argument is a register or a jump offset */\nconst OpArgK = 3;  /* argument is a constant or register/constant */\n\n/* basic instruction format */\nconst iABC  = 0;\nconst iABx  = 1;\nconst iAsBx = 2;\nconst iAx   = 3;\n\nconst luaP_opmodes = [\n    0 << 7 | 1 << 6 | OpArgR << 4 | OpArgN << 2 | iABC,   /* OP_MOVE */\n    0 << 7 | 1 << 6 | OpArgK << 4 | OpArgN << 2 | iABx,   /* OP_LOADK */\n    0 << 7 | 1 << 6 | OpArgN << 4 | OpArgN << 2 | iABx,   /* OP_LOADKX */\n    0 << 7 | 1 << 6 | OpArgU << 4 | OpArgU << 2 | iABC,   /* OP_LOADBOOL */\n    0 << 7 | 1 << 6 | OpArgU << 4 | OpArgN << 2 | iABC,   /* OP_LOADNIL */\n    0 << 7 | 1 << 6 | OpArgU << 4 | OpArgN << 2 | iABC,   /* OP_GETUPVAL */\n    0 << 7 | 1 << 6 | OpArgU << 4 | OpArgK << 2 | iABC,   /* OP_GETTABUP */\n    0 << 7 | 1 << 6 | OpArgR << 4 | OpArgK << 2 | iABC,   /* OP_GETTABLE */\n    0 << 7 | 0 << 6 | OpArgK << 4 | OpArgK << 2 | iABC,   /* OP_SETTABUP */\n    0 << 7 | 0 << 6 | OpArgU << 4 | OpArgN << 2 | iABC,   /* OP_SETUPVAL */\n    0 << 7 | 0 << 6 | OpArgK << 4 | OpArgK << 2 | iABC,   /* OP_SETTABLE */\n    0 << 7 | 1 << 6 | OpArgU << 4 | OpArgU << 2 | iABC,   /* OP_NEWTABLE */\n    0 << 7 | 1 << 6 | OpArgR << 4 | OpArgK << 2 | iABC,   /* OP_SELF */\n    0 << 7 | 1 << 6 | OpArgK << 4 | OpArgK << 2 | iABC,   /* OP_ADD */\n    0 << 7 | 1 << 6 | OpArgK << 4 | OpArgK << 2 | iABC,   /* OP_SUB */\n    0 << 7 | 1 << 6 | OpArgK << 4 | OpArgK << 2 | iABC,   /* OP_MUL */\n    0 << 7 | 1 << 6 | OpArgK << 4 | OpArgK << 2 | iABC,   /* OP_MOD */\n    0 << 7 | 1 << 6 | OpArgK << 4 | OpArgK << 2 | iABC,   /* OP_POW */\n    0 << 7 | 1 << 6 | OpArgK << 4 | OpArgK << 2 | iABC,   /* OP_DIV */\n    0 << 7 | 1 << 6 | OpArgK << 4 | OpArgK << 2 | iABC,   /* OP_IDIV */\n    0 << 7 | 1 << 6 | OpArgK << 4 | OpArgK << 2 | iABC,   /* OP_BAND */\n    0 << 7 | 1 << 6 | OpArgK << 4 | OpArgK << 2 | iABC,   /* OP_BOR */\n    0 << 7 | 1 << 6 | OpArgK << 4 | OpArgK << 2 | iABC,   /* OP_BXOR */\n    0 << 7 | 1 << 6 | OpArgK << 4 | OpArgK << 2 | iABC,   /* OP_SHL */\n    0 << 7 | 1 << 6 | OpArgK << 4 | OpArgK << 2 | iABC,   /* OP_SHR */\n    0 << 7 | 1 << 6 | OpArgR << 4 | OpArgN << 2 | iABC,   /* OP_UNM */\n    0 << 7 | 1 << 6 | OpArgR << 4 | OpArgN << 2 | iABC,   /* OP_BNOT */\n    0 << 7 | 1 << 6 | OpArgR << 4 | OpArgN << 2 | iABC,   /* OP_NOT */\n    0 << 7 | 1 << 6 | OpArgR << 4 | OpArgN << 2 | iABC,   /* OP_LEN */\n    0 << 7 | 1 << 6 | OpArgR << 4 | OpArgR << 2 | iABC,   /* OP_CONCAT */\n    0 << 7 | 0 << 6 | OpArgR << 4 | OpArgN << 2 | iAsBx,  /* OP_JMP */\n    1 << 7 | 0 << 6 | OpArgK << 4 | OpArgK << 2 | iABC,   /* OP_EQ */\n    1 << 7 | 0 << 6 | OpArgK << 4 | OpArgK << 2 | iABC,   /* OP_LT */\n    1 << 7 | 0 << 6 | OpArgK << 4 | OpArgK << 2 | iABC,   /* OP_LE */\n    1 << 7 | 0 << 6 | OpArgN << 4 | OpArgU << 2 | iABC,   /* OP_TEST */\n    1 << 7 | 1 << 6 | OpArgR << 4 | OpArgU << 2 | iABC,   /* OP_TESTSET */\n    0 << 7 | 1 << 6 | OpArgU << 4 | OpArgU << 2 | iABC,   /* OP_CALL */\n    0 << 7 | 1 << 6 | OpArgU << 4 | OpArgU << 2 | iABC,   /* OP_TAILCALL */\n    0 << 7 | 0 << 6 | OpArgU << 4 | OpArgN << 2 | iABC,   /* OP_RETURN */\n    0 << 7 | 1 << 6 | OpArgR << 4 | OpArgN << 2 | iAsBx,  /* OP_FORLOOP */\n    0 << 7 | 1 << 6 | OpArgR << 4 | OpArgN << 2 | iAsBx,  /* OP_FORPREP */\n    0 << 7 | 0 << 6 | OpArgN << 4 | OpArgU << 2 | iABC,   /* OP_TFORCALL */\n    0 << 7 | 1 << 6 | OpArgR << 4 | OpArgN << 2 | iAsBx,  /* OP_TFORLOOP */\n    0 << 7 | 0 << 6 | OpArgU << 4 | OpArgU << 2 | iABC,   /* OP_SETLIST */\n    0 << 7 | 1 << 6 | OpArgU << 4 | OpArgN << 2 | iABx,   /* OP_CLOSURE */\n    0 << 7 | 1 << 6 | OpArgU << 4 | OpArgN << 2 | iABC,   /* OP_VARARG */\n    0 << 7 | 0 << 6 | OpArgU << 4 | OpArgU << 2 | iAx     /* OP_EXTRAARG */\n];\n\nconst getOpMode = function(m) {\n    return luaP_opmodes[m] & 3;\n};\n\nconst getBMode = function(m) {\n    return (luaP_opmodes[m] >> 4) & 3;\n};\n\nconst getCMode = function(m) {\n    return (luaP_opmodes[m] >> 2) & 3;\n};\n\nconst testAMode = function(m) {\n    return luaP_opmodes[m] & (1 << 6);\n};\n\nconst testTMode = function(m) {\n    return luaP_opmodes[m] & (1 << 7);\n};\n\nconst SIZE_C     = 9;\nconst SIZE_B     = 9;\nconst SIZE_Bx    = (SIZE_C + SIZE_B);\nconst SIZE_A     = 8;\nconst SIZE_Ax    = (SIZE_C + SIZE_B + SIZE_A);\nconst SIZE_OP    = 6;\nconst POS_OP     = 0;\nconst POS_A      = (POS_OP + SIZE_OP);\nconst POS_C      = (POS_A + SIZE_A);\nconst POS_B      = (POS_C + SIZE_C);\nconst POS_Bx     = POS_C;\nconst POS_Ax     = POS_A;\nconst MAXARG_Bx  = ((1 << SIZE_Bx) - 1);\nconst MAXARG_sBx = (MAXARG_Bx >> 1); /* 'sBx' is signed */\nconst MAXARG_Ax  = ((1<<SIZE_Ax)-1);\nconst MAXARG_A   = ((1 << SIZE_A) - 1);\nconst MAXARG_B   = ((1 << SIZE_B) - 1);\nconst MAXARG_C   = ((1 << SIZE_C) - 1);\n\n/* this bit 1 means constant (0 means register) */\nconst BITRK      = (1 << (SIZE_B - 1));\n\nconst MAXINDEXRK = (BITRK - 1);\n\n/*\n** invalid register that fits in 8 bits\n*/\nconst NO_REG     = MAXARG_A;\n\n/* test whether value is a constant */\nconst ISK = function (x) {\n    return x & BITRK;\n};\n\n/* gets the index of the constant */\nconst INDEXK = function (r) {\n    return r & ~BITRK;\n};\n\n/* code a constant index as a RK value */\nconst RKASK = function(x) {\n    return x | BITRK;\n};\n\n\n/* creates a mask with 'n' 1 bits at position 'p' */\nconst MASK1 = function(n, p) {\n    return ((~((~0)<<(n)))<<(p));\n};\n\n/* creates a mask with 'n' 0 bits at position 'p' */\nconst MASK0 = function(n, p) {\n    return (~MASK1(n, p));\n};\n\nconst GET_OPCODE = function(i) {\n    return i.opcode;\n};\n\nconst SET_OPCODE = function(i, o) {\n    i.code = (i.code & MASK0(SIZE_OP, POS_OP)) | ((o << POS_OP) & MASK1(SIZE_OP, POS_OP));\n    return fullins(i);\n};\n\nconst setarg = function(i, v, pos, size) {\n    i.code = (i.code & MASK0(size, pos)) | ((v << pos) & MASK1(size, pos));\n    return fullins(i);\n};\n\nconst GETARG_A = function(i) {\n    return i.A;\n};\n\nconst SETARG_A = function(i,v) {\n    return setarg(i, v, POS_A, SIZE_A);\n};\n\nconst GETARG_B = function(i) {\n    return i.B;\n};\n\nconst SETARG_B = function(i,v) {\n    return setarg(i, v, POS_B, SIZE_B);\n};\n\nconst GETARG_C = function(i) {\n    return i.C;\n};\n\nconst SETARG_C = function(i,v) {\n    return setarg(i, v, POS_C, SIZE_C);\n};\n\nconst GETARG_Bx = function(i) {\n    return i.Bx;\n};\n\nconst SETARG_Bx = function(i,v) {\n    return setarg(i, v, POS_Bx, SIZE_Bx);\n};\n\nconst GETARG_Ax = function(i) {\n    return i.Ax;\n};\n\nconst SETARG_Ax = function(i,v) {\n    return setarg(i, v, POS_Ax, SIZE_Ax);\n};\n\nconst GETARG_sBx = function(i) {\n    return i.sBx;\n};\n\nconst SETARG_sBx = function(i, b) {\n    return SETARG_Bx(i, b + MAXARG_sBx);\n};\n\n/*\n** Pre-calculate all possible part of the instruction\n*/\nconst fullins = function(ins) {\n    if (typeof ins === \"number\") {\n        return {\n            code:   ins,\n            opcode: (ins >> POS_OP) & MASK1(SIZE_OP, 0),\n            A:      (ins >> POS_A)  & MASK1(SIZE_A,  0),\n            B:      (ins >> POS_B)  & MASK1(SIZE_B,  0),\n            C:      (ins >> POS_C)  & MASK1(SIZE_C,  0),\n            Bx:     (ins >> POS_Bx) & MASK1(SIZE_Bx, 0),\n            Ax:     (ins >> POS_Ax) & MASK1(SIZE_Ax, 0),\n            sBx:    ((ins >> POS_Bx) & MASK1(SIZE_Bx, 0)) - MAXARG_sBx\n        };\n    } else {\n        let i = ins.code;\n        ins.opcode = (i >> POS_OP) & MASK1(SIZE_OP, 0);\n        ins.A      = (i >> POS_A)  & MASK1(SIZE_A,  0);\n        ins.B      = (i >> POS_B)  & MASK1(SIZE_B,  0);\n        ins.C      = (i >> POS_C)  & MASK1(SIZE_C,  0);\n        ins.Bx     = (i >> POS_Bx) & MASK1(SIZE_Bx, 0);\n        ins.Ax     = (i >> POS_Ax) & MASK1(SIZE_Ax, 0);\n        ins.sBx    = ((i >> POS_Bx) & MASK1(SIZE_Bx, 0)) - MAXARG_sBx;\n        return ins;\n    }\n};\n\nconst CREATE_ABC = function(o, a, b, c) {\n    return fullins(o << POS_OP | a << POS_A | b << POS_B | c << POS_C);\n};\n\nconst CREATE_ABx = function(o, a, bc) {\n    return fullins(o << POS_OP | a << POS_A | bc << POS_Bx);\n};\n\nconst CREATE_Ax = function(o, a) {\n    return fullins(o << POS_OP | a << POS_Ax);\n};\n\n/* number of list items to accumulate before a SETLIST instruction */\nconst LFIELDS_PER_FLUSH = 50;\n\nmodule.exports.BITRK               = BITRK;\nmodule.exports.CREATE_ABC          = CREATE_ABC;\nmodule.exports.CREATE_ABx          = CREATE_ABx;\nmodule.exports.CREATE_Ax           = CREATE_Ax;\nmodule.exports.GET_OPCODE          = GET_OPCODE;\nmodule.exports.GETARG_A            = GETARG_A;\nmodule.exports.GETARG_B            = GETARG_B;\nmodule.exports.GETARG_C            = GETARG_C;\nmodule.exports.GETARG_Bx           = GETARG_Bx;\nmodule.exports.GETARG_Ax           = GETARG_Ax;\nmodule.exports.GETARG_sBx          = GETARG_sBx;\nmodule.exports.INDEXK              = INDEXK;\nmodule.exports.ISK                 = ISK;\nmodule.exports.LFIELDS_PER_FLUSH   = LFIELDS_PER_FLUSH;\nmodule.exports.MAXARG_A            = MAXARG_A;\nmodule.exports.MAXARG_Ax           = MAXARG_Ax;\nmodule.exports.MAXARG_B            = MAXARG_B;\nmodule.exports.MAXARG_Bx           = MAXARG_Bx;\nmodule.exports.MAXARG_C            = MAXARG_C;\nmodule.exports.MAXARG_sBx          = MAXARG_sBx;\nmodule.exports.MAXINDEXRK          = MAXINDEXRK;\nmodule.exports.NO_REG              = NO_REG;\nmodule.exports.OpArgK              = OpArgK;\nmodule.exports.OpArgN              = OpArgN;\nmodule.exports.OpArgR              = OpArgR;\nmodule.exports.OpArgU              = OpArgU;\nmodule.exports.OpCodes             = OpCodes;\nmodule.exports.OpCodesI            = OpCodesI;\nmodule.exports.POS_A               = POS_A;\nmodule.exports.POS_Ax              = POS_Ax;\nmodule.exports.POS_B               = POS_B;\nmodule.exports.POS_Bx              = POS_Bx;\nmodule.exports.POS_C               = POS_C;\nmodule.exports.POS_OP              = POS_OP;\nmodule.exports.RKASK               = RKASK;\nmodule.exports.SETARG_A            = SETARG_A;\nmodule.exports.SETARG_Ax           = SETARG_Ax;\nmodule.exports.SETARG_B            = SETARG_B;\nmodule.exports.SETARG_Bx           = SETARG_Bx;\nmodule.exports.SETARG_C            = SETARG_C;\nmodule.exports.SETARG_sBx          = SETARG_sBx;\nmodule.exports.SET_OPCODE          = SET_OPCODE;\nmodule.exports.SIZE_A              = SIZE_A;\nmodule.exports.SIZE_Ax             = SIZE_Ax;\nmodule.exports.SIZE_B              = SIZE_B;\nmodule.exports.SIZE_Bx             = SIZE_Bx;\nmodule.exports.SIZE_C              = SIZE_C;\nmodule.exports.SIZE_OP             = SIZE_OP;\nmodule.exports.fullins             = fullins;\nmodule.exports.getBMode            = getBMode;\nmodule.exports.getCMode            = getCMode;\nmodule.exports.getOpMode           = getOpMode;\nmodule.exports.iABC                = iABC;\nmodule.exports.iABx                = iABx;\nmodule.exports.iAsBx               = iAsBx;\nmodule.exports.iAx                 = iAx;\nmodule.exports.testAMode           = testAMode;\nmodule.exports.testTMode           = testTMode;\n", ";\n\nconst {\n    LUA_MASKLINE,\n    LUA_MASKCOUNT,\n    LUA_MULTRET,\n    constant_types: {\n        LUA_TBOOLEAN,\n        LUA_TLCF,\n        LUA_TLIGHTUSERDATA,\n        LUA_TLNGSTR,\n        LUA_TNIL,\n        LUA_TNUMBER,\n        LUA_TNUMFLT,\n        LUA_TNUMINT,\n        LUA_TSHRSTR,\n        LUA_TTABLE,\n        LUA_TUSERDATA\n    },\n    to_luastring\n} = require('./defs.js');\nconst {\n    INDEXK,\n    ISK,\n    LFIELDS_PER_FLUSH,\n    OpCodesI: {\n        OP_ADD,\n        OP_BAND,\n        OP_BNOT,\n        OP_BOR,\n        OP_BXOR,\n        OP_CALL,\n        OP_CLOSURE,\n        OP_CONCAT,\n        OP_DIV,\n        OP_EQ,\n        OP_EXTRAARG,\n        OP_FORLOOP,\n        OP_FORPREP,\n        OP_GETTABLE,\n        OP_GETTABUP,\n        OP_GETUPVAL,\n        OP_IDIV,\n        OP_JMP,\n        OP_LE,\n        OP_LEN,\n        OP_LOADBOOL,\n        OP_LOADK,\n        OP_LOADKX,\n        OP_LOADNIL,\n        OP_LT,\n        OP_MOD,\n        OP_MOVE,\n        OP_MUL,\n        OP_NEWTABLE,\n        OP_NOT,\n        OP_POW,\n        OP_RETURN,\n        OP_SELF,\n        OP_SETLIST,\n        OP_SETTABLE,\n        OP_SETTABUP,\n        OP_SETUPVAL,\n        OP_SHL,\n        OP_SHR,\n        OP_SUB,\n        OP_TAILCALL,\n        OP_TEST,\n        OP_TESTSET,\n        OP_TFORCALL,\n        OP_TFORLOOP,\n        OP_UNM,\n        OP_VARARG\n    }\n} = require('./lopcodes.js');\nconst {\n    LUA_MAXINTEGER,\n    LUA_MININTEGER,\n    lua_numbertointeger\n} = require('./luaconf.js');\nconst {\n    lua_assert,\n    luai_nummod\n} = require('./llimits.js');\nconst lobject = require('./lobject.js');\nconst lfunc   = require('./lfunc.js');\nconst lstate  = require('./lstate.js');\nconst {\n    luaS_bless,\n    luaS_eqlngstr,\n    luaS_hashlongstr\n} = require('./lstring.js');\nconst ldo     = require('./ldo.js');\nconst ltm     = require('./ltm.js');\nconst ltable  = require('./ltable.js');\nconst ldebug  = require('./ldebug.js');\n\n/*\n** finish execution of an opcode interrupted by an yield\n*/\nconst luaV_finishOp = function(L) {\n    let ci = L.ci;\n    let base = ci.l_base;\n    let inst = ci.l_code[ci.l_savedpc - 1];  /* interrupted instruction */\n    let op = inst.opcode;\n\n    switch (op) {  /* finish its execution */\n        case OP_ADD: case OP_SUB: case OP_MUL: case OP_DIV: case OP_IDIV:\n        case OP_BAND: case OP_BOR: case OP_BXOR: case OP_SHL: case OP_SHR:\n        case OP_MOD: case OP_POW:\n        case OP_UNM: case OP_BNOT: case OP_LEN:\n        case OP_GETTABUP: case OP_GETTABLE: case OP_SELF: {\n            lobject.setobjs2s(L, base + inst.A, L.top-1);\n            delete L.stack[--L.top];\n            break;\n        }\n        case OP_LE: case OP_LT: case OP_EQ: {\n            let res = !L.stack[L.top - 1].l_isfalse();\n            delete L.stack[--L.top];\n            if (ci.callstatus & lstate.CIST_LEQ) {  /* \"<=\" using \"<\" instead? */\n                lua_assert(op === OP_LE);\n                ci.callstatus ^= lstate.CIST_LEQ;  /* clear mark */\n                res = !res;  /* negate result */\n            }\n            lua_assert(ci.l_code[ci.l_savedpc].opcode === OP_JMP);\n            if (res !== (inst.A ? true : false))  /* condition failed? */\n                ci.l_savedpc++;  /* skip jump instruction */\n            break;\n        }\n        case OP_CONCAT: {\n            let top = L.top - 1;  /* top when 'luaT_trybinTM' was called */\n            let b = inst.B;  /* first element to concatenate */\n            let total = top - 1 - (base + b);  /* yet to concatenate */\n            lobject.setobjs2s(L, top - 2, top);  /* put TM result in proper position */\n            if (total > 1) {  /* are there elements to concat? */\n                L.top = top - 1;  /* top is one after last element (at top-2) */\n                luaV_concat(L, total);  /* concat them (may yield again) */\n            }\n            /* move final result to final position */\n            lobject.setobjs2s(L, ci.l_base + inst.A, L.top - 1);\n            ldo.adjust_top(L, ci.top);  /* restore top */\n            break;\n        }\n        case OP_TFORCALL: {\n            lua_assert(ci.l_code[ci.l_savedpc].opcode === OP_TFORLOOP);\n            ldo.adjust_top(L, ci.top);  /* correct top */\n            break;\n        }\n        case OP_CALL: {\n            if (inst.C - 1 >= 0)  /* nresults >= 0? */\n                ldo.adjust_top(L, ci.top);  /* adjust results */\n            break;\n        }\n    }\n};\n\nconst RA = function(L, base, i) {\n    return base + i.A;\n};\n\nconst RB = function(L, base, i) {\n    return base + i.B;\n};\n\n// const RC = function(L, base, i) {\n//     return base + i.C;\n// };\n\nconst RKB = function(L, base, k, i) {\n    return ISK(i.B) ? k[INDEXK(i.B)] : L.stack[base + i.B];\n};\n\nconst RKC = function(L, base, k, i) {\n    return ISK(i.C) ? k[INDEXK(i.C)] : L.stack[base + i.C];\n};\n\nconst luaV_execute = function(L) {\n    let ci = L.ci;\n\n    ci.callstatus |= lstate.CIST_FRESH;\n    newframe:\n    for (;;) {\n        lua_assert(ci === L.ci);\n        let cl = ci.func.value;\n        let k = cl.p.k;\n        let base = ci.l_base;\n\n        let i = ci.l_code[ci.l_savedpc++];\n\n        if (L.hookmask & (LUA_MASKLINE | LUA_MASKCOUNT)) {\n            ldebug.luaG_traceexec(L);\n        }\n\n        let ra = RA(L, base, i);\n        let opcode = i.opcode;\n\n        switch (opcode) {\n            case OP_MOVE: {\n                lobject.setobjs2s(L, ra, RB(L, base, i));\n                break;\n            }\n            case OP_LOADK: {\n                let konst = k[i.Bx];\n                lobject.setobj2s(L, ra, konst);\n                break;\n            }\n            case OP_LOADKX: {\n                lua_assert(ci.l_code[ci.l_savedpc].opcode === OP_EXTRAARG);\n                let konst = k[ci.l_code[ci.l_savedpc++].Ax];\n                lobject.setobj2s(L, ra, konst);\n                break;\n            }\n            case OP_LOADBOOL: {\n                L.stack[ra].setbvalue(i.B !== 0);\n\n                if (i.C !== 0)\n                    ci.l_savedpc++; /* skip next instruction (if C) */\n\n                break;\n            }\n            case OP_LOADNIL: {\n                for (let j = 0; j <= i.B; j++)\n                    L.stack[ra + j].setnilvalue();\n                break;\n            }\n            case OP_GETUPVAL: {\n                let b = i.B;\n                lobject.setobj2s(L, ra, cl.upvals[b]);\n                break;\n            }\n            case OP_GETTABUP: {\n                let upval = cl.upvals[i.B];\n                let rc = RKC(L, base, k, i);\n                luaV_gettable(L, upval, rc, ra);\n                break;\n            }\n            case OP_GETTABLE: {\n                let rb = L.stack[RB(L, base, i)];\n                let rc = RKC(L, base, k, i);\n                luaV_gettable(L, rb, rc, ra);\n                break;\n            }\n            case OP_SETTABUP: {\n                let upval = cl.upvals[i.A];\n                let rb = RKB(L, base, k, i);\n                let rc = RKC(L, base, k, i);\n                settable(L, upval, rb, rc);\n                break;\n            }\n            case OP_SETUPVAL: {\n                let uv = cl.upvals[i.B];\n                uv.setfrom(L.stack[ra]);\n                break;\n            }\n            case OP_SETTABLE: {\n                let table = L.stack[ra];\n                let key = RKB(L, base, k, i);\n                let v = RKC(L, base, k, i);\n\n                settable(L, table, key, v);\n                break;\n            }\n            case OP_NEWTABLE: {\n                L.stack[ra].sethvalue(ltable.luaH_new(L));\n                break;\n            }\n            case OP_SELF: {\n                let rb = RB(L, base, i);\n                let rc = RKC(L, base, k, i);\n                lobject.setobjs2s(L, ra + 1, rb);\n                luaV_gettable(L, L.stack[rb], rc, ra);\n                break;\n            }\n            case OP_ADD: {\n                let op1 = RKB(L, base, k, i);\n                let op2 = RKC(L, base, k, i);\n                let numberop1, numberop2;\n\n                if (op1.ttisinteger() && op2.ttisinteger()) {\n                    L.stack[ra].setivalue((op1.value + op2.value)|0);\n                } else if ((numberop1 = tonumber(op1)) !== false && (numberop2 = tonumber(op2)) !== false) {\n                    L.stack[ra].setfltvalue(numberop1 + numberop2);\n                } else {\n                    ltm.luaT_trybinTM(L, op1, op2, L.stack[ra], ltm.TMS.TM_ADD);\n                }\n                break;\n            }\n            case OP_SUB: {\n                let op1 = RKB(L, base, k, i);\n                let op2 = RKC(L, base, k, i);\n                let numberop1, numberop2;\n\n                if (op1.ttisinteger() && op2.ttisinteger()) {\n                    L.stack[ra].setivalue((op1.value - op2.value)|0);\n                } else if ((numberop1 = tonumber(op1)) !== false && (numberop2 = tonumber(op2)) !== false) {\n                    L.stack[ra].setfltvalue(numberop1 - numberop2);\n                } else {\n                    ltm.luaT_trybinTM(L, op1, op2, L.stack[ra], ltm.TMS.TM_SUB);\n                }\n                break;\n            }\n            case OP_MUL: {\n                let op1 = RKB(L, base, k, i);\n                let op2 = RKC(L, base, k, i);\n                let numberop1, numberop2;\n\n                if (op1.ttisinteger() && op2.ttisinteger()) {\n                    L.stack[ra].setivalue(luaV_imul(op1.value, op2.value));\n                } else if ((numberop1 = tonumber(op1)) !== false && (numberop2 = tonumber(op2)) !== false) {\n                    L.stack[ra].setfltvalue(numberop1 * numberop2);\n                } else {\n                    ltm.luaT_trybinTM(L, op1, op2, L.stack[ra], ltm.TMS.TM_MUL);\n                }\n                break;\n            }\n            case OP_MOD: {\n                let op1 = RKB(L, base, k, i);\n                let op2 = RKC(L, base, k, i);\n                let numberop1, numberop2;\n\n                if (op1.ttisinteger() && op2.ttisinteger()) {\n                    L.stack[ra].setivalue(luaV_mod(L, op1.value, op2.value));\n                } else if ((numberop1 = tonumber(op1)) !== false && (numberop2 = tonumber(op2)) !== false) {\n                    L.stack[ra].setfltvalue(luai_nummod(L, numberop1, numberop2));\n                } else {\n                    ltm.luaT_trybinTM(L, op1, op2, L.stack[ra], ltm.TMS.TM_MOD);\n                }\n                break;\n            }\n            case OP_POW: {\n                let op1 = RKB(L, base, k, i);\n                let op2 = RKC(L, base, k, i);\n                let numberop1, numberop2;\n\n                if ((numberop1 = tonumber(op1)) !== false && (numberop2 = tonumber(op2)) !== false) {\n                    L.stack[ra].setfltvalue(Math.pow(numberop1, numberop2));\n                } else {\n                    ltm.luaT_trybinTM(L, op1, op2, L.stack[ra], ltm.TMS.TM_POW);\n                }\n                break;\n            }\n            case OP_DIV: {\n                let op1 = RKB(L, base, k, i);\n                let op2 = RKC(L, base, k, i);\n                let numberop1, numberop2;\n\n                if ((numberop1 = tonumber(op1)) !== false && (numberop2 = tonumber(op2)) !== false) {\n                    L.stack[ra].setfltvalue(numberop1 / numberop2);\n                } else {\n                    ltm.luaT_trybinTM(L, op1, op2, L.stack[ra], ltm.TMS.TM_DIV);\n                }\n                break;\n            }\n            case OP_IDIV: {\n                let op1 = RKB(L, base, k, i);\n                let op2 = RKC(L, base, k, i);\n                let numberop1, numberop2;\n\n                if (op1.ttisinteger() && op2.ttisinteger()) {\n                    L.stack[ra].setivalue(luaV_div(L, op1.value, op2.value));\n                } else if ((numberop1 = tonumber(op1)) !== false && (numberop2 = tonumber(op2)) !== false) {\n                    L.stack[ra].setfltvalue(Math.floor(numberop1 / numberop2));\n                } else {\n                    ltm.luaT_trybinTM(L, op1, op2, L.stack[ra], ltm.TMS.TM_IDIV);\n                }\n                break;\n            }\n            case OP_BAND: {\n                let op1 = RKB(L, base, k, i);\n                let op2 = RKC(L, base, k, i);\n                let numberop1, numberop2;\n\n                if ((numberop1 = tointeger(op1)) !== false && (numberop2 = tointeger(op2)) !== false) {\n                    L.stack[ra].setivalue(numberop1 & numberop2);\n                } else {\n                    ltm.luaT_trybinTM(L, op1, op2, L.stack[ra], ltm.TMS.TM_BAND);\n                }\n                break;\n            }\n            case OP_BOR: {\n                let op1 = RKB(L, base, k, i);\n                let op2 = RKC(L, base, k, i);\n                let numberop1, numberop2;\n\n                if ((numberop1 = tointeger(op1)) !== false && (numberop2 = tointeger(op2)) !== false) {\n                    L.stack[ra].setivalue(numberop1 | numberop2);\n                } else {\n                    ltm.luaT_trybinTM(L, op1, op2, L.stack[ra], ltm.TMS.TM_BOR);\n                }\n                break;\n            }\n            case OP_BXOR: {\n                let op1 = RKB(L, base, k, i);\n                let op2 = RKC(L, base, k, i);\n                let numberop1, numberop2;\n\n                if ((numberop1 = tointeger(op1)) !== false && (numberop2 = tointeger(op2)) !== false) {\n                    L.stack[ra].setivalue(numberop1 ^ numberop2);\n                } else {\n                    ltm.luaT_trybinTM(L, op1, op2, L.stack[ra], ltm.TMS.TM_BXOR);\n                }\n                break;\n            }\n            case OP_SHL: {\n                let op1 = RKB(L, base, k, i);\n                let op2 = RKC(L, base, k, i);\n                let numberop1, numberop2;\n\n                if ((numberop1 = tointeger(op1)) !== false && (numberop2 = tointeger(op2)) !== false) {\n                    L.stack[ra].setivalue(luaV_shiftl(numberop1, numberop2));\n                } else {\n                    ltm.luaT_trybinTM(L, op1, op2, L.stack[ra], ltm.TMS.TM_SHL);\n                }\n                break;\n            }\n            case OP_SHR: {\n                let op1 = RKB(L, base, k, i);\n                let op2 = RKC(L, base, k, i);\n                let numberop1, numberop2;\n\n                if ((numberop1 = tointeger(op1)) !== false && (numberop2 = tointeger(op2)) !== false) {\n                    L.stack[ra].setivalue(luaV_shiftl(numberop1, -numberop2));\n                } else {\n                    ltm.luaT_trybinTM(L, op1, op2, L.stack[ra], ltm.TMS.TM_SHR);\n                }\n                break;\n            }\n            case OP_UNM: {\n                let op = L.stack[RB(L, base, i)];\n                let numberop;\n\n                if (op.ttisinteger()) {\n                    L.stack[ra].setivalue((-op.value)|0);\n                } else if ((numberop = tonumber(op)) !== false) {\n                    L.stack[ra].setfltvalue(-numberop);\n                } else {\n                    ltm.luaT_trybinTM(L, op, op, L.stack[ra], ltm.TMS.TM_UNM);\n                }\n                break;\n            }\n            case OP_BNOT: {\n                let op = L.stack[RB(L, base, i)];\n\n                if (op.ttisinteger()) {\n                    L.stack[ra].setivalue(~op.value);\n                } else {\n                    ltm.luaT_trybinTM(L, op, op, L.stack[ra], ltm.TMS.TM_BNOT);\n                }\n                break;\n            }\n            case OP_NOT: {\n                let op = L.stack[RB(L, base, i)];\n                L.stack[ra].setbvalue(op.l_isfalse());\n                break;\n            }\n            case OP_LEN: {\n                luaV_objlen(L, L.stack[ra], L.stack[RB(L, base, i)]);\n                break;\n            }\n            case OP_CONCAT: {\n                let b = i.B;\n                let c = i.C;\n                L.top = base + c + 1; /* mark the end of concat operands */\n                luaV_concat(L, c - b + 1);\n                let rb = base + b;\n                lobject.setobjs2s(L, ra, rb);\n                ldo.adjust_top(L, ci.top); /* restore top */\n                break;\n            }\n            case OP_JMP: {\n                dojump(L, ci, i, 0);\n                break;\n            }\n            case OP_EQ: {\n                if (luaV_equalobj(L, RKB(L, base, k, i), RKC(L, base, k, i)) !== i.A)\n                    ci.l_savedpc++;\n                else\n                    donextjump(L, ci);\n                break;\n            }\n            case OP_LT: {\n                if (luaV_lessthan(L, RKB(L, base, k, i), RKC(L, base, k, i)) !== i.A)\n                    ci.l_savedpc++;\n                else\n                    donextjump(L, ci);\n                break;\n            }\n            case OP_LE: {\n                if (luaV_lessequal(L, RKB(L, base, k, i), RKC(L, base, k, i)) !== i.A)\n                    ci.l_savedpc++;\n                else\n                    donextjump(L, ci);\n                break;\n            }\n            case OP_TEST: {\n                if (i.C ? L.stack[ra].l_isfalse() : !L.stack[ra].l_isfalse())\n                    ci.l_savedpc++;\n                else\n                    donextjump(L, ci);\n                break;\n            }\n            case OP_TESTSET: {\n                let rbIdx = RB(L, base, i);\n                let rb = L.stack[rbIdx];\n                if (i.C ? rb.l_isfalse() : !rb.l_isfalse())\n                    ci.l_savedpc++;\n                else {\n                    lobject.setobjs2s(L, ra, rbIdx);\n                    donextjump(L, ci);\n                }\n                break;\n            }\n            case OP_CALL: {\n                let b = i.B;\n                let nresults = i.C - 1;\n                if (b !== 0) ldo.adjust_top(L, ra+b);  /* else previous instruction set top */\n                if (ldo.luaD_precall(L, ra, nresults)) {\n                    if (nresults >= 0)\n                        ldo.adjust_top(L, ci.top);  /* adjust results */\n                } else {\n                    ci = L.ci;\n                    continue newframe;\n                }\n\n                break;\n            }\n            case OP_TAILCALL: {\n                let b = i.B;\n                if (b !== 0) ldo.adjust_top(L, ra+b);  /* else previous instruction set top */\n                if (ldo.luaD_precall(L, ra, LUA_MULTRET)) { // JS function\n                } else {\n                    /* tail call: put called frame (n) in place of caller one (o) */\n                    let nci = L.ci;\n                    let oci = nci.previous;\n                    let nfunc = nci.func;\n                    let nfuncOff = nci.funcOff;\n                    let ofuncOff = oci.funcOff;\n                    let lim = nci.l_base + nfunc.value.p.numparams;\n                    if (cl.p.p.length > 0) lfunc.luaF_close(L, oci.l_base);\n                    for (let aux = 0; nfuncOff + aux < lim; aux++)\n                        lobject.setobjs2s(L, ofuncOff + aux, nfuncOff + aux);\n                    oci.l_base = ofuncOff + (nci.l_base - nfuncOff);\n                    oci.top = ofuncOff + (L.top - nfuncOff);\n                    ldo.adjust_top(L, oci.top);  /* correct top */\n                    oci.l_code = nci.l_code;\n                    oci.l_savedpc = nci.l_savedpc;\n                    oci.callstatus |= lstate.CIST_TAIL;\n                    oci.next = null;\n                    ci = L.ci = oci;\n\n                    lua_assert(L.top === oci.l_base + L.stack[ofuncOff].value.p.maxstacksize);\n\n                    continue newframe;\n                }\n                break;\n            }\n            case OP_RETURN: {\n                if (cl.p.p.length > 0) lfunc.luaF_close(L, base);\n                let b = ldo.luaD_poscall(L, ci, ra, (i.B !== 0 ? i.B - 1 : L.top - ra));\n\n                if (ci.callstatus & lstate.CIST_FRESH)\n                    return; /* external invocation: return */\n                /* invocation via reentry: continue execution */\n                ci = L.ci;\n                if (b) ldo.adjust_top(L, ci.top);\n                lua_assert(ci.callstatus & lstate.CIST_LUA);\n                lua_assert(ci.l_code[ci.l_savedpc - 1].opcode === OP_CALL);\n                continue newframe;\n            }\n            case OP_FORLOOP: {\n                if (L.stack[ra].ttisinteger()) { /* integer loop? */\n                    let step = L.stack[ra + 2].value;\n                    let idx = (L.stack[ra].value + step)|0;\n                    let limit = L.stack[ra + 1].value;\n\n                    if (0 < step ? idx <= limit : limit <= idx) {\n                        ci.l_savedpc += i.sBx;\n                        L.stack[ra].chgivalue(idx);  /* update internal index... */\n                        L.stack[ra + 3].setivalue(idx);\n                    }\n                } else { /* floating loop */\n                    let step = L.stack[ra + 2].value;\n                    let idx = L.stack[ra].value + step;\n                    let limit = L.stack[ra + 1].value;\n\n                    if (0 < step ? idx <= limit : limit <= idx) {\n                        ci.l_savedpc += i.sBx;\n                        L.stack[ra].chgfltvalue(idx);  /* update internal index... */\n                        L.stack[ra + 3].setfltvalue(idx);\n                    }\n                }\n                break;\n            }\n            case OP_FORPREP: {\n                let init = L.stack[ra];\n                let plimit = L.stack[ra + 1];\n                let pstep = L.stack[ra + 2];\n                let forlim;\n\n                if (init.ttisinteger() && pstep.ttisinteger() && (forlim = forlimit(plimit, pstep.value))) {\n                    /* all values are integer */\n                    let initv = forlim.stopnow ? 0 : init.value;\n                    plimit.value = forlim.ilimit;\n                    init.value = (initv - pstep.value)|0;\n                } else { /* try making all values floats */\n                    let nlimit, nstep, ninit;\n                    if ((nlimit = tonumber(plimit)) === false)\n                        ldebug.luaG_runerror(L, to_luastring(\"'for' limit must be a number\", true));\n                    L.stack[ra + 1].setfltvalue(nlimit);\n                    if ((nstep = tonumber(pstep)) === false)\n                        ldebug.luaG_runerror(L, to_luastring(\"'for' step must be a number\", true));\n                    L.stack[ra + 2].setfltvalue(nstep);\n                    if ((ninit = tonumber(init)) === false)\n                        ldebug.luaG_runerror(L, to_luastring(\"'for' initial value must be a number\", true));\n                    L.stack[ra].setfltvalue(ninit - nstep);\n                }\n\n                ci.l_savedpc += i.sBx;\n                break;\n            }\n            case OP_TFORCALL: {\n                let cb = ra + 3; /* call base */\n                lobject.setobjs2s(L, cb+2, ra+2);\n                lobject.setobjs2s(L, cb+1, ra+1);\n                lobject.setobjs2s(L, cb, ra);\n                ldo.adjust_top(L, cb+3);  /* func. + 2 args (state and index) */\n                ldo.luaD_call(L, cb, i.C);\n                ldo.adjust_top(L, ci.top);\n                /* go straight to OP_TFORLOOP */\n                i = ci.l_code[ci.l_savedpc++];\n                ra = RA(L, base, i);\n                lua_assert(i.opcode === OP_TFORLOOP);\n            }\n            /* fall through */\n            case OP_TFORLOOP: {\n                if (!L.stack[ra + 1].ttisnil()) { /* continue loop? */\n                    lobject.setobjs2s(L, ra, ra + 1); /* save control variable */\n                    ci.l_savedpc += i.sBx; /* jump back */\n                }\n                break;\n            }\n            case OP_SETLIST: {\n                let n = i.B;\n                let c = i.C;\n\n                if (n === 0) n = L.top - ra - 1;\n\n                if (c === 0) {\n                    lua_assert(ci.l_code[ci.l_savedpc].opcode === OP_EXTRAARG);\n                    c = ci.l_code[ci.l_savedpc++].Ax;\n                }\n\n                let h = L.stack[ra].value;\n                let last = ((c - 1) * LFIELDS_PER_FLUSH) + n;\n\n                for (; n > 0; n--) {\n                    ltable.luaH_setint(h, last--, L.stack[ra + n]);\n                }\n                ldo.adjust_top(L, ci.top);  /* correct top (in case of previous open call) */\n                break;\n            }\n            case OP_CLOSURE: {\n                let p = cl.p.p[i.Bx];\n                let ncl = getcached(p, cl.upvals, L.stack, base);  /* cached closure */\n                if (ncl === null)  /* no match? */\n                    pushclosure(L, p, cl.upvals, base, ra);  /* create a new one */\n                else\n                    L.stack[ra].setclLvalue(ncl);\n                break;\n            }\n            case OP_VARARG: {\n                let b = i.B - 1;\n                let n = base - ci.funcOff - cl.p.numparams - 1;\n                let j;\n\n                if (n < 0) /* less arguments than parameters? */\n                    n = 0; /* no vararg arguments */\n\n                if (b < 0) {\n                    b = n;  /* get all var. arguments */\n                    ldo.luaD_checkstack(L, n);\n                    ldo.adjust_top(L, ra + n);\n                }\n\n                for (j = 0; j < b && j < n; j++)\n                    lobject.setobjs2s(L, ra + j, base - n + j);\n\n                for (; j < b; j++) /* complete required results with nil */\n                    L.stack[ra + j].setnilvalue();\n                break;\n            }\n            case OP_EXTRAARG: {\n                throw Error(\"invalid opcode\");\n            }\n        }\n    }\n};\n\nconst dojump = function(L, ci, i, e) {\n    let a = i.A;\n    if (a !== 0) lfunc.luaF_close(L, ci.l_base + a - 1);\n    ci.l_savedpc += i.sBx + e;\n};\n\nconst donextjump = function(L, ci) {\n    dojump(L, ci, ci.l_code[ci.l_savedpc], 1);\n};\n\n\nconst luaV_lessthan = function(L, l, r) {\n    if (l.ttisnumber() && r.ttisnumber())\n        return LTnum(l, r) ? 1 : 0;\n    else if (l.ttisstring() && r.ttisstring())\n        return l_strcmp(l.tsvalue(), r.tsvalue()) < 0 ? 1 : 0;\n    else {\n        let res = ltm.luaT_callorderTM(L, l, r, ltm.TMS.TM_LT);\n        if (res === null)\n            ldebug.luaG_ordererror(L, l, r);\n        return res ? 1 : 0;\n    }\n};\n\nconst luaV_lessequal = function(L, l, r) {\n    let res;\n\n    if (l.ttisnumber() && r.ttisnumber())\n        return LEnum(l, r) ? 1 : 0;\n    else if (l.ttisstring() && r.ttisstring())\n        return l_strcmp(l.tsvalue(), r.tsvalue()) <= 0 ? 1 : 0;\n    else {\n        res = ltm.luaT_callorderTM(L, l, r, ltm.TMS.TM_LE);\n        if (res !== null)\n            return res ? 1 : 0;\n    }\n    /* try 'lt': */\n    L.ci.callstatus |= lstate.CIST_LEQ; /* mark it is doing 'lt' for 'le' */\n    res = ltm.luaT_callorderTM(L, r, l, ltm.TMS.TM_LT);\n    L.ci.callstatus ^= lstate.CIST_LEQ; /* clear mark */\n    if (res === null)\n        ldebug.luaG_ordererror(L, l, r);\n    return res ? 0 : 1; /* result is negated */\n};\n\nconst luaV_equalobj = function(L, t1, t2) {\n    if (t1.ttype() !== t2.ttype()) { /* not the same variant? */\n        if (t1.ttnov() !== t2.ttnov() || t1.ttnov() !== LUA_TNUMBER)\n            return 0; /* only numbers can be equal with different variants */\n        else { /* two numbers with different variants */\n            /* OPTIMIZATION: instead of calling luaV_tointeger we can just let JS do the comparison */\n            return (t1.value === t2.value) ? 1 : 0;\n        }\n    }\n\n    let tm;\n\n    /* values have same type and same variant */\n    switch(t1.ttype()) {\n        case LUA_TNIL:\n            return 1;\n        case LUA_TBOOLEAN:\n            return t1.value == t2.value ? 1 : 0; // Might be 1 or true\n        case LUA_TLIGHTUSERDATA:\n        case LUA_TNUMINT:\n        case LUA_TNUMFLT:\n        case LUA_TLCF:\n            return t1.value === t2.value ? 1 : 0;\n        case LUA_TSHRSTR:\n        case LUA_TLNGSTR: {\n            return luaS_eqlngstr(t1.tsvalue(), t2.tsvalue()) ? 1 : 0;\n        }\n        case LUA_TUSERDATA:\n        case LUA_TTABLE:\n            if (t1.value === t2.value) return 1;\n            else if (L === null) return 0;\n\n            tm = ltm.fasttm(L, t1.value.metatable, ltm.TMS.TM_EQ);\n            if (tm === null)\n                tm = ltm.fasttm(L, t2.value.metatable, ltm.TMS.TM_EQ);\n            break;\n        default:\n            return t1.value === t2.value ? 1 : 0;\n    }\n\n    if (tm === null) /* no TM? */\n        return 0;\n\n    let tv = new lobject.TValue(); /* doesn't use the stack */\n    ltm.luaT_callTM(L, tm, t1, t2, tv, 1);\n    return tv.l_isfalse() ? 0 : 1;\n};\n\nconst luaV_rawequalobj = function(t1, t2) {\n    return luaV_equalobj(null, t1, t2);\n};\n\nconst forlimit = function(obj, step) {\n    let stopnow = false;\n    let ilimit = luaV_tointeger(obj, step < 0 ? 2 : 1);\n    if (ilimit === false) {\n        let n = tonumber(obj);\n        if (n === false)\n            return false;\n\n        if (0 < n) {\n            ilimit = LUA_MAXINTEGER;\n            if (step < 0) stopnow = true;\n        } else {\n            ilimit = LUA_MININTEGER;\n            if (step >= 0) stopnow = true;\n        }\n    }\n\n    return {\n        stopnow: stopnow,\n        ilimit: ilimit\n    };\n};\n\n/*\n** try to convert a value to an integer, rounding according to 'mode':\n** mode === 0: accepts only integral values\n** mode === 1: takes the floor of the number\n** mode === 2: takes the ceil of the number\n*/\nconst luaV_tointeger = function(obj, mode) {\n    if (obj.ttisfloat()) {\n        let n = obj.value;\n        let f = Math.floor(n);\n\n        if (n !== f) { /* not an integral value? */\n            if (mode === 0)\n                return false;  /* fails if mode demands integral value */\n            else if (mode > 1)  /* needs ceil? */\n                f += 1;  /* convert floor to ceil (remember: n !== f) */\n        }\n\n        return lua_numbertointeger(f);\n    } else if (obj.ttisinteger()) {\n        return obj.value;\n    } else if (cvt2num(obj)) {\n        let v = new lobject.TValue();\n        if (lobject.luaO_str2num(obj.svalue(), v) === (obj.vslen() + 1))\n            return luaV_tointeger(v, mode);\n    }\n\n    return false;\n};\n\nconst tointeger = function(o) {\n    return o.ttisinteger() ? o.value : luaV_tointeger(o, 0);\n};\n\nconst tonumber = function(o) {\n    if (o.ttnov() === LUA_TNUMBER)\n        return o.value;\n\n    if (cvt2num(o)) {  /* string convertible to number? */\n        let v = new lobject.TValue();\n        if (lobject.luaO_str2num(o.svalue(), v) === (o.vslen() + 1))\n            return v.value;\n    }\n\n    return false;\n};\n\n/*\n** Return 'l < r', for numbers.\n** As fengari uses javascript numbers for both floats and integers and has\n** correct semantics, we can just compare values.\n*/\nconst LTnum = function(l, r) {\n    return l.value < r.value;\n};\n\n/*\n** Return 'l <= r', for numbers.\n*/\nconst LEnum = function(l, r) {\n    return l.value <= r.value;\n};\n\n/*\n** Compare two strings 'ls' x 'rs', returning an integer smaller-equal-\n** -larger than zero if 'ls' is smaller-equal-larger than 'rs'.\n*/\nconst l_strcmp = function(ls, rs) {\n    let l = luaS_hashlongstr(ls);\n    let r = luaS_hashlongstr(rs);\n    /* In fengari we assume string hash has same collation as byte values */\n    if (l === r)\n        return 0;\n    else if (l < r)\n        return -1;\n    else\n        return 1;\n};\n\n/*\n** Main operation 'ra' = #rb'.\n*/\nconst luaV_objlen = function(L, ra, rb) {\n    let tm;\n    switch(rb.ttype()) {\n        case LUA_TTABLE: {\n            let h = rb.value;\n            tm = ltm.fasttm(L, h.metatable, ltm.TMS.TM_LEN);\n            if (tm !== null) break; /* metamethod? break switch to call it */\n            ra.setivalue(ltable.luaH_getn(h)); /* else primitive len */\n            return;\n        }\n        case LUA_TSHRSTR:\n        case LUA_TLNGSTR:\n            ra.setivalue(rb.vslen());\n            return;\n        default: {\n            tm = ltm.luaT_gettmbyobj(L, rb, ltm.TMS.TM_LEN);\n            if (tm.ttisnil())\n                ldebug.luaG_typeerror(L, rb, to_luastring(\"get length of\", true));\n            break;\n        }\n    }\n\n    ltm.luaT_callTM(L, tm, rb, rb, ra, 1);\n};\n\n/* Shim taken from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul */\nconst luaV_imul = Math.imul || function(a, b) {\n    let aHi = (a >>> 16) & 0xffff;\n    let aLo = a & 0xffff;\n    let bHi = (b >>> 16) & 0xffff;\n    let bLo = b & 0xffff;\n    /*\n    ** the shift by 0 fixes the sign on the high part\n    ** the final |0 converts the unsigned value into a signed value\n    */\n    return ((aLo * bLo) + (((aHi * bLo + aLo * bHi) << 16) >>> 0) | 0);\n};\n\nconst luaV_div = function(L, m, n) {\n    if (n === 0)\n        ldebug.luaG_runerror(L, to_luastring(\"attempt to divide by zero\"));\n    return Math.floor(m / n)|0;\n};\n\n// % semantic on negative numbers is different in js\nconst luaV_mod = function(L, m, n) {\n    if (n === 0)\n        ldebug.luaG_runerror(L, to_luastring(\"attempt to perform 'n%%0'\"));\n    return (m - Math.floor(m / n) * n)|0;\n};\n\nconst NBITS = 32;\n\nconst luaV_shiftl = function(x, y) {\n    if (y < 0) {  /* shift right? */\n        if (y <= -NBITS) return 0;\n        else return x >>> -y;\n    }\n    else {  /* shift left */\n        if (y >= NBITS) return 0;\n        else return x << y;\n    }\n};\n\n/*\n** check whether cached closure in prototype 'p' may be reused, that is,\n** whether there is a cached closure with the same upvalues needed by\n** new closure to be created.\n*/\nconst getcached = function(p, encup, stack, base) {\n    let c = p.cache;\n    if (c !== null) {  /* is there a cached closure? */\n        let uv = p.upvalues;\n        let nup = uv.length;\n        for (let i = 0; i < nup; i++) {  /* check whether it has right upvalues */\n            let v = uv[i].instack ? stack[base + uv[i].idx] : encup[uv[i].idx];\n            if (c.upvals[i] !== v)\n                return null;  /* wrong upvalue; cannot reuse closure */\n        }\n    }\n    return c;  /* return cached closure (or NULL if no cached closure) */\n};\n\n/*\n** create a new Lua closure, push it in the stack, and initialize\n** its upvalues.\n*/\nconst pushclosure = function(L, p, encup, base, ra) {\n    let nup = p.upvalues.length;\n    let uv = p.upvalues;\n    let ncl = new lobject.LClosure(L, nup);\n    ncl.p = p;\n    L.stack[ra].setclLvalue(ncl);\n    for (let i = 0; i < nup; i++) {\n        if (uv[i].instack)\n            ncl.upvals[i] = lfunc.luaF_findupval(L, base + uv[i].idx);\n        else\n            ncl.upvals[i] = encup[uv[i].idx];\n    }\n    p.cache = ncl;  /* save it on cache for reuse */\n};\n\nconst cvt2str = function(o) {\n    return o.ttisnumber();\n};\n\nconst cvt2num = function(o) {\n    return o.ttisstring();\n};\n\nconst tostring = function(L, i) {\n    let o = L.stack[i];\n\n    if (o.ttisstring()) return true;\n\n    if (cvt2str(o)) {\n        lobject.luaO_tostring(L, o);\n        return true;\n    }\n\n    return false;\n};\n\nconst isemptystr = function(o) {\n    return o.ttisstring() && o.vslen() === 0;\n};\n\n/* copy strings in stack from top - n up to top - 1 to buffer */\nconst copy2buff = function(L, top, n, buff) {\n    let tl = 0;  /* size already copied */\n    do {\n        let tv = L.stack[top-n];\n        let l = tv.vslen();  /* length of string being copied */\n        let s = tv.svalue();\n        buff.set(s, tl);\n        tl += l;\n    } while (--n > 0);\n};\n\n/*\n** Main operation for concatenation: concat 'total' values in the stack,\n** from 'L->top - total' up to 'L->top - 1'.\n*/\nconst luaV_concat = function(L, total) {\n    lua_assert(total >= 2);\n    do {\n        let top = L.top;\n        let n = 2; /* number of elements handled in this pass (at least 2) */\n\n        if (!(L.stack[top-2].ttisstring() || cvt2str(L.stack[top-2])) || !tostring(L, top - 1)) {\n            ltm.luaT_trybinTM(L, L.stack[top-2], L.stack[top-1], L.stack[top-2], ltm.TMS.TM_CONCAT);\n        } else if (isemptystr(L.stack[top-1])) {\n            tostring(L, top - 2);\n        } else if (isemptystr(L.stack[top-2])) {\n            lobject.setobjs2s(L, top - 2, top - 1);\n        } else {\n            /* at least two non-empty string values; get as many as possible */\n            let tl = L.stack[top-1].vslen();\n            /* collect total length and number of strings */\n            for (n = 1; n < total && tostring(L, top - n - 1); n++) {\n                let l = L.stack[top - n - 1].vslen();\n                tl += l;\n            }\n            let buff = new Uint8Array(tl);\n            copy2buff(L, top, n, buff);\n            let ts = luaS_bless(L, buff);\n            lobject.setsvalue2s(L, top - n, ts);\n        }\n        total -= n - 1; /* got 'n' strings to create 1 new */\n        /* popped 'n' strings and pushed one */\n        for (; L.top > top-(n-1);)\n            delete L.stack[--L.top];\n    } while (total > 1); /* repeat until only 1 result left */\n};\n\nconst MAXTAGLOOP = 2000;\n\nconst luaV_gettable = function(L, t, key, ra) {\n    for (let loop = 0; loop < MAXTAGLOOP; loop++) {\n        let tm;\n\n        if (!t.ttistable()) {\n            tm = ltm.luaT_gettmbyobj(L, t, ltm.TMS.TM_INDEX);\n            if (tm.ttisnil())\n                ldebug.luaG_typeerror(L, t, to_luastring('index', true)); /* no metamethod */\n            /* else will try the metamethod */\n        } else {\n            let slot = ltable.luaH_get(L, t.value, key);\n            if (!slot.ttisnil()) {\n                lobject.setobj2s(L, ra, slot);\n                return;\n            } else { /* 't' is a table */\n                tm = ltm.fasttm(L, t.value.metatable, ltm.TMS.TM_INDEX);  /* table's metamethod */\n                if (tm === null) { /* no metamethod? */\n                    L.stack[ra].setnilvalue(); /* result is nil */\n                    return;\n                }\n            }\n            /* else will try the metamethod */\n        }\n        if (tm.ttisfunction()) { /* is metamethod a function? */\n            ltm.luaT_callTM(L, tm, t, key, L.stack[ra], 1); /* call it */\n            return;\n        }\n        t = tm;  /* else try to access 'tm[key]' */\n    }\n\n    ldebug.luaG_runerror(L, to_luastring(\"'__index' chain too long; possible loop\", true));\n};\n\nconst settable = function(L, t, key, val) {\n    for (let loop = 0; loop < MAXTAGLOOP; loop++) {\n        let tm;\n        if (t.ttistable()) {\n            let h = t.value; /* save 't' table */\n            let slot = ltable.luaH_get(L, h, key);\n            if (!slot.ttisnil() || (tm = ltm.fasttm(L, h.metatable, ltm.TMS.TM_NEWINDEX)) === null) {\n                ltable.luaH_setfrom(L, h, key, val);\n                ltable.invalidateTMcache(h);\n                return;\n            }\n            /* else will try the metamethod */\n        } else { /* not a table; check metamethod */\n            if ((tm = ltm.luaT_gettmbyobj(L, t, ltm.TMS.TM_NEWINDEX)).ttisnil())\n                ldebug.luaG_typeerror(L, t, to_luastring('index', true));\n        }\n        /* try the metamethod */\n        if (tm.ttisfunction()) {\n            ltm.luaT_callTM(L, tm, t, key, val, 0);\n            return;\n        }\n        t = tm;  /* else repeat assignment over 'tm' */\n    }\n\n    ldebug.luaG_runerror(L, to_luastring(\"'__newindex' chain too long; possible loop\", true));\n};\n\n\nmodule.exports.cvt2str          = cvt2str;\nmodule.exports.cvt2num          = cvt2num;\nmodule.exports.luaV_gettable    = luaV_gettable;\nmodule.exports.luaV_concat      = luaV_concat;\nmodule.exports.luaV_div         = luaV_div;\nmodule.exports.luaV_equalobj    = luaV_equalobj;\nmodule.exports.luaV_execute     = luaV_execute;\nmodule.exports.luaV_finishOp    = luaV_finishOp;\nmodule.exports.luaV_imul        = luaV_imul;\nmodule.exports.luaV_lessequal   = luaV_lessequal;\nmodule.exports.luaV_lessthan    = luaV_lessthan;\nmodule.exports.luaV_mod         = luaV_mod;\nmodule.exports.luaV_objlen      = luaV_objlen;\nmodule.exports.luaV_rawequalobj = luaV_rawequalobj;\nmodule.exports.luaV_shiftl      = luaV_shiftl;\nmodule.exports.luaV_tointeger   = luaV_tointeger;\nmodule.exports.settable         = settable;\nmodule.exports.tointeger        = tointeger;\nmodule.exports.tonumber         = tonumber;\n", ";\n\nconst {\n    constant_types: {\n        LUA_TTABLE,\n        LUA_TUSERDATA\n    },\n    to_luastring\n} = require('./defs.js');\nconst { lua_assert } = require('./llimits.js');\nconst lobject = require('./lobject.js');\nconst ldo     = require('./ldo.js');\nconst lstate  = require('./lstate.js');\nconst {\n    luaS_bless,\n    luaS_new\n} = require('./lstring.js');\nconst ltable  = require('./ltable.js');\nconst ldebug  = require('./ldebug.js');\nconst lvm     = require('./lvm.js');\n\nconst luaT_typenames_ = [\n    \"no value\",\n    \"nil\",\n    \"boolean\",\n    \"userdata\",\n    \"number\",\n    \"string\",\n    \"table\",\n    \"function\",\n    \"userdata\",\n    \"thread\",\n    \"proto\" /* this last case is used for tests only */\n].map(e => to_luastring(e));\n\nconst ttypename = function(t) {\n    return luaT_typenames_[t + 1];\n};\n\n\n/*\n* WARNING: if you change the order of this enumeration,\n* grep \"ORDER TM\" and \"ORDER OP\"\n*/\nconst TMS = {\n    TM_INDEX:    0,\n    TM_NEWINDEX: 1,\n    TM_GC:       2,\n    TM_MODE:     3,\n    TM_LEN:      4,\n    TM_EQ:       5,  /* last tag method with fast access */\n    TM_ADD:      6,\n    TM_SUB:      7,\n    TM_MUL:      8,\n    TM_MOD:      9,\n    TM_POW:     10,\n    TM_DIV:     11,\n    TM_IDIV:    12,\n    TM_BAND:    13 ,\n    TM_BOR:     14,\n    TM_BXOR:    15,\n    TM_SHL:     16,\n    TM_SHR:     17,\n    TM_UNM:     18,\n    TM_BNOT:    19,\n    TM_LT:      20,\n    TM_LE:      21,\n    TM_CONCAT:  22,\n    TM_CALL:    23,\n    TM_N:       24  /* number of elements in the enum */\n};\n\nconst luaT_init = function(L) {\n    L.l_G.tmname[TMS.TM_INDEX]    = new luaS_new(L, to_luastring(\"__index\", true));\n    L.l_G.tmname[TMS.TM_NEWINDEX] = new luaS_new(L, to_luastring(\"__newindex\", true));\n    L.l_G.tmname[TMS.TM_GC]       = new luaS_new(L, to_luastring(\"__gc\", true));\n    L.l_G.tmname[TMS.TM_MODE]     = new luaS_new(L, to_luastring(\"__mode\", true));\n    L.l_G.tmname[TMS.TM_LEN]      = new luaS_new(L, to_luastring(\"__len\", true));\n    L.l_G.tmname[TMS.TM_EQ]       = new luaS_new(L, to_luastring(\"__eq\", true));\n    L.l_G.tmname[TMS.TM_ADD]      = new luaS_new(L, to_luastring(\"__add\", true));\n    L.l_G.tmname[TMS.TM_SUB]      = new luaS_new(L, to_luastring(\"__sub\", true));\n    L.l_G.tmname[TMS.TM_MUL]      = new luaS_new(L, to_luastring(\"__mul\", true));\n    L.l_G.tmname[TMS.TM_MOD]      = new luaS_new(L, to_luastring(\"__mod\", true));\n    L.l_G.tmname[TMS.TM_POW]      = new luaS_new(L, to_luastring(\"__pow\", true));\n    L.l_G.tmname[TMS.TM_DIV]      = new luaS_new(L, to_luastring(\"__div\", true));\n    L.l_G.tmname[TMS.TM_IDIV]     = new luaS_new(L, to_luastring(\"__idiv\", true));\n    L.l_G.tmname[TMS.TM_BAND]     = new luaS_new(L, to_luastring(\"__band\", true));\n    L.l_G.tmname[TMS.TM_BOR]      = new luaS_new(L, to_luastring(\"__bor\", true));\n    L.l_G.tmname[TMS.TM_BXOR]     = new luaS_new(L, to_luastring(\"__bxor\", true));\n    L.l_G.tmname[TMS.TM_SHL]      = new luaS_new(L, to_luastring(\"__shl\", true));\n    L.l_G.tmname[TMS.TM_SHR]      = new luaS_new(L, to_luastring(\"__shr\", true));\n    L.l_G.tmname[TMS.TM_UNM]      = new luaS_new(L, to_luastring(\"__unm\", true));\n    L.l_G.tmname[TMS.TM_BNOT]     = new luaS_new(L, to_luastring(\"__bnot\", true));\n    L.l_G.tmname[TMS.TM_LT]       = new luaS_new(L, to_luastring(\"__lt\", true));\n    L.l_G.tmname[TMS.TM_LE]       = new luaS_new(L, to_luastring(\"__le\", true));\n    L.l_G.tmname[TMS.TM_CONCAT]   = new luaS_new(L, to_luastring(\"__concat\", true));\n    L.l_G.tmname[TMS.TM_CALL]     = new luaS_new(L, to_luastring(\"__call\", true));\n};\n\n/*\n** Return the name of the type of an object. For tables and userdata\n** with metatable, use their '__name' metafield, if present.\n*/\nconst __name = to_luastring('__name', true);\nconst luaT_objtypename = function(L, o) {\n    let mt;\n    if ((o.ttistable() && (mt = o.value.metatable) !== null) ||\n        (o.ttisfulluserdata() && (mt = o.value.metatable) !== null)) {\n        let name = ltable.luaH_getstr(mt, luaS_bless(L, __name));\n        if (name.ttisstring())\n            return name.svalue();\n    }\n    return ttypename(o.ttnov());\n};\n\nconst luaT_callTM = function(L, f, p1, p2, p3, hasres) {\n    let func = L.top;\n\n    lobject.pushobj2s(L, f); /* push function (assume EXTRA_STACK) */\n    lobject.pushobj2s(L, p1); /* 1st argument */\n    lobject.pushobj2s(L, p2); /* 2nd argument */\n\n    if (!hasres)  /* no result? 'p3' is third argument */\n        lobject.pushobj2s(L, p3); /* 3rd argument */\n\n    if (L.ci.callstatus & lstate.CIST_LUA)\n        ldo.luaD_call(L, func, hasres);\n    else\n        ldo.luaD_callnoyield(L, func, hasres);\n\n    if (hasres) {  /* if has result, move it to its place */\n        let tv = L.stack[L.top-1];\n        delete L.stack[--L.top];\n        p3.setfrom(tv);\n    }\n};\n\nconst luaT_callbinTM = function(L, p1, p2, res, event) {\n    let tm = luaT_gettmbyobj(L, p1, event);\n    if (tm.ttisnil())\n        tm = luaT_gettmbyobj(L, p2, event);\n    if (tm.ttisnil()) return false;\n    luaT_callTM(L, tm, p1, p2, res, 1);\n    return true;\n};\n\nconst luaT_trybinTM = function(L, p1, p2, res, event) {\n    if (!luaT_callbinTM(L, p1, p2, res, event)) {\n        switch (event) {\n            case TMS.TM_CONCAT:\n                return ldebug.luaG_concaterror(L, p1, p2);\n            case TMS.TM_BAND: case TMS.TM_BOR: case TMS.TM_BXOR:\n            case TMS.TM_SHL: case TMS.TM_SHR: case TMS.TM_BNOT: {\n                let n1 = lvm.tonumber(p1);\n                let n2 = lvm.tonumber(p2);\n                if (n1 !== false && n2 !== false)\n                    return ldebug.luaG_tointerror(L, p1, p2);\n                else\n                    return ldebug.luaG_opinterror(L, p1, p2, to_luastring(\"perform bitwise operation on\", true));\n            }\n            default:\n                return ldebug.luaG_opinterror(L, p1, p2, to_luastring(\"perform arithmetic on\", true));\n        }\n    }\n};\n\nconst luaT_callorderTM = function(L, p1, p2, event) {\n    let res = new lobject.TValue();\n    if (!luaT_callbinTM(L, p1, p2, res, event))\n        return null;\n    else\n        return !res.l_isfalse();\n};\n\nconst fasttm = function(l, et, e) {\n    return et === null ? null :\n        (et.flags & (1 << e)) ? null : luaT_gettm(et, e, l.l_G.tmname[e]);\n};\n\nconst luaT_gettm = function(events, event, ename) {\n    const tm = ltable.luaH_getstr(events, ename);\n    lua_assert(event <= TMS.TM_EQ);\n    if (tm.ttisnil()) {  /* no tag method? */\n        events.flags |= 1<<event;  /* cache this fact */\n        return null;\n    }\n    else return tm;\n};\n\nconst luaT_gettmbyobj = function(L, o, event) {\n    let mt;\n    switch(o.ttnov()) {\n        case LUA_TTABLE:\n        case LUA_TUSERDATA:\n            mt = o.value.metatable;\n            break;\n        default:\n            mt = L.l_G.mt[o.ttnov()];\n    }\n\n    return mt ? ltable.luaH_getstr(mt, L.l_G.tmname[event]) : lobject.luaO_nilobject;\n};\n\nmodule.exports.fasttm           = fasttm;\nmodule.exports.TMS              = TMS;\nmodule.exports.luaT_callTM      = luaT_callTM;\nmodule.exports.luaT_callbinTM   = luaT_callbinTM;\nmodule.exports.luaT_trybinTM    = luaT_trybinTM;\nmodule.exports.luaT_callorderTM = luaT_callorderTM;\nmodule.exports.luaT_gettm       = luaT_gettm;\nmodule.exports.luaT_gettmbyobj  = luaT_gettmbyobj;\nmodule.exports.luaT_init        = luaT_init;\nmodule.exports.luaT_objtypename = luaT_objtypename;\nmodule.exports.ttypename        = ttypename;\n", ";\n\nconst {\n    LUA_MINSTACK,\n    LUA_RIDX_GLOBALS,\n    LUA_RIDX_MAINTHREAD,\n    constant_types: {\n        LUA_NUMTAGS,\n        LUA_TNIL,\n        LUA_TTABLE,\n        LUA_TTHREAD\n    },\n    thread_status: {\n        LUA_OK\n    }\n} = require('./defs.js');\nconst lobject              = require('./lobject.js');\nconst ldo                  = require('./ldo.js');\nconst lapi                 = require('./lapi.js');\nconst ltable               = require('./ltable.js');\nconst ltm                  = require('./ltm.js');\n\nconst EXTRA_STACK = 5;\n\nconst BASIC_STACK_SIZE = 2 * LUA_MINSTACK;\n\nclass CallInfo {\n\n    constructor() {\n        this.func = null;\n        this.funcOff = NaN;\n        this.top = NaN;\n        this.previous = null;\n        this.next = null;\n\n        /* only for Lua functions */\n        this.l_base = NaN; /* base for this function */\n        this.l_code = null; /* reference to this.func.p.code */\n        this.l_savedpc = NaN; /* offset into l_code */\n        /* only for JS functions */\n        this.c_k = null;  /* continuation in case of yields */\n        this.c_old_errfunc = null;\n        this.c_ctx = null;  /* context info. in case of yields */\n\n        this.nresults = NaN;\n        this.callstatus = NaN;\n    }\n\n}\n\nclass lua_State {\n\n    constructor(g) {\n        this.id = g.id_counter++;\n\n        this.base_ci = new CallInfo(); /* CallInfo for first level (C calling Lua) */\n        this.top = NaN; /* first free slot in the stack */\n        this.stack_last = NaN; /* last free slot in the stack */\n        this.oldpc = NaN; /* last pc traced */\n\n        /* preinit_thread */\n        this.l_G = g;\n        this.stack = null;\n        this.ci = null;\n        this.errorJmp = null;\n        this.nCcalls = 0;\n        this.hook = null;\n        this.hookmask = 0;\n        this.basehookcount = 0;\n        this.allowhook = 1;\n        this.hookcount = this.basehookcount;\n        this.nny = 1;\n        this.status = LUA_OK;\n        this.errfunc = 0;\n    }\n\n}\n\nclass global_State {\n\n    constructor() {\n        this.id_counter = 1; /* used to give objects unique ids */\n        this.ids = new WeakMap();\n\n        this.mainthread = null;\n        this.l_registry = new lobject.TValue(LUA_TNIL, null);\n        this.panic = null;\n        this.atnativeerror = null;\n        this.version = null;\n        this.tmname = new Array(ltm.TMS.TM_N);\n        this.mt = new Array(LUA_NUMTAGS);\n    }\n\n}\n\nconst luaE_extendCI = function(L) {\n    let ci = new CallInfo();\n    L.ci.next = ci;\n    ci.previous = L.ci;\n    ci.next = null;\n    L.ci = ci;\n    return ci;\n};\n\nconst luaE_freeCI = function(L) {\n    let ci = L.ci;\n    ci.next = null;\n};\n\nconst stack_init = function(L1, L) {\n    L1.stack = new Array(BASIC_STACK_SIZE);\n    L1.top = 0;\n    L1.stack_last = BASIC_STACK_SIZE - EXTRA_STACK;\n    /* initialize first ci */\n    let ci = L1.base_ci;\n    ci.next = ci.previous = null;\n    ci.callstatus = 0;\n    ci.funcOff = L1.top;\n    ci.func = L1.stack[L1.top];\n    L1.stack[L1.top++] = new lobject.TValue(LUA_TNIL, null);\n    ci.top = L1.top + LUA_MINSTACK;\n    L1.ci = ci;\n};\n\nconst freestack = function(L) {\n    L.ci = L.base_ci;\n    luaE_freeCI(L);\n    L.stack = null;\n};\n\n/*\n** Create registry table and its predefined values\n*/\nconst init_registry = function(L, g) {\n    let registry = ltable.luaH_new(L);\n    g.l_registry.sethvalue(registry);\n    ltable.luaH_setint(registry, LUA_RIDX_MAINTHREAD, new lobject.TValue(LUA_TTHREAD, L));\n    ltable.luaH_setint(registry, LUA_RIDX_GLOBALS, new lobject.TValue(LUA_TTABLE, ltable.luaH_new(L)));\n};\n\n/*\n** open parts of the state that may cause memory-allocation errors.\n** ('g->version' !== NULL flags that the state was completely build)\n*/\nconst f_luaopen = function(L) {\n    let g = L.l_G;\n    stack_init(L, L);\n    init_registry(L, g);\n    ltm.luaT_init(L);\n    g.version = lapi.lua_version(null);\n};\n\nconst lua_newthread = function(L) {\n    let g = L.l_G;\n    let L1 = new lua_State(g);\n    L.stack[L.top] = new lobject.TValue(LUA_TTHREAD, L1);\n    lapi.api_incr_top(L);\n    L1.hookmask = L.hookmask;\n    L1.basehookcount = L.basehookcount;\n    L1.hook = L.hook;\n    L1.hookcount = L1.basehookcount;\n    stack_init(L1, L);\n    return L1;\n};\n\nconst luaE_freethread = function(L, L1) {\n    freestack(L1);\n};\n\nconst lua_newstate = function() {\n    let g = new global_State();\n    let L = new lua_State(g);\n    g.mainthread = L;\n\n    if (ldo.luaD_rawrunprotected(L, f_luaopen, null) !== LUA_OK) {\n        L = null;\n    }\n\n    return L;\n};\n\nconst close_state = function(L) {\n    freestack(L);\n};\n\nconst lua_close = function(L) {\n    L = L.l_G.mainthread;  /* only the main thread can be closed */\n    close_state(L);\n};\n\nmodule.exports.lua_State       = lua_State;\nmodule.exports.CallInfo        = CallInfo;\nmodule.exports.CIST_OAH        = (1<<0);  /* original value of 'allowhook' */\nmodule.exports.CIST_LUA        = (1<<1);  /* call is running a Lua function */\nmodule.exports.CIST_HOOKED     = (1<<2);  /* call is running a debug hook */\nmodule.exports.CIST_FRESH      = (1<<3);  /* call is running on a fresh invocation of luaV_execute */\nmodule.exports.CIST_YPCALL     = (1<<4);  /* call is a yieldable protected call */\nmodule.exports.CIST_TAIL       = (1<<5);  /* call was tail called */\nmodule.exports.CIST_HOOKYIELD  = (1<<6);  /* last hook called yielded */\nmodule.exports.CIST_LEQ        = (1<<7);  /* using __lt for __le */\nmodule.exports.CIST_FIN        = (1<<8);   /* call is running a finalizer */\nmodule.exports.EXTRA_STACK     = EXTRA_STACK;\nmodule.exports.lua_close       = lua_close;\nmodule.exports.lua_newstate    = lua_newstate;\nmodule.exports.lua_newthread   = lua_newthread;\nmodule.exports.luaE_extendCI   = luaE_extendCI;\nmodule.exports.luaE_freeCI     = luaE_freeCI;\nmodule.exports.luaE_freethread = luaE_freethread;\n", ";\n\nconst {\n    LUA_OPADD,\n    LUA_OPBAND,\n    LUA_OPBNOT,\n    LUA_OPBOR,\n    LUA_OPBXOR,\n    LUA_OPDIV,\n    LUA_OPIDIV,\n    LUA_OPMOD,\n    LUA_OPMUL,\n    LUA_OPPOW,\n    LUA_OPSHL,\n    LUA_OPSHR,\n    LUA_OPSUB,\n    LUA_OPUNM,\n    constant_types: {\n        LUA_NUMTAGS,\n        LUA_TBOOLEAN,\n        LUA_TCCL,\n        LUA_TFUNCTION,\n        LUA_TLCF,\n        LUA_TLCL,\n        LUA_TLIGHTUSERDATA,\n        LUA_TLNGSTR,\n        LUA_TNIL,\n        LUA_TNUMBER,\n        LUA_TNUMFLT,\n        LUA_TNUMINT,\n        LUA_TSHRSTR,\n        LUA_TSTRING,\n        LUA_TTABLE,\n        LUA_TTHREAD,\n        LUA_TUSERDATA\n    },\n    from_userstring,\n    luastring_indexOf,\n    luastring_of,\n    to_jsstring,\n    to_luastring\n} = require('./defs.js');\nconst {\n    lisdigit,\n    lisprint,\n    lisspace,\n    lisxdigit\n} = require('./ljstype.js');\nconst ldebug  = require('./ldebug.js');\nconst ldo     = require('./ldo.js');\nconst lstate  = require('./lstate.js');\nconst {\n    luaS_bless,\n    luaS_new\n} = require('./lstring.js');\nconst ltable  = require('./ltable.js');\nconst {\n    LUA_COMPAT_FLOATSTRING,\n    ldexp,\n    lua_integer2str,\n    lua_number2str\n} = require('./luaconf.js');\nconst lvm     = require('./lvm.js');\nconst {\n    MAX_INT,\n    luai_nummod,\n    lua_assert\n} = require(\"./llimits.js\");\nconst ltm     = require('./ltm.js');\n\nconst LUA_TPROTO = LUA_NUMTAGS;\nconst LUA_TDEADKEY = LUA_NUMTAGS+1;\n\nclass TValue {\n\n    constructor(type, value) {\n        this.type = type;\n        this.value = value;\n    }\n\n    /* type tag of a TValue (bits 0-3 for tags + variant bits 4-5) */\n    ttype() {\n        return this.type & 0x3F;\n    }\n\n    /* type tag of a TValue with no variants (bits 0-3) */\n    ttnov() {\n        return this.type & 0x0F;\n    }\n\n    checktag(t) {\n        return this.type === t;\n    }\n\n    checktype(t) {\n        return this.ttnov() === t;\n    }\n\n    ttisnumber() {\n        return this.checktype(LUA_TNUMBER);\n    }\n\n    ttisfloat() {\n        return this.checktag(LUA_TNUMFLT);\n    }\n\n    ttisinteger() {\n        return this.checktag(LUA_TNUMINT);\n    }\n\n    ttisnil() {\n        return this.checktag(LUA_TNIL);\n    }\n\n    ttisboolean() {\n        return this.checktag(LUA_TBOOLEAN);\n    }\n\n    ttislightuserdata() {\n        return this.checktag(LUA_TLIGHTUSERDATA);\n    }\n\n    ttisstring() {\n        return this.checktype(LUA_TSTRING);\n    }\n\n    ttisshrstring() {\n        return this.checktag(LUA_TSHRSTR);\n    }\n\n    ttislngstring() {\n        return this.checktag(LUA_TLNGSTR);\n    }\n\n    ttistable() {\n        return this.checktag(LUA_TTABLE);\n    }\n\n    ttisfunction() {\n        return this.checktype(LUA_TFUNCTION);\n    }\n\n    ttisclosure() {\n        return (this.type & 0x1F) === LUA_TFUNCTION;\n    }\n\n    ttisCclosure() {\n        return this.checktag(LUA_TCCL);\n    }\n\n    ttisLclosure() {\n        return this.checktag(LUA_TLCL);\n    }\n\n    ttislcf() {\n        return this.checktag(LUA_TLCF);\n    }\n\n    ttisfulluserdata() {\n        return this.checktag(LUA_TUSERDATA);\n    }\n\n    ttisthread() {\n        return this.checktag(LUA_TTHREAD);\n    }\n\n    ttisdeadkey() {\n        return this.checktag(LUA_TDEADKEY);\n    }\n\n    l_isfalse() {\n        return this.ttisnil() || (this.ttisboolean() && this.value === false);\n    }\n\n    setfltvalue(x) {\n        this.type = LUA_TNUMFLT;\n        this.value = x;\n    }\n\n    chgfltvalue(x) {\n        lua_assert(this.type == LUA_TNUMFLT);\n        this.value = x;\n    }\n\n    setivalue(x) {\n        this.type = LUA_TNUMINT;\n        this.value = x;\n    }\n\n    chgivalue(x) {\n        lua_assert(this.type == LUA_TNUMINT);\n        this.value = x;\n    }\n\n    setnilvalue() {\n        this.type = LUA_TNIL;\n        this.value = null;\n    }\n\n    setfvalue(x) {\n        this.type = LUA_TLCF;\n        this.value = x;\n    }\n\n    setpvalue(x) {\n        this.type = LUA_TLIGHTUSERDATA;\n        this.value = x;\n    }\n\n    setbvalue(x) {\n        this.type = LUA_TBOOLEAN;\n        this.value = x;\n    }\n\n    setsvalue(x) {\n        this.type = LUA_TLNGSTR; /* LUA_TSHRSTR? */\n        this.value = x;\n    }\n\n    setuvalue(x) {\n        this.type = LUA_TUSERDATA;\n        this.value = x;\n    }\n\n    setthvalue(x) {\n        this.type = LUA_TTHREAD;\n        this.value = x;\n    }\n\n    setclLvalue(x) {\n        this.type = LUA_TLCL;\n        this.value = x;\n    }\n\n    setclCvalue(x) {\n        this.type = LUA_TCCL;\n        this.value = x;\n    }\n\n    sethvalue(x) {\n        this.type = LUA_TTABLE;\n        this.value = x;\n    }\n\n    setdeadvalue() {\n        this.type = LUA_TDEADKEY;\n        this.value = null;\n    }\n\n    setfrom(tv) { /* in lua C source setobj2t is often used for this */\n        this.type = tv.type;\n        this.value = tv.value;\n    }\n\n    tsvalue() {\n        lua_assert(this.ttisstring());\n        return this.value;\n    }\n\n    svalue() {\n        return this.tsvalue().getstr();\n    }\n\n    vslen() {\n        return this.tsvalue().tsslen();\n    }\n\n    jsstring(from, to) {\n        return to_jsstring(this.svalue(), from, to, true);\n    }\n}\n\nconst pushobj2s = function(L, tv) {\n    L.stack[L.top++] = new TValue(tv.type, tv.value);\n};\nconst pushsvalue2s = function(L, ts) {\n    L.stack[L.top++] = new TValue(LUA_TLNGSTR, ts);\n};\n/* from stack to (same) stack */\nconst setobjs2s = function(L, newidx, oldidx) {\n    L.stack[newidx].setfrom(L.stack[oldidx]);\n};\n/* to stack (not from same stack) */\nconst setobj2s = function(L, newidx, oldtv) {\n    L.stack[newidx].setfrom(oldtv);\n};\nconst setsvalue2s = function(L, newidx, ts) {\n    L.stack[newidx].setsvalue(ts);\n};\n\nconst luaO_nilobject = new TValue(LUA_TNIL, null);\nObject.freeze(luaO_nilobject);\nmodule.exports.luaO_nilobject = luaO_nilobject;\n\nclass LClosure {\n\n    constructor(L, n) {\n        this.id = L.l_G.id_counter++;\n\n        this.p = null;\n        this.nupvalues = n;\n        this.upvals = new Array(n); /* list of upvalues. initialised in luaF_initupvals */\n    }\n\n}\n\nclass CClosure {\n\n    constructor(L, f, n) {\n        this.id = L.l_G.id_counter++;\n\n        this.f = f;\n        this.nupvalues = n;\n        this.upvalue = new Array(n); /* list of upvalues as TValues */\n        while (n--) {\n            this.upvalue[n] = new TValue(LUA_TNIL, null);\n        }\n    }\n\n}\n\nclass Udata {\n\n    constructor(L, size) {\n        this.id = L.l_G.id_counter++;\n\n        this.metatable = null;\n        this.uservalue = new TValue(LUA_TNIL, null);\n        this.len = size;\n        this.data = Object.create(null); // ignores size argument\n    }\n\n}\n\n/*\n** Description of a local variable for function prototypes\n** (used for debug information)\n*/\nclass LocVar {\n    constructor() {\n        this.varname = null;\n        this.startpc = NaN;  /* first point where variable is active */\n        this.endpc = NaN;    /* first point where variable is dead */\n    }\n}\n\nconst RETS = to_luastring(\"...\");\nconst PRE  = to_luastring(\"[string \\\"\");\nconst POS  = to_luastring(\"\\\"]\");\n\nconst luaO_chunkid = function(source, bufflen) {\n    let l = source.length;\n    let out;\n    if (source[0] === 61 /* ('=').charCodeAt(0) */) {  /* 'literal' source */\n        if (l < bufflen) {  /* small enough? */\n            out = new Uint8Array(l-1);\n            out.set(source.subarray(1));\n        } else {  /* truncate it */\n            out = new Uint8Array(bufflen);\n            out.set(source.subarray(1, bufflen+1));\n        }\n    } else if (source[0] === 64 /* ('@').charCodeAt(0) */) {  /* file name */\n        if (l <= bufflen) {  /* small enough? */\n            out = new Uint8Array(l-1);\n            out.set(source.subarray(1));\n        } else {  /* add '...' before rest of name */\n            out = new Uint8Array(bufflen);\n            out.set(RETS);\n            bufflen -= RETS.length;\n            out.set(source.subarray(l - bufflen), RETS.length);\n        }\n    } else {  /* string; format as [string \"source\"] */\n        out = new Uint8Array(bufflen);\n        let nli = luastring_indexOf(source, 10 /* ('\\n').charCodeAt(0) */);  /* find first new line (if any) */\n        out.set(PRE);  /* add prefix */\n        let out_i = PRE.length;\n        bufflen -= PRE.length + RETS.length + POS.length;  /* save space for prefix+suffix */\n        if (l < bufflen && nli === -1) {  /* small one-line source? */\n            out.set(source, out_i);  /* keep it */\n            out_i += source.length;\n        } else {\n            if (nli !== -1) l = nli;  /* stop at first newline */\n            if (l > bufflen) l = bufflen;\n            out.set(source.subarray(0, l), out_i);\n            out_i += l;\n            out.set(RETS, out_i);\n            out_i += RETS.length;\n        }\n        out.set(POS, out_i);\n        out_i += POS.length;\n        out = out.subarray(0, out_i);\n    }\n    return out;\n};\n\nconst luaO_hexavalue = function(c) {\n    if (lisdigit(c)) return c - 48;\n    else return (c & 0xdf) - 55;\n};\n\nconst UTF8BUFFSZ = 8;\n\nconst luaO_utf8esc = function(buff, x) {\n    let n = 1;  /* number of bytes put in buffer (backwards) */\n    lua_assert(x <= 0x10FFFF);\n    if (x < 0x80)  /* ascii? */\n        buff[UTF8BUFFSZ - 1] = x;\n    else {  /* need continuation bytes */\n        let mfb = 0x3f;  /* maximum that fits in first byte */\n        do {\n            buff[UTF8BUFFSZ - (n++)] = 0x80 | (x & 0x3f);\n            x >>= 6;  /* remove added bits */\n            mfb >>= 1;  /* now there is one less bit available in first byte */\n        } while (x > mfb);  /* still needs continuation byte? */\n        buff[UTF8BUFFSZ - n] = (~mfb << 1) | x;  /* add first byte */\n    }\n    return n;\n};\n\n/* maximum number of significant digits to read (to avoid overflows\n   even with single floats) */\nconst MAXSIGDIG = 30;\n\n/*\n** convert an hexadecimal numeric string to a number, following\n** C99 specification for 'strtod'\n*/\nconst lua_strx2number = function(s) {\n    let i = 0;\n    let r = 0.0;  /* result (accumulator) */\n    let sigdig = 0;  /* number of significant digits */\n    let nosigdig = 0;  /* number of non-significant digits */\n    let e = 0;  /* exponent correction */\n    let neg;  /* 1 if number is negative */\n    let hasdot = false;  /* true after seen a dot */\n    while (lisspace(s[i])) i++;  /* skip initial spaces */\n    if ((neg = (s[i] === 45 /* ('-').charCodeAt(0) */))) i++;  /* check signal */\n    else if (s[i] === 43 /* ('+').charCodeAt(0) */) i++;\n    if (!(s[i] === 48 /* ('0').charCodeAt(0) */ && (s[i+1] === 120 /* ('x').charCodeAt(0) */ || s[i+1] === 88 /* ('X').charCodeAt(0) */)))  /* check '0x' */\n        return null;  /* invalid format (no '0x') */\n    for (i += 2; ; i++) {  /* skip '0x' and read numeral */\n        if (s[i] === 46 /* ('.').charCodeAt(0) i.e. dot/lua_getlocaledecpoint(); */) {\n            if (hasdot) break;  /* second dot? stop loop */\n            else hasdot = true;\n        } else if (lisxdigit(s[i])) {\n            if (sigdig === 0 && s[i] === 48 /* ('0').charCodeAt(0) */)  /* non-significant digit (zero)? */\n                nosigdig++;\n            else if (++sigdig <= MAXSIGDIG)  /* can read it without overflow? */\n                r = (r * 16) + luaO_hexavalue(s[i]);\n            else e++; /* too many digits; ignore, but still count for exponent */\n            if (hasdot) e--;  /* decimal digit? correct exponent */\n        } else break;  /* neither a dot nor a digit */\n    }\n\n    if (nosigdig + sigdig === 0)  /* no digits? */\n        return null;  /* invalid format */\n    e *= 4;  /* each digit multiplies/divides value by 2^4 */\n    if (s[i] === 112 /* ('p').charCodeAt(0) */ || s[i] === 80 /* ('P').charCodeAt(0) */) {  /* exponent part? */\n        let exp1 = 0;  /* exponent value */\n        let neg1;  /* exponent signal */\n        i++;  /* skip 'p' */\n        if ((neg1 = (s[i] === 45 /* ('-').charCodeAt(0) */))) i++;  /* signal */\n        else if (s[i] === 43 /* ('+').charCodeAt(0) */) i++;\n        if (!lisdigit(s[i]))\n            return null;  /* invalid; must have at least one digit */\n        while (lisdigit(s[i]))  /* read exponent */\n            exp1 = exp1 * 10 + s[i++] - 48 /* ('0').charCodeAt(0) */;\n        if (neg1) exp1 = -exp1;\n        e += exp1;\n    }\n    if (neg) r = -r;\n    return {\n        n: ldexp(r, e),\n        i: i\n    };\n};\n\nconst lua_str2number = function(s) {\n    try {\n        s = to_jsstring(s);\n    } catch (e) {\n        return null;\n    }\n    /* use a regex to validate number and also to get length\n       parseFloat ignores trailing junk */\n    let r = /^[\\t\\v\\f \\n\\r]*[+-]?(?:[0-9]+\\.?[0-9]*|\\.[0-9]*)(?:[eE][+-]?[0-9]+)?/.exec(s);\n    if (!r)\n        return null;\n    let flt = parseFloat(r[0]);\n    return !isNaN(flt) ? { n: flt, i: r[0].length } : null;\n};\n\nconst l_str2dloc = function(s, mode) {\n    let result = mode === 'x' ? lua_strx2number(s) : lua_str2number(s); /* try to convert */\n    if (result === null) return null;\n    while (lisspace(s[result.i])) result.i++;  /* skip trailing spaces */\n    return (result.i === s.length || s[result.i] === 0) ? result : null;  /* OK if no trailing characters */\n};\n\nconst SIGILS = [\n    46  /* (\".\").charCodeAt(0) */,\n    120 /* (\"x\").charCodeAt(0) */,\n    88  /* (\"X\").charCodeAt(0) */,\n    110 /* (\"n\").charCodeAt(0) */,\n    78  /* (\"N\").charCodeAt(0) */\n];\nconst modes = {\n    [ 46]: \".\",\n    [120]: \"x\",\n    [ 88]: \"x\",\n    [110]: \"n\",\n    [ 78]: \"n\"\n};\nconst l_str2d = function(s) {\n    let l = s.length;\n    let pmode = 0;\n    for (let i=0; i<l; i++) {\n        let v = s[i];\n        if (SIGILS.indexOf(v) !== -1) {\n            pmode = v;\n            break;\n        }\n    }\n    let mode = modes[pmode];\n    if (mode === 'n')  /* reject 'inf' and 'nan' */\n        return null;\n    let end = l_str2dloc(s, mode);  /* try to convert */\n    // if (end === null) {   /* failed? may be a different locale */\n    //     throw new Error(\"Locale not available to handle number\"); // TODO\n    // }\n    return end;\n};\n\nconst MAXBY10  = Math.floor(MAX_INT / 10);\nconst MAXLASTD = MAX_INT % 10;\n\nconst l_str2int = function(s) {\n    let i = 0;\n    let a = 0;\n    let empty = true;\n    let neg;\n\n    while (lisspace(s[i])) i++;  /* skip initial spaces */\n    if ((neg = (s[i] === 45 /* ('-').charCodeAt(0) */))) i++;\n    else if (s[i] === 43 /* ('+').charCodeAt(0) */) i++;\n    if (s[i] === 48 /* ('0').charCodeAt(0) */ && (s[i+1] === 120 /* ('x').charCodeAt(0) */ || s[i+1] === 88 /* ('X').charCodeAt(0) */)) {  /* hex? */\n        i += 2;  /* skip '0x' */\n        for (; i < s.length && lisxdigit(s[i]); i++) {\n            a = (a * 16 + luaO_hexavalue(s[i]))|0;\n            empty = false;\n        }\n    } else {  /* decimal */\n        for (; i < s.length && lisdigit(s[i]); i++) {\n            let d = s[i] - 48 /* ('0').charCodeAt(0) */;\n            if (a >= MAXBY10 && (a > MAXBY10 || d > MAXLASTD + neg))  /* overflow? */\n                return null;  /* do not accept it (as integer) */\n            a = (a * 10 + d)|0;\n            empty = false;\n        }\n    }\n    while (i < s.length && lisspace(s[i])) i++;  /* skip trailing spaces */\n    if (empty || (i !== s.length && s[i] !== 0)) return null;  /* something wrong in the numeral */\n    else {\n        return {\n            n: (neg ? -a : a)|0,\n            i: i\n        };\n    }\n};\n\nconst luaO_str2num = function(s, o) {\n    let s2i = l_str2int(s);\n    if (s2i !== null) {   /* try as an integer */\n        o.setivalue(s2i.n);\n        return s2i.i+1;\n    } else {   /* else try as a float */\n        s2i = l_str2d(s);\n        if (s2i !== null) {\n            o.setfltvalue(s2i.n);\n            return s2i.i+1;\n        } else\n            return 0;  /* conversion failed */\n    }\n};\n\nconst luaO_tostring = function(L, obj) {\n    let buff;\n    if (obj.ttisinteger())\n        buff = to_luastring(lua_integer2str(obj.value));\n    else {\n        let str = lua_number2str(obj.value);\n        if (!LUA_COMPAT_FLOATSTRING && /^[-0123456789]+$/.test(str)) {  /* looks like an int? */\n            str += '.0'; /* adds '.0' to result: lua_getlocaledecpoint removed as optimisation */\n        }\n        buff = to_luastring(str);\n    }\n    obj.setsvalue(luaS_bless(L, buff));\n};\n\nconst pushstr = function(L, str) {\n    ldo.luaD_inctop(L);\n    setsvalue2s(L, L.top-1, luaS_new(L, str));\n};\n\nconst luaO_pushvfstring = function(L, fmt, argp) {\n    let n = 0;\n    let i = 0;\n    let a = 0;\n    let e;\n    for (;;) {\n        e = luastring_indexOf(fmt, 37 /* ('%').charCodeAt(0) */, i);\n        if (e == -1) break;\n        pushstr(L, fmt.subarray(i, e));\n        switch(fmt[e+1]) {\n            case 115 /* ('s').charCodeAt(0) */: {\n                let s = argp[a++];\n                if (s === null) s = to_luastring(\"(null)\", true);\n                else {\n                    s = from_userstring(s);\n                    /* respect null terminator */\n                    let i = luastring_indexOf(s, 0);\n                    if (i !== -1)\n                        s = s.subarray(0, i);\n                }\n                pushstr(L, s);\n                break;\n            }\n            case 99 /* ('c').charCodeAt(0) */: {\n                let buff = argp[a++];\n                if (lisprint(buff))\n                    pushstr(L, luastring_of(buff));\n                else\n                    luaO_pushfstring(L, to_luastring(\"<\\\\%d>\", true), buff);\n                break;\n            }\n            case 100 /* ('d').charCodeAt(0) */:\n            case 73 /* ('I').charCodeAt(0) */:\n                ldo.luaD_inctop(L);\n                L.stack[L.top-1].setivalue(argp[a++]);\n                luaO_tostring(L, L.stack[L.top-1]);\n                break;\n            case 102 /* ('f').charCodeAt(0) */:\n                ldo.luaD_inctop(L);\n                L.stack[L.top-1].setfltvalue(argp[a++]);\n                luaO_tostring(L, L.stack[L.top-1]);\n                break;\n            case 112 /* ('p').charCodeAt(0) */: {\n                let v = argp[a++];\n                if (v instanceof lstate.lua_State ||\n                    v instanceof ltable.Table ||\n                    v instanceof Udata ||\n                    v instanceof LClosure ||\n                    v instanceof CClosure) {\n                    pushstr(L, to_luastring(\"0x\"+v.id.toString(16)));\n                } else {\n                    switch(typeof v) {\n                        case \"undefined\":\n                            pushstr(L, to_luastring(\"undefined\"));\n                            break;\n                        case \"number\":  /* before check object as null is an object */\n                            pushstr(L, to_luastring(\"Number(\"+v+\")\"));\n                            break;\n                        case \"string\":  /* before check object as null is an object */\n                            pushstr(L, to_luastring(\"String(\"+JSON.stringify(v)+\")\"));\n                            break;\n                        case \"boolean\":  /* before check object as null is an object */\n                            pushstr(L, to_luastring(v?\"Boolean(true)\":\"Boolean(false)\"));\n                            break;\n                        case \"object\":\n                            if (v === null) { /* null is special */\n                                pushstr(L, to_luastring(\"null\"));\n                                break;\n                            }\n                            /* fall through */\n                        case \"function\": {\n                            let id = L.l_G.ids.get(v);\n                            if (!id) {\n                                id = L.l_G.id_counter++;\n                                L.l_G.ids.set(v, id);\n                            }\n                            pushstr(L, to_luastring(\"0x\"+id.toString(16)));\n                            break;\n                        }\n                        default:\n                            /* user provided object. no id available */\n                            pushstr(L, to_luastring(\"<id NYI>\"));\n                    }\n                }\n                break;\n            }\n            case 85 /* ('U').charCodeAt(0) */: {\n                let buff = new Uint8Array(UTF8BUFFSZ);\n                let l = luaO_utf8esc(buff, argp[a++]);\n                pushstr(L, buff.subarray(UTF8BUFFSZ - l));\n                break;\n            }\n            case 37 /* ('%').charCodeAt(0) */:\n                pushstr(L, to_luastring(\"%\", true));\n                break;\n            default:\n                ldebug.luaG_runerror(L, to_luastring(\"invalid option '%%%c' to 'lua_pushfstring'\"), fmt[e + 1]);\n        }\n        n += 2;\n        i = e + 2;\n    }\n    ldo.luaD_checkstack(L, 1);\n    pushstr(L, fmt.subarray(i));\n    if (n > 0) lvm.luaV_concat(L, n+1);\n    return L.stack[L.top-1].svalue();\n};\n\nconst luaO_pushfstring = function(L, fmt, ...argp) {\n    return luaO_pushvfstring(L, fmt, argp);\n};\n\n\n/*\n** converts an integer to a \"floating point byte\", represented as\n** (eeeeexxx), where the real value is (1xxx) * 2^(eeeee - 1) if\n** eeeee !== 0 and (xxx) otherwise.\n*/\nconst luaO_int2fb = function(x) {\n    let e = 0;  /* exponent */\n    if (x < 8) return x;\n    while (x >= (8 << 4)) {  /* coarse steps */\n        x = (x + 0xf) >> 4;  /* x = ceil(x / 16) */\n        e += 4;\n    }\n    while (x >= (8 << 1)) {  /* fine steps */\n        x = (x + 1) >> 1;  /* x = ceil(x / 2) */\n        e++;\n    }\n    return ((e+1) << 3) | (x - 8);\n};\n\nconst intarith = function(L, op, v1, v2) {\n    switch (op) {\n        case LUA_OPADD:  return (v1 + v2)|0;\n        case LUA_OPSUB:  return (v1 - v2)|0;\n        case LUA_OPMUL:  return lvm.luaV_imul(v1, v2);\n        case LUA_OPMOD:  return lvm.luaV_mod(L, v1, v2);\n        case LUA_OPIDIV: return lvm.luaV_div(L, v1, v2);\n        case LUA_OPBAND: return (v1 & v2);\n        case LUA_OPBOR:  return (v1 | v2);\n        case LUA_OPBXOR: return (v1 ^ v2);\n        case LUA_OPSHL:  return lvm.luaV_shiftl(v1, v2);\n        case LUA_OPSHR:  return lvm.luaV_shiftl(v1, -v2);\n        case LUA_OPUNM:  return (0 - v1)|0;\n        case LUA_OPBNOT: return (~0 ^ v1);\n        default: lua_assert(0);\n    }\n};\n\n\nconst numarith = function(L, op, v1, v2) {\n    switch (op) {\n        case LUA_OPADD:  return v1 + v2;\n        case LUA_OPSUB:  return v1 - v2;\n        case LUA_OPMUL:  return v1 * v2;\n        case LUA_OPDIV:  return v1 / v2;\n        case LUA_OPPOW:  return Math.pow(v1, v2);\n        case LUA_OPIDIV: return Math.floor(v1 / v2);\n        case LUA_OPUNM:  return -v1;\n        case LUA_OPMOD:  return luai_nummod(L, v1, v2);\n        default: lua_assert(0);\n    }\n};\n\nconst luaO_arith = function(L, op, p1, p2, p3) {\n    let res = (typeof p3 === \"number\") ? L.stack[p3] : p3;  /* FIXME */\n\n    switch (op) {\n        case LUA_OPBAND: case LUA_OPBOR: case LUA_OPBXOR:\n        case LUA_OPSHL: case LUA_OPSHR:\n        case LUA_OPBNOT: {  /* operate only on integers */\n            let i1, i2;\n            if ((i1 = lvm.tointeger(p1)) !== false && (i2 = lvm.tointeger(p2)) !== false) {\n                res.setivalue(intarith(L, op, i1, i2));\n                return;\n            }\n            else break;  /* go to the end */\n        }\n        case LUA_OPDIV: case LUA_OPPOW: {  /* operate only on floats */\n            let n1, n2;\n            if ((n1 = lvm.tonumber(p1)) !== false && (n2 = lvm.tonumber(p2)) !== false) {\n                res.setfltvalue(numarith(L, op, n1, n2));\n                return;\n            }\n            else break;  /* go to the end */\n        }\n        default: {  /* other operations */\n            let n1, n2;\n            if (p1.ttisinteger() && p2.ttisinteger()) {\n                res.setivalue(intarith(L, op, p1.value, p2.value));\n                return;\n            }\n            else if ((n1 = lvm.tonumber(p1)) !== false && (n2 = lvm.tonumber(p2)) !== false) {\n                res.setfltvalue(numarith(L, op, n1, n2));\n                return;\n            }\n            else break;  /* go to the end */\n        }\n    }\n    /* could not perform raw operation; try metamethod */\n    lua_assert(L !== null);  /* should not fail when folding (compile time) */\n    ltm.luaT_trybinTM(L, p1, p2, p3, (op - LUA_OPADD) + ltm.TMS.TM_ADD);\n};\n\n\nmodule.exports.CClosure          = CClosure;\nmodule.exports.LClosure          = LClosure;\nmodule.exports.LUA_TDEADKEY      = LUA_TDEADKEY;\nmodule.exports.LUA_TPROTO        = LUA_TPROTO;\nmodule.exports.LocVar            = LocVar;\nmodule.exports.TValue            = TValue;\nmodule.exports.Udata             = Udata;\nmodule.exports.UTF8BUFFSZ        = UTF8BUFFSZ;\nmodule.exports.luaO_arith        = luaO_arith;\nmodule.exports.luaO_chunkid      = luaO_chunkid;\nmodule.exports.luaO_hexavalue    = luaO_hexavalue;\nmodule.exports.luaO_int2fb       = luaO_int2fb;\nmodule.exports.luaO_pushfstring  = luaO_pushfstring;\nmodule.exports.luaO_pushvfstring = luaO_pushvfstring;\nmodule.exports.luaO_str2num      = luaO_str2num;\nmodule.exports.luaO_tostring     = luaO_tostring;\nmodule.exports.luaO_utf8esc      = luaO_utf8esc;\nmodule.exports.numarith          = numarith;\nmodule.exports.pushobj2s         = pushobj2s;\nmodule.exports.pushsvalue2s      = pushsvalue2s;\nmodule.exports.setobjs2s         = setobjs2s;\nmodule.exports.setobj2s          = setobj2s;\nmodule.exports.setsvalue2s       = setsvalue2s;\n", ";\n\nconst { constant_types: { LUA_TNIL } } = require('./defs.js');\nconst lobject = require('./lobject.js');\n\nclass Proto {\n    constructor(L) {\n        this.id = L.l_G.id_counter++;\n        this.k = [];              // constants used by the function\n        this.p = [];              // functions defined inside the function\n        this.code = [];           // opcodes\n        this.cache = null;        // last-created closure with this prototype\n        this.lineinfo = [];       // map from opcodes to source lines (debug information)\n        this.upvalues = [];       // upvalue information\n        this.numparams = 0;       // number of fixed parameters\n        this.is_vararg = false;\n        this.maxstacksize = 0;    // number of registers needed by this function\n        this.locvars = [];        // information about local variables (debug information)\n        this.linedefined = 0;     // debug information\n        this.lastlinedefined = 0; // debug information\n        this.source = null;       // used for debug information\n    }\n}\n\nconst luaF_newLclosure = function(L, n) {\n    return new lobject.LClosure(L, n);\n};\n\n\nconst luaF_findupval = function(L, level) {\n    return L.stack[level];\n};\n\nconst luaF_close = function(L, level) {\n    /* Create new TValues on stack;\n     * any closures will keep referencing old TValues */\n    for (let i=level; i<L.top; i++) {\n        let old = L.stack[i];\n        L.stack[i] = new lobject.TValue(old.type, old.value);\n    }\n};\n\n/*\n** fill a closure with new upvalues\n*/\nconst luaF_initupvals = function(L, cl) {\n    for (let i = 0; i < cl.nupvalues; i++)\n        cl.upvals[i] = new lobject.TValue(LUA_TNIL, null);\n};\n\n/*\n** Look for n-th local variable at line 'line' in function 'func'.\n** Returns null if not found.\n*/\nconst luaF_getlocalname = function(f, local_number, pc) {\n    for (let i = 0; i < f.locvars.length && f.locvars[i].startpc <= pc; i++) {\n        if (pc < f.locvars[i].endpc) {  /* is variable active? */\n            local_number--;\n            if (local_number === 0)\n                return f.locvars[i].varname.getstr();\n        }\n    }\n    return null;  /* not found */\n};\n\nmodule.exports.MAXUPVAL          = 255;\nmodule.exports.Proto             = Proto;\nmodule.exports.luaF_findupval    = luaF_findupval;\nmodule.exports.luaF_close        = luaF_close;\nmodule.exports.luaF_getlocalname = luaF_getlocalname;\nmodule.exports.luaF_initupvals   = luaF_initupvals;\nmodule.exports.luaF_newLclosure  = luaF_newLclosure;\n", ";\n\nconst { lua_assert } = require(\"./llimits.js\");\n\nclass MBuffer {\n    constructor() {\n        this.buffer = null;\n        this.n = 0;\n    }\n}\n\nconst luaZ_buffer = function(buff) {\n    return buff.buffer.subarray(0, buff.n);\n};\n\nconst luaZ_buffremove = function(buff, i) {\n    buff.n -= i;\n};\n\nconst luaZ_resetbuffer = function(buff) {\n    buff.n = 0;\n};\n\nconst luaZ_resizebuffer = function(L, buff, size) {\n    let newbuff = new Uint8Array(size);\n    if (buff.buffer)\n        newbuff.set(buff.buffer);\n    buff.buffer = newbuff;\n};\n\nclass ZIO {\n    constructor(L, reader, data) {\n        this.L = L;           /* Lua state (for reader) */\n        lua_assert(typeof reader == \"function\", \"ZIO requires a reader\");\n        this.reader = reader; /* reader function */\n        this.data = data;     /* additional data */\n        this.n = 0;           /* bytes still unread */\n        this.buffer = null;\n        this.off = 0;         /* current position in buffer */\n    }\n\n    zgetc () {\n        return ((this.n--) > 0) ? this.buffer[this.off++] : luaZ_fill(this);\n    }\n}\n\nconst EOZ = -1;\n\nconst luaZ_fill = function(z) {\n    let buff = z.reader(z.L, z.data);\n    if (buff === null)\n        return EOZ;\n    lua_assert(buff instanceof Uint8Array, \"Should only load binary of array of bytes\");\n    let size = buff.length;\n    if (size === 0)\n        return EOZ;\n    z.buffer = buff;\n    z.off = 0;\n    z.n = size - 1;\n    return z.buffer[z.off++];\n};\n\n/* b should be an array-like that will be set to bytes\n * b_offset is the offset at which to start filling */\nconst luaZ_read = function(z, b, b_offset, n) {\n    while (n) {\n        if (z.n === 0) { /* no bytes in buffer? */\n            if (luaZ_fill(z) === EOZ)\n                return n; /* no more input; return number of missing bytes */\n            else {\n                z.n++;  /* luaZ_fill consumed first byte; put it back */\n                z.off--;\n            }\n        }\n        let m = (n <= z.n) ? n : z.n; /* min. between n and z->n */\n        for (let i=0; i<m; i++) {\n            b[b_offset++] = z.buffer[z.off++];\n        }\n        z.n -= m;\n        if (z.n === 0) // remove reference to input so it can get freed\n            z.buffer = null;\n        n -= m;\n    }\n\n    return 0;\n};\n\nmodule.exports.EOZ               = EOZ;\nmodule.exports.luaZ_buffer       = luaZ_buffer;\nmodule.exports.luaZ_buffremove   = luaZ_buffremove;\nmodule.exports.luaZ_fill         = luaZ_fill;\nmodule.exports.luaZ_read         = luaZ_read;\nmodule.exports.luaZ_resetbuffer  = luaZ_resetbuffer;\nmodule.exports.luaZ_resizebuffer = luaZ_resizebuffer;\nmodule.exports.MBuffer           = MBuffer;\nmodule.exports.ZIO               = ZIO;\n", ";\n\nconst {\n    constant_types: { LUA_TBOOLEAN, LUA_TLNGSTR },\n    thread_status: { LUA_ERRSYNTAX },\n    to_luastring\n} = require('./defs.js');\nconst {\n    LUA_MINBUFFER,\n    MAX_INT,\n    lua_assert\n} = require('./llimits.js');\nconst ldebug   = require('./ldebug.js');\nconst ldo      = require('./ldo.js');\nconst {\n    lisdigit,\n    lislalnum,\n    lislalpha,\n    lisspace,\n    lisxdigit\n} = require('./ljstype.js');\nconst lobject  = require('./lobject.js');\nconst {\n    luaS_bless,\n    luaS_hash,\n    luaS_hashlongstr,\n    luaS_new\n} = require('./lstring.js');\nconst ltable   = require('./ltable.js');\nconst {\n    EOZ,\n    luaZ_buffer,\n    luaZ_buffremove,\n    luaZ_resetbuffer,\n    luaZ_resizebuffer\n} = require('./lzio.js');\n\nconst FIRST_RESERVED = 257;\n\nconst LUA_ENV = to_luastring(\"_ENV\", true);\n\n/* terminal symbols denoted by reserved words */\nconst TK_AND      = FIRST_RESERVED;\nconst TK_BREAK    = FIRST_RESERVED + 1;\nconst TK_DO       = FIRST_RESERVED + 2;\nconst TK_ELSE     = FIRST_RESERVED + 3;\nconst TK_ELSEIF   = FIRST_RESERVED + 4;\nconst TK_END      = FIRST_RESERVED + 5;\nconst TK_FALSE    = FIRST_RESERVED + 6;\nconst TK_FOR      = FIRST_RESERVED + 7;\nconst TK_FUNCTION = FIRST_RESERVED + 8;\nconst TK_GOTO     = FIRST_RESERVED + 9;\nconst TK_IF       = FIRST_RESERVED + 10;\nconst TK_IN       = FIRST_RESERVED + 11;\nconst TK_LOCAL    = FIRST_RESERVED + 12;\nconst TK_NIL      = FIRST_RESERVED + 13;\nconst TK_NOT      = FIRST_RESERVED + 14;\nconst TK_OR       = FIRST_RESERVED + 15;\nconst TK_REPEAT   = FIRST_RESERVED + 16;\nconst TK_RETURN   = FIRST_RESERVED + 17;\nconst TK_THEN     = FIRST_RESERVED + 18;\nconst TK_TRUE     = FIRST_RESERVED + 19;\nconst TK_UNTIL    = FIRST_RESERVED + 20;\nconst TK_WHILE    = FIRST_RESERVED + 21;\n/* other terminal symbols */\nconst TK_IDIV     = FIRST_RESERVED + 22;\nconst TK_CONCAT   = FIRST_RESERVED + 23;\nconst TK_DOTS     = FIRST_RESERVED + 24;\nconst TK_EQ       = FIRST_RESERVED + 25;\nconst TK_GE       = FIRST_RESERVED + 26;\nconst TK_LE       = FIRST_RESERVED + 27;\nconst TK_NE       = FIRST_RESERVED + 28;\nconst TK_SHL      = FIRST_RESERVED + 29;\nconst TK_SHR      = FIRST_RESERVED + 30;\nconst TK_DBCOLON  = FIRST_RESERVED + 31;\nconst TK_EOS      = FIRST_RESERVED + 32;\nconst TK_FLT      = FIRST_RESERVED + 33;\nconst TK_INT      = FIRST_RESERVED + 34;\nconst TK_NAME     = FIRST_RESERVED + 35;\nconst TK_STRING   = FIRST_RESERVED + 36;\n\nconst RESERVED = {\n    \"TK_AND\":      TK_AND,\n    \"TK_BREAK\":    TK_BREAK,\n    \"TK_DO\":       TK_DO,\n    \"TK_ELSE\":     TK_ELSE,\n    \"TK_ELSEIF\":   TK_ELSEIF,\n    \"TK_END\":      TK_END,\n    \"TK_FALSE\":    TK_FALSE,\n    \"TK_FOR\":      TK_FOR,\n    \"TK_FUNCTION\": TK_FUNCTION,\n    \"TK_GOTO\":     TK_GOTO,\n    \"TK_IF\":       TK_IF,\n    \"TK_IN\":       TK_IN,\n    \"TK_LOCAL\":    TK_LOCAL,\n    \"TK_NIL\":      TK_NIL,\n    \"TK_NOT\":      TK_NOT,\n    \"TK_OR\":       TK_OR,\n    \"TK_REPEAT\":   TK_REPEAT,\n    \"TK_RETURN\":   TK_RETURN,\n    \"TK_THEN\":     TK_THEN,\n    \"TK_TRUE\":     TK_TRUE,\n    \"TK_UNTIL\":    TK_UNTIL,\n    \"TK_WHILE\":    TK_WHILE,\n    \"TK_IDIV\":     TK_IDIV,\n    \"TK_CONCAT\":   TK_CONCAT,\n    \"TK_DOTS\":     TK_DOTS,\n    \"TK_EQ\":       TK_EQ,\n    \"TK_GE\":       TK_GE,\n    \"TK_LE\":       TK_LE,\n    \"TK_NE\":       TK_NE,\n    \"TK_SHL\":      TK_SHL,\n    \"TK_SHR\":      TK_SHR,\n    \"TK_DBCOLON\":  TK_DBCOLON,\n    \"TK_EOS\":      TK_EOS,\n    \"TK_FLT\":      TK_FLT,\n    \"TK_INT\":      TK_INT,\n    \"TK_NAME\":     TK_NAME,\n    \"TK_STRING\":   TK_STRING\n};\n\nconst luaX_tokens = [\n    \"and\", \"break\", \"do\", \"else\", \"elseif\",\n    \"end\", \"false\", \"for\", \"function\", \"goto\", \"if\",\n    \"in\", \"local\", \"nil\", \"not\", \"or\", \"repeat\",\n    \"return\", \"then\", \"true\", \"until\", \"while\",\n    \"//\", \"..\", \"...\", \"==\", \">=\", \"<=\", \"~=\",\n    \"<<\", \">>\", \"::\", \"<eof>\",\n    \"<number>\", \"<integer>\", \"<name>\", \"<string>\"\n].map((e, i)=>to_luastring(e));\n\nclass SemInfo {\n    constructor() {\n        this.r = NaN;\n        this.i = NaN;\n        this.ts = null;\n    }\n}\n\nclass Token {\n    constructor() {\n        this.token = NaN;\n        this.seminfo = new SemInfo();\n    }\n}\n\n/* state of the lexer plus state of the parser when shared by all\n   functions */\nclass LexState {\n    constructor() {\n        this.current = NaN;  /* current character (charint) */\n        this.linenumber = NaN;  /* input line counter */\n        this.lastline = NaN;  /* line of last token 'consumed' */\n        this.t = new Token();  /* current token */\n        this.lookahead = new Token();  /* look ahead token */\n        this.fs = null;  /* current function (parser) */\n        this.L = null;\n        this.z = null; /* input stream */\n        this.buff = null;  /* buffer for tokens */\n        this.h = null;  /* to reuse strings */\n        this.dyd = null;  /* dynamic structures used by the parser */\n        this.source = null;  /* current source name */\n        this.envn = null;  /* environment variable name */\n    }\n}\n\nconst save = function(ls, c) {\n    let b = ls.buff;\n    if (b.n + 1 > b.buffer.length) {\n        if (b.buffer.length >= MAX_INT/2)\n            lexerror(ls, to_luastring(\"lexical element too long\", true), 0);\n        let newsize = b.buffer.length*2;\n        luaZ_resizebuffer(ls.L, b, newsize);\n    }\n    b.buffer[b.n++] = c < 0 ? 255 + c + 1 : c;\n};\n\nconst luaX_token2str = function(ls, token) {\n    if (token < FIRST_RESERVED) {  /* single-byte symbols? */\n        return lobject.luaO_pushfstring(ls.L, to_luastring(\"'%c'\", true), token);\n    } else {\n        let s = luaX_tokens[token - FIRST_RESERVED];\n        if (token < TK_EOS)  /* fixed format (symbols and reserved words)? */\n            return lobject.luaO_pushfstring(ls.L, to_luastring(\"'%s'\", true), s);\n        else  /* names, strings, and numerals */\n            return s;\n    }\n};\n\nconst currIsNewline = function(ls) {\n    return ls.current === 10 /* ('\\n').charCodeAt(0) */ || ls.current === 13 /* ('\\r').charCodeAt(0) */;\n};\n\nconst next = function(ls) {\n    ls.current = ls.z.zgetc();\n};\n\nconst save_and_next = function(ls) {\n    save(ls, ls.current);\n    next(ls);\n};\n\n/*\n** creates a new string and anchors it in scanner's table so that\n** it will not be collected until the end of the compilation\n** (by that time it should be anchored somewhere)\n*/\nconst TVtrue = new lobject.TValue(LUA_TBOOLEAN, true);\nconst luaX_newstring = function(ls, str) {\n    let L = ls.L;\n    let ts = luaS_new(L, str);\n    /* HACK: Workaround lack of ltable 'keyfromval' */\n    let tpair = ls.h.strong.get(luaS_hashlongstr(ts));\n    if (!tpair) { /* not in use yet? */\n        let key = new lobject.TValue(LUA_TLNGSTR, ts);\n        ltable.luaH_setfrom(L, ls.h, key, TVtrue);\n    } else { /* string already present */\n        ts = tpair.key.tsvalue(); /* re-use value previously stored */\n    }\n    return ts;\n};\n\n/*\n** increment line number and skips newline sequence (any of\n** \\n, \\r, \\n\\r, or \\r\\n)\n*/\nconst inclinenumber = function(ls) {\n    let old = ls.current;\n    lua_assert(currIsNewline(ls));\n    next(ls);  /* skip '\\n' or '\\r' */\n    if (currIsNewline(ls) && ls.current !== old)\n        next(ls);  /* skip '\\n\\r' or '\\r\\n' */\n    if (++ls.linenumber >= MAX_INT)\n        lexerror(ls, to_luastring(\"chunk has too many lines\", true), 0);\n};\n\nconst luaX_setinput = function(L, ls, z, source, firstchar) {\n    ls.t = {\n        token: 0,\n        seminfo: new SemInfo()\n    };\n    ls.L = L;\n    ls.current = firstchar;\n    ls.lookahead = {\n        token: TK_EOS,\n        seminfo: new SemInfo()\n    };\n    ls.z = z;\n    ls.fs = null;\n    ls.linenumber = 1;\n    ls.lastline = 1;\n    ls.source = source;\n    ls.envn = luaS_bless(L, LUA_ENV);\n    luaZ_resizebuffer(L, ls.buff, LUA_MINBUFFER);  /* initialize buffer */\n};\n\nconst check_next1 = function(ls, c) {\n    if (ls.current === c) {\n        next(ls);\n        return true;\n    }\n\n    return false;\n};\n\n/*\n** Check whether current char is in set 'set' (with two chars) and\n** saves it\n*/\nconst check_next2 = function(ls, set) {\n    if (ls.current === set[0].charCodeAt(0) || ls.current === set[1].charCodeAt(0)) {\n        save_and_next(ls);\n        return true;\n    }\n\n    return false;\n};\n\nconst read_numeral = function(ls, seminfo) {\n    let expo = \"Ee\";\n    let first = ls.current;\n    lua_assert(lisdigit(ls.current));\n    save_and_next(ls);\n    if (first === 48 /* ('0').charCodeAt(0) */ && check_next2(ls, \"xX\"))  /* hexadecimal? */\n        expo = \"Pp\";\n\n    for (;;) {\n        if (check_next2(ls, expo))  /* exponent part? */\n            check_next2(ls, \"-+\");  /* optional exponent sign */\n        if (lisxdigit(ls.current))\n            save_and_next(ls);\n        else if (ls.current === 46 /* ('.').charCodeAt(0) */)\n            save_and_next(ls);\n        else break;\n    }\n\n    // save(ls, 0);\n\n    let obj = new lobject.TValue();\n    if (lobject.luaO_str2num(luaZ_buffer(ls.buff), obj) === 0)  /* format error? */\n        lexerror(ls, to_luastring(\"malformed number\", true), TK_FLT);\n    if (obj.ttisinteger()) {\n        seminfo.i = obj.value;\n        return TK_INT;\n    } else {\n        lua_assert(obj.ttisfloat());\n        seminfo.r = obj.value;\n        return TK_FLT;\n    }\n};\n\nconst txtToken = function(ls, token) {\n    switch (token) {\n        case TK_NAME: case TK_STRING:\n        case TK_FLT: case TK_INT:\n            // save(ls, 0);\n            return lobject.luaO_pushfstring(ls.L, to_luastring(\"'%s'\", true), luaZ_buffer(ls.buff));\n        default:\n            return luaX_token2str(ls, token);\n    }\n};\n\nconst lexerror = function(ls, msg, token) {\n    msg = ldebug.luaG_addinfo(ls.L, msg, ls.source, ls.linenumber);\n    if (token)\n        lobject.luaO_pushfstring(ls.L, to_luastring(\"%s near %s\"), msg, txtToken(ls, token));\n    ldo.luaD_throw(ls.L, LUA_ERRSYNTAX);\n};\n\nconst luaX_syntaxerror = function(ls, msg) {\n    lexerror(ls, msg, ls.t.token);\n};\n\n/*\n** skip a sequence '[=*[' or ']=*]'; if sequence is well formed, return\n** its number of '='s; otherwise, return a negative number (-1 iff there\n** are no '='s after initial bracket)\n*/\nconst skip_sep = function(ls) {\n    let count = 0;\n    let s = ls.current;\n    lua_assert(s === 91 /* ('[').charCodeAt(0) */ || s === 93 /* (']').charCodeAt(0) */);\n    save_and_next(ls);\n    while (ls.current === 61 /* ('=').charCodeAt(0) */) {\n        save_and_next(ls);\n        count++;\n    }\n    return ls.current === s ? count : (-count) - 1;\n};\n\nconst read_long_string = function(ls, seminfo, sep) {\n    let line = ls.linenumber;  /* initial line (for error message) */\n    save_and_next(ls);  /* skip 2nd '[' */\n\n    if (currIsNewline(ls))  /* string starts with a newline? */\n        inclinenumber(ls);  /* skip it */\n\n    let skip = false;\n    for (; !skip ;) {\n        switch (ls.current) {\n            case EOZ: {  /* error */\n                let what = seminfo ? \"string\" : \"comment\";\n                let msg = `unfinished long ${what} (starting at line ${line})`;\n                lexerror(ls, to_luastring(msg), TK_EOS);\n                break;\n            }\n            case 93 /* (']').charCodeAt(0) */: {\n                if (skip_sep(ls) === sep) {\n                    save_and_next(ls);  /* skip 2nd ']' */\n                    skip = true;\n                }\n                break;\n            }\n            case 10 /* ('\\n').charCodeAt(0) */:\n            case 13 /* ('\\r').charCodeAt(0) */: {\n                save(ls, 10 /* ('\\n').charCodeAt(0) */);\n                inclinenumber(ls);\n                if (!seminfo) luaZ_resetbuffer(ls.buff);\n                break;\n            }\n            default: {\n                if (seminfo) save_and_next(ls);\n                else next(ls);\n            }\n        }\n    }\n\n    if (seminfo)\n        seminfo.ts = luaX_newstring(ls, ls.buff.buffer.subarray(2 + sep, ls.buff.n - (2 + sep)));\n};\n\nconst esccheck = function(ls, c, msg) {\n    if (!c) {\n        if (ls.current !== EOZ)\n            save_and_next(ls);  /* add current to buffer for error message */\n        lexerror(ls, msg, TK_STRING);\n    }\n};\n\nconst gethexa = function(ls) {\n    save_and_next(ls);\n    esccheck(ls, lisxdigit(ls.current), to_luastring(\"hexadecimal digit expected\", true));\n    return lobject.luaO_hexavalue(ls.current);\n};\n\nconst readhexaesc = function(ls) {\n    let r = gethexa(ls);\n    r = (r << 4) + gethexa(ls);\n    luaZ_buffremove(ls.buff, 2);  /* remove saved chars from buffer */\n    return r;\n};\n\nconst readutf8desc = function(ls) {\n    let i = 4;  /* chars to be removed: '\\', 'u', '{', and first digit */\n    save_and_next(ls);  /* skip 'u' */\n    esccheck(ls, ls.current === 123 /* ('{').charCodeAt(0) */, to_luastring(\"missing '{'\", true));\n    let r = gethexa(ls);  /* must have at least one digit */\n\n    save_and_next(ls);\n    while (lisxdigit(ls.current)) {\n        i++;\n        r = (r << 4) + lobject.luaO_hexavalue(ls.current);\n        esccheck(ls, r <= 0x10FFFF, to_luastring(\"UTF-8 value too large\", true));\n        save_and_next(ls);\n    }\n    esccheck(ls, ls.current === 125 /* ('}').charCodeAt(0) */, to_luastring(\"missing '}'\", true));\n    next(ls);  /* skip '}' */\n    luaZ_buffremove(ls.buff, i);  /* remove saved chars from buffer */\n    return r;\n};\n\nconst utf8esc = function(ls) {\n    let buff = new Uint8Array(lobject.UTF8BUFFSZ);\n    let n = lobject.luaO_utf8esc(buff, readutf8desc(ls));\n    for (; n > 0; n--)  /* add 'buff' to string */\n        save(ls, buff[lobject.UTF8BUFFSZ - n]);\n};\n\nconst readdecesc = function(ls) {\n    let r = 0;  /* result accumulator */\n    let i;\n    for (i = 0; i < 3 && lisdigit(ls.current); i++) {  /* read up to 3 digits */\n        r = 10 * r + ls.current - 48 /* ('0').charCodeAt(0) */;\n        save_and_next(ls);\n    }\n    esccheck(ls, r <= 255, to_luastring(\"decimal escape too large\", true));\n    luaZ_buffremove(ls.buff, i);  /* remove read digits from buffer */\n    return r;\n};\n\nconst read_string = function(ls, del, seminfo) {\n    save_and_next(ls);  /* keep delimiter (for error messages) */\n\n    while (ls.current !== del) {\n        switch (ls.current) {\n            case EOZ:\n                lexerror(ls, to_luastring(\"unfinished string\", true), TK_EOS);\n                break;\n            case 10 /* ('\\n').charCodeAt(0) */:\n            case 13 /* ('\\r').charCodeAt(0) */:\n                lexerror(ls, to_luastring(\"unfinished string\", true), TK_STRING);\n                break;\n            case 92 /* ('\\\\').charCodeAt(0) */: {  /* escape sequences */\n                save_and_next(ls);  /* keep '\\\\' for error messages */\n                let will;\n                let c;\n                switch(ls.current) {\n                    case 97 /* ('a').charCodeAt(0) */: c = 7 /* \\a isn't valid JS */; will = 'read_save'; break;\n                    case 98 /* ('b').charCodeAt(0) */: c = 8 /* ('\\b').charCodeAt(0) */; will = 'read_save'; break;\n                    case 102 /* ('f').charCodeAt(0) */: c = 12 /* ('\\f').charCodeAt(0) */; will = 'read_save'; break;\n                    case 110 /* ('n').charCodeAt(0) */: c = 10 /* ('\\n').charCodeAt(0) */; will = 'read_save'; break;\n                    case 114 /* ('r').charCodeAt(0) */: c = 13 /* ('\\r').charCodeAt(0) */; will = 'read_save'; break;\n                    case 116 /* ('t').charCodeAt(0) */: c = 9 /* ('\\t').charCodeAt(0) */; will = 'read_save'; break;\n                    case 118 /* ('v').charCodeAt(0) */: c = 11 /* ('\\v').charCodeAt(0) */; will = 'read_save'; break;\n                    case 120 /* ('x').charCodeAt(0) */: c = readhexaesc(ls); will = 'read_save'; break;\n                    case 117 /* ('u').charCodeAt(0) */: utf8esc(ls); will = 'no_save'; break;\n                    case 10 /* ('\\n').charCodeAt(0) */:\n                    case 13 /* ('\\r').charCodeAt(0) */:\n                        inclinenumber(ls); c = 10 /* ('\\n').charCodeAt(0) */; will = 'only_save'; break;\n                    case 92 /* ('\\\\').charCodeAt(0) */:\n                    case 34 /* ('\"').charCodeAt(0) */:\n                    case 39 /* ('\\'').charCodeAt(0) */:\n                        c = ls.current; will = 'read_save'; break;\n                    case EOZ: will = 'no_save'; break;  /* will raise an error next loop */\n                    case 122 /* ('z').charCodeAt(0) */: {  /* zap following span of spaces */\n                        luaZ_buffremove(ls.buff, 1);  /* remove '\\\\' */\n                        next(ls);  /* skip the 'z' */\n                        while (lisspace(ls.current)) {\n                            if (currIsNewline(ls)) inclinenumber(ls);\n                            else next(ls);\n                        }\n                        will = 'no_save'; break;\n                    }\n                    default: {\n                        esccheck(ls, lisdigit(ls.current), to_luastring(\"invalid escape sequence\", true));\n                        c = readdecesc(ls);  /* digital escape '\\ddd' */\n                        will = 'only_save'; break;\n                    }\n                }\n\n                if (will === 'read_save')\n                    next(ls);\n\n                if (will === 'read_save' || will === 'only_save') {\n                    luaZ_buffremove(ls.buff, 1);  /* remove '\\\\' */\n                    save(ls, c);\n                }\n\n                break;\n            }\n            default:\n                save_and_next(ls);\n        }\n    }\n    save_and_next(ls);  /* skip delimiter */\n\n    seminfo.ts = luaX_newstring(ls, ls.buff.buffer.subarray(1, ls.buff.n-1));\n};\n\nconst token_to_index = Object.create(null); /* don't want to return true for e.g. 'hasOwnProperty' */\nluaX_tokens.forEach((e, i)=>token_to_index[luaS_hash(e)] = i);\n\nconst isreserved = function(w) {\n    let kidx = token_to_index[luaS_hashlongstr(w)];\n    return kidx !== void 0 && kidx <= 22;\n};\n\nconst llex = function(ls, seminfo) {\n    luaZ_resetbuffer(ls.buff);\n    for (;;) {\n        lua_assert(typeof ls.current == \"number\"); /* fengari addition */\n        switch (ls.current) {\n            case 10 /* ('\\n').charCodeAt(0) */:\n            case 13 /* ('\\r').charCodeAt(0) */: {  /* line breaks */\n                inclinenumber(ls);\n                break;\n            }\n            case 32 /* (' ').charCodeAt(0) */:\n            case 12 /* ('\\f').charCodeAt(0) */:\n            case 9 /* ('\\t').charCodeAt(0) */:\n            case 11 /* ('\\v').charCodeAt(0) */: {  /* spaces */\n                next(ls);\n                break;\n            }\n            case 45 /* ('-').charCodeAt(0) */: {  /* '-' or '--' (comment) */\n                next(ls);\n                if (ls.current !== 45 /* ('-').charCodeAt(0) */) return 45 /* ('-').charCodeAt(0) */;\n                /* else is a comment */\n                next(ls);\n                if (ls.current === 91 /* ('[').charCodeAt(0) */) {  /* long comment? */\n                    let sep = skip_sep(ls);\n                    luaZ_resetbuffer(ls.buff);  /* 'skip_sep' may dirty the buffer */\n                    if (sep >= 0) {\n                        read_long_string(ls, null, sep);  /* skip long comment */\n                        luaZ_resetbuffer(ls.buff);  /* previous call may dirty the buff. */\n                        break;\n                    }\n                }\n\n                /* else short comment */\n                while (!currIsNewline(ls) && ls.current !== EOZ)\n                    next(ls);  /* skip until end of line (or end of file) */\n                break;\n            }\n            case 91 /* ('[').charCodeAt(0) */: {  /* long string or simply '[' */\n                let sep = skip_sep(ls);\n                if (sep >= 0) {\n                    read_long_string(ls, seminfo, sep);\n                    return TK_STRING;\n                } else if (sep !== -1)  /* '[=...' missing second bracket */\n                    lexerror(ls, to_luastring(\"invalid long string delimiter\", true), TK_STRING);\n                return 91 /* ('[').charCodeAt(0) */;\n            }\n            case 61 /* ('=').charCodeAt(0) */: {\n                next(ls);\n                if (check_next1(ls, 61 /* ('=').charCodeAt(0) */)) return TK_EQ;\n                else return 61 /* ('=').charCodeAt(0) */;\n            }\n            case 60 /* ('<').charCodeAt(0) */: {\n                next(ls);\n                if (check_next1(ls, 61 /* ('=').charCodeAt(0) */)) return TK_LE;\n                else if (check_next1(ls, 60 /* ('<').charCodeAt(0) */)) return TK_SHL;\n                else return 60 /* ('<').charCodeAt(0) */;\n            }\n            case 62 /* ('>').charCodeAt(0) */: {\n                next(ls);\n                if (check_next1(ls, 61 /* ('=').charCodeAt(0) */)) return TK_GE;\n                else if (check_next1(ls, 62 /* ('>').charCodeAt(0) */)) return TK_SHR;\n                else return 62 /* ('>').charCodeAt(0) */;\n            }\n            case 47 /* ('/').charCodeAt(0) */: {\n                next(ls);\n                if (check_next1(ls, 47 /* ('/').charCodeAt(0) */)) return TK_IDIV;\n                else return 47 /* ('/').charCodeAt(0) */;\n            }\n            case 126 /* ('~').charCodeAt(0) */: {\n                next(ls);\n                if (check_next1(ls, 61 /* ('=').charCodeAt(0) */)) return TK_NE;\n                else return 126 /* ('~').charCodeAt(0) */;\n            }\n            case 58 /* (':').charCodeAt(0) */: {\n                next(ls);\n                if (check_next1(ls, 58 /* (':').charCodeAt(0) */)) return TK_DBCOLON;\n                else return 58 /* (':').charCodeAt(0) */;\n            }\n            case 34 /* ('\"').charCodeAt(0) */:\n            case 39 /* ('\\'').charCodeAt(0) */: {  /* short literal strings */\n                read_string(ls, ls.current, seminfo);\n                return TK_STRING;\n            }\n            case 46 /* ('.').charCodeAt(0) */: {  /* '.', '..', '...', or number */\n                save_and_next(ls);\n                if (check_next1(ls, 46 /* ('.').charCodeAt(0) */)) {\n                    if (check_next1(ls, 46 /* ('.').charCodeAt(0) */))\n                        return TK_DOTS;   /* '...' */\n                    else return TK_CONCAT;   /* '..' */\n                }\n                else if (!lisdigit(ls.current)) return 46 /* ('.').charCodeAt(0) */;\n                else return read_numeral(ls, seminfo);\n            }\n            case 48 /* ('0').charCodeAt(0) */: case 49 /* ('1').charCodeAt(0) */: case 50 /* ('2').charCodeAt(0) */: case 51 /* ('3').charCodeAt(0) */: case 52 /* ('4').charCodeAt(0) */:\n            case 53 /* ('5').charCodeAt(0) */: case 54 /* ('6').charCodeAt(0) */: case 55 /* ('7').charCodeAt(0) */: case 56 /* ('8').charCodeAt(0) */: case 57 /* ('9').charCodeAt(0) */: {\n                return read_numeral(ls, seminfo);\n            }\n            case EOZ: {\n                return TK_EOS;\n            }\n            default: {\n                if (lislalpha(ls.current)) {  /* identifier or reserved word? */\n                    do {\n                        save_and_next(ls);\n                    } while (lislalnum(ls.current));\n                    let ts = luaX_newstring(ls, luaZ_buffer(ls.buff));\n                    seminfo.ts = ts;\n                    let kidx = token_to_index[luaS_hashlongstr(ts)];\n                    if (kidx !== void 0 && kidx <= 22)  /* reserved word? */\n                        return kidx + FIRST_RESERVED;\n                    else\n                        return TK_NAME;\n                } else {  /* single-char tokens (+ - / ...) */\n                    let c = ls.current;\n                    next(ls);\n                    return c;\n                }\n            }\n        }\n    }\n};\n\nconst luaX_next = function(ls) {\n    ls.lastline = ls.linenumber;\n    if (ls.lookahead.token !== TK_EOS) {  /* is there a look-ahead token? */\n        ls.t.token = ls.lookahead.token;  /* use this one */\n        ls.t.seminfo.i = ls.lookahead.seminfo.i;\n        ls.t.seminfo.r = ls.lookahead.seminfo.r;\n        ls.t.seminfo.ts = ls.lookahead.seminfo.ts;\n        ls.lookahead.token = TK_EOS;  /* and discharge it */\n    } else\n        ls.t.token = llex(ls, ls.t.seminfo);  /* read next token */\n};\n\nconst luaX_lookahead = function(ls) {\n    lua_assert(ls.lookahead.token === TK_EOS);\n    ls.lookahead.token = llex(ls, ls.lookahead.seminfo);\n    return ls.lookahead.token;\n};\n\nmodule.exports.FIRST_RESERVED   = FIRST_RESERVED;\nmodule.exports.LUA_ENV          = LUA_ENV;\nmodule.exports.LexState         = LexState;\nmodule.exports.RESERVED         = RESERVED;\nmodule.exports.isreserved       = isreserved;\nmodule.exports.luaX_lookahead   = luaX_lookahead;\nmodule.exports.luaX_newstring   = luaX_newstring;\nmodule.exports.luaX_next        = luaX_next;\nmodule.exports.luaX_setinput    = luaX_setinput;\nmodule.exports.luaX_syntaxerror = luaX_syntaxerror;\nmodule.exports.luaX_token2str   = luaX_token2str;\nmodule.exports.luaX_tokens      = luaX_tokens;\n", ";\n\nconst {\n    LUA_MULTRET,\n    LUA_OPADD,\n    LUA_OPBAND,\n    LUA_OPBNOT,\n    LUA_OPBOR,\n    LUA_OPBXOR,\n    LUA_OPDIV,\n    LUA_OPIDIV,\n    LUA_OPMOD,\n    LUA_OPSHL,\n    LUA_OPSHR,\n    LUA_OPUNM,\n    constant_types: {\n        LUA_TBOOLEAN,\n        LUA_TLIGHTUSERDATA,\n        LUA_TLNGSTR,\n        LUA_TNIL,\n        LUA_TNUMFLT,\n        LUA_TNUMINT,\n        LUA_TTABLE\n    },\n    to_luastring\n} = require('./defs.js');\nconst { lua_assert } = require(\"./llimits.js\");\nconst llex     = require('./llex.js');\nconst lobject  = require('./lobject.js');\nconst lopcodes = require('./lopcodes.js');\nconst lparser  = require('./lparser.js');\nconst ltable   = require('./ltable.js');\nconst lvm      = require('./lvm.js');\n\nconst OpCodesI = lopcodes.OpCodesI;\nconst TValue   = lobject.TValue;\n\n/* Maximum number of registers in a Lua function (must fit in 8 bits) */\nconst MAXREGS = 255;\n\n/*\n** Marks the end of a patch list. It is an invalid value both as an absolute\n** address, and as a list link (would link an element to itself).\n*/\nconst NO_JUMP = -1;\n\nconst BinOpr = {\n    OPR_ADD:      0,\n    OPR_SUB:      1,\n    OPR_MUL:      2,\n    OPR_MOD:      3,\n    OPR_POW:      4,\n    OPR_DIV:      5,\n    OPR_IDIV:     6,\n    OPR_BAND:     7,\n    OPR_BOR:      8,\n    OPR_BXOR:     9,\n    OPR_SHL:      10,\n    OPR_SHR:      11,\n    OPR_CONCAT:   12,\n    OPR_EQ:       13,\n    OPR_LT:       14,\n    OPR_LE:       15,\n    OPR_NE:       16,\n    OPR_GT:       17,\n    OPR_GE:       18,\n    OPR_AND:      19,\n    OPR_OR:       20,\n    OPR_NOBINOPR: 21\n};\n\nconst UnOpr = {\n    OPR_MINUS:    0,\n    OPR_BNOT:     1,\n    OPR_NOT:      2,\n    OPR_LEN:      3,\n    OPR_NOUNOPR:  4\n};\n\nconst hasjumps = function(e) {\n    return e.t !== e.f;\n};\n\n/*\n** If expression is a numeric constant returns either true or a new TValue\n** (depending on 'make_tvalue'). Otherwise, returns false.\n*/\nconst tonumeral = function(e, make_tvalue) {\n    let ek = lparser.expkind;\n    if (hasjumps(e))\n        return false;  /* not a numeral */\n    switch (e.k) {\n        case ek.VKINT:\n            if (make_tvalue) {\n                return new TValue(LUA_TNUMINT, e.u.ival);\n            }\n            return true;\n        case ek.VKFLT:\n            if (make_tvalue) {\n                return new TValue(LUA_TNUMFLT, e.u.nval);\n            }\n            return true;\n        default: return false;\n    }\n};\n\n/*\n** Create a OP_LOADNIL instruction, but try to optimize: if the previous\n** instruction is also OP_LOADNIL and ranges are compatible, adjust\n** range of previous instruction instead of emitting a new one. (For\n** instance, 'local a; local b' will generate a single opcode.)\n*/\nconst luaK_nil = function(fs, from, n) {\n    let previous;\n    let l = from + n - 1;  /* last register to set nil */\n    if (fs.pc > fs.lasttarget) {  /* no jumps to current position? */\n        previous = fs.f.code[fs.pc-1];\n        if (previous.opcode === OpCodesI.OP_LOADNIL) {  /* previous is LOADNIL? */\n            let pfrom = previous.A;  /* get previous range */\n            let pl = pfrom + previous.B;\n            if ((pfrom <= from && from <= pl + 1) ||\n                    (from <= pfrom && pfrom <= l + 1)) {  /* can connect both? */\n                if (pfrom < from) from = pfrom;  /* from = min(from, pfrom) */\n                if (pl > l) l = pl;  /* l = max(l, pl) */\n                lopcodes.SETARG_A(previous, from);\n                lopcodes.SETARG_B(previous, l - from);\n                return;\n            }\n        }  /* else go through */\n    }\n    luaK_codeABC(fs, OpCodesI.OP_LOADNIL, from, n - 1, 0);  /* else no optimization */\n};\n\nconst getinstruction = function(fs, e) {\n    return fs.f.code[e.u.info];\n};\n\n/*\n** Gets the destination address of a jump instruction. Used to traverse\n** a list of jumps.\n*/\nconst getjump = function(fs, pc) {\n    let offset = fs.f.code[pc].sBx;\n    if (offset === NO_JUMP)  /* point to itself represents end of list */\n        return NO_JUMP;  /* end of list */\n    else\n        return pc + 1 + offset;  /* turn offset into absolute position */\n};\n\n/*\n** Fix jump instruction at position 'pc' to jump to 'dest'.\n** (Jump addresses are relative in Lua)\n*/\nconst fixjump = function(fs, pc, dest) {\n    let jmp = fs.f.code[pc];\n    let offset = dest - (pc + 1);\n    lua_assert(dest !== NO_JUMP);\n    if (Math.abs(offset) > lopcodes.MAXARG_sBx)\n        llex.luaX_syntaxerror(fs.ls, to_luastring(\"control structure too long\", true));\n    lopcodes.SETARG_sBx(jmp, offset);\n};\n\n/*\n** Concatenate jump-list 'l2' into jump-list 'l1'\n*/\nconst luaK_concat = function(fs, l1, l2) {\n    if (l2 === NO_JUMP) return l1;  /* nothing to concatenate? */\n    else if (l1 === NO_JUMP)  /* no original list? */\n        l1 = l2;\n    else {\n        let list = l1;\n        let next = getjump(fs, list);\n        while (next !== NO_JUMP) {  /* find last element */\n            list = next;\n            next = getjump(fs, list);\n        }\n        fixjump(fs, list, l2);\n    }\n\n    return l1;\n};\n\n/*\n** Create a jump instruction and return its position, so its destination\n** can be fixed later (with 'fixjump'). If there are jumps to\n** this position (kept in 'jpc'), link them all together so that\n** 'patchlistaux' will fix all them directly to the final destination.\n*/\nconst luaK_jump = function (fs) {\n    let jpc = fs.jpc;  /* save list of jumps to here */\n    fs.jpc = NO_JUMP;  /* no more jumps to here */\n    let j = luaK_codeAsBx(fs, OpCodesI.OP_JMP, 0, NO_JUMP);\n    j = luaK_concat(fs, j, jpc);  /* keep them on hold */\n    return j;\n};\n\nconst luaK_jumpto = function(fs, t) {\n    return luaK_patchlist(fs, luaK_jump(fs), t);\n};\n\n/*\n** Code a 'return' instruction\n*/\nconst luaK_ret = function(fs, first, nret) {\n    luaK_codeABC(fs, OpCodesI.OP_RETURN, first, nret + 1, 0);\n};\n\n/*\n** Code a \"conditional jump\", that is, a test or comparison opcode\n** followed by a jump. Return jump position.\n*/\nconst condjump = function(fs, op, A, B, C) {\n    luaK_codeABC(fs, op, A, B, C);\n    return luaK_jump(fs);\n};\n\n/*\n** returns current 'pc' and marks it as a jump target (to avoid wrong\n** optimizations with consecutive instructions not in the same basic block).\n*/\nconst luaK_getlabel = function(fs) {\n    fs.lasttarget = fs.pc;\n    return fs.pc;\n};\n\n/*\n** Returns the position of the instruction \"controlling\" a given\n** jump (that is, its condition), or the jump itself if it is\n** unconditional.\n*/\nconst getjumpcontroloffset = function(fs, pc) {\n    if (pc >= 1 && lopcodes.testTMode(fs.f.code[pc - 1].opcode))\n        return pc - 1;\n    else\n        return pc;\n};\nconst getjumpcontrol = function(fs, pc) {\n    return fs.f.code[getjumpcontroloffset(fs, pc)];\n};\n\n/*\n** Patch destination register for a TESTSET instruction.\n** If instruction in position 'node' is not a TESTSET, return 0 (\"fails\").\n** Otherwise, if 'reg' is not 'NO_REG', set it as the destination\n** register. Otherwise, change instruction to a simple 'TEST' (produces\n** no register value)\n*/\nconst patchtestreg = function(fs, node, reg) {\n    let pc = getjumpcontroloffset(fs, node);\n    let i = fs.f.code[pc];\n    if (i.opcode !== OpCodesI.OP_TESTSET)\n        return false;  /* cannot patch other instructions */\n    if (reg !== lopcodes.NO_REG && reg !== i.B)\n        lopcodes.SETARG_A(i, reg);\n    else {\n        /* no register to put value or register already has the value;\n           change instruction to simple test */\n        fs.f.code[pc] = lopcodes.CREATE_ABC(OpCodesI.OP_TEST, i.B, 0, i.C);\n    }\n    return true;\n};\n\n/*\n** Traverse a list of tests ensuring no one produces a value\n*/\nconst removevalues = function(fs, list) {\n    for (; list !== NO_JUMP; list = getjump(fs, list))\n        patchtestreg(fs, list, lopcodes.NO_REG);\n};\n\n/*\n** Traverse a list of tests, patching their destination address and\n** registers: tests producing values jump to 'vtarget' (and put their\n** values in 'reg'), other tests jump to 'dtarget'.\n*/\nconst patchlistaux = function(fs, list, vtarget, reg, dtarget) {\n    while (list !== NO_JUMP) {\n        let next = getjump(fs, list);\n        if (patchtestreg(fs, list, reg))\n            fixjump(fs, list, vtarget);\n        else\n            fixjump(fs, list, dtarget);  /* jump to default target */\n        list = next;\n    }\n};\n\n/*\n** Ensure all pending jumps to current position are fixed (jumping\n** to current position with no values) and reset list of pending\n** jumps\n*/\nconst dischargejpc = function(fs) {\n    patchlistaux(fs, fs.jpc, fs.pc, lopcodes.NO_REG, fs.pc);\n    fs.jpc = NO_JUMP;\n};\n\n/*\n** Add elements in 'list' to list of pending jumps to \"here\"\n** (current position)\n*/\nconst luaK_patchtohere = function(fs, list) {\n    luaK_getlabel(fs);  /* mark \"here\" as a jump target */\n    fs.jpc = luaK_concat(fs, fs.jpc, list);\n};\n\n/*\n** Path all jumps in 'list' to jump to 'target'.\n** (The assert means that we cannot fix a jump to a forward address\n** because we only know addresses once code is generated.)\n*/\nconst luaK_patchlist = function(fs, list, target) {\n    if (target === fs.pc)  /* 'target' is current position? */\n        luaK_patchtohere(fs, list);  /* add list to pending jumps */\n    else {\n        lua_assert(target < fs.pc);\n        patchlistaux(fs, list, target, lopcodes.NO_REG, target);\n    }\n};\n\n/*\n** Path all jumps in 'list' to close upvalues up to given 'level'\n** (The assertion checks that jumps either were closing nothing\n** or were closing higher levels, from inner blocks.)\n*/\nconst luaK_patchclose = function(fs, list, level) {\n    level++;  /* argument is +1 to reserve 0 as non-op */\n    for (; list !== NO_JUMP; list = getjump(fs, list)) {\n        let ins = fs.f.code[list];\n        lua_assert(ins.opcode === OpCodesI.OP_JMP && (ins.A === 0 || ins.A >= level));\n        lopcodes.SETARG_A(ins, level);\n    }\n};\n\n/*\n** Emit instruction 'i', checking for array sizes and saving also its\n** line information. Return 'i' position.\n*/\nconst luaK_code = function(fs, i) {\n    let f = fs.f;\n    dischargejpc(fs);  /* 'pc' will change */\n    /* put new instruction in code array */\n    f.code[fs.pc] = i;\n    f.lineinfo[fs.pc] = fs.ls.lastline;\n    return fs.pc++;\n};\n\n/*\n** Format and emit an 'iABC' instruction. (Assertions check consistency\n** of parameters versus opcode.)\n*/\nconst luaK_codeABC = function(fs, o, a, b, c) {\n    lua_assert(lopcodes.getOpMode(o) === lopcodes.iABC);\n    lua_assert(lopcodes.getBMode(o) !== lopcodes.OpArgN || b === 0);\n    lua_assert(lopcodes.getCMode(o) !== lopcodes.OpArgN || c === 0);\n    lua_assert(a <= lopcodes.MAXARG_A && b <= lopcodes.MAXARG_B && c <= lopcodes.MAXARG_C);\n    return luaK_code(fs, lopcodes.CREATE_ABC(o, a, b, c));\n};\n\n/*\n** Format and emit an 'iABx' instruction.\n*/\nconst luaK_codeABx = function(fs, o, a, bc) {\n    lua_assert(lopcodes.getOpMode(o) === lopcodes.iABx || lopcodes.getOpMode(o) === lopcodes.iAsBx);\n    lua_assert(lopcodes.getCMode(o) === lopcodes.OpArgN);\n    lua_assert(a <= lopcodes.MAXARG_A && bc <= lopcodes.MAXARG_Bx);\n    return luaK_code(fs, lopcodes.CREATE_ABx(o, a, bc));\n};\n\nconst luaK_codeAsBx = function(fs,o,A,sBx) {\n    return luaK_codeABx(fs, o, A, (sBx) + lopcodes.MAXARG_sBx);\n};\n\n/*\n** Emit an \"extra argument\" instruction (format 'iAx')\n*/\nconst codeextraarg = function(fs, a) {\n    lua_assert(a <= lopcodes.MAXARG_Ax);\n    return luaK_code(fs, lopcodes.CREATE_Ax(OpCodesI.OP_EXTRAARG, a));\n};\n\n/*\n** Emit a \"load constant\" instruction, using either 'OP_LOADK'\n** (if constant index 'k' fits in 18 bits) or an 'OP_LOADKX'\n** instruction with \"extra argument\".\n*/\nconst luaK_codek = function(fs, reg, k) {\n    if (k <= lopcodes.MAXARG_Bx)\n        return luaK_codeABx(fs, OpCodesI.OP_LOADK, reg, k);\n    else {\n        let p = luaK_codeABx(fs, OpCodesI.OP_LOADKX, reg, 0);\n        codeextraarg(fs, k);\n        return p;\n    }\n};\n\n/*\n** Check register-stack level, keeping track of its maximum size\n** in field 'maxstacksize'\n*/\nconst luaK_checkstack = function(fs, n) {\n    let newstack = fs.freereg + n;\n    if (newstack > fs.f.maxstacksize) {\n        if (newstack >= MAXREGS)\n            llex.luaX_syntaxerror(fs.ls, to_luastring(\"function or expression needs too many registers\", true));\n        fs.f.maxstacksize = newstack;\n    }\n};\n\n/*\n** Reserve 'n' registers in register stack\n*/\nconst luaK_reserveregs = function(fs, n) {\n    luaK_checkstack(fs, n);\n    fs.freereg += n;\n};\n\n/*\n** Free register 'reg', if it is neither a constant index nor\n** a local variable.\n*/\nconst freereg = function(fs, reg) {\n    if (!lopcodes.ISK(reg) && reg >= fs.nactvar) {\n        fs.freereg--;\n        lua_assert(reg === fs.freereg);\n    }\n};\n\n/*\n** Free register used by expression 'e' (if any)\n*/\nconst freeexp = function(fs, e) {\n    if (e.k === lparser.expkind.VNONRELOC)\n        freereg(fs, e.u.info);\n};\n\n/*\n** Free registers used by expressions 'e1' and 'e2' (if any) in proper\n** order.\n*/\nconst freeexps = function(fs, e1, e2) {\n    let r1 = (e1.k === lparser.expkind.VNONRELOC) ? e1.u.info : -1;\n    let r2 = (e2.k === lparser.expkind.VNONRELOC) ? e2.u.info : -1;\n    if (r1 > r2) {\n        freereg(fs, r1);\n        freereg(fs, r2);\n    }\n    else {\n        freereg(fs, r2);\n        freereg(fs, r1);\n    }\n};\n\n\n/*\n** Add constant 'v' to prototype's list of constants (field 'k').\n** Use scanner's table to cache position of constants in constant list\n** and try to reuse constants. Because some values should not be used\n** as keys (nil cannot be a key, integer keys can collapse with float\n** keys), the caller must provide a useful 'key' for indexing the cache.\n*/\nconst addk = function(fs, key, v) {\n    let f = fs.f;\n    let idx = ltable.luaH_get(fs.L, fs.ls.h, key);  /* index scanner table */\n    if (idx.ttisinteger()) {  /* is there an index there? */\n        let k = idx.value;\n        /* correct value? (warning: must distinguish floats from integers!) */\n        if (k < fs.nk && f.k[k].ttype() === v.ttype() && f.k[k].value === v.value)\n            return k;  /* reuse index */\n    }\n    /* constant not found; create a new entry */\n    let k = fs.nk;\n    ltable.luaH_setfrom(fs.L, fs.ls.h, key, new lobject.TValue(LUA_TNUMINT, k));\n    f.k[k] = v;\n    fs.nk++;\n    return k;\n};\n\n/*\n** Add a string to list of constants and return its index.\n*/\nconst luaK_stringK = function(fs, s) {\n    let o = new TValue(LUA_TLNGSTR, s);\n    return addk(fs, o, o);  /* use string itself as key */\n};\n\n\n/*\n** Add an integer to list of constants and return its index.\n** Integers use userdata as keys to avoid collision with floats with\n** same value.\n*/\nconst luaK_intK = function(fs, n) {\n    let k = new TValue(LUA_TLIGHTUSERDATA, n);\n    let o = new TValue(LUA_TNUMINT, n);\n    return addk(fs, k, o);\n};\n\n/*\n** Add a float to list of constants and return its index.\n*/\nconst luaK_numberK = function(fs, r) {\n    let o = new TValue(LUA_TNUMFLT, r);\n    return addk(fs, o, o);  /* use number itself as key */\n};\n\n\n/*\n** Add a boolean to list of constants and return its index.\n*/\nconst boolK = function(fs, b) {\n    let o = new TValue(LUA_TBOOLEAN, b);\n    return addk(fs, o, o);  /* use boolean itself as key */\n};\n\n\n/*\n** Add nil to list of constants and return its index.\n*/\nconst nilK = function(fs) {\n    let v = new TValue(LUA_TNIL, null);\n    let k = new TValue(LUA_TTABLE, fs.ls.h);\n    /* cannot use nil as key; instead use table itself to represent nil */\n    return addk(fs, k, v);\n};\n\n/*\n** Fix an expression to return the number of results 'nresults'.\n** Either 'e' is a multi-ret expression (function call or vararg)\n** or 'nresults' is LUA_MULTRET (as any expression can satisfy that).\n*/\nconst luaK_setreturns = function(fs, e, nresults) {\n    let ek = lparser.expkind;\n    if (e.k === ek.VCALL) {  /* expression is an open function call? */\n        lopcodes.SETARG_C(getinstruction(fs, e), nresults + 1);\n    }\n    else if (e.k === ek.VVARARG) {\n        let pc = getinstruction(fs, e);\n        lopcodes.SETARG_B(pc, nresults + 1);\n        lopcodes.SETARG_A(pc, fs.freereg);\n        luaK_reserveregs(fs, 1);\n    }\n    else lua_assert(nresults === LUA_MULTRET);\n};\n\nconst luaK_setmultret = function(fs, e) {\n    luaK_setreturns(fs, e, LUA_MULTRET);\n};\n\n/*\n** Fix an expression to return one result.\n** If expression is not a multi-ret expression (function call or\n** vararg), it already returns one result, so nothing needs to be done.\n** Function calls become VNONRELOC expressions (as its result comes\n** fixed in the base register of the call), while vararg expressions\n** become VRELOCABLE (as OP_VARARG puts its results where it wants).\n** (Calls are created returning one result, so that does not need\n** to be fixed.)\n*/\nconst luaK_setoneret = function(fs, e) {\n    let ek = lparser.expkind;\n    if (e.k === ek.VCALL) {  /* expression is an open function call? */\n        /* already returns 1 value */\n        lua_assert(getinstruction(fs, e).C === 2);\n        e.k = ek.VNONRELOC;  /* result has fixed position */\n        e.u.info = getinstruction(fs, e).A;\n    } else if (e.k === ek.VVARARG) {\n        lopcodes.SETARG_B(getinstruction(fs, e), 2);\n        e.k = ek.VRELOCABLE;  /* can relocate its simple result */\n    }\n};\n\n/*\n** Ensure that expression 'e' is not a variable.\n*/\nconst luaK_dischargevars = function(fs, e) {\n    let ek = lparser.expkind;\n\n    switch (e.k) {\n        case ek.VLOCAL: {  /* already in a register */\n            e.k =  ek.VNONRELOC;  /* becomes a non-relocatable value */\n            break;\n        }\n        case ek.VUPVAL: {  /* move value to some (pending) register */\n            e.u.info = luaK_codeABC(fs, OpCodesI.OP_GETUPVAL, 0, e.u.info, 0);\n            e.k = ek.VRELOCABLE;\n            break;\n        }\n        case ek.VINDEXED: {\n            let op;\n            freereg(fs, e.u.ind.idx);\n            if (e.u.ind.vt === ek.VLOCAL) {  /* is 't' in a register? */\n                freereg(fs, e.u.ind.t);\n                op = OpCodesI.OP_GETTABLE;\n            } else {\n                lua_assert(e.u.ind.vt === ek.VUPVAL);\n                op = OpCodesI.OP_GETTABUP;  /* 't' is in an upvalue */\n            }\n            e.u.info = luaK_codeABC(fs, op, 0, e.u.ind.t, e.u.ind.idx);\n            e.k = ek.VRELOCABLE;\n            break;\n        }\n        case ek.VVARARG: case ek.VCALL: {\n            luaK_setoneret(fs, e);\n            break;\n        }\n        default: break;  /* there is one value available (somewhere) */\n    }\n};\n\nconst code_loadbool = function(fs, A, b, jump) {\n    luaK_getlabel(fs);  /* those instructions may be jump targets */\n    return luaK_codeABC(fs, OpCodesI.OP_LOADBOOL, A, b, jump);\n};\n\n/*\n** Ensures expression value is in register 'reg' (and therefore\n** 'e' will become a non-relocatable expression).\n*/\nconst discharge2reg = function(fs, e, reg) {\n    let ek = lparser.expkind;\n    luaK_dischargevars(fs, e);\n    switch (e.k) {\n        case ek.VNIL: {\n            luaK_nil(fs, reg, 1);\n            break;\n        }\n        case ek.VFALSE: case ek.VTRUE: {\n            luaK_codeABC(fs, OpCodesI.OP_LOADBOOL, reg, e.k === ek.VTRUE, 0);\n            break;\n        }\n        case ek.VK: {\n            luaK_codek(fs, reg, e.u.info);\n            break;\n        }\n        case ek.VKFLT: {\n            luaK_codek(fs, reg, luaK_numberK(fs, e.u.nval));\n            break;\n        }\n        case ek.VKINT: {\n            luaK_codek(fs, reg, luaK_intK(fs, e.u.ival));\n            break;\n        }\n        case ek.VRELOCABLE: {\n            let pc = getinstruction(fs, e);\n            lopcodes.SETARG_A(pc, reg);  /* instruction will put result in 'reg' */\n            break;\n        }\n        case ek.VNONRELOC: {\n            if (reg !== e.u.info)\n                luaK_codeABC(fs, OpCodesI.OP_MOVE, reg, e.u.info, 0);\n            break;\n        }\n        default: {\n            lua_assert(e.k === ek.VJMP);\n            return;  /* nothing to do... */\n        }\n    }\n    e.u.info = reg;\n    e.k = ek.VNONRELOC;\n};\n\n/*\n** Ensures expression value is in any register.\n*/\nconst discharge2anyreg = function(fs, e) {\n    if (e.k !== lparser.expkind.VNONRELOC) {  /* no fixed register yet? */\n        luaK_reserveregs(fs, 1);  /* get a register */\n        discharge2reg(fs, e, fs.freereg-1);  /* put value there */\n    }\n};\n\n/*\n** check whether list has any jump that do not produce a value\n** or produce an inverted value\n*/\nconst need_value = function(fs, list) {\n    for (; list !== NO_JUMP; list = getjump(fs, list)) {\n        let i = getjumpcontrol(fs, list);\n        if (i.opcode !== OpCodesI.OP_TESTSET) return true;\n    }\n    return false;  /* not found */\n};\n\n/*\n** Ensures final expression result (including results from its jump\n** lists) is in register 'reg'.\n** If expression has jumps, need to patch these jumps either to\n** its final position or to \"load\" instructions (for those tests\n** that do not produce values).\n*/\nconst exp2reg = function(fs, e, reg) {\n    let ek = lparser.expkind;\n    discharge2reg(fs, e, reg);\n    if (e.k === ek.VJMP)  /* expression itself is a test? */\n        e.t = luaK_concat(fs, e.t, e.u.info);  /* put this jump in 't' list */\n    if (hasjumps(e)) {\n        let final;  /* position after whole expression */\n        let p_f = NO_JUMP;  /* position of an eventual LOAD false */\n        let p_t = NO_JUMP;  /* position of an eventual LOAD true */\n        if (need_value(fs, e.t) || need_value(fs, e.f)) {\n            let fj = (e.k === ek.VJMP) ? NO_JUMP : luaK_jump(fs);\n            p_f = code_loadbool(fs, reg, 0, 1);\n            p_t = code_loadbool(fs, reg, 1, 0);\n            luaK_patchtohere(fs, fj);\n        }\n        final = luaK_getlabel(fs);\n        patchlistaux(fs, e.f, final, reg, p_f);\n        patchlistaux(fs, e.t, final, reg, p_t);\n    }\n    e.f = e.t = NO_JUMP;\n    e.u.info = reg;\n    e.k = ek.VNONRELOC;\n};\n\n/*\n** Ensures final expression result (including results from its jump\n** lists) is in next available register.\n*/\nconst luaK_exp2nextreg = function(fs, e) {\n    luaK_dischargevars(fs, e);\n    freeexp(fs, e);\n    luaK_reserveregs(fs, 1);\n    exp2reg(fs, e, fs.freereg - 1);\n};\n\n\n/*\n** Ensures final expression result (including results from its jump\n** lists) is in some (any) register and return that register.\n*/\nconst luaK_exp2anyreg = function(fs, e) {\n    luaK_dischargevars(fs, e);\n    if (e.k === lparser.expkind.VNONRELOC) {  /* expression already has a register? */\n        if (!hasjumps(e))  /* no jumps? */\n            return e.u.info;  /* result is already in a register */\n        if (e.u.info >= fs.nactvar) {  /* reg. is not a local? */\n            exp2reg(fs, e, e.u.info);  /* put final result in it */\n            return e.u.info;\n        }\n    }\n    luaK_exp2nextreg(fs, e);  /* otherwise, use next available register */\n    return e.u.info;\n};\n\n/*\n** Ensures final expression result is either in a register or in an\n** upvalue.\n*/\nconst luaK_exp2anyregup = function(fs, e) {\n    if (e.k !== lparser.expkind.VUPVAL || hasjumps(e))\n        luaK_exp2anyreg(fs, e);\n};\n\n/*\n** Ensures final expression result is either in a register or it is\n** a constant.\n*/\nconst luaK_exp2val = function(fs, e) {\n    if (hasjumps(e))\n        luaK_exp2anyreg(fs, e);\n    else\n        luaK_dischargevars(fs, e);\n};\n\n/*\n** Ensures final expression result is in a valid R/K index\n** (that is, it is either in a register or in 'k' with an index\n** in the range of R/K indices).\n** Returns R/K index.\n*/\nconst luaK_exp2RK = function(fs, e) {\n    let ek = lparser.expkind;\n    let vk = false;\n    luaK_exp2val(fs, e);\n    switch (e.k) {  /* move constants to 'k' */\n        case ek.VTRUE: e.u.info = boolK(fs, true); vk = true; break;\n        case ek.VFALSE: e.u.info = boolK(fs, false); vk = true; break;\n        case ek.VNIL: e.u.info = nilK(fs); vk = true; break;\n        case ek.VKINT: e.u.info = luaK_intK(fs, e.u.ival); vk = true; break;\n        case ek.VKFLT: e.u.info = luaK_numberK(fs, e.u.nval); vk = true; break;\n        case ek.VK: vk = true; break;\n        default: break;\n    }\n\n    if (vk) {\n        e.k = ek.VK;\n        if (e.u.info <= lopcodes.MAXINDEXRK)  /* constant fits in 'argC'? */\n            return lopcodes.RKASK(e.u.info);\n    }\n\n    /* not a constant in the right range: put it in a register */\n    return luaK_exp2anyreg(fs, e);\n};\n\n/*\n** Generate code to store result of expression 'ex' into variable 'var'.\n*/\nconst luaK_storevar = function(fs, vr, ex) {\n    let ek = lparser.expkind;\n    switch (vr.k) {\n        case ek.VLOCAL: {\n            freeexp(fs, ex);\n            exp2reg(fs, ex, vr.u.info);  /* compute 'ex' into proper place */\n            return;\n        }\n        case ek.VUPVAL: {\n            let e = luaK_exp2anyreg(fs, ex);\n            luaK_codeABC(fs, OpCodesI.OP_SETUPVAL, e, vr.u.info, 0);\n            break;\n        }\n        case ek.VINDEXED: {\n            let op = (vr.u.ind.vt === ek.VLOCAL) ? OpCodesI.OP_SETTABLE : OpCodesI.OP_SETTABUP;\n            let e = luaK_exp2RK(fs, ex);\n            luaK_codeABC(fs, op, vr.u.ind.t, vr.u.ind.idx, e);\n            break;\n        }\n    }\n    freeexp(fs, ex);\n};\n\n\n/*\n** Emit SELF instruction (convert expression 'e' into 'e:key(e,').\n*/\nconst luaK_self = function(fs, e, key) {\n    luaK_exp2anyreg(fs, e);\n    let ereg = e.u.info;  /* register where 'e' was placed */\n    freeexp(fs, e);\n    e.u.info = fs.freereg;  /* base register for op_self */\n    e.k = lparser.expkind.VNONRELOC;  /* self expression has a fixed register */\n    luaK_reserveregs(fs, 2);  /* function and 'self' produced by op_self */\n    luaK_codeABC(fs, OpCodesI.OP_SELF, e.u.info, ereg, luaK_exp2RK(fs, key));\n    freeexp(fs, key);\n};\n\n/*\n** Negate condition 'e' (where 'e' is a comparison).\n*/\nconst negatecondition = function(fs, e) {\n    let pc = getjumpcontrol(fs, e.u.info);\n    lua_assert(lopcodes.testTMode(pc.opcode) && pc.opcode !== OpCodesI.OP_TESTSET && pc.opcode !== OpCodesI.OP_TEST);\n    lopcodes.SETARG_A(pc, !(pc.A));\n};\n\n/*\n** Emit instruction to jump if 'e' is 'cond' (that is, if 'cond'\n** is true, code will jump if 'e' is true.) Return jump position.\n** Optimize when 'e' is 'not' something, inverting the condition\n** and removing the 'not'.\n*/\nconst jumponcond = function(fs, e, cond) {\n    if (e.k === lparser.expkind.VRELOCABLE) {\n        let ie = getinstruction(fs, e);\n        if (ie.opcode === OpCodesI.OP_NOT) {\n            fs.pc--;  /* remove previous OP_NOT */\n            return condjump(fs, OpCodesI.OP_TEST, ie.B, 0, !cond);\n        }\n        /* else go through */\n    }\n    discharge2anyreg(fs, e);\n    freeexp(fs, e);\n    return condjump(fs, OpCodesI.OP_TESTSET, lopcodes.NO_REG, e.u.info, cond);\n};\n\n/*\n** Emit code to go through if 'e' is true, jump otherwise.\n*/\nconst luaK_goiftrue = function(fs, e) {\n    let ek = lparser.expkind;\n    let pc;  /* pc of new jump */\n    luaK_dischargevars(fs, e);\n    switch (e.k) {\n        case ek.VJMP: {  /* condition? */\n            negatecondition(fs, e);  /* jump when it is false */\n            pc = e.u.info;  /* save jump position */\n            break;\n        }\n        case ek.VK: case ek.VKFLT: case ek.VKINT: case ek.VTRUE: {\n            pc = NO_JUMP;  /* always true; do nothing */\n            break;\n        }\n        default: {\n            pc = jumponcond(fs, e, 0);  /* jump when false */\n            break;\n        }\n    }\n    e.f = luaK_concat(fs, e.f, pc);  /* insert new jump in false list */\n    luaK_patchtohere(fs, e.t);  /* true list jumps to here (to go through) */\n    e.t = NO_JUMP;\n};\n\n/*\n** Emit code to go through if 'e' is false, jump otherwise.\n*/\nconst luaK_goiffalse = function(fs, e) {\n    let ek = lparser.expkind;\n    let pc;  /* pc of new jump */\n    luaK_dischargevars(fs, e);\n    switch (e.k) {\n        case ek.VJMP: {\n            pc = e.u.info;  /* already jump if true */\n            break;\n        }\n        case ek.VNIL: case ek.VFALSE: {\n            pc = NO_JUMP;  /* always false; do nothing */\n            break;\n        }\n        default: {\n            pc = jumponcond(fs, e, 1);  /* jump if true */\n            break;\n        }\n    }\n    e.t = luaK_concat(fs, e.t, pc);  /* insert new jump in 't' list */\n    luaK_patchtohere(fs, e.f);  /* false list jumps to here (to go through) */\n    e.f = NO_JUMP;\n};\n\n/*\n** Code 'not e', doing constant folding.\n*/\nconst codenot = function(fs, e) {\n    let ek = lparser.expkind;\n    luaK_dischargevars(fs, e);\n    switch (e.k) {\n        case ek.VNIL: case ek.VFALSE: {\n            e.k = ek.VTRUE;  /* true === not nil === not false */\n            break;\n        }\n        case ek.VK: case ek.VKFLT: case ek.VKINT: case ek.VTRUE: {\n            e.k = ek.VFALSE;  /* false === not \"x\" === not 0.5 === not 1 === not true */\n            break;\n        }\n        case ek.VJMP: {\n            negatecondition(fs, e);\n            break;\n        }\n        case ek.VRELOCABLE:\n        case ek.VNONRELOC: {\n            discharge2anyreg(fs, e);\n            freeexp(fs, e);\n            e.u.info = luaK_codeABC(fs, OpCodesI.OP_NOT, 0, e.u.info, 0);\n            e.k = ek.VRELOCABLE;\n            break;\n        }\n    }\n    /* interchange true and false lists */\n    { let temp = e.f; e.f = e.t; e.t = temp; }\n    removevalues(fs, e.f);  /* values are useless when negated */\n    removevalues(fs, e.t);\n};\n\n/*\n** Create expression 't[k]'. 't' must have its final result already in a\n** register or upvalue.\n*/\nconst luaK_indexed = function(fs, t, k) {\n    let ek = lparser.expkind;\n    lua_assert(!hasjumps(t) && (lparser.vkisinreg(t.k) || t.k === ek.VUPVAL));\n    t.u.ind.t = t.u.info;  /* register or upvalue index */\n    t.u.ind.idx = luaK_exp2RK(fs, k);  /* R/K index for key */\n    t.u.ind.vt = (t.k === ek.VUPVAL) ? ek.VUPVAL : ek.VLOCAL;\n    t.k = ek.VINDEXED;\n};\n\n/*\n** Return false if folding can raise an error.\n** Bitwise operations need operands convertible to integers; division\n** operations cannot have 0 as divisor.\n*/\nconst validop = function(op, v1, v2) {\n    switch (op) {\n        case LUA_OPBAND: case LUA_OPBOR: case LUA_OPBXOR:\n        case LUA_OPSHL: case LUA_OPSHR: case LUA_OPBNOT: {  /* conversion errors */\n            return (lvm.tointeger(v1) !== false && lvm.tointeger(v2) !== false);\n        }\n        case LUA_OPDIV: case LUA_OPIDIV: case LUA_OPMOD:  /* division by 0 */\n            return (v2.value !== 0);\n        default: return 1;  /* everything else is valid */\n    }\n};\n\n/*\n** Try to \"constant-fold\" an operation; return 1 iff successful.\n** (In this case, 'e1' has the final result.)\n*/\nconst constfolding = function(op, e1, e2) {\n    let ek = lparser.expkind;\n    let v1, v2;\n    if (!(v1 = tonumeral(e1, true)) || !(v2 = tonumeral(e2, true)) || !validop(op, v1, v2))\n        return 0;  /* non-numeric operands or not safe to fold */\n    let res = new TValue(); /* FIXME */\n    lobject.luaO_arith(null, op, v1, v2, res);  /* does operation */\n    if (res.ttisinteger()) {\n        e1.k = ek.VKINT;\n        e1.u.ival = res.value;\n    }\n    else {  /* folds neither NaN nor 0.0 (to avoid problems with -0.0) */\n        let n = res.value;\n        if (isNaN(n) || n === 0)\n            return false;\n        e1.k = ek.VKFLT;\n        e1.u.nval = n;\n    }\n    return true;\n};\n\n/*\n** Emit code for unary expressions that \"produce values\"\n** (everything but 'not').\n** Expression to produce final result will be encoded in 'e'.\n*/\nconst codeunexpval = function(fs, op, e, line) {\n    let r = luaK_exp2anyreg(fs, e);  /* opcodes operate only on registers */\n    freeexp(fs, e);\n    e.u.info = luaK_codeABC(fs, op, 0, r, 0);  /* generate opcode */\n    e.k = lparser.expkind.VRELOCABLE;  /* all those operations are relocatable */\n    luaK_fixline(fs, line);\n};\n\n/*\n** Emit code for binary expressions that \"produce values\"\n** (everything but logical operators 'and'/'or' and comparison\n** operators).\n** Expression to produce final result will be encoded in 'e1'.\n** Because 'luaK_exp2RK' can free registers, its calls must be\n** in \"stack order\" (that is, first on 'e2', which may have more\n** recent registers to be released).\n*/\nconst codebinexpval = function(fs, op, e1, e2, line) {\n    let rk2 = luaK_exp2RK(fs, e2);  /* both operands are \"RK\" */\n    let rk1 = luaK_exp2RK(fs, e1);\n    freeexps(fs, e1, e2);\n    e1.u.info = luaK_codeABC(fs, op, 0, rk1, rk2);  /* generate opcode */\n    e1.k = lparser.expkind.VRELOCABLE;  /* all those operations are relocatable */\n    luaK_fixline(fs, line);\n};\n\n\n/*\n** Emit code for comparisons.\n** 'e1' was already put in R/K form by 'luaK_infix'.\n*/\nconst codecomp = function(fs, opr, e1, e2) {\n    let ek = lparser.expkind;\n\n    let rk1;\n    if (e1.k === ek.VK)\n        rk1 = lopcodes.RKASK(e1.u.info);\n    else {\n        lua_assert(e1.k === ek.VNONRELOC);\n        rk1 = e1.u.info;\n    }\n\n    let rk2 = luaK_exp2RK(fs, e2);\n    freeexps(fs, e1, e2);\n    switch (opr) {\n        case BinOpr.OPR_NE: {  /* '(a ~= b)' ==> 'not (a === b)' */\n            e1.u.info = condjump(fs, OpCodesI.OP_EQ, 0, rk1, rk2);\n            break;\n        }\n        case BinOpr.OPR_GT: case BinOpr.OPR_GE: {\n            /* '(a > b)' ==> '(b < a)';  '(a >= b)' ==> '(b <= a)' */\n            let op = (opr - BinOpr.OPR_NE) + OpCodesI.OP_EQ;\n            e1.u.info = condjump(fs, op, 1, rk2, rk1);  /* invert operands */\n            break;\n        }\n        default: {  /* '==', '<', '<=' use their own opcodes */\n            let op = (opr - BinOpr.OPR_EQ) + OpCodesI.OP_EQ;\n            e1.u.info = condjump(fs, op, 1, rk1, rk2);\n            break;\n        }\n    }\n    e1.k = ek.VJMP;\n};\n\n/*\n** Apply prefix operation 'op' to expression 'e'.\n*/\nconst luaK_prefix = function(fs, op, e, line) {\n    let ef = new lparser.expdesc();\n    ef.k = lparser.expkind.VKINT;\n    ef.u.ival = ef.u.nval = ef.u.info = 0;\n    ef.t = NO_JUMP;\n    ef.f = NO_JUMP;\n    switch (op) {\n        case UnOpr.OPR_MINUS: case UnOpr.OPR_BNOT:  /* use 'ef' as fake 2nd operand */\n            if (constfolding(op + LUA_OPUNM, e, ef))\n                break;\n            /* FALLTHROUGH */\n        case UnOpr.OPR_LEN:\n            codeunexpval(fs, op + OpCodesI.OP_UNM, e, line);\n            break;\n        case UnOpr.OPR_NOT: codenot(fs, e); break;\n    }\n};\n\n/*\n** Process 1st operand 'v' of binary operation 'op' before reading\n** 2nd operand.\n*/\nconst luaK_infix = function(fs, op, v) {\n    switch (op) {\n        case BinOpr.OPR_AND: {\n            luaK_goiftrue(fs, v);  /* go ahead only if 'v' is true */\n            break;\n        }\n        case BinOpr.OPR_OR: {\n            luaK_goiffalse(fs, v);  /* go ahead only if 'v' is false */\n            break;\n        }\n        case BinOpr.OPR_CONCAT: {\n            luaK_exp2nextreg(fs, v);  /* operand must be on the 'stack' */\n            break;\n        }\n        case BinOpr.OPR_ADD: case BinOpr.OPR_SUB:\n        case BinOpr.OPR_MUL: case BinOpr.OPR_DIV: case BinOpr.OPR_IDIV:\n        case BinOpr.OPR_MOD: case BinOpr.OPR_POW:\n        case BinOpr.OPR_BAND: case BinOpr.OPR_BOR: case BinOpr.OPR_BXOR:\n        case BinOpr.OPR_SHL: case BinOpr.OPR_SHR: {\n            if (!tonumeral(v, false))\n                luaK_exp2RK(fs, v);\n            /* else keep numeral, which may be folded with 2nd operand */\n            break;\n        }\n        default: {\n            luaK_exp2RK(fs, v);\n            break;\n        }\n    }\n};\n\n/*\n** Finalize code for binary operation, after reading 2nd operand.\n** For '(a .. b .. c)' (which is '(a .. (b .. c))', because\n** concatenation is right associative), merge second CONCAT into first\n** one.\n*/\nconst luaK_posfix = function(fs, op, e1, e2, line) {\n    let ek = lparser.expkind;\n    switch (op) {\n        case BinOpr.OPR_AND: {\n            lua_assert(e1.t === NO_JUMP);  /* list closed by 'luK_infix' */\n            luaK_dischargevars(fs, e2);\n            e2.f = luaK_concat(fs, e2.f, e1.f);\n            e1.to(e2);\n            break;\n        }\n        case BinOpr.OPR_OR: {\n            lua_assert(e1.f === NO_JUMP);  /* list closed by 'luK_infix' */\n            luaK_dischargevars(fs, e2);\n            e2.t = luaK_concat(fs, e2.t, e1.t);\n            e1.to(e2);\n            break;\n        }\n        case BinOpr.OPR_CONCAT: {\n            luaK_exp2val(fs, e2);\n            let ins = getinstruction(fs, e2);\n            if (e2.k === ek.VRELOCABLE && ins.opcode === OpCodesI.OP_CONCAT) {\n                lua_assert(e1.u.info === ins.B - 1);\n                freeexp(fs, e1);\n                lopcodes.SETARG_B(ins, e1.u.info);\n                e1.k = ek.VRELOCABLE; e1.u.info = e2.u.info;\n            }\n            else {\n                luaK_exp2nextreg(fs, e2);  /* operand must be on the 'stack' */\n                codebinexpval(fs, OpCodesI.OP_CONCAT, e1, e2, line);\n            }\n            break;\n        }\n        case BinOpr.OPR_ADD: case BinOpr.OPR_SUB: case BinOpr.OPR_MUL: case BinOpr.OPR_DIV:\n        case BinOpr.OPR_IDIV: case BinOpr.OPR_MOD: case BinOpr.OPR_POW:\n        case BinOpr.OPR_BAND: case BinOpr.OPR_BOR: case BinOpr.OPR_BXOR:\n        case BinOpr.OPR_SHL: case BinOpr.OPR_SHR: {\n            if (!constfolding(op + LUA_OPADD, e1, e2))\n                codebinexpval(fs, op + OpCodesI.OP_ADD, e1, e2, line);\n            break;\n        }\n        case BinOpr.OPR_EQ: case BinOpr.OPR_LT: case BinOpr.OPR_LE:\n        case BinOpr.OPR_NE: case BinOpr.OPR_GT: case BinOpr.OPR_GE: {\n            codecomp(fs, op, e1, e2);\n            break;\n        }\n    }\n\n    return e1;\n};\n\n/*\n** Change line information associated with current position.\n*/\nconst luaK_fixline = function(fs, line) {\n    fs.f.lineinfo[fs.pc - 1] = line;\n};\n\n/*\n** Emit a SETLIST instruction.\n** 'base' is register that keeps table;\n** 'nelems' is #table plus those to be stored now;\n** 'tostore' is number of values (in registers 'base + 1',...) to add to\n** table (or LUA_MULTRET to add up to stack top).\n*/\nconst luaK_setlist = function(fs, base, nelems, tostore) {\n    let c =  (nelems - 1)/lopcodes.LFIELDS_PER_FLUSH + 1;\n    let b = (tostore === LUA_MULTRET) ? 0 : tostore;\n    lua_assert(tostore !== 0 && tostore <= lopcodes.LFIELDS_PER_FLUSH);\n    if (c <= lopcodes.MAXARG_C)\n        luaK_codeABC(fs, OpCodesI.OP_SETLIST, base, b, c);\n    else if (c <= lopcodes.MAXARG_Ax) {\n        luaK_codeABC(fs, OpCodesI.OP_SETLIST, base, b, 0);\n        codeextraarg(fs, c);\n    }\n    else\n        llex.luaX_syntaxerror(fs.ls, to_luastring(\"constructor too long\", true));\n    fs.freereg = base + 1;  /* free registers with list values */\n};\n\n\nmodule.exports.BinOpr             = BinOpr;\nmodule.exports.NO_JUMP            = NO_JUMP;\nmodule.exports.UnOpr              = UnOpr;\nmodule.exports.getinstruction     = getinstruction;\nmodule.exports.luaK_checkstack    = luaK_checkstack;\nmodule.exports.luaK_code          = luaK_code;\nmodule.exports.luaK_codeABC       = luaK_codeABC;\nmodule.exports.luaK_codeABx       = luaK_codeABx;\nmodule.exports.luaK_codeAsBx      = luaK_codeAsBx;\nmodule.exports.luaK_codek         = luaK_codek;\nmodule.exports.luaK_concat        = luaK_concat;\nmodule.exports.luaK_dischargevars = luaK_dischargevars;\nmodule.exports.luaK_exp2RK        = luaK_exp2RK;\nmodule.exports.luaK_exp2anyreg    = luaK_exp2anyreg;\nmodule.exports.luaK_exp2anyregup  = luaK_exp2anyregup;\nmodule.exports.luaK_exp2nextreg   = luaK_exp2nextreg;\nmodule.exports.luaK_exp2val       = luaK_exp2val;\nmodule.exports.luaK_fixline       = luaK_fixline;\nmodule.exports.luaK_getlabel      = luaK_getlabel;\nmodule.exports.luaK_goiffalse     = luaK_goiffalse;\nmodule.exports.luaK_goiftrue      = luaK_goiftrue;\nmodule.exports.luaK_indexed       = luaK_indexed;\nmodule.exports.luaK_infix         = luaK_infix;\nmodule.exports.luaK_intK          = luaK_intK;\nmodule.exports.luaK_jump          = luaK_jump;\nmodule.exports.luaK_jumpto        = luaK_jumpto;\nmodule.exports.luaK_nil           = luaK_nil;\nmodule.exports.luaK_numberK       = luaK_numberK;\nmodule.exports.luaK_patchclose    = luaK_patchclose;\nmodule.exports.luaK_patchlist     = luaK_patchlist;\nmodule.exports.luaK_patchtohere   = luaK_patchtohere;\nmodule.exports.luaK_posfix        = luaK_posfix;\nmodule.exports.luaK_prefix        = luaK_prefix;\nmodule.exports.luaK_reserveregs   = luaK_reserveregs;\nmodule.exports.luaK_ret           = luaK_ret;\nmodule.exports.luaK_self          = luaK_self;\nmodule.exports.luaK_setlist       = luaK_setlist;\nmodule.exports.luaK_setmultret    = luaK_setmultret;\nmodule.exports.luaK_setoneret     = luaK_setoneret;\nmodule.exports.luaK_setreturns    = luaK_setreturns;\nmodule.exports.luaK_storevar      = luaK_storevar;\nmodule.exports.luaK_stringK       = luaK_stringK;\n", ";\n\nconst {\n    LUA_MULTRET,\n    to_luastring\n} = require('./defs.js');\nconst {\n    BinOpr: {\n        OPR_ADD,\n        OPR_AND,\n        OPR_BAND,\n        OPR_BOR,\n        OPR_BXOR,\n        OPR_CONCAT,\n        OPR_DIV,\n        OPR_EQ,\n        OPR_GE,\n        OPR_GT,\n        OPR_IDIV,\n        OPR_LE,\n        OPR_LT,\n        OPR_MOD,\n        OPR_MUL,\n        OPR_NE,\n        OPR_NOBINOPR,\n        OPR_OR,\n        OPR_POW,\n        OPR_SHL,\n        OPR_SHR,\n        OPR_SUB\n    },\n    UnOpr: {\n        OPR_BNOT,\n        OPR_LEN,\n        OPR_MINUS,\n        OPR_NOT,\n        OPR_NOUNOPR\n    },\n    NO_JUMP,\n    getinstruction,\n    luaK_checkstack,\n    luaK_codeABC,\n    luaK_codeABx,\n    luaK_codeAsBx,\n    luaK_codek,\n    luaK_concat,\n    luaK_dischargevars,\n    luaK_exp2RK,\n    luaK_exp2anyreg,\n    luaK_exp2anyregup,\n    luaK_exp2nextreg,\n    luaK_exp2val,\n    luaK_fixline,\n    luaK_getlabel,\n    luaK_goiffalse,\n    luaK_goiftrue,\n    luaK_indexed,\n    luaK_infix,\n    luaK_intK,\n    luaK_jump,\n    luaK_jumpto,\n    luaK_nil,\n    luaK_patchclose,\n    luaK_patchlist,\n    luaK_patchtohere,\n    luaK_posfix,\n    luaK_prefix,\n    luaK_reserveregs,\n    luaK_ret,\n    luaK_self,\n    luaK_setlist,\n    luaK_setmultret,\n    luaK_setoneret,\n    luaK_setreturns,\n    luaK_storevar,\n    luaK_stringK\n} = require('./lcode.js');\nconst ldo      = require('./ldo.js');\nconst lfunc    = require('./lfunc.js');\nconst llex     = require('./llex.js');\nconst {\n    LUAI_MAXCCALLS,\n    MAX_INT,\n    lua_assert\n}  = require('./llimits.js');\nconst lobject  = require('./lobject.js');\nconst {\n    OpCodesI: {\n        OP_CALL,\n        OP_CLOSURE,\n        OP_FORLOOP,\n        OP_FORPREP,\n        OP_GETUPVAL,\n        OP_MOVE,\n        OP_NEWTABLE,\n        OP_SETTABLE,\n        OP_TAILCALL,\n        OP_TFORCALL,\n        OP_TFORLOOP,\n        OP_VARARG\n    },\n    LFIELDS_PER_FLUSH,\n    SETARG_B,\n    SETARG_C,\n    SET_OPCODE\n} = require('./lopcodes.js');\nconst {\n    luaS_eqlngstr,\n    luaS_new,\n    luaS_newliteral\n} = require('./lstring.js');\nconst ltable   = require('./ltable.js');\nconst Proto    = lfunc.Proto;\nconst R        = llex.RESERVED;\n\nconst MAXVARS = 200;\n\nconst hasmultret = function(k) {\n    return k === expkind.VCALL || k === expkind.VVARARG;\n};\n\nconst eqstr = function(a, b) {\n    /* TODO: use plain equality as strings are cached */\n    return luaS_eqlngstr(a, b);\n};\n\nclass BlockCnt {\n    constructor() {\n        this.previous = null;  /* chain */\n        this.firstlabel = NaN; /* index of first label in this block */\n        this.firstgoto = NaN;  /* index of first pending goto in this block */\n        this.nactvar = NaN;    /* # active locals outside the block */\n        this.upval = NaN;      /* true if some variable in the block is an upvalue */\n        this.isloop = NaN;     /* true if 'block' is a loop */\n    }\n}\n\nconst expkind = {\n    VVOID: 0,        /* when 'expdesc' describes the last expression a list,\n                        this kind means an empty list (so, no expression) */\n    VNIL: 1,         /* constant nil */\n    VTRUE: 2,        /* constant true */\n    VFALSE: 3,       /* constant false */\n    VK: 4,           /* constant in 'k'; info = index of constant in 'k' */\n    VKFLT: 5,        /* floating constant; nval = numerical float value */\n    VKINT: 6,        /* integer constant; nval = numerical integer value */\n    VNONRELOC: 7,    /* expression has its value in a fixed register;\n                        info = result register */\n    VLOCAL: 8,       /* local variable; info = local register */\n    VUPVAL: 9,       /* upvalue variable; info = index of upvalue in 'upvalues' */\n    VINDEXED: 10,    /* indexed variable;\n                        ind.vt = whether 't' is register or upvalue;\n                        ind.t = table register or upvalue;\n                        ind.idx = key's R/K index */\n    VJMP: 11,        /* expression is a test/comparison;\n                        info = pc of corresponding jump instruction */\n    VRELOCABLE: 12,  /* expression can put result in any register;\n                        info = instruction pc */\n    VCALL: 13,       /* expression is a function call; info = instruction pc */\n    VVARARG: 14      /* vararg expression; info = instruction pc */\n};\n\nconst vkisvar = function(k) {\n    return expkind.VLOCAL <= k && k <= expkind.VINDEXED;\n};\n\nconst vkisinreg = function(k) {\n    return k === expkind.VNONRELOC || k === expkind.VLOCAL;\n};\n\nclass expdesc {\n    constructor() {\n        this.k = NaN;\n        this.u = {\n            ival: NaN,    /* for VKINT */\n            nval: NaN,    /* for VKFLT */\n            info: NaN,    /* for generic use */\n            ind: {        /* for indexed variables (VINDEXED) */\n                idx: NaN, /* index (R/K) */\n                t: NaN,   /* table (register or upvalue) */\n                vt: NaN   /* whether 't' is register (VLOCAL) or upvalue (VUPVAL) */\n            }\n        };\n        this.t = NaN;     /* patch list of 'exit when true' */\n        this.f = NaN;     /* patch list of 'exit when false' */\n    }\n\n    to(e) { // Copy e content to this, cf. luaK_posfix\n        this.k = e.k;\n        this.u = e.u;\n        this.t = e.t;\n        this.f = e.f;\n    }\n}\n\nclass FuncState {\n    constructor() {\n        this.f = null;         /* current function header */\n        this.prev = null;      /* enclosing function */\n        this.ls = null;        /* lexical state */\n        this.bl = null;        /* chain of current blocks */\n        this.pc = NaN;         /* next position to code (equivalent to 'ncode') */\n        this.lasttarget = NaN; /* 'label' of last 'jump label' */\n        this.jpc = NaN;        /* list of pending jumps to 'pc' */\n        this.nk = NaN;         /* number of elements in 'k' */\n        this.np = NaN;         /* number of elements in 'p' */\n        this.firstlocal = NaN; /* index of first local var (in Dyndata array) */\n        this.nlocvars = NaN;   /* number of elements in 'f->locvars' */\n        this.nactvar = NaN;    /* number of active local variables */\n        this.nups = NaN;       /* number of upvalues */\n        this.freereg = NaN;    /* first free register */\n    }\n}\n\n/* description of active local variable */\nclass Vardesc {\n    constructor() {\n        this.idx = NaN;  /* variable index in stack */\n    }\n}\n\n\n/* description of pending goto statements and label statements */\nclass Labeldesc {\n    constructor() {\n        this.name = null;  /* label identifier */\n        this.pc = NaN;  /* position in code */\n        this.line = NaN;  /* line where it appeared */\n        this.nactvar = NaN;  /* local level where it appears in current block */\n    }\n}\n\n\n/* list of labels or gotos */\nclass Labellist {\n    constructor() {\n        this.arr = []; /* array */\n        this.n = NaN;  /* number of entries in use */\n        this.size = NaN;  /* array size */\n    }\n}\n\n/* dynamic structures used by the parser */\nclass Dyndata {\n    constructor() {\n        this.actvar = {  /* list of active local variables */\n            arr: [],\n            n: NaN,\n            size: NaN\n        };\n        this.gt = new Labellist();\n        this.label = new Labellist();\n    }\n}\n\nconst semerror = function(ls, msg) {\n    ls.t.token = 0;  /* remove \"near <token>\" from final message */\n    llex.luaX_syntaxerror(ls, msg);\n};\n\nconst error_expected = function(ls, token) {\n    llex.luaX_syntaxerror(ls, lobject.luaO_pushfstring(ls.L, to_luastring(\"%s expected\", true), llex.luaX_token2str(ls, token)));\n};\n\nconst errorlimit = function(fs, limit, what) {\n    let L = fs.ls.L;\n    let line = fs.f.linedefined;\n    let where = (line === 0)\n        ? to_luastring(\"main function\", true)\n        : lobject.luaO_pushfstring(L, to_luastring(\"function at line %d\", true), line);\n    let msg = lobject.luaO_pushfstring(L, to_luastring(\"too many %s (limit is %d) in %s\", true),\n        what, limit, where);\n    llex.luaX_syntaxerror(fs.ls, msg);\n};\n\nconst checklimit = function(fs, v, l, what) {\n    if (v > l) errorlimit(fs, l, what);\n};\n\nconst testnext = function(ls, c) {\n    if (ls.t.token === c) {\n        llex.luaX_next(ls);\n        return true;\n    }\n\n    return false;\n};\n\nconst check = function(ls, c) {\n    if (ls.t.token !== c)\n        error_expected(ls, c);\n};\n\nconst checknext = function(ls, c) {\n    check(ls, c);\n    llex.luaX_next(ls);\n};\n\nconst check_condition = function(ls, c, msg) {\n    if (!c)\n        llex.luaX_syntaxerror(ls, msg);\n};\n\nconst check_match = function(ls, what, who, where) {\n    if (!testnext(ls, what)) {\n        if (where === ls.linenumber)\n            error_expected(ls, what);\n        else\n            llex.luaX_syntaxerror(ls, lobject.luaO_pushfstring(ls.L,\n                to_luastring(\"%s expected (to close %s at line %d)\"),\n                llex.luaX_token2str(ls, what), llex.luaX_token2str(ls, who), where));\n    }\n};\n\nconst str_checkname = function(ls) {\n    check(ls, R.TK_NAME);\n    let ts = ls.t.seminfo.ts;\n    llex.luaX_next(ls);\n    return ts;\n};\n\nconst init_exp = function(e, k, i) {\n    e.f = e.t = NO_JUMP;\n    e.k = k;\n    e.u.info = i;\n};\n\nconst codestring = function(ls, e, s) {\n    init_exp(e, expkind.VK, luaK_stringK(ls.fs, s));\n};\n\nconst checkname = function(ls, e) {\n    codestring(ls, e, str_checkname(ls));\n};\n\nconst registerlocalvar = function(ls, varname) {\n    let fs = ls.fs;\n    let f = fs.f;\n    f.locvars[fs.nlocvars] = new lobject.LocVar();\n    f.locvars[fs.nlocvars].varname = varname;\n    return fs.nlocvars++;\n};\n\nconst new_localvar = function(ls, name) {\n    let fs = ls.fs;\n    let dyd = ls.dyd;\n    let reg = registerlocalvar(ls, name);\n    checklimit(fs, dyd.actvar.n + 1 - fs.firstlocal, MAXVARS, to_luastring(\"local variables\", true));\n    dyd.actvar.arr[dyd.actvar.n] = new Vardesc();\n    dyd.actvar.arr[dyd.actvar.n].idx = reg;\n    dyd.actvar.n++;\n};\n\nconst new_localvarliteral = function(ls, name) {\n    new_localvar(ls, llex.luaX_newstring(ls, to_luastring(name, true)));\n};\n\nconst getlocvar = function(fs, i) {\n    let idx = fs.ls.dyd.actvar.arr[fs.firstlocal + i].idx;\n    lua_assert(idx < fs.nlocvars);\n    return fs.f.locvars[idx];\n};\n\nconst adjustlocalvars = function(ls, nvars) {\n    let fs = ls.fs;\n    fs.nactvar = fs.nactvar + nvars;\n    for (; nvars; nvars--)\n        getlocvar(fs, fs.nactvar - nvars).startpc = fs.pc;\n};\n\nconst removevars = function(fs, tolevel) {\n    fs.ls.dyd.actvar.n -= fs.nactvar - tolevel;\n    while (fs.nactvar > tolevel)\n        getlocvar(fs, --fs.nactvar).endpc = fs.pc;\n};\n\nconst searchupvalue = function(fs, name) {\n    let up = fs.f.upvalues;\n    for (let i = 0; i < fs.nups; i++) {\n        if (eqstr(up[i].name, name))\n            return i;\n    }\n    return -1;  /* not found */\n};\n\nconst newupvalue = function(fs, name, v) {\n    let f = fs.f;\n    checklimit(fs, fs.nups + 1, lfunc.MAXUPVAL, to_luastring(\"upvalues\", true));\n    f.upvalues[fs.nups] = {\n        instack: v.k === expkind.VLOCAL,\n        idx: v.u.info,\n        name: name\n    };\n    return fs.nups++;\n};\n\nconst searchvar = function(fs, n) {\n    for (let i = fs.nactvar - 1; i >= 0; i--) {\n        if (eqstr(n, getlocvar(fs, i).varname))\n            return i;\n    }\n\n    return -1;\n};\n\n/*\n** Mark block where variable at given level was defined\n** (to emit close instructions later).\n*/\nconst markupval = function(fs, level) {\n    let bl = fs.bl;\n    while (bl.nactvar > level)\n        bl = bl.previous;\n    bl.upval = 1;\n};\n\n/*\n** Find variable with given name 'n'. If it is an upvalue, add this\n** upvalue into all intermediate functions.\n*/\nconst singlevaraux = function(fs, n, vr, base) {\n    if (fs === null)  /* no more levels? */\n        init_exp(vr, expkind.VVOID, 0);  /* default is global */\n    else {\n        let v = searchvar(fs, n);  /* look up locals at current level */\n        if (v >= 0) {  /* found? */\n            init_exp(vr, expkind.VLOCAL, v);  /* variable is local */\n            if (!base)\n                markupval(fs, v);  /* local will be used as an upval */\n        } else {  /* not found as local at current level; try upvalues */\n            let idx = searchupvalue(fs, n);  /* try existing upvalues */\n            if (idx < 0) {  /* not found? */\n                singlevaraux(fs.prev, n, vr, 0);  /* try upper levels */\n                if (vr.k === expkind.VVOID)  /* not found? */\n                    return;  /* it is a global */\n                /* else was LOCAL or UPVAL */\n                idx = newupvalue(fs, n, vr);  /* will be a new upvalue */\n            }\n            init_exp(vr, expkind.VUPVAL, idx);  /* new or old upvalue */\n        }\n    }\n};\n\nconst singlevar = function(ls, vr) {\n    let varname = str_checkname(ls);\n    let fs = ls.fs;\n    singlevaraux(fs, varname, vr, 1);\n    if (vr.k === expkind.VVOID) {  /* is global name? */\n        let key = new expdesc();\n        singlevaraux(fs, ls.envn, vr, 1);  /* get environment variable */\n        lua_assert(vr.k !== expkind.VVOID);  /* this one must exist */\n        codestring(ls, key, varname);  /* key is variable name */\n        luaK_indexed(fs, vr, key);  /* env[varname] */\n    }\n};\n\nconst adjust_assign = function(ls, nvars, nexps, e) {\n    let fs = ls.fs;\n    let extra = nvars - nexps;\n    if (hasmultret(e.k)) {\n        extra++;  /* includes call itself */\n        if (extra < 0) extra = 0;\n        luaK_setreturns(fs, e, extra);  /* last exp. provides the difference */\n        if (extra > 1) luaK_reserveregs(fs, extra - 1);\n    } else {\n        if (e.k !== expkind.VVOID) luaK_exp2nextreg(fs, e);  /* close last expression */\n        if (extra > 0) {\n            let reg = fs.freereg;\n            luaK_reserveregs(fs, extra);\n            luaK_nil(fs, reg, extra);\n        }\n    }\n    if (nexps > nvars)\n        ls.fs.freereg -= nexps - nvars;  /* remove extra values */\n};\n\nconst enterlevel = function(ls) {\n    let L = ls.L;\n    ++L.nCcalls;\n    checklimit(ls.fs, L.nCcalls, LUAI_MAXCCALLS, to_luastring(\"JS levels\", true));\n};\n\nconst leavelevel = function(ls) {\n    return ls.L.nCcalls--;\n};\n\nconst closegoto = function(ls, g, label) {\n    let fs = ls.fs;\n    let gl = ls.dyd.gt;\n    let gt = gl.arr[g];\n    lua_assert(eqstr(gt.name, label.name));\n    if (gt.nactvar < label.nactvar) {\n        let vname = getlocvar(fs, gt.nactvar).varname;\n        let msg = lobject.luaO_pushfstring(ls.L,\n            to_luastring(\"<goto %s> at line %d jumps into the scope of local '%s'\"),\n            gt.name.getstr(), gt.line, vname.getstr());\n        semerror(ls, msg);\n    }\n    luaK_patchlist(fs, gt.pc, label.pc);\n    /* remove goto from pending list */\n    for (let i = g; i < gl.n - 1; i++)\n        gl.arr[i] = gl.arr[i + 1];\n    gl.n--;\n};\n\n/*\n** try to close a goto with existing labels; this solves backward jumps\n*/\nconst findlabel = function(ls, g) {\n    let bl = ls.fs.bl;\n    let dyd = ls.dyd;\n    let gt = dyd.gt.arr[g];\n    /* check labels in current block for a match */\n    for (let i = bl.firstlabel; i < dyd.label.n; i++) {\n        let lb = dyd.label.arr[i];\n        if (eqstr(lb.name, gt.name)) {  /* correct label? */\n            if (gt.nactvar > lb.nactvar && (bl.upval || dyd.label.n > bl.firstlabel))\n                luaK_patchclose(ls.fs, gt.pc, lb.nactvar);\n            closegoto(ls, g, lb);  /* close it */\n            return true;\n        }\n    }\n    return false;  /* label not found; cannot close goto */\n};\n\nconst newlabelentry = function(ls, l, name, line, pc) {\n    let n = l.n;\n    l.arr[n] = new Labeldesc();\n    l.arr[n].name = name;\n    l.arr[n].line = line;\n    l.arr[n].nactvar = ls.fs.nactvar;\n    l.arr[n].pc = pc;\n    l.n = n + 1;\n    return n;\n};\n\n/*\n** check whether new label 'lb' matches any pending gotos in current\n** block; solves forward jumps\n*/\nconst findgotos = function(ls, lb) {\n    let gl = ls.dyd.gt;\n    let i = ls.fs.bl.firstgoto;\n    while (i < gl.n) {\n        if (eqstr(gl.arr[i].name, lb.name))\n            closegoto(ls, i, lb);\n        else\n            i++;\n    }\n};\n\n/*\n** export pending gotos to outer level, to check them against\n** outer labels; if the block being exited has upvalues, and\n** the goto exits the scope of any variable (which can be the\n** upvalue), close those variables being exited.\n*/\nconst movegotosout = function(fs, bl) {\n    let i = bl.firstgoto;\n    let gl = fs.ls.dyd.gt;\n    /* correct pending gotos to current block and try to close it\n       with visible labels */\n    while (i < gl.n) {\n        let gt = gl.arr[i];\n        if (gt.nactvar > bl.nactvar) {\n            if (bl.upval)\n                luaK_patchclose(fs, gt.pc, bl.nactvar);\n            gt.nactvar = bl.nactvar;\n        }\n        if (!findlabel(fs.ls, i))\n            i++;  /* move to next one */\n    }\n};\n\nconst enterblock = function(fs, bl, isloop) {\n    bl.isloop = isloop;\n    bl.nactvar = fs.nactvar;\n    bl.firstlabel = fs.ls.dyd.label.n;\n    bl.firstgoto = fs.ls.dyd.gt.n;\n    bl.upval = 0;\n    bl.previous = fs.bl;\n    fs.bl = bl;\n    lua_assert(fs.freereg === fs.nactvar);\n};\n\n/*\n** create a label named 'break' to resolve break statements\n*/\nconst breaklabel = function(ls) {\n    let n = luaS_newliteral(ls.L, \"break\");\n    let l = newlabelentry(ls, ls.dyd.label, n, 0, ls.fs.pc);\n    findgotos(ls, ls.dyd.label.arr[l]);\n};\n\n/*\n** generates an error for an undefined 'goto'; choose appropriate\n** message when label name is a reserved word (which can only be 'break')\n*/\nconst undefgoto = function(ls, gt) {\n    let msg = llex.isreserved(gt.name)\n        ? \"<%s> at line %d not inside a loop\"\n        : \"no visible label '%s' for <goto> at line %d\";\n    msg = lobject.luaO_pushfstring(ls.L, to_luastring(msg), gt.name.getstr(), gt.line);\n    semerror(ls, msg);\n};\n\n/*\n** adds a new prototype into list of prototypes\n*/\nconst addprototype = function(ls) {\n    let L = ls.L;\n    let clp = new Proto(L);\n    let fs = ls.fs;\n    let f = fs.f;  /* prototype of current function */\n    f.p[fs.np++] = clp;\n    return clp;\n};\n\n/*\n** codes instruction to create new closure in parent function.\n*/\nconst codeclosure = function(ls, v) {\n    let fs = ls.fs.prev;\n    init_exp(v, expkind.VRELOCABLE, luaK_codeABx(fs, OP_CLOSURE, 0, fs.np -1));\n    luaK_exp2nextreg(fs, v);  /* fix it at the last register */\n};\n\nconst open_func = function(ls, fs, bl) {\n    fs.prev = ls.fs;  /* linked list of funcstates */\n    fs.ls = ls;\n    ls.fs = fs;\n    fs.pc = 0;\n    fs.lasttarget = 0;\n    fs.jpc = NO_JUMP;\n    fs.freereg = 0;\n    fs.nk = 0;\n    fs.np = 0;\n    fs.nups = 0;\n    fs.nlocvars = 0;\n    fs.nactvar = 0;\n    fs.firstlocal = ls.dyd.actvar.n;\n    fs.bl = null;\n    let f = fs.f;\n    f.source = ls.source;\n    f.maxstacksize = 2;  /* registers 0/1 are always valid */\n    enterblock(fs, bl, false);\n};\n\nconst leaveblock = function(fs) {\n    let bl = fs.bl;\n    let ls = fs.ls;\n    if (bl.previous && bl.upval) {\n        /* create a 'jump to here' to close upvalues */\n        let j = luaK_jump(fs);\n        luaK_patchclose(fs, j , bl.nactvar);\n        luaK_patchtohere(fs, j);\n    }\n\n    if (bl.isloop)\n        breaklabel(ls);  /* close pending breaks */\n\n    fs.bl = bl.previous;\n    removevars(fs, bl.nactvar);\n    lua_assert(bl.nactvar === fs.nactvar);\n    fs.freereg = fs.nactvar;  /* free registers */\n    ls.dyd.label.n = bl.firstlabel;  /* remove local labels */\n    if (bl.previous)  /* inner block? */\n        movegotosout(fs, bl);  /* update pending gotos to outer block */\n    else if (bl.firstgoto < ls.dyd.gt.n)  /* pending gotos in outer block? */\n        undefgoto(ls, ls.dyd.gt.arr[bl.firstgoto]);  /* error */\n};\n\nconst close_func = function(ls) {\n    let fs = ls.fs;\n    luaK_ret(fs, 0, 0);  /* final return */\n    leaveblock(fs);\n    lua_assert(fs.bl === null);\n    ls.fs = fs.prev;\n};\n\n/*============================================================*/\n/* GRAMMAR RULES */\n/*============================================================*/\n\nconst block_follow = function(ls, withuntil) {\n    switch (ls.t.token) {\n        case R.TK_ELSE: case R.TK_ELSEIF:\n        case R.TK_END: case R.TK_EOS:\n            return true;\n        case R.TK_UNTIL: return withuntil;\n        default: return false;\n    }\n};\n\nconst statlist = function(ls) {\n    /* statlist -> { stat [';'] } */\n    while (!block_follow(ls, 1)) {\n        if (ls.t.token === R.TK_RETURN) {\n            statement(ls);\n            return;  /* 'return' must be last statement */\n        }\n        statement(ls);\n    }\n};\n\nconst fieldsel = function(ls, v) {\n    /* fieldsel -> ['.' | ':'] NAME */\n    let fs = ls.fs;\n    let key = new expdesc();\n    luaK_exp2anyregup(fs, v);\n    llex.luaX_next(ls);  /* skip the dot or colon */\n    checkname(ls, key);\n    luaK_indexed(fs, v, key);\n};\n\nconst yindex = function(ls, v) {\n    /* index -> '[' expr ']' */\n    llex.luaX_next(ls);  /* skip the '[' */\n    expr(ls, v);\n    luaK_exp2val(ls.fs, v);\n    checknext(ls, 93 /* (']').charCodeAt(0) */);\n};\n\n/*\n** {======================================================================\n** Rules for Constructors\n** =======================================================================\n*/\n\nclass ConsControl {\n    constructor() {\n        this.v = new expdesc(); /* last list item read */\n        this.t = new expdesc(); /* table descriptor */\n        this.nh = NaN;          /* total number of 'record' elements */\n        this.na = NaN;          /* total number of array elements */\n        this.tostore = NaN;     /* number of array elements pending to be stored */\n    }\n}\n\nconst recfield = function(ls, cc) {\n    /* recfield -> (NAME | '['exp1']') = exp1 */\n    let fs = ls.fs;\n    let reg = ls.fs.freereg;\n    let key = new expdesc();\n    let val = new expdesc();\n\n    if (ls.t.token === R.TK_NAME) {\n        checklimit(fs, cc.nh, MAX_INT, to_luastring(\"items in a constructor\", true));\n        checkname(ls, key);\n    } else  /* ls->t.token === '[' */\n        yindex(ls, key);\n    cc.nh++;\n    checknext(ls, 61 /* ('=').charCodeAt(0) */);\n    let rkkey = luaK_exp2RK(fs, key);\n    expr(ls, val);\n    luaK_codeABC(fs, OP_SETTABLE, cc.t.u.info, rkkey, luaK_exp2RK(fs, val));\n    fs.freereg = reg;  /* free registers */\n};\n\nconst closelistfield = function(fs, cc) {\n    if (cc.v.k === expkind.VVOID) return;  /* there is no list item */\n    luaK_exp2nextreg(fs, cc.v);\n    cc.v.k = expkind.VVOID;\n    if (cc.tostore === LFIELDS_PER_FLUSH) {\n        luaK_setlist(fs, cc.t.u.info, cc.na, cc.tostore);  /* flush */\n        cc.tostore = 0;  /* no more items pending */\n    }\n};\n\nconst lastlistfield = function(fs, cc) {\n    if (cc.tostore === 0) return;\n    if (hasmultret(cc.v.k)) {\n        luaK_setmultret(fs, cc.v);\n        luaK_setlist(fs, cc.t.u.info, cc.na, LUA_MULTRET);\n        cc.na--;  /* do not count last expression (unknown number of elements) */\n    } else {\n        if (cc.v.k !== expkind.VVOID)\n            luaK_exp2nextreg(fs, cc.v);\n        luaK_setlist(fs, cc.t.u.info, cc.na, cc.tostore);\n    }\n};\n\nconst listfield = function(ls, cc) {\n    /* listfield -> exp */\n    expr(ls, cc.v);\n    checklimit(ls.fs, cc.na, MAX_INT, to_luastring(\"items in a constructor\", true));\n    cc.na++;\n    cc.tostore++;\n};\n\nconst field = function(ls, cc) {\n    /* field -> listfield | recfield */\n    switch (ls.t.token) {\n        case R.TK_NAME: {  /* may be 'listfield' or 'recfield' */\n            if (llex.luaX_lookahead(ls) !== 61 /* ('=').charCodeAt(0) */)  /* expression? */\n                listfield(ls, cc);\n            else\n                recfield(ls, cc);\n            break;\n        }\n        case 91 /* ('[').charCodeAt(0) */: {\n            recfield(ls, cc);\n            break;\n        }\n        default: {\n            listfield(ls, cc);\n            break;\n        }\n    }\n};\n\nconst constructor = function(ls, t) {\n    /* constructor -> '{' [ field { sep field } [sep] ] '}'\n       sep -> ',' | ';' */\n    let fs = ls.fs;\n    let line = ls.linenumber;\n    let pc = luaK_codeABC(fs, OP_NEWTABLE, 0, 0, 0);\n    let cc = new ConsControl();\n    cc.na = cc.nh = cc.tostore = 0;\n    cc.t = t;\n    init_exp(t, expkind.VRELOCABLE, pc);\n    init_exp(cc.v, expkind.VVOID, 0);  /* no value (yet) */\n    luaK_exp2nextreg(ls.fs, t);  /* fix it at stack top */\n    checknext(ls, 123 /* ('{').charCodeAt(0) */);\n    do {\n        lua_assert(cc.v.k === expkind.VVOID || cc.tostore > 0);\n        if (ls.t.token === 125 /* ('}').charCodeAt(0) */) break;\n        closelistfield(fs, cc);\n        field(ls, cc);\n    } while (testnext(ls, 44 /* (',').charCodeAt(0) */) || testnext(ls, 59 /* (';').charCodeAt(0) */));\n    check_match(ls, 125 /* ('}').charCodeAt(0) */, 123 /* ('{').charCodeAt(0) */, line);\n    lastlistfield(fs, cc);\n    SETARG_B(fs.f.code[pc], lobject.luaO_int2fb(cc.na));  /* set initial array size */\n    SETARG_C(fs.f.code[pc], lobject.luaO_int2fb(cc.nh));  /* set initial table size */\n};\n\n/* }====================================================================== */\n\nconst parlist = function(ls) {\n    /* parlist -> [ param { ',' param } ] */\n    let fs = ls.fs;\n    let f = fs.f;\n    let nparams = 0;\n    f.is_vararg = false;\n    if (ls.t.token !== 41 /* (')').charCodeAt(0) */) {  /* is 'parlist' not empty? */\n        do {\n            switch (ls.t.token) {\n                case R.TK_NAME: {  /* param -> NAME */\n                    new_localvar(ls, str_checkname(ls));\n                    nparams++;\n                    break;\n                }\n                case R.TK_DOTS: {  /* param -> '...' */\n                    llex.luaX_next(ls);\n                    f.is_vararg = true;  /* declared vararg */\n                    break;\n                }\n                default: llex.luaX_syntaxerror(ls, to_luastring(\"<name> or '...' expected\", true));\n            }\n        } while(!f.is_vararg && testnext(ls, 44 /* (',').charCodeAt(0) */));\n    }\n    adjustlocalvars(ls, nparams);\n    f.numparams = fs.nactvar;\n    luaK_reserveregs(fs, fs.nactvar);  /* reserve register for parameters */\n};\n\nconst body = function(ls, e, ismethod, line) {\n    /* body ->  '(' parlist ')' block END */\n    let new_fs = new FuncState();\n    let bl = new BlockCnt();\n    new_fs.f = addprototype(ls);\n    new_fs.f.linedefined = line;\n    open_func(ls, new_fs, bl);\n    checknext(ls, 40 /* ('(').charCodeAt(0) */);\n    if (ismethod) {\n        new_localvarliteral(ls, \"self\");  /* create 'self' parameter */\n        adjustlocalvars(ls, 1);\n    }\n    parlist(ls);\n    checknext(ls, 41 /* (')').charCodeAt(0) */);\n    statlist(ls);\n    new_fs.f.lastlinedefined = ls.linenumber;\n    check_match(ls, R.TK_END, R.TK_FUNCTION, line);\n    codeclosure(ls, e);\n    close_func(ls);\n};\n\nconst explist = function(ls, v) {\n    /* explist -> expr { ',' expr } */\n    let n = 1;  /* at least one expression */\n    expr(ls, v);\n    while (testnext(ls, 44 /* (',').charCodeAt(0) */)) {\n        luaK_exp2nextreg(ls.fs, v);\n        expr(ls, v);\n        n++;\n    }\n    return n;\n};\n\nconst funcargs = function(ls, f, line) {\n    let fs = ls.fs;\n    let args = new expdesc();\n    switch (ls.t.token) {\n        case 40 /* ('(').charCodeAt(0) */: {  /* funcargs -> '(' [ explist ] ')' */\n            llex.luaX_next(ls);\n            if (ls.t.token === 41 /* (')').charCodeAt(0) */)  /* arg list is empty? */\n                args.k = expkind.VVOID;\n            else {\n                explist(ls, args);\n                luaK_setmultret(fs, args);\n            }\n            check_match(ls, 41 /* (')').charCodeAt(0) */, 40 /* ('(').charCodeAt(0) */, line);\n            break;\n        }\n        case 123 /* ('{').charCodeAt(0) */: {  /* funcargs -> constructor */\n            constructor(ls, args);\n            break;\n        }\n        case R.TK_STRING: {  /* funcargs -> STRING */\n            codestring(ls, args, ls.t.seminfo.ts);\n            llex.luaX_next(ls);  /* must use 'seminfo' before 'next' */\n            break;\n        }\n        default: {\n            llex.luaX_syntaxerror(ls, to_luastring(\"function arguments expected\", true));\n        }\n    }\n    lua_assert(f.k === expkind.VNONRELOC);\n    let nparams;\n    let base = f.u.info;  /* base register for call */\n    if (hasmultret(args.k))\n        nparams = LUA_MULTRET;  /* open call */\n    else {\n        if (args.k !== expkind.VVOID)\n            luaK_exp2nextreg(fs, args);  /* close last argument */\n        nparams = fs.freereg - (base+1);\n    }\n    init_exp(f, expkind.VCALL, luaK_codeABC(fs, OP_CALL, base, nparams+1, 2));\n    luaK_fixline(fs, line);\n    fs.freereg = base + 1; /* call remove function and arguments and leaves (unless changed) one result */\n};\n\n/*\n** {======================================================================\n** Expression parsing\n** =======================================================================\n*/\n\nconst primaryexp = function(ls, v) {\n    /* primaryexp -> NAME | '(' expr ')' */\n    switch (ls.t.token) {\n        case 40 /* ('(').charCodeAt(0) */: {\n            let line = ls.linenumber;\n            llex.luaX_next(ls);\n            expr(ls, v);\n            check_match(ls, 41 /* (')').charCodeAt(0) */, 40 /* ('(').charCodeAt(0) */, line);\n            luaK_dischargevars(ls.fs, v);\n            return;\n        }\n        case R.TK_NAME: {\n            singlevar(ls, v);\n            return;\n        }\n        default: {\n            llex.luaX_syntaxerror(ls, to_luastring(\"unexpected symbol\", true));\n        }\n    }\n};\n\nconst suffixedexp = function(ls, v) {\n    /* suffixedexp ->\n       primaryexp { '.' NAME | '[' exp ']' | ':' NAME funcargs | funcargs } */\n    let fs = ls.fs;\n    let line = ls.linenumber;\n    primaryexp(ls, v);\n    for (;;) {\n        switch (ls.t.token) {\n            case 46 /* ('.').charCodeAt(0) */: {  /* fieldsel */\n                fieldsel(ls, v);\n                break;\n            }\n            case 91 /* ('[').charCodeAt(0) */: {  /* '[' exp1 ']' */\n                let key = new expdesc();\n                luaK_exp2anyregup(fs, v);\n                yindex(ls, key);\n                luaK_indexed(fs, v, key);\n                break;\n            }\n            case 58 /* (':').charCodeAt(0) */: {  /* ':' NAME funcargs */\n                let key = new expdesc();\n                llex.luaX_next(ls);\n                checkname(ls, key);\n                luaK_self(fs, v, key);\n                funcargs(ls, v, line);\n                break;\n            }\n            case 40 /* ('(').charCodeAt(0) */: case R.TK_STRING: case 123 /* ('{').charCodeAt(0) */: {  /* funcargs */\n                luaK_exp2nextreg(fs, v);\n                funcargs(ls, v, line);\n                break;\n            }\n            default: return;\n        }\n    }\n};\n\nconst simpleexp = function(ls, v) {\n    /* simpleexp -> FLT | INT | STRING | NIL | TRUE | FALSE | ... |\n       constructor | FUNCTION body | suffixedexp */\n    switch (ls.t.token) {\n        case R.TK_FLT: {\n            init_exp(v, expkind.VKFLT, 0);\n            v.u.nval = ls.t.seminfo.r;\n            break;\n        }\n        case R.TK_INT: {\n            init_exp(v, expkind.VKINT, 0);\n            v.u.ival = ls.t.seminfo.i;\n            break;\n        }\n        case R.TK_STRING: {\n            codestring(ls, v, ls.t.seminfo.ts);\n            break;\n        }\n        case R.TK_NIL: {\n            init_exp(v, expkind.VNIL, 0);\n            break;\n        }\n        case R.TK_TRUE: {\n            init_exp(v, expkind.VTRUE, 0);\n            break;\n        }\n        case R.TK_FALSE: {\n            init_exp(v, expkind.VFALSE, 0);\n            break;\n        }\n        case R.TK_DOTS: {  /* vararg */\n            let fs = ls.fs;\n            check_condition(ls, fs.f.is_vararg, to_luastring(\"cannot use '...' outside a vararg function\", true));\n            init_exp(v, expkind.VVARARG, luaK_codeABC(fs, OP_VARARG, 0, 1, 0));\n            break;\n        }\n        case 123 /* ('{').charCodeAt(0) */: {  /* constructor */\n            constructor(ls, v);\n            return;\n        }\n        case R.TK_FUNCTION: {\n            llex.luaX_next(ls);\n            body(ls, v, 0, ls.linenumber);\n            return;\n        }\n        default: {\n            suffixedexp(ls, v);\n            return;\n        }\n    }\n    llex.luaX_next(ls);\n};\n\nconst getunopr = function(op) {\n    switch (op) {\n        case R.TK_NOT: return OPR_NOT;\n        case 45 /* ('-').charCodeAt(0) */: return OPR_MINUS;\n        case 126 /* ('~').charCodeAt(0) */: return OPR_BNOT;\n        case 35 /* ('#').charCodeAt(0) */: return OPR_LEN;\n        default: return OPR_NOUNOPR;\n    }\n};\n\nconst getbinopr = function(op) {\n    switch (op) {\n        case 43 /* ('+').charCodeAt(0) */: return OPR_ADD;\n        case 45 /* ('-').charCodeAt(0) */: return OPR_SUB;\n        case 42 /* ('*').charCodeAt(0) */: return OPR_MUL;\n        case 37 /* ('%').charCodeAt(0) */: return OPR_MOD;\n        case 94 /* ('^').charCodeAt(0) */: return OPR_POW;\n        case 47 /* ('/').charCodeAt(0) */: return OPR_DIV;\n        case R.TK_IDIV:   return OPR_IDIV;\n        case 38 /* ('&').charCodeAt(0) */: return OPR_BAND;\n        case 124 /* ('|').charCodeAt(0) */: return OPR_BOR;\n        case 126 /* ('~').charCodeAt(0) */: return OPR_BXOR;\n        case R.TK_SHL:    return OPR_SHL;\n        case R.TK_SHR:    return OPR_SHR;\n        case R.TK_CONCAT: return OPR_CONCAT;\n        case R.TK_NE:     return OPR_NE;\n        case R.TK_EQ:     return OPR_EQ;\n        case 60 /* ('<').charCodeAt(0) */: return OPR_LT;\n        case R.TK_LE:     return OPR_LE;\n        case 62 /* ('>').charCodeAt(0) */: return OPR_GT;\n        case R.TK_GE:     return OPR_GE;\n        case R.TK_AND:    return OPR_AND;\n        case R.TK_OR:     return OPR_OR;\n        default:          return OPR_NOBINOPR;\n    }\n};\n\nconst priority = [  /* ORDER OPR */\n    {left: 10, right: 10}, {left: 10, right: 10},     /* '+' '-' */\n    {left: 11, right: 11}, {left: 11, right: 11},     /* '*' '%' */\n    {left: 14, right: 13},               /* '^' (right associative) */\n    {left: 11, right: 11}, {left: 11, right: 11},     /* '/' '//' */\n    {left: 6, right: 6}, {left: 4, right: 4}, {left: 5, right: 5}, /* '&' '|' '~' */\n    {left: 7, right: 7}, {left: 7, right: 7},         /* '<<' '>>' */\n    {left: 9, right: 8},                 /* '..' (right associative) */\n    {left: 3, right: 3}, {left: 3, right: 3}, {left: 3, right: 3}, /* ==, <, <= */\n    {left: 3, right: 3}, {left: 3, right: 3}, {left: 3, right: 3}, /* ~=, >, >= */\n    {left: 2, right: 2}, {left: 1, right: 1}          /* and, or */\n];\n\nconst UNARY_PRIORITY = 12;\n\n/*\n** subexpr -> (simpleexp | unop subexpr) { binop subexpr }\n** where 'binop' is any binary operator with a priority higher than 'limit'\n*/\nconst subexpr = function(ls, v, limit) {\n    enterlevel(ls);\n    let uop = getunopr(ls.t.token);\n    if (uop !== OPR_NOUNOPR) {\n        let line = ls.linenumber;\n        llex.luaX_next(ls);\n        subexpr(ls, v, UNARY_PRIORITY);\n        luaK_prefix(ls.fs, uop, v, line);\n    } else\n        simpleexp(ls, v);\n    /* expand while operators have priorities higher than 'limit' */\n    let op = getbinopr(ls.t.token);\n    while (op !== OPR_NOBINOPR && priority[op].left > limit) {\n        let v2 = new expdesc();\n        let line = ls.linenumber;\n        llex.luaX_next(ls);\n        luaK_infix(ls.fs, op, v);\n        /* read sub-expression with higher priority */\n        let nextop = subexpr(ls, v2, priority[op].right);\n        luaK_posfix(ls.fs, op, v, v2, line);\n        op = nextop;\n    }\n    leavelevel(ls);\n    return op;  /* return first untreated operator */\n};\n\nconst expr = function(ls, v) {\n    subexpr(ls, v, 0);\n};\n\n/* }==================================================================== */\n\n\n\n/*\n** {======================================================================\n** Rules for Statements\n** =======================================================================\n*/\n\nconst block = function(ls) {\n    /* block -> statlist */\n    let fs = ls.fs;\n    let bl = new BlockCnt();\n    enterblock(fs, bl, 0);\n    statlist(ls);\n    leaveblock(fs);\n};\n\n/*\n** structure to chain all variables in the left-hand side of an\n** assignment\n*/\nclass LHS_assign {\n    constructor() {\n        this.prev = null;\n        this.v = new expdesc();  /* variable (global, local, upvalue, or indexed) */\n    }\n}\n\n/*\n** check whether, in an assignment to an upvalue/local variable, the\n** upvalue/local variable is begin used in a previous assignment to a\n** table. If so, save original upvalue/local value in a safe place and\n** use this safe copy in the previous assignment.\n*/\nconst check_conflict = function(ls, lh, v) {\n    let fs = ls.fs;\n    let extra = fs.freereg;  /* eventual position to save local variable */\n    let conflict = false;\n    for (; lh; lh = lh.prev) {  /* check all previous assignments */\n        if (lh.v.k === expkind.VINDEXED) {  /* assigning to a table? */\n            /* table is the upvalue/local being assigned now? */\n            if (lh.v.u.ind.vt === v.k && lh.v.u.ind.t === v.u.info) {\n                conflict = true;\n                lh.v.u.ind.vt = expkind.VLOCAL;\n                lh.v.u.ind.t = extra;  /* previous assignment will use safe copy */\n            }\n            /* index is the local being assigned? (index cannot be upvalue) */\n            if (v.k === expkind.VLOCAL && lh.v.u.ind.idx === v.u.info) {\n                conflict = true;\n                lh.v.u.ind.idx = extra;  /* previous assignment will use safe copy */\n            }\n        }\n    }\n    if (conflict) {\n        /* copy upvalue/local value to a temporary (in position 'extra') */\n        let op = v.k === expkind.VLOCAL ? OP_MOVE : OP_GETUPVAL;\n        luaK_codeABC(fs, op, extra, v.u.info, 0);\n        luaK_reserveregs(fs, 1);\n    }\n};\n\nconst assignment = function(ls, lh, nvars) {\n    let e = new expdesc();\n    check_condition(ls, vkisvar(lh.v.k), to_luastring(\"syntax error\", true));\n    if (testnext(ls, 44 /* (',').charCodeAt(0) */)) {  /* assignment -> ',' suffixedexp assignment */\n        let nv = new LHS_assign();\n        nv.prev = lh;\n        suffixedexp(ls, nv.v);\n        if (nv.v.k !== expkind.VINDEXED)\n            check_conflict(ls, lh, nv.v);\n        checklimit(ls.fs, nvars + ls.L.nCcalls, LUAI_MAXCCALLS, to_luastring(\"JS levels\", true));\n        assignment(ls, nv, nvars + 1);\n    } else {  /* assignment -> '=' explist */\n        checknext(ls, 61 /* ('=').charCodeAt(0) */);\n        let nexps = explist(ls, e);\n        if (nexps !== nvars)\n            adjust_assign(ls, nvars, nexps, e);\n        else {\n            luaK_setoneret(ls.fs, e);  /* close last expression */\n            luaK_storevar(ls.fs, lh.v, e);\n            return;  /* avoid default */\n        }\n    }\n    init_exp(e, expkind.VNONRELOC, ls.fs.freereg-1);  /* default assignment */\n    luaK_storevar(ls.fs, lh.v, e);\n};\n\nconst cond = function(ls) {\n    /* cond -> exp */\n    let v = new expdesc();\n    expr(ls, v);  /* read condition */\n    if (v.k === expkind.VNIL) v.k = expkind.VFALSE;  /* 'falses' are all equal here */\n    luaK_goiftrue(ls.fs, v);\n    return v.f;\n};\n\nconst gotostat = function(ls, pc) {\n    let line = ls.linenumber;\n    let label;\n    if (testnext(ls, R.TK_GOTO))\n        label = str_checkname(ls);\n    else {\n        llex.luaX_next(ls);  /* skip break */\n        label = luaS_newliteral(ls.L, \"break\");\n    }\n    let g = newlabelentry(ls, ls.dyd.gt, label, line, pc);\n    findlabel(ls, g);  /* close it if label already defined */\n};\n\n/* check for repeated labels on the same block */\nconst checkrepeated = function(fs, ll, label) {\n    for (let i = fs.bl.firstlabel; i < ll.n; i++) {\n        if (eqstr(label, ll.arr[i].name)) {\n            let msg = lobject.luaO_pushfstring(fs.ls.L,\n                to_luastring(\"label '%s' already defined on line %d\", true),\n                label.getstr(), ll.arr[i].line);\n            semerror(fs.ls, msg);\n        }\n    }\n};\n\n/* skip no-op statements */\nconst skipnoopstat = function(ls) {\n    while (ls.t.token === 59 /* (';').charCodeAt(0) */ || ls.t.token === R.TK_DBCOLON)\n        statement(ls);\n};\n\nconst labelstat = function(ls, label, line) {\n    /* label -> '::' NAME '::' */\n    let fs = ls.fs;\n    let ll = ls.dyd.label;\n    let l;  /* index of new label being created */\n    checkrepeated(fs, ll, label);  /* check for repeated labels */\n    checknext(ls, R.TK_DBCOLON);  /* skip double colon */\n    /* create new entry for this label */\n    l = newlabelentry(ls, ll, label, line, luaK_getlabel(fs));\n    skipnoopstat(ls);  /* skip other no-op statements */\n    if (block_follow(ls, 0)) {  /* label is last no-op statement in the block? */\n        /* assume that locals are already out of scope */\n        ll.arr[l].nactvar = fs.bl.nactvar;\n    }\n    findgotos(ls, ll.arr[l]);\n};\n\nconst whilestat = function(ls, line) {\n    /* whilestat -> WHILE cond DO block END */\n    let fs = ls.fs;\n    let bl = new BlockCnt();\n    llex.luaX_next(ls);  /* skip WHILE */\n    let whileinit = luaK_getlabel(fs);\n    let condexit = cond(ls);\n    enterblock(fs, bl, 1);\n    checknext(ls, R.TK_DO);\n    block(ls);\n    luaK_jumpto(fs, whileinit);\n    check_match(ls, R.TK_END, R.TK_WHILE, line);\n    leaveblock(fs);\n    luaK_patchtohere(fs, condexit);  /* false conditions finish the loop */\n};\n\nconst repeatstat = function(ls, line) {\n    /* repeatstat -> REPEAT block UNTIL cond */\n    let fs = ls.fs;\n    let repeat_init = luaK_getlabel(fs);\n    let bl1 = new BlockCnt();\n    let bl2 = new BlockCnt();\n    enterblock(fs, bl1, 1);  /* loop block */\n    enterblock(fs, bl2, 0);  /* scope block */\n    llex.luaX_next(ls);  /* skip REPEAT */\n    statlist(ls);\n    check_match(ls, R.TK_UNTIL, R.TK_REPEAT, line);\n    let condexit = cond(ls);  /* read condition (inside scope block) */\n    if (bl2.upval)  /* upvalues? */\n        luaK_patchclose(fs, condexit, bl2.nactvar);\n    leaveblock(fs);  /* finish scope */\n    luaK_patchlist(fs, condexit, repeat_init);  /* close the loop */\n    leaveblock(fs);  /* finish loop */\n};\n\nconst exp1 = function(ls) {\n    let e = new expdesc();\n    expr(ls, e);\n    luaK_exp2nextreg(ls.fs, e);\n    lua_assert(e.k === expkind.VNONRELOC);\n    let reg = e.u.info;\n    return reg;\n};\n\nconst forbody = function(ls, base, line, nvars, isnum) {\n    /* forbody -> DO block */\n    let bl = new BlockCnt();\n    let fs = ls.fs;\n    let endfor;\n    adjustlocalvars(ls, 3);  /* control variables */\n    checknext(ls, R.TK_DO);\n    let prep = isnum ? luaK_codeAsBx(fs, OP_FORPREP, base, NO_JUMP) : luaK_jump(fs);\n    enterblock(fs, bl, 0);  /* scope for declared variables */\n    adjustlocalvars(ls, nvars);\n    luaK_reserveregs(fs, nvars);\n    block(ls);\n    leaveblock(fs);  /* end of scope for declared variables */\n    luaK_patchtohere(fs, prep);\n    if (isnum)  /* end of scope for declared variables */\n        endfor = luaK_codeAsBx(fs, OP_FORLOOP, base, NO_JUMP);\n    else {  /* generic for */\n        luaK_codeABC(fs, OP_TFORCALL, base, 0, nvars);\n        luaK_fixline(fs, line);\n        endfor = luaK_codeAsBx(fs, OP_TFORLOOP, base + 2, NO_JUMP);\n    }\n    luaK_patchlist(fs, endfor, prep + 1);\n    luaK_fixline(fs, line);\n};\n\nconst fornum = function(ls, varname, line) {\n    /* fornum -> NAME = exp1,exp1[,exp1] forbody */\n    let fs = ls.fs;\n    let base = fs.freereg;\n    new_localvarliteral(ls, \"(for index)\");\n    new_localvarliteral(ls, \"(for limit)\");\n    new_localvarliteral(ls, \"(for step)\");\n    new_localvar(ls, varname);\n    checknext(ls, 61 /* ('=').charCodeAt(0) */);\n    exp1(ls);  /* initial value */\n    checknext(ls, 44 /* (',').charCodeAt(0) */);\n    exp1(ls);  /* limit */\n    if (testnext(ls, 44 /* (',').charCodeAt(0) */))\n        exp1(ls);  /* optional step */\n    else {  /* default step = 1 */\n        luaK_codek(fs, fs.freereg, luaK_intK(fs, 1));\n        luaK_reserveregs(fs, 1);\n    }\n    forbody(ls, base, line, 1, 1);\n};\n\nconst forlist = function(ls, indexname) {\n    /* forlist -> NAME {,NAME} IN explist forbody */\n    let fs = ls.fs;\n    let e = new expdesc();\n    let nvars = 4;  /* gen, state, control, plus at least one declared var */\n    let base = fs.freereg;\n    /* create control variables */\n    new_localvarliteral(ls, \"(for generator)\");\n    new_localvarliteral(ls, \"(for state)\");\n    new_localvarliteral(ls, \"(for control)\");\n    /* create declared variables */\n    new_localvar(ls, indexname);\n    while (testnext(ls, 44 /* (',').charCodeAt(0) */)) {\n        new_localvar(ls, str_checkname(ls));\n        nvars++;\n    }\n    checknext(ls, R.TK_IN);\n    let line = ls.linenumber;\n    adjust_assign(ls, 3, explist(ls, e), e);\n    luaK_checkstack(fs, 3);  /* extra space to call generator */\n    forbody(ls, base, line, nvars - 3, 0);\n};\n\nconst forstat = function(ls, line) {\n    /* forstat -> FOR (fornum | forlist) END */\n    let fs = ls.fs;\n    let bl = new BlockCnt();\n    enterblock(fs, bl, 1);  /* scope for loop and control variables */\n    llex.luaX_next(ls);  /* skip 'for' */\n    let varname = str_checkname(ls);  /* first variable name */\n    switch (ls.t.token) {\n        case 61 /* ('=').charCodeAt(0) */: fornum(ls, varname, line); break;\n        case 44 /* (',').charCodeAt(0) */: case R.TK_IN: forlist(ls, varname); break;\n        default: llex.luaX_syntaxerror(ls, to_luastring(\"'=' or 'in' expected\", true));\n    }\n    check_match(ls, R.TK_END, R.TK_FOR, line);\n    leaveblock(fs);  /* loop scope ('break' jumps to this point) */\n};\n\nconst test_then_block = function(ls, escapelist) {\n    /* test_then_block -> [IF | ELSEIF] cond THEN block */\n    let bl = new BlockCnt();\n    let fs = ls.fs;\n    let v = new expdesc();\n    let jf;  /* instruction to skip 'then' code (if condition is false) */\n\n    llex.luaX_next(ls);  /* skip IF or ELSEIF */\n    expr(ls, v);  /* read condition */\n    checknext(ls, R.TK_THEN);\n\n    if (ls.t.token === R.TK_GOTO || ls.t.token === R.TK_BREAK) {\n        luaK_goiffalse(ls.fs, v);  /* will jump to label if condition is true */\n        enterblock(fs, bl, false);  /* must enter block before 'goto' */\n        gotostat(ls, v.t);   /* handle goto/break */\n        while (testnext(ls, 59 /* (';').charCodeAt(0) */));  /* skip colons */\n        if (block_follow(ls, 0)) {  /* 'goto' is the entire block? */\n            leaveblock(fs);\n            return escapelist;  /* and that is it */\n        } else  /* must skip over 'then' part if condition is false */\n            jf = luaK_jump(fs);\n    } else {  /* regular case (not goto/break) */\n        luaK_goiftrue(ls.fs, v);  /* skip over block if condition is false */\n        enterblock(fs, bl, false);\n        jf = v.f;\n    }\n\n    statlist(ls);  /* 'then' part */\n    leaveblock(fs);\n    if (ls.t.token === R.TK_ELSE || ls.t.token === R.TK_ELSEIF)  /* followed by 'else'/'elseif'? */\n        escapelist = luaK_concat(fs, escapelist, luaK_jump(fs));  /* must jump over it */\n    luaK_patchtohere(fs, jf);\n\n    return escapelist;\n};\n\nconst ifstat = function(ls, line) {\n    /* ifstat -> IF cond THEN block {ELSEIF cond THEN block} [ELSE block] END */\n    let fs = ls.fs;\n    let escapelist = NO_JUMP;  /* exit list for finished parts */\n    escapelist = test_then_block(ls, escapelist);  /* IF cond THEN block */\n    while (ls.t.token === R.TK_ELSEIF)\n        escapelist = test_then_block(ls, escapelist);  /* ELSEIF cond THEN block */\n    if (testnext(ls, R.TK_ELSE))\n        block(ls);  /* 'else' part */\n    check_match(ls, R.TK_END, R.TK_IF, line);\n    luaK_patchtohere(fs, escapelist);  /* patch escape list to 'if' end */\n};\n\nconst localfunc = function(ls) {\n    let b = new expdesc();\n    let fs = ls.fs;\n    new_localvar(ls, str_checkname(ls));  /* new local variable */\n    adjustlocalvars(ls, 1);  /* enter its scope */\n    body(ls, b, 0, ls.linenumber);  /* function created in next register */\n    /* debug information will only see the variable after this point! */\n    getlocvar(fs, b.u.info).startpc = fs.pc;\n};\n\nconst localstat = function(ls) {\n    /* stat -> LOCAL NAME {',' NAME} ['=' explist] */\n    let nvars = 0;\n    let nexps;\n    let e = new expdesc();\n    do {\n        new_localvar(ls, str_checkname(ls));\n        nvars++;\n    } while (testnext(ls, 44 /* (',').charCodeAt(0) */));\n    if (testnext(ls, 61 /* ('=').charCodeAt(0) */))\n        nexps = explist(ls, e);\n    else {\n        e.k = expkind.VVOID;\n        nexps = 0;\n    }\n    adjust_assign(ls, nvars, nexps, e);\n    adjustlocalvars(ls, nvars);\n};\n\nconst funcname = function(ls, v) {\n    /* funcname -> NAME {fieldsel} [':' NAME] */\n    let ismethod = 0;\n    singlevar(ls, v);\n    while (ls.t.token === 46 /* ('.').charCodeAt(0) */)\n        fieldsel(ls, v);\n    if (ls.t.token === 58 /* (':').charCodeAt(0) */) {\n        ismethod = 1;\n        fieldsel(ls, v);\n    }\n    return ismethod;\n};\n\nconst funcstat = function(ls, line) {\n    /* funcstat -> FUNCTION funcname body */\n    let v = new expdesc();\n    let b = new expdesc();\n    llex.luaX_next(ls);  /* skip FUNCTION */\n    let ismethod = funcname(ls, v);\n    body(ls, b, ismethod, line);\n    luaK_storevar(ls.fs, v, b);\n    luaK_fixline(ls.fs, line);  /* definition \"happens\" in the first line */\n};\n\nconst exprstat= function(ls) {\n    /* stat -> func | assignment */\n    let fs = ls.fs;\n    let v = new LHS_assign();\n    suffixedexp(ls, v.v);\n    if (ls.t.token === 61 /* ('=').charCodeAt(0) */ || ls.t.token === 44 /* (',').charCodeAt(0) */) { /* stat . assignment ? */\n        v.prev = null;\n        assignment(ls, v, 1);\n    }\n    else {  /* stat -> func */\n        check_condition(ls, v.v.k === expkind.VCALL, to_luastring(\"syntax error\", true));\n        SETARG_C(getinstruction(fs, v.v), 1);  /* call statement uses no results */\n    }\n};\n\nconst retstat = function(ls) {\n    /* stat -> RETURN [explist] [';'] */\n    let fs = ls.fs;\n    let e = new expdesc();\n    let first, nret;  /* registers with returned values */\n    if (block_follow(ls, 1) || ls.t.token === 59 /* (';').charCodeAt(0) */)\n        first = nret = 0;  /* return no values */\n    else {\n        nret = explist(ls, e);  /* optional return values */\n        if (hasmultret(e.k)) {\n            luaK_setmultret(fs, e);\n            if (e.k === expkind.VCALL && nret === 1) {  /* tail call? */\n                SET_OPCODE(getinstruction(fs, e), OP_TAILCALL);\n                lua_assert(getinstruction(fs, e).A === fs.nactvar);\n            }\n            first = fs.nactvar;\n            nret = LUA_MULTRET;  /* return all values */\n        } else {\n            if (nret === 1)  /* only one single value? */\n                first = luaK_exp2anyreg(fs, e);\n            else {\n                luaK_exp2nextreg(fs, e);  /* values must go to the stack */\n                first = fs.nactvar;  /* return all active values */\n                lua_assert(nret === fs.freereg - first);\n            }\n        }\n    }\n    luaK_ret(fs, first, nret);\n    testnext(ls, 59 /* (';').charCodeAt(0) */);  /* skip optional semicolon */\n};\n\nconst statement = function(ls) {\n    let line = ls.linenumber;  /* may be needed for error messages */\n    enterlevel(ls);\n    switch(ls.t.token) {\n        case 59 /* (';').charCodeAt(0) */: {  /* stat -> ';' (empty statement) */\n            llex.luaX_next(ls);  /* skip ';' */\n            break;\n        }\n        case R.TK_IF: {  /* stat -> ifstat */\n            ifstat(ls, line);\n            break;\n        }\n        case R.TK_WHILE: {  /* stat -> whilestat */\n            whilestat(ls, line);\n            break;\n        }\n        case R.TK_DO: {  /* stat -> DO block END */\n            llex.luaX_next(ls);  /* skip DO */\n            block(ls);\n            check_match(ls, R.TK_END, R.TK_DO, line);\n            break;\n        }\n        case R.TK_FOR: {  /* stat -> forstat */\n            forstat(ls, line);\n            break;\n        }\n        case R.TK_REPEAT: {  /* stat -> repeatstat */\n            repeatstat(ls, line);\n            break;\n        }\n        case R.TK_FUNCTION: {  /* stat -> funcstat */\n            funcstat(ls, line);\n            break;\n        }\n        case R.TK_LOCAL: {  /* stat -> localstat */\n            llex.luaX_next(ls);  /* skip LOCAL */\n            if (testnext(ls, R.TK_FUNCTION))  /* local function? */\n                localfunc(ls);\n            else\n                localstat(ls);\n            break;\n        }\n        case R.TK_DBCOLON: {  /* stat -> label */\n            llex.luaX_next(ls);  /* skip double colon */\n            labelstat(ls, str_checkname(ls), line);\n            break;\n        }\n        case R.TK_RETURN: {  /* skip double colon */\n            llex.luaX_next(ls);  /* skip RETURN */\n            retstat(ls);\n            break;\n        }\n        case R.TK_BREAK:   /* stat -> breakstat */\n        case R.TK_GOTO: {  /* stat -> 'goto' NAME */\n            gotostat(ls, luaK_jump(ls.fs));\n            break;\n        }\n        default: {  /* stat -> func | assignment */\n            exprstat(ls);\n            break;\n        }\n    }\n    lua_assert(ls.fs.f.maxstacksize >= ls.fs.freereg && ls.fs.freereg >= ls.fs.nactvar);\n    ls.fs.freereg = ls.fs.nactvar;  /* free registers */\n    leavelevel(ls);\n};\n\n/*\n** compiles the main function, which is a regular vararg function with an\n** upvalue named LUA_ENV\n*/\nconst mainfunc = function(ls, fs) {\n    let bl = new BlockCnt();\n    let v = new expdesc();\n    open_func(ls, fs, bl);\n    fs.f.is_vararg = true;  /* main function is always declared vararg */\n    init_exp(v, expkind.VLOCAL, 0);  /* create and... */\n    newupvalue(fs, ls.envn, v);  /* ...set environment upvalue */\n    llex.luaX_next(ls);  /* read first token */\n    statlist(ls);  /* parse main body */\n    check(ls, R.TK_EOS);\n    close_func(ls);\n};\n\nconst luaY_parser = function(L, z, buff, dyd, name, firstchar) {\n    let lexstate = new llex.LexState();\n    let funcstate = new FuncState();\n    let cl = lfunc.luaF_newLclosure(L, 1);  /* create main closure */\n    ldo.luaD_inctop(L);\n    L.stack[L.top-1].setclLvalue(cl);\n    lexstate.h = ltable.luaH_new(L);  /* create table for scanner */\n    ldo.luaD_inctop(L);\n    L.stack[L.top-1].sethvalue(lexstate.h);\n    funcstate.f = cl.p = new Proto(L);\n    funcstate.f.source = luaS_new(L, name);\n    lexstate.buff = buff;\n    lexstate.dyd = dyd;\n    dyd.actvar.n = dyd.gt.n = dyd.label.n = 0;\n    llex.luaX_setinput(L, lexstate, z, funcstate.f.source, firstchar);\n    mainfunc(lexstate, funcstate);\n    lua_assert(!funcstate.prev && funcstate.nups === 1 && !lexstate.fs);\n    /* all scopes should be correctly finished */\n    lua_assert(dyd.actvar.n === 0 && dyd.gt.n === 0 && dyd.label.n === 0);\n    delete L.stack[--L.top];  /* remove scanner's table */\n    return cl;  /* closure is on the stack, too */\n};\n\n\nmodule.exports.Dyndata     = Dyndata;\nmodule.exports.expkind     = expkind;\nmodule.exports.expdesc     = expdesc;\nmodule.exports.luaY_parser = luaY_parser;\nmodule.exports.vkisinreg   = vkisinreg;\n", ";\n\nconst {\n    LUA_SIGNATURE,\n    constant_types: {\n        LUA_TBOOLEAN,\n        LUA_TLNGSTR,\n        LUA_TNIL,\n        LUA_TNUMFLT,\n        LUA_TNUMINT,\n        LUA_TSHRSTR\n    },\n    thread_status: { LUA_ERRSYNTAX },\n    is_luastring,\n    luastring_eq,\n    to_luastring\n} = require('./defs.js');\nconst ldo      = require('./ldo.js');\nconst lfunc    = require('./lfunc.js');\nconst lobject  = require('./lobject.js');\nconst {\n    MAXARG_sBx,\n    POS_A,\n    POS_Ax,\n    POS_B,\n    POS_Bx,\n    POS_C,\n    POS_OP,\n    SIZE_A,\n    SIZE_Ax,\n    SIZE_B,\n    SIZE_Bx,\n    SIZE_C,\n    SIZE_OP\n} = require('./lopcodes.js');\nconst { lua_assert } = require(\"./llimits.js\");\nconst { luaS_bless } = require('./lstring.js');\nconst {\n    luaZ_read,\n    ZIO\n} = require('./lzio.js');\n\nlet LUAC_DATA = [0x19, 0x93, 13, 10, 0x1a, 10];\n\nclass BytecodeParser {\n\n    constructor(L, Z, name) {\n        this.intSize = 4;\n        this.size_tSize = 4;\n        this.instructionSize = 4;\n        this.integerSize = 4;\n        this.numberSize = 8;\n\n        lua_assert(Z instanceof ZIO, \"BytecodeParser only operates on a ZIO\");\n        lua_assert(is_luastring(name));\n\n        if (name[0] === 64 /* ('@').charCodeAt(0) */ || name[0] === 61 /* ('=').charCodeAt(0) */)\n            this.name = name.subarray(1);\n        else if (name[0] == LUA_SIGNATURE[0])\n            this.name = to_luastring(\"binary string\", true);\n        else\n            this.name = name;\n\n        this.L = L;\n        this.Z = Z;\n\n        // Used to do buffer to number conversions\n        this.arraybuffer = new ArrayBuffer(\n            Math.max(this.intSize, this.size_tSize, this.instructionSize, this.integerSize, this.numberSize)\n        );\n        this.dv = new DataView(this.arraybuffer);\n        this.u8 = new Uint8Array(this.arraybuffer);\n    }\n\n    read(size) {\n        let u8 = new Uint8Array(size);\n        if(luaZ_read(this.Z, u8, 0, size) !== 0)\n            this.error(\"truncated\");\n        return u8;\n    }\n\n    LoadByte() {\n        if (luaZ_read(this.Z, this.u8, 0, 1) !== 0)\n            this.error(\"truncated\");\n        return this.u8[0];\n    }\n\n    LoadInt() {\n        if (luaZ_read(this.Z, this.u8, 0, this.intSize) !== 0)\n            this.error(\"truncated\");\n        return this.dv.getInt32(0, true);\n    }\n\n    LoadNumber() {\n        if (luaZ_read(this.Z, this.u8, 0, this.numberSize) !== 0)\n            this.error(\"truncated\");\n        return this.dv.getFloat64(0, true);\n    }\n\n    LoadInteger() {\n        if (luaZ_read(this.Z, this.u8, 0, this.integerSize) !== 0)\n            this.error(\"truncated\");\n        return this.dv.getInt32(0, true);\n    }\n\n    LoadSize_t() {\n        return this.LoadInteger();\n    }\n\n    LoadString() {\n        let size = this.LoadByte();\n        if (size === 0xFF)\n            size = this.LoadSize_t();\n        if (size === 0)\n            return null;\n        return luaS_bless(this.L, this.read(size-1));\n    }\n\n    /* creates a mask with 'n' 1 bits at position 'p' */\n    static MASK1(n, p) {\n        return ((~((~0)<<(n)))<<(p));\n    }\n\n    LoadCode(f) {\n        let n = this.LoadInt();\n        let p = BytecodeParser;\n\n        for (let i = 0; i < n; i++) {\n            if (luaZ_read(this.Z, this.u8, 0, this.instructionSize) !== 0)\n                this.error(\"truncated\");\n            let ins = this.dv.getUint32(0, true);\n            f.code[i] = {\n                code:   ins,\n                opcode: (ins >> POS_OP) & p.MASK1(SIZE_OP, 0),\n                A:      (ins >> POS_A)  & p.MASK1(SIZE_A,  0),\n                B:      (ins >> POS_B)  & p.MASK1(SIZE_B,  0),\n                C:      (ins >> POS_C)  & p.MASK1(SIZE_C,  0),\n                Bx:     (ins >> POS_Bx) & p.MASK1(SIZE_Bx, 0),\n                Ax:     (ins >> POS_Ax) & p.MASK1(SIZE_Ax, 0),\n                sBx:    ((ins >> POS_Bx) & p.MASK1(SIZE_Bx, 0)) - MAXARG_sBx\n            };\n        }\n    }\n\n    LoadConstants(f) {\n        let n = this.LoadInt();\n\n        for (let i = 0; i < n; i++) {\n            let t = this.LoadByte();\n\n            switch (t) {\n                case LUA_TNIL:\n                    f.k.push(new lobject.TValue(LUA_TNIL, null));\n                    break;\n                case LUA_TBOOLEAN:\n                    f.k.push(new lobject.TValue(LUA_TBOOLEAN, this.LoadByte() !== 0));\n                    break;\n                case LUA_TNUMFLT:\n                    f.k.push(new lobject.TValue(LUA_TNUMFLT, this.LoadNumber()));\n                    break;\n                case LUA_TNUMINT:\n                    f.k.push(new lobject.TValue(LUA_TNUMINT, this.LoadInteger()));\n                    break;\n                case LUA_TSHRSTR:\n                case LUA_TLNGSTR:\n                    f.k.push(new lobject.TValue(LUA_TLNGSTR, this.LoadString()));\n                    break;\n                default:\n                    this.error(`unrecognized constant '${t}'`);\n            }\n        }\n    }\n\n    LoadProtos(f) {\n        let n = this.LoadInt();\n\n        for (let i = 0; i < n; i++) {\n            f.p[i] = new lfunc.Proto(this.L);\n            this.LoadFunction(f.p[i], f.source);\n        }\n    }\n\n    LoadUpvalues(f) {\n        let n = this.LoadInt();\n\n        for (let i = 0; i < n; i++) {\n            f.upvalues[i] = {\n                name:    null,\n                instack: this.LoadByte(),\n                idx:     this.LoadByte()\n            };\n        }\n    }\n\n    LoadDebug(f) {\n        let n = this.LoadInt();\n        for (let i = 0; i < n; i++)\n            f.lineinfo[i] = this.LoadInt();\n\n        n = this.LoadInt();\n        for (let i = 0; i < n; i++) {\n            f.locvars[i] = {\n                varname: this.LoadString(),\n                startpc: this.LoadInt(),\n                endpc:   this.LoadInt()\n            };\n        }\n\n        n = this.LoadInt();\n        for (let i = 0; i < n; i++) {\n            f.upvalues[i].name = this.LoadString();\n        }\n    }\n\n    LoadFunction(f, psource) {\n        f.source = this.LoadString();\n        if (f.source === null)  /* no source in dump? */\n            f.source = psource;  /* reuse parent's source */\n        f.linedefined = this.LoadInt();\n        f.lastlinedefined = this.LoadInt();\n        f.numparams = this.LoadByte();\n        f.is_vararg = this.LoadByte() !== 0;\n        f.maxstacksize = this.LoadByte();\n        this.LoadCode(f);\n        this.LoadConstants(f);\n        this.LoadUpvalues(f);\n        this.LoadProtos(f);\n        this.LoadDebug(f);\n    }\n\n    checkliteral(s, msg) {\n        let buff = this.read(s.length);\n        if (!luastring_eq(buff, s))\n            this.error(msg);\n    }\n\n    checkHeader() {\n        this.checkliteral(LUA_SIGNATURE.subarray(1), \"not a\"); /* 1st char already checked */\n\n        if (this.LoadByte() !== 0x53)\n            this.error(\"version mismatch in\");\n\n        if (this.LoadByte() !== 0)\n            this.error(\"format mismatch in\");\n\n        this.checkliteral(LUAC_DATA, \"corrupted\");\n\n        this.intSize         = this.LoadByte();\n        this.size_tSize      = this.LoadByte();\n        this.instructionSize = this.LoadByte();\n        this.integerSize     = this.LoadByte();\n        this.numberSize      = this.LoadByte();\n\n        this.checksize(this.intSize, 4, \"int\");\n        this.checksize(this.size_tSize, 4, \"size_t\");\n        this.checksize(this.instructionSize, 4, \"instruction\");\n        this.checksize(this.integerSize, 4, \"integer\");\n        this.checksize(this.numberSize, 8, \"number\");\n\n        if (this.LoadInteger() !== 0x5678)\n            this.error(\"endianness mismatch in\");\n\n        if (this.LoadNumber() !== 370.5)\n            this.error(\"float format mismatch in\");\n\n    }\n\n    error(why) {\n        lobject.luaO_pushfstring(this.L, to_luastring(\"%s: %s precompiled chunk\"), this.name, to_luastring(why));\n        ldo.luaD_throw(this.L, LUA_ERRSYNTAX);\n    }\n\n    checksize(byte, size, tname) {\n        if (byte !== size)\n            this.error(`${tname} size mismatch in`);\n    }\n}\n\nconst luaU_undump = function(L, Z, name) {\n    let S = new BytecodeParser(L, Z, name);\n    S.checkHeader();\n    let cl = lfunc.luaF_newLclosure(L, S.LoadByte());\n    ldo.luaD_inctop(L);\n    L.stack[L.top-1].setclLvalue(cl);\n    cl.p = new lfunc.Proto(L);\n    S.LoadFunction(cl.p, null);\n    lua_assert(cl.nupvalues === cl.p.upvalues.length);\n    /* luai_verifycode */\n    return cl;\n};\n\nmodule.exports.luaU_undump = luaU_undump;\n", ";\n\nconst {\n    LUA_HOOKCALL,\n    LUA_HOOKRET,\n    LUA_HOOKTAILCALL,\n    LUA_MASKCALL,\n    LUA_MASKLINE,\n    LUA_MASKRET,\n    LUA_MINSTACK,\n    LUA_MULTRET,\n    LUA_SIGNATURE,\n    constant_types: {\n        LUA_TCCL,\n        LUA_TLCF,\n        LUA_TLCL,\n        LUA_TNIL\n    },\n    thread_status: {\n        LUA_ERRMEM,\n        LUA_ERRERR,\n        LUA_ERRRUN,\n        LUA_ERRSYNTAX,\n        LUA_OK,\n        LUA_YIELD\n    },\n    lua_Debug,\n    luastring_indexOf,\n    to_luastring\n} = require('./defs.js');\nconst lapi     = require('./lapi.js');\nconst ldebug   = require('./ldebug.js');\nconst lfunc    = require('./lfunc.js');\nconst {\n    api_check,\n    lua_assert,\n    LUAI_MAXCCALLS\n} = require('./llimits.js');\nconst lobject  = require('./lobject.js');\nconst lopcodes = require('./lopcodes.js');\nconst lparser  = require('./lparser.js');\nconst lstate   = require('./lstate.js');\nconst { luaS_newliteral } = require('./lstring.js');\nconst ltm      = require('./ltm.js');\nconst { LUAI_MAXSTACK } = require('./luaconf.js');\nconst lundump  = require('./lundump.js');\nconst lvm      = require('./lvm.js');\nconst { MBuffer } = require('./lzio.js');\n\nconst adjust_top = function(L, newtop) {\n    if (L.top < newtop) {\n        while (L.top < newtop)\n            L.stack[L.top++] = new lobject.TValue(LUA_TNIL, null);\n    } else {\n        while (L.top > newtop)\n            delete L.stack[--L.top];\n    }\n};\n\nconst seterrorobj = function(L, errcode, oldtop) {\n    let current_top = L.top;\n\n    /* extend stack so that L.stack[oldtop] is sure to exist */\n    while (L.top < oldtop + 1)\n        L.stack[L.top++] = new lobject.TValue(LUA_TNIL, null);\n\n    switch (errcode) {\n        case LUA_ERRMEM: {\n            lobject.setsvalue2s(L, oldtop, luaS_newliteral(L, \"not enough memory\"));\n            break;\n        }\n        case LUA_ERRERR: {\n            lobject.setsvalue2s(L, oldtop, luaS_newliteral(L, \"error in error handling\"));\n            break;\n        }\n        default: {\n            lobject.setobjs2s(L, oldtop, current_top - 1);\n        }\n    }\n\n    while (L.top > oldtop + 1)\n        delete L.stack[--L.top];\n};\n\nconst ERRORSTACKSIZE = LUAI_MAXSTACK + 200;\n\nconst luaD_reallocstack = function(L, newsize) {\n    lua_assert(newsize <= LUAI_MAXSTACK || newsize == ERRORSTACKSIZE);\n    lua_assert(L.stack_last == L.stack.length - lstate.EXTRA_STACK);\n    L.stack.length = newsize;\n    L.stack_last = newsize - lstate.EXTRA_STACK;\n};\n\nconst luaD_growstack = function(L, n) {\n    let size = L.stack.length;\n    if (size > LUAI_MAXSTACK)\n        luaD_throw(L, LUA_ERRERR);\n    else {\n        let needed = L.top + n + lstate.EXTRA_STACK;\n        let newsize = 2 * size;\n        if (newsize > LUAI_MAXSTACK) newsize = LUAI_MAXSTACK;\n        if (newsize < needed) newsize = needed;\n        if (newsize > LUAI_MAXSTACK) {  /* stack overflow? */\n            luaD_reallocstack(L, ERRORSTACKSIZE);\n            ldebug.luaG_runerror(L, to_luastring(\"stack overflow\", true));\n        }\n        else\n            luaD_reallocstack(L, newsize);\n    }\n};\n\nconst luaD_checkstack = function(L, n) {\n    if (L.stack_last - L.top <= n)\n        luaD_growstack(L, n);\n};\n\nconst stackinuse = function(L) {\n    let lim = L.top;\n    for (let ci = L.ci; ci !== null; ci = ci.previous) {\n        if (lim < ci.top) lim = ci.top;\n    }\n    lua_assert(lim <= L.stack_last);\n    return lim + 1; /* part of stack in use */\n};\n\nconst luaD_shrinkstack = function(L) {\n    let inuse = stackinuse(L);\n    let goodsize = inuse + Math.floor(inuse / 8) + 2*lstate.EXTRA_STACK;\n    if (goodsize > LUAI_MAXSTACK)\n        goodsize = LUAI_MAXSTACK;  /* respect stack limit */\n    if (L.stack.length > LUAI_MAXSTACK)  /* had been handling stack overflow? */\n        lstate.luaE_freeCI(L);  /* free all CIs (list grew because of an error) */\n    /* if thread is currently not handling a stack overflow and its\n     good size is smaller than current size, shrink its stack */\n    if (inuse <= (LUAI_MAXSTACK - lstate.EXTRA_STACK) && goodsize < L.stack.length)\n        luaD_reallocstack(L, goodsize);\n};\n\nconst luaD_inctop = function(L) {\n    luaD_checkstack(L, 1);\n    L.stack[L.top++] = new lobject.TValue(LUA_TNIL, null);\n};\n\n/*\n** Prepares a function call: checks the stack, creates a new CallInfo\n** entry, fills in the relevant information, calls hook if needed.\n** If function is a JS function, does the call, too. (Otherwise, leave\n** the execution ('luaV_execute') to the caller, to allow stackless\n** calls.) Returns true iff function has been executed (JS function).\n*/\nconst luaD_precall = function(L, off, nresults) {\n    let func = L.stack[off];\n\n    switch(func.type) {\n        case LUA_TCCL:\n        case LUA_TLCF: {\n            let f = func.type === LUA_TCCL ? func.value.f : func.value;\n\n            luaD_checkstack(L, LUA_MINSTACK);\n            let ci = lstate.luaE_extendCI(L);\n            ci.funcOff = off;\n            ci.nresults = nresults;\n            ci.func = func;\n            ci.top = L.top + LUA_MINSTACK;\n            lua_assert(ci.top <= L.stack_last);\n            ci.callstatus = 0;\n            if (L.hookmask & LUA_MASKCALL)\n                luaD_hook(L, LUA_HOOKCALL, -1);\n            let n = f(L); /* do the actual call */\n            if (typeof n !== \"number\" || n < 0 || (n|0) !== n)\n                throw Error(\"invalid return value from JS function (expected integer)\");\n            lapi.api_checknelems(L, n);\n\n            luaD_poscall(L, ci, L.top - n, n);\n\n            return true;\n        }\n        case LUA_TLCL: {\n            let base;\n            let p = func.value.p;\n            let n = L.top - off - 1;\n            let fsize = p.maxstacksize;\n            luaD_checkstack(L, fsize);\n            if (p.is_vararg) {\n                base = adjust_varargs(L, p, n);\n            } else {\n                for (; n < p.numparams; n++)\n                    L.stack[L.top++] = new lobject.TValue(LUA_TNIL, null); // complete missing arguments\n                base = off + 1;\n            }\n\n            let ci = lstate.luaE_extendCI(L);\n            ci.funcOff = off;\n            ci.nresults = nresults;\n            ci.func = func;\n            ci.l_base = base;\n            ci.top = base + fsize;\n            adjust_top(L, ci.top);\n            ci.l_code = p.code;\n            ci.l_savedpc = 0;\n            ci.callstatus = lstate.CIST_LUA;\n            if (L.hookmask & LUA_MASKCALL)\n                callhook(L, ci);\n            return false;\n        }\n        default:\n            luaD_checkstack(L, 1);\n            tryfuncTM(L, off, func);\n            return luaD_precall(L, off, nresults);\n    }\n};\n\nconst luaD_poscall = function(L, ci, firstResult, nres) {\n    let wanted = ci.nresults;\n\n    if (L.hookmask & (LUA_MASKRET | LUA_MASKLINE)) {\n        if (L.hookmask & LUA_MASKRET)\n            luaD_hook(L, LUA_HOOKRET, -1);\n        L.oldpc = ci.previous.l_savedpc;  /* 'oldpc' for caller function */\n    }\n\n    let res = ci.funcOff;\n    L.ci = ci.previous;\n    L.ci.next = null;\n    return moveresults(L, firstResult, res, nres, wanted);\n};\n\nconst moveresults = function(L, firstResult, res, nres, wanted) {\n    switch (wanted) {\n        case 0:\n            break;\n        case 1: {\n            if (nres === 0)\n                L.stack[res].setnilvalue();\n            else {\n                lobject.setobjs2s(L, res, firstResult); /* move it to proper place */\n            }\n            break;\n        }\n        case LUA_MULTRET: {\n            for (let i = 0; i < nres; i++)\n                lobject.setobjs2s(L, res + i, firstResult + i);\n            for (let i=L.top; i>=(res + nres); i--)\n                delete L.stack[i];\n            L.top = res + nres;\n            return false;\n        }\n        default: {\n            let i;\n            if (wanted <= nres) {\n                for (i = 0; i < wanted; i++)\n                    lobject.setobjs2s(L, res + i, firstResult + i);\n            } else {\n                for (i = 0; i < nres; i++)\n                    lobject.setobjs2s(L, res + i, firstResult + i);\n                for (; i < wanted; i++) {\n                    if (res+i >= L.top)\n                        L.stack[res + i] = new lobject.TValue(LUA_TNIL, null);\n                    else\n                        L.stack[res + i].setnilvalue();\n                }\n            }\n            break;\n        }\n    }\n    let newtop = res + wanted; /* top points after the last result */\n    for (let i=L.top; i>=newtop; i--)\n        delete L.stack[i];\n    L.top = newtop;\n    return true;\n};\n\n/*\n** Call a hook for the given event. Make sure there is a hook to be\n** called. (Both 'L->hook' and 'L->hookmask', which triggers this\n** function, can be changed asynchronously by signals.)\n*/\nconst luaD_hook = function(L, event, line) {\n    let hook = L.hook;\n    if (hook && L.allowhook) {  /* make sure there is a hook */\n        let ci = L.ci;\n        let top = L.top;\n        let ci_top = ci.top;\n        let ar = new lua_Debug();\n        ar.event = event;\n        ar.currentline = line;\n        ar.i_ci = ci;\n        luaD_checkstack(L, LUA_MINSTACK);  /* ensure minimum stack size */\n        ci.top = L.top + LUA_MINSTACK;\n        lua_assert(ci.top <= L.stack_last);\n        L.allowhook = 0;  /* cannot call hooks inside a hook */\n        ci.callstatus |= lstate.CIST_HOOKED;\n        hook(L, ar);\n        lua_assert(!L.allowhook);\n        L.allowhook = 1;\n        ci.top = ci_top;\n        adjust_top(L, top);\n        ci.callstatus &= ~lstate.CIST_HOOKED;\n    }\n};\n\nconst callhook = function(L, ci) {\n    let hook = LUA_HOOKCALL;\n    ci.l_savedpc++;  /* hooks assume 'pc' is already incremented */\n    if ((ci.previous.callstatus & lstate.CIST_LUA) &&\n      ci.previous.l_code[ci.previous.l_savedpc - 1].opcode == lopcodes.OpCodesI.OP_TAILCALL) {\n        ci.callstatus |= lstate.CIST_TAIL;\n        hook = LUA_HOOKTAILCALL;\n    }\n    luaD_hook(L, hook, -1);\n    ci.l_savedpc--;  /* correct 'pc' */\n};\n\nconst adjust_varargs = function(L, p, actual) {\n    let nfixargs = p.numparams;\n    /* move fixed parameters to final position */\n    let fixed = L.top - actual; /* first fixed argument */\n    let base = L.top; /* final position of first argument */\n\n    let i;\n    for (i = 0; i < nfixargs && i < actual; i++) {\n        lobject.pushobj2s(L, L.stack[fixed + i]);\n        L.stack[fixed + i].setnilvalue();\n    }\n\n    for (; i < nfixargs; i++)\n        L.stack[L.top++] = new lobject.TValue(LUA_TNIL, null);\n\n    return base;\n};\n\nconst tryfuncTM = function(L, off, func) {\n    let tm = ltm.luaT_gettmbyobj(L, func, ltm.TMS.TM_CALL);\n    if (!tm.ttisfunction(tm))\n        ldebug.luaG_typeerror(L, func, to_luastring(\"call\", true));\n    /* Open a hole inside the stack at 'func' */\n    lobject.pushobj2s(L, L.stack[L.top-1]); /* push top of stack again */\n    for (let p = L.top-2; p > off; p--)\n        lobject.setobjs2s(L, p, p-1); /* move other items up one */\n    lobject.setobj2s(L, off, tm); /* tag method is the new function to be called */\n};\n\n/*\n** Check appropriate error for stack overflow (\"regular\" overflow or\n** overflow while handling stack overflow). If 'nCalls' is larger than\n** LUAI_MAXCCALLS (which means it is handling a \"regular\" overflow) but\n** smaller than 9/8 of LUAI_MAXCCALLS, does not report an error (to\n** allow overflow handling to work)\n*/\nconst stackerror = function(L) {\n    if (L.nCcalls === LUAI_MAXCCALLS)\n        ldebug.luaG_runerror(L, to_luastring(\"JS stack overflow\", true));\n    else if (L.nCcalls >= LUAI_MAXCCALLS + (LUAI_MAXCCALLS >> 3))\n        luaD_throw(L, LUA_ERRERR);  /* error while handing stack error */\n};\n\n/*\n** Call a function (JS or Lua). The function to be called is at func.\n** The arguments are on the stack, right after the function.\n** When returns, all the results are on the stack, starting at the original\n** function position.\n*/\nconst luaD_call = function(L, off, nResults) {\n    if (++L.nCcalls >= LUAI_MAXCCALLS)\n        stackerror(L);\n    if (!luaD_precall(L, off, nResults))\n        lvm.luaV_execute(L);\n    L.nCcalls--;\n};\n\nconst luaD_throw = function(L, errcode) {\n    if (L.errorJmp) {  /* thread has an error handler? */\n        L.errorJmp.status = errcode;  /* set status */\n        throw L.errorJmp;\n    } else {  /* thread has no error handler */\n        let g = L.l_G;\n        L.status = errcode;  /* mark it as dead */\n        if (g.mainthread.errorJmp) {  /* main thread has a handler? */\n            g.mainthread.stack[g.mainthread.top++] = L.stack[L.top - 1];  /* copy error obj. */\n            luaD_throw(g.mainthread, errcode);  /* re-throw in main thread */\n        } else {  /* no handler at all; abort */\n            let panic = g.panic;\n            if (panic) {  /* panic function? */\n                seterrorobj(L, errcode, L.top);  /* assume EXTRA_STACK */\n                if (L.ci.top < L.top)\n                    L.ci.top = L.top;  /* pushing msg. can break this invariant */\n                panic(L);  /* call panic function (last chance to jump out) */\n            }\n            throw new Error(`Aborted ${errcode}`);\n        }\n    }\n};\n\nconst luaD_rawrunprotected = function(L, f, ud) {\n    let oldnCcalls = L.nCcalls;\n    let lj = {\n        status: LUA_OK,\n        previous: L.errorJmp /* chain new error handler */\n    };\n    L.errorJmp = lj;\n\n    try {\n        f(L, ud);\n    } catch (e) {\n        if (lj.status === LUA_OK) {\n            /* error was not thrown via luaD_throw, i.e. it is a JS error */\n            /* run user error handler (if it exists) */\n            let atnativeerror = L.l_G.atnativeerror;\n            if (atnativeerror) {\n                try {\n                    lj.status = LUA_OK;\n\n                    lapi.lua_pushcfunction(L, atnativeerror);\n                    lapi.lua_pushlightuserdata(L, e);\n                    luaD_callnoyield(L, L.top - 2, 1);\n\n                    /* Now run the message handler (if it exists) */\n                    /* copy of luaG_errormsg without the throw */\n                    if (L.errfunc !== 0) {  /* is there an error handling function? */\n                        let errfunc = L.errfunc;\n                        lobject.pushobj2s(L, L.stack[L.top - 1]); /* move argument */\n                        lobject.setobjs2s(L, L.top - 2, errfunc); /* push function */\n                        luaD_callnoyield(L, L.top - 2, 1);\n                    }\n\n                    lj.status = LUA_ERRRUN;\n                } catch(e2) {\n                    if (lj.status === LUA_OK) {\n                        /* also failed */\n                        lj.status = -1;\n                    }\n                }\n            } else {\n                lj.status = -1;\n            }\n        }\n    }\n\n    L.errorJmp = lj.previous;\n    L.nCcalls = oldnCcalls;\n\n    return lj.status;\n\n};\n\n/*\n** Completes the execution of an interrupted C function, calling its\n** continuation function.\n*/\nconst finishCcall = function(L, status) {\n    let ci = L.ci;\n\n    /* must have a continuation and must be able to call it */\n    lua_assert(ci.c_k !== null && L.nny === 0);\n    /* error status can only happen in a protected call */\n    lua_assert(ci.callstatus & lstate.CIST_YPCALL || status === LUA_YIELD);\n\n    if (ci.callstatus & lstate.CIST_YPCALL) {  /* was inside a pcall? */\n        ci.callstatus &= ~lstate.CIST_YPCALL;  /* continuation is also inside it */\n        L.errfunc = ci.c_old_errfunc;  /* with the same error function */\n    }\n\n    /* finish 'lua_callk'/'lua_pcall'; CIST_YPCALL and 'errfunc' already\n       handled */\n    if (ci.nresults === LUA_MULTRET && L.ci.top < L.top) L.ci.top = L.top;\n    let c_k = ci.c_k; /* don't want to call as method */\n    let n = c_k(L, status, ci.c_ctx);  /* call continuation function */\n    lapi.api_checknelems(L, n);\n    luaD_poscall(L, ci, L.top - n, n);  /* finish 'luaD_precall' */\n};\n\n/*\n** Executes \"full continuation\" (everything in the stack) of a\n** previously interrupted coroutine until the stack is empty (or another\n** interruption long-jumps out of the loop). If the coroutine is\n** recovering from an error, 'ud' points to the error status, which must\n** be passed to the first continuation function (otherwise the default\n** status is LUA_YIELD).\n*/\nconst unroll = function(L, ud) {\n    if (ud !== null)  /* error status? */\n        finishCcall(L, ud);  /* finish 'lua_pcallk' callee */\n\n    while (L.ci !== L.base_ci) {  /* something in the stack */\n        if (!(L.ci.callstatus & lstate.CIST_LUA))  /* C function? */\n            finishCcall(L, LUA_YIELD);  /* complete its execution */\n        else {  /* Lua function */\n            lvm.luaV_finishOp(L);  /* finish interrupted instruction */\n            lvm.luaV_execute(L);  /* execute down to higher C 'boundary' */\n        }\n    }\n};\n\n/*\n** Try to find a suspended protected call (a \"recover point\") for the\n** given thread.\n*/\nconst findpcall = function(L) {\n    for (let ci = L.ci; ci !== null; ci = ci.previous) {  /* search for a pcall */\n        if (ci.callstatus & lstate.CIST_YPCALL)\n            return ci;\n    }\n\n    return null;  /* no pending pcall */\n};\n\n/*\n** Recovers from an error in a coroutine. Finds a recover point (if\n** there is one) and completes the execution of the interrupted\n** 'luaD_pcall'. If there is no recover point, returns zero.\n*/\nconst recover = function(L, status) {\n    let ci = findpcall(L);\n    if (ci === null) return 0;  /* no recovery point */\n    /* \"finish\" luaD_pcall */\n    let oldtop = ci.extra;\n    lfunc.luaF_close(L, oldtop);\n    seterrorobj(L, status, oldtop);\n    L.ci = ci;\n    L.allowhook = ci.callstatus & lstate.CIST_OAH;  /* restore original 'allowhook' */\n    L.nny = 0;  /* should be zero to be yieldable */\n    luaD_shrinkstack(L);\n    L.errfunc = ci.c_old_errfunc;\n    return 1;  /* continue running the coroutine */\n};\n\n/*\n** Signal an error in the call to 'lua_resume', not in the execution\n** of the coroutine itself. (Such errors should not be handled by any\n** coroutine error handler and should not kill the coroutine.)\n*/\nconst resume_error = function(L, msg, narg) {\n    let ts = luaS_newliteral(L, msg);\n    if (narg === 0) {\n        lobject.pushsvalue2s(L, ts);\n        api_check(L, L.top <= L.ci.top, \"stack overflow\");\n    } else {\n        /* remove args from the stack */\n        for (let i=1; i<narg; i++)\n            delete L.stack[--L.top];\n        lobject.setsvalue2s(L, L.top-1, ts);  /* push error message */\n    }\n    return LUA_ERRRUN;\n};\n\n/*\n** Do the work for 'lua_resume' in protected mode. Most of the work\n** depends on the status of the coroutine: initial state, suspended\n** inside a hook, or regularly suspended (optionally with a continuation\n** function), plus erroneous cases: non-suspended coroutine or dead\n** coroutine.\n*/\nconst resume = function(L, n) {\n    let firstArg = L.top - n;  /* first argument */\n    let ci = L.ci;\n    if (L.status === LUA_OK) {  /* starting a coroutine? */\n        if (!luaD_precall(L, firstArg - 1, LUA_MULTRET))  /* Lua function? */\n            lvm.luaV_execute(L);  /* call it */\n    } else {  /* resuming from previous yield */\n        lua_assert(L.status === LUA_YIELD);\n        L.status = LUA_OK;  /* mark that it is running (again) */\n        ci.funcOff = ci.extra;\n        ci.func = L.stack[ci.funcOff];\n\n        if (ci.callstatus & lstate.CIST_LUA)  /* yielded inside a hook? */\n            lvm.luaV_execute(L);  /* just continue running Lua code */\n        else {  /* 'common' yield */\n            if (ci.c_k !== null) {  /* does it have a continuation function? */\n                n = ci.c_k(L, LUA_YIELD, ci.c_ctx); /* call continuation */\n                lapi.api_checknelems(L, n);\n                firstArg = L.top - n;  /* yield results come from continuation */\n            }\n\n            luaD_poscall(L, ci, firstArg, n);  /* finish 'luaD_precall' */\n        }\n\n        unroll(L, null);  /* run continuation */\n    }\n};\n\nconst lua_resume = function(L, from, nargs) {\n    let oldnny = L.nny;  /* save \"number of non-yieldable\" calls */\n\n    if (L.status === LUA_OK) {  /* may be starting a coroutine */\n        if (L.ci !== L.base_ci)  /* not in base level? */\n            return resume_error(L, \"cannot resume non-suspended coroutine\", nargs);\n    } else if (L.status !== LUA_YIELD)\n        return resume_error(L, \"cannot resume dead coroutine\", nargs);\n\n    L.nCcalls = from ? from.nCcalls + 1 : 1;\n    if (L.nCcalls >= LUAI_MAXCCALLS)\n        return resume_error(L, \"JS stack overflow\", nargs);\n\n    L.nny = 0;  /* allow yields */\n\n    lapi.api_checknelems(L, L.status === LUA_OK ? nargs + 1: nargs);\n\n    let status = luaD_rawrunprotected(L, resume, nargs);\n    if (status === -1)  /* error calling 'lua_resume'? */\n        status = LUA_ERRRUN;\n    else {  /* continue running after recoverable errors */\n        while (status > LUA_YIELD && recover(L, status)) {\n            /* unroll continuation */\n            status = luaD_rawrunprotected(L, unroll, status);\n        }\n\n        if (status > LUA_YIELD) {  /* unrecoverable error? */\n            L.status = status;  /* mark thread as 'dead' */\n            seterrorobj(L, status, L.top);  /* push error message */\n            L.ci.top = L.top;\n        } else\n            lua_assert(status === L.status);  /* normal end or yield */\n    }\n\n    L.nny = oldnny;  /* restore 'nny' */\n    L.nCcalls--;\n    lua_assert(L.nCcalls === (from ? from.nCcalls : 0));\n    return status;\n};\n\nconst lua_isyieldable = function(L) {\n    return L.nny === 0;\n};\n\nconst lua_yieldk = function(L, nresults, ctx, k) {\n    let ci = L.ci;\n    lapi.api_checknelems(L, nresults);\n\n    if (L.nny > 0) {\n        if (L !== L.l_G.mainthread)\n            ldebug.luaG_runerror(L, to_luastring(\"attempt to yield across a JS-call boundary\", true));\n        else\n            ldebug.luaG_runerror(L, to_luastring(\"attempt to yield from outside a coroutine\", true));\n    }\n\n    L.status = LUA_YIELD;\n    ci.extra = ci.funcOff;  /* save current 'func' */\n    if (ci.callstatus & lstate.CIST_LUA)  /* inside a hook? */\n        api_check(L, k === null, \"hooks cannot continue after yielding\");\n    else {\n        ci.c_k = k;\n        if (k !== null)  /* is there a continuation? */\n            ci.c_ctx = ctx;  /* save context */\n        ci.funcOff = L.top - nresults - 1;  /* protect stack below results */\n        ci.func = L.stack[ci.funcOff];\n        luaD_throw(L, LUA_YIELD);\n    }\n\n    lua_assert(ci.callstatus & lstate.CIST_HOOKED);  /* must be inside a hook */\n    return 0;  /* return to 'luaD_hook' */\n};\n\nconst lua_yield = function(L, n) {\n    lua_yieldk(L, n, 0, null);\n};\n\nconst luaD_pcall = function(L, func, u, old_top, ef) {\n    let old_ci = L.ci;\n    let old_allowhooks = L.allowhook;\n    let old_nny = L.nny;\n    let old_errfunc = L.errfunc;\n    L.errfunc = ef;\n\n    let status = luaD_rawrunprotected(L, func, u);\n\n    if (status !== LUA_OK) {\n        lfunc.luaF_close(L, old_top);\n        seterrorobj(L, status, old_top);\n        L.ci = old_ci;\n        L.allowhook = old_allowhooks;\n        L.nny = old_nny;\n        luaD_shrinkstack(L);\n    }\n\n    L.errfunc = old_errfunc;\n\n    return status;\n};\n\n/*\n** Similar to 'luaD_call', but does not allow yields during the call\n*/\nconst luaD_callnoyield = function(L, off, nResults) {\n    L.nny++;\n    luaD_call(L, off, nResults);\n    L.nny--;\n};\n\n/*\n** Execute a protected parser.\n*/\nclass SParser {\n    constructor(z, name, mode) {  /* data to 'f_parser' */\n        this.z = z;\n        this.buff = new MBuffer();  /* dynamic structure used by the scanner */\n        this.dyd = new lparser.Dyndata();  /* dynamic structures used by the parser */\n        this.mode = mode;\n        this.name = name;\n    }\n}\n\nconst checkmode = function(L, mode, x) {\n    if (mode && luastring_indexOf(mode, x[0]) === -1) {\n        lobject.luaO_pushfstring(L,\n            to_luastring(\"attempt to load a %s chunk (mode is '%s')\"), x, mode);\n        luaD_throw(L, LUA_ERRSYNTAX);\n    }\n};\n\nconst f_parser = function(L, p) {\n    let cl;\n    let c = p.z.zgetc();  /* read first character */\n    if (c === LUA_SIGNATURE[0]) {\n        checkmode(L, p.mode, to_luastring(\"binary\", true));\n        cl = lundump.luaU_undump(L, p.z, p.name);\n    } else {\n        checkmode(L, p.mode, to_luastring(\"text\", true));\n        cl = lparser.luaY_parser(L, p.z, p.buff, p.dyd, p.name, c);\n    }\n\n    lua_assert(cl.nupvalues === cl.p.upvalues.length);\n    lfunc.luaF_initupvals(L, cl);\n};\n\nconst luaD_protectedparser = function(L, z, name, mode) {\n    let p = new SParser(z, name, mode);\n    L.nny++;  /* cannot yield during parsing */\n    let status = luaD_pcall(L, f_parser, p, L.top, L.errfunc);\n    L.nny--;\n    return status;\n};\n\nmodule.exports.adjust_top           = adjust_top;\nmodule.exports.luaD_call            = luaD_call;\nmodule.exports.luaD_callnoyield     = luaD_callnoyield;\nmodule.exports.luaD_checkstack      = luaD_checkstack;\nmodule.exports.luaD_growstack       = luaD_growstack;\nmodule.exports.luaD_hook            = luaD_hook;\nmodule.exports.luaD_inctop          = luaD_inctop;\nmodule.exports.luaD_pcall           = luaD_pcall;\nmodule.exports.luaD_poscall         = luaD_poscall;\nmodule.exports.luaD_precall         = luaD_precall;\nmodule.exports.luaD_protectedparser = luaD_protectedparser;\nmodule.exports.luaD_rawrunprotected = luaD_rawrunprotected;\nmodule.exports.luaD_reallocstack    = luaD_reallocstack;\nmodule.exports.luaD_throw           = luaD_throw;\nmodule.exports.lua_isyieldable      = lua_isyieldable;\nmodule.exports.lua_resume           = lua_resume;\nmodule.exports.lua_yield            = lua_yield;\nmodule.exports.lua_yieldk           = lua_yieldk;\n", ";\n\nconst {\n    LUA_HOOKCOUNT,\n    LUA_HOOKLINE,\n    LUA_MASKCOUNT,\n    LUA_MASKLINE,\n    constant_types: {\n        LUA_TBOOLEAN,\n        LUA_TNIL,\n        LUA_TTABLE\n    },\n    thread_status: {\n        LUA_ERRRUN,\n        LUA_YIELD\n    },\n    from_userstring,\n    luastring_eq,\n    luastring_indexOf,\n    to_luastring\n} = require('./defs.js');\nconst {\n    api_check,\n    lua_assert\n} = require('./llimits.js');\nconst { LUA_IDSIZE } = require('./luaconf.js');\nconst lapi     = require('./lapi.js');\nconst ldo      = require('./ldo.js');\nconst lfunc    = require('./lfunc.js');\nconst llex     = require('./llex.js');\nconst lobject  = require('./lobject.js');\nconst lopcodes = require('./lopcodes.js');\nconst lstate   = require('./lstate.js');\nconst ltable   = require('./ltable.js');\nconst ltm      = require('./ltm.js');\nconst lvm      = require('./lvm.js');\n\nconst currentpc = function(ci) {\n    lua_assert(ci.callstatus & lstate.CIST_LUA);\n    return ci.l_savedpc - 1;\n};\n\nconst currentline = function(ci) {\n    return ci.func.value.p.lineinfo.length !== 0 ? ci.func.value.p.lineinfo[currentpc(ci)] : -1;\n};\n\n/*\n** If function yielded, its 'func' can be in the 'extra' field. The\n** next function restores 'func' to its correct value for debugging\n** purposes. (It exchanges 'func' and 'extra'; so, when called again,\n** after debugging, it also \"re-restores\" ** 'func' to its altered value.\n*/\nconst swapextra = function(L) {\n    if (L.status === LUA_YIELD) {\n        let ci = L.ci;  /* get function that yielded */\n        let temp = ci.funcOff;  /* exchange its 'func' and 'extra' values */\n        ci.func = L.stack[ci.extra];\n        ci.funcOff = ci.extra;\n        ci.extra = temp;\n    }\n};\n\nconst lua_sethook = function(L, func, mask, count) {\n    if (func === null || mask === 0) {  /* turn off hooks? */\n        mask = 0;\n        func = null;\n    }\n    if (L.ci.callstatus & lstate.CIST_LUA)\n        L.oldpc = L.ci.l_savedpc;\n    L.hook = func;\n    L.basehookcount = count;\n    L.hookcount = L.basehookcount;\n    L.hookmask = mask;\n};\n\nconst lua_gethook = function(L) {\n    return L.hook;\n};\n\n\nconst lua_gethookmask = function(L) {\n    return L.hookmask;\n};\n\n\nconst lua_gethookcount = function(L) {\n    return L.basehookcount;\n};\n\nconst lua_getstack = function(L, level, ar) {\n    let ci;\n    let status;\n    if (level < 0) return 0;  /* invalid (negative) level */\n    for (ci = L.ci; level > 0 && ci !== L.base_ci; ci = ci.previous)\n        level--;\n    if (level === 0 && ci !== L.base_ci) {  /* level found? */\n        status = 1;\n        ar.i_ci = ci;\n    } else\n        status = 0;  /* no such level */\n    return status;\n};\n\nconst upvalname = function(p, uv) {\n    lua_assert(uv < p.upvalues.length);\n    let s = p.upvalues[uv].name;\n    if (s === null) return to_luastring(\"?\", true);\n    return s.getstr();\n};\n\nconst findvararg = function(ci, n) {\n    let nparams = ci.func.value.p.numparams;\n    if (n >= ci.l_base - ci.funcOff - nparams)\n        return null;  /* no such vararg */\n    else {\n        return {\n            pos: ci.funcOff + nparams + n,\n            name: to_luastring(\"(*vararg)\", true)  /* generic name for any vararg */\n        };\n    }\n};\n\nconst findlocal = function(L, ci, n) {\n    let base, name = null;\n\n    if (ci.callstatus & lstate.CIST_LUA) {\n        if (n < 0)  /* access to vararg values? */\n            return findvararg(ci, -n);\n        else {\n            base = ci.l_base;\n            name = lfunc.luaF_getlocalname(ci.func.value.p, n, currentpc(ci));\n        }\n    } else\n        base = ci.funcOff + 1;\n\n    if (name === null) {  /* no 'standard' name? */\n        let limit = ci === L.ci ? L.top : ci.next.funcOff;\n        if (limit - base >= n && n > 0)  /* is 'n' inside 'ci' stack? */\n            name = to_luastring(\"(*temporary)\", true);  /* generic name for any valid slot */\n        else\n            return null;  /* no name */\n    }\n    return {\n        pos: base + (n - 1),\n        name: name\n    };\n};\n\nconst lua_getlocal = function(L, ar, n) {\n    let name;\n    swapextra(L);\n    if (ar === null) {  /* information about non-active function? */\n        if (!L.stack[L.top - 1].ttisLclosure())  /* not a Lua function? */\n            name = null;\n        else  /* consider live variables at function start (parameters) */\n            name = lfunc.luaF_getlocalname(L.stack[L.top - 1].value.p, n, 0);\n    } else {  /* active function; get information through 'ar' */\n        let local = findlocal(L, ar.i_ci, n);\n        if (local) {\n            name = local.name;\n            lobject.pushobj2s(L, L.stack[local.pos]);\n            api_check(L, L.top <= L.ci.top, \"stack overflow\");\n        } else {\n            name = null;\n        }\n    }\n    swapextra(L);\n    return name;\n};\n\nconst lua_setlocal = function(L, ar, n) {\n    let name;\n    swapextra(L);\n    let local = findlocal(L, ar.i_ci, n);\n    if (local) {\n        name = local.name;\n        lobject.setobjs2s(L, local.pos, L.top - 1);\n        delete L.stack[--L.top];  /* pop value */\n    } else {\n        name = null;\n    }\n    swapextra(L);\n    return name;\n};\n\nconst funcinfo = function(ar, cl) {\n    if (cl === null || cl instanceof lobject.CClosure) {\n        ar.source = to_luastring(\"=[JS]\", true);\n        ar.linedefined = -1;\n        ar.lastlinedefined = -1;\n        ar.what = to_luastring(\"J\", true);\n    } else {\n        let p = cl.p;\n        ar.source = p.source ? p.source.getstr() : to_luastring(\"=?\", true);\n        ar.linedefined = p.linedefined;\n        ar.lastlinedefined = p.lastlinedefined;\n        ar.what = ar.linedefined === 0 ? to_luastring(\"main\", true) : to_luastring(\"Lua\", true);\n    }\n\n    ar.short_src = lobject.luaO_chunkid(ar.source, LUA_IDSIZE);\n};\n\nconst collectvalidlines = function(L, f) {\n    if (f === null || f instanceof lobject.CClosure) {\n        L.stack[L.top] = new lobject.TValue(LUA_TNIL, null);\n        lapi.api_incr_top(L);\n    } else {\n        let lineinfo = f.p.lineinfo;\n        let t = ltable.luaH_new(L);\n        L.stack[L.top] = new lobject.TValue(LUA_TTABLE, t);\n        lapi.api_incr_top(L);\n        let v = new lobject.TValue(LUA_TBOOLEAN, true);\n        for (let i = 0; i < lineinfo.length; i++)\n            ltable.luaH_setint(t, lineinfo[i], v);\n    }\n};\n\nconst getfuncname = function(L, ci) {\n    let r = {\n        name: null,\n        funcname: null\n    };\n    if (ci === null)\n        return null;\n    else if (ci.callstatus & lstate.CIST_FIN) {  /* is this a finalizer? */\n        r.name = to_luastring(\"__gc\", true);\n        r.funcname = to_luastring(\"metamethod\", true);  /* report it as such */\n        return r;\n    }\n    /* calling function is a known Lua function? */\n    else if (!(ci.callstatus & lstate.CIST_TAIL) && ci.previous.callstatus & lstate.CIST_LUA)\n        return funcnamefromcode(L, ci.previous);\n    else return null;  /* no way to find a name */\n};\n\nconst auxgetinfo = function(L, what, ar, f, ci) {\n    let status = 1;\n    for (; what.length > 0; what = what.subarray(1)) {\n        switch (what[0]) {\n            case 83 /* ('S').charCodeAt(0) */: {\n                funcinfo(ar, f);\n                break;\n            }\n            case 108 /* ('l').charCodeAt(0) */: {\n                ar.currentline = ci && ci.callstatus & lstate.CIST_LUA ? currentline(ci) : -1;\n                break;\n            }\n            case 117 /* ('u').charCodeAt(0) */: {\n                ar.nups = f === null ? 0 : f.nupvalues;\n                if (f === null || f instanceof lobject.CClosure) {\n                    ar.isvararg = true;\n                    ar.nparams = 0;\n                } else {\n                    ar.isvararg = f.p.is_vararg;\n                    ar.nparams = f.p.numparams;\n                }\n                break;\n            }\n            case 116 /* ('t').charCodeAt(0) */: {\n                ar.istailcall = ci ? ci.callstatus & lstate.CIST_TAIL : 0;\n                break;\n            }\n            case 110 /* ('n').charCodeAt(0) */: {\n                let r = getfuncname(L, ci);\n                if (r === null) {\n                    ar.namewhat = to_luastring(\"\", true);\n                    ar.name = null;\n                } else {\n                    ar.namewhat = r.funcname;\n                    ar.name = r.name;\n                }\n                break;\n            }\n            case 76 /* ('L').charCodeAt(0) */:\n            case 102 /* ('f').charCodeAt(0) */:  /* handled by lua_getinfo */\n                break;\n            default: status = 0;  /* invalid option */\n        }\n    }\n\n    return status;\n};\n\nconst lua_getinfo = function(L, what, ar) {\n    what = from_userstring(what);\n    let status, cl, ci, func;\n    swapextra(L);\n    if (what[0] === 62 /* ('>').charCodeAt(0) */) {\n        ci = null;\n        func = L.stack[L.top - 1];\n        api_check(L, func.ttisfunction(), \"function expected\");\n        what = what.subarray(1);  /* skip the '>' */\n        L.top--;  /* pop function */\n    } else {\n        ci = ar.i_ci;\n        func = ci.func;\n        lua_assert(ci.func.ttisfunction());\n    }\n\n    cl = func.ttisclosure() ? func.value : null;\n    status = auxgetinfo(L, what, ar, cl, ci);\n    if (luastring_indexOf(what, 102 /* ('f').charCodeAt(0) */) >= 0) {\n        lobject.pushobj2s(L, func);\n        api_check(L, L.top <= L.ci.top, \"stack overflow\");\n    }\n\n    swapextra(L);\n    if (luastring_indexOf(what, 76 /* ('L').charCodeAt(0) */) >= 0)\n        collectvalidlines(L, cl);\n\n    return status;\n};\n\nconst kname = function(p, pc, c) {\n    let r = {\n        name: null,\n        funcname: null\n    };\n\n    if (lopcodes.ISK(c)) {  /* is 'c' a constant? */\n        let kvalue = p.k[lopcodes.INDEXK(c)];\n        if (kvalue.ttisstring()) {  /* literal constant? */\n            r.name = kvalue.svalue();  /* it is its own name */\n            return r;\n        }\n        /* else no reasonable name found */\n    } else {  /* 'c' is a register */\n        let what = getobjname(p, pc, c); /* search for 'c' */\n        if (what && what.funcname[0] === 99 /* ('c').charCodeAt(0) */) {  /* found a constant name? */\n            return what;  /* 'name' already filled */\n        }\n        /* else no reasonable name found */\n    }\n    r.name = to_luastring(\"?\", true);\n    return r;  /* no reasonable name found */\n};\n\nconst filterpc = function(pc, jmptarget) {\n    if (pc < jmptarget)  /* is code conditional (inside a jump)? */\n        return -1;  /* cannot know who sets that register */\n    else return pc;  /* current position sets that register */\n};\n\n/*\n** try to find last instruction before 'lastpc' that modified register 'reg'\n*/\nconst findsetreg = function(p, lastpc, reg) {\n    let setreg = -1;  /* keep last instruction that changed 'reg' */\n    let jmptarget = 0;  /* any code before this address is conditional */\n    let OCi = lopcodes.OpCodesI;\n    for (let pc = 0; pc < lastpc; pc++) {\n        let i = p.code[pc];\n        let a = i.A;\n        switch (i.opcode) {\n            case OCi.OP_LOADNIL: {\n                let b = i.B;\n                if (a <= reg && reg <= a + b)  /* set registers from 'a' to 'a+b' */\n                    setreg = filterpc(pc, jmptarget);\n                break;\n            }\n            case OCi.OP_TFORCALL: {\n                if (reg >= a + 2)  /* affect all regs above its base */\n                    setreg = filterpc(pc, jmptarget);\n                break;\n            }\n            case OCi.OP_CALL:\n            case OCi.OP_TAILCALL: {\n                if (reg >= a)  /* affect all registers above base */\n                    setreg = filterpc(pc, jmptarget);\n                break;\n            }\n            case OCi.OP_JMP: {\n                let b = i.sBx;\n                let dest = pc + 1 + b;\n                /* jump is forward and do not skip 'lastpc'? */\n                if (pc < dest && dest <= lastpc) {\n                    if (dest > jmptarget)\n                        jmptarget = dest;  /* update 'jmptarget' */\n                }\n                break;\n            }\n            default:\n                if (lopcodes.testAMode(i.opcode) && reg === a)\n                    setreg = filterpc(pc, jmptarget);\n                break;\n        }\n    }\n\n    return setreg;\n};\n\n\nconst getobjname = function(p, lastpc, reg) {\n    let r = {\n        name: lfunc.luaF_getlocalname(p, reg + 1, lastpc),\n        funcname: null\n    };\n\n    if (r.name) {  /* is a local? */\n        r.funcname = to_luastring(\"local\", true);\n        return r;\n    }\n\n    /* else try symbolic execution */\n    let pc = findsetreg(p, lastpc, reg);\n    let OCi = lopcodes.OpCodesI;\n    if (pc !== -1) {  /* could find instruction? */\n        let i = p.code[pc];\n        switch (i.opcode) {\n            case OCi.OP_MOVE: {\n                let b = i.B;  /* move from 'b' to 'a' */\n                if (b < i.A)\n                    return getobjname(p, pc, b);  /* get name for 'b' */\n                break;\n            }\n            case OCi.OP_GETTABUP:\n            case OCi.OP_GETTABLE: {\n                let k = i.C;  /* key index */\n                let t = i.B;  /* table index */\n                let vn = i.opcode === OCi.OP_GETTABLE ? lfunc.luaF_getlocalname(p, t + 1, pc) : upvalname(p, t);\n                r.name = kname(p, pc, k).name;\n                r.funcname = (vn && luastring_eq(vn, llex.LUA_ENV)) ? to_luastring(\"global\", true) : to_luastring(\"field\", true);\n                return r;\n            }\n            case OCi.OP_GETUPVAL: {\n                r.name = upvalname(p, i.B);\n                r.funcname = to_luastring(\"upvalue\", true);\n                return r;\n            }\n            case OCi.OP_LOADK:\n            case OCi.OP_LOADKX: {\n                let b = i.opcode === OCi.OP_LOADK ? i.Bx : p.code[pc + 1].Ax;\n                if (p.k[b].ttisstring()) {\n                    r.name = p.k[b].svalue();\n                    r.funcname = to_luastring(\"constant\", true);\n                    return r;\n                }\n                break;\n            }\n            case OCi.OP_SELF: {\n                let k = i.C;\n                r.name = kname(p, pc, k).name;\n                r.funcname = to_luastring(\"method\", true);\n                return r;\n            }\n            default: break;\n        }\n    }\n\n    return null;\n};\n\n/*\n** Try to find a name for a function based on the code that called it.\n** (Only works when function was called by a Lua function.)\n** Returns what the name is (e.g., \"for iterator\", \"method\",\n** \"metamethod\") and sets '*name' to point to the name.\n*/\nconst funcnamefromcode = function(L, ci) {\n    let r = {\n        name: null,\n        funcname: null\n    };\n\n    let tm = 0;  /* (initial value avoids warnings) */\n    let p = ci.func.value.p;  /* calling function */\n    let pc = currentpc(ci);  /* calling instruction index */\n    let i = p.code[pc];  /* calling instruction */\n    let OCi = lopcodes.OpCodesI;\n\n    if (ci.callstatus & lstate.CIST_HOOKED) {\n        r.name = to_luastring(\"?\", true);\n        r.funcname = to_luastring(\"hook\", true);\n        return r;\n    }\n\n    switch (i.opcode) {\n        case OCi.OP_CALL:\n        case OCi.OP_TAILCALL:\n            return getobjname(p, pc, i.A);  /* get function name */\n        case OCi.OP_TFORCALL:\n            r.name = to_luastring(\"for iterator\", true);\n            r.funcname = to_luastring(\"for iterator\", true);\n            return r;\n        /* other instructions can do calls through metamethods */\n        case OCi.OP_SELF:\n        case OCi.OP_GETTABUP:\n        case OCi.OP_GETTABLE:\n            tm = ltm.TMS.TM_INDEX;\n            break;\n        case OCi.OP_SETTABUP:\n        case OCi.OP_SETTABLE:\n            tm = ltm.TMS.TM_NEWINDEX;\n            break;\n        case OCi.OP_ADD:    tm = ltm.TMS.TM_ADD;    break;\n        case OCi.OP_SUB:    tm = ltm.TMS.TM_SUB;    break;\n        case OCi.OP_MUL:    tm = ltm.TMS.TM_MUL;    break;\n        case OCi.OP_MOD:    tm = ltm.TMS.TM_MOD;    break;\n        case OCi.OP_POW:    tm = ltm.TMS.TM_POW;    break;\n        case OCi.OP_DIV:    tm = ltm.TMS.TM_DIV;    break;\n        case OCi.OP_IDIV:   tm = ltm.TMS.TM_IDIV;   break;\n        case OCi.OP_BAND:   tm = ltm.TMS.TM_BAND;   break;\n        case OCi.OP_BOR:    tm = ltm.TMS.TM_BOR;    break;\n        case OCi.OP_BXOR:   tm = ltm.TMS.TM_BXOR;   break;\n        case OCi.OP_SHL:    tm = ltm.TMS.TM_SHL;    break;\n        case OCi.OP_SHR:    tm = ltm.TMS.TM_SHR;    break;\n        case OCi.OP_UNM:    tm = ltm.TMS.TM_UNM;    break;\n        case OCi.OP_BNOT:   tm = ltm.TMS.TM_BNOT;   break;\n        case OCi.OP_LEN:    tm = ltm.TMS.TM_LEN;    break;\n        case OCi.OP_CONCAT: tm = ltm.TMS.TM_CONCAT; break;\n        case OCi.OP_EQ:     tm = ltm.TMS.TM_EQ;     break;\n        case OCi.OP_LT:     tm = ltm.TMS.TM_LT;     break;\n        case OCi.OP_LE:     tm = ltm.TMS.TM_LE;     break;\n        default:\n            return null;  /* cannot find a reasonable name */\n    }\n\n    r.name = L.l_G.tmname[tm].getstr();\n    r.funcname = to_luastring(\"metamethod\", true);\n    return r;\n};\n\nconst isinstack = function(L, ci, o) {\n    for (let i = ci.l_base; i < ci.top; i++) {\n        if (L.stack[i] === o)\n            return i;\n    }\n\n    return false;\n};\n\n/*\n** Checks whether value 'o' came from an upvalue. (That can only happen\n** with instructions OP_GETTABUP/OP_SETTABUP, which operate directly on\n** upvalues.)\n*/\nconst getupvalname = function(L, ci, o) {\n    let c = ci.func.value;\n    for (let i = 0; i < c.nupvalues; i++) {\n        if (c.upvals[i] === o) {\n            return {\n                name: upvalname(c.p, i),\n                funcname: to_luastring('upvalue', true)\n            };\n        }\n    }\n\n    return null;\n};\n\nconst varinfo = function(L, o) {\n    let ci = L.ci;\n    let kind = null;\n    if (ci.callstatus & lstate.CIST_LUA) {\n        kind = getupvalname(L, ci, o);  /* check whether 'o' is an upvalue */\n        let stkid = isinstack(L, ci, o);\n        if (!kind && stkid)  /* no? try a register */\n            kind = getobjname(ci.func.value.p, currentpc(ci), stkid - ci.l_base);\n    }\n\n    return kind ? lobject.luaO_pushfstring(L, to_luastring(\" (%s '%s')\", true), kind.funcname, kind.name) : to_luastring(\"\", true);\n};\n\nconst luaG_typeerror = function(L, o, op) {\n    let t = ltm.luaT_objtypename(L, o);\n    luaG_runerror(L, to_luastring(\"attempt to %s a %s value%s\", true), op, t, varinfo(L, o));\n};\n\nconst luaG_concaterror = function(L, p1, p2) {\n    if (p1.ttisstring() || lvm.cvt2str(p1)) p1 = p2;\n    luaG_typeerror(L, p1, to_luastring('concatenate', true));\n};\n\n/*\n** Error when both values are convertible to numbers, but not to integers\n*/\nconst luaG_opinterror = function(L, p1, p2, msg) {\n    if (lvm.tonumber(p1) === false)\n        p2 = p1;\n    luaG_typeerror(L, p2, msg);\n};\n\nconst luaG_ordererror = function(L, p1, p2) {\n    let t1 = ltm.luaT_objtypename(L, p1);\n    let t2 = ltm.luaT_objtypename(L, p2);\n    if (luastring_eq(t1, t2))\n        luaG_runerror(L, to_luastring(\"attempt to compare two %s values\", true), t1);\n    else\n        luaG_runerror(L, to_luastring(\"attempt to compare %s with %s\", true), t1, t2);\n};\n\n/* add src:line information to 'msg' */\nconst luaG_addinfo = function(L, msg, src, line) {\n    let buff;\n    if (src)\n        buff = lobject.luaO_chunkid(src.getstr(), LUA_IDSIZE);\n    else\n        buff = to_luastring(\"?\", true);\n\n    return lobject.luaO_pushfstring(L, to_luastring(\"%s:%d: %s\", true), buff, line, msg);\n};\n\nconst luaG_runerror = function(L, fmt, ...argp) {\n    let ci = L.ci;\n    let msg = lobject.luaO_pushvfstring(L, fmt, argp);\n    if (ci.callstatus & lstate.CIST_LUA)  /* if Lua function, add source:line information */\n        luaG_addinfo(L, msg, ci.func.value.p.source, currentline(ci));\n    luaG_errormsg(L);\n};\n\nconst luaG_errormsg = function(L) {\n    if (L.errfunc !== 0) {  /* is there an error handling function? */\n        let errfunc = L.errfunc;\n        lobject.pushobj2s(L, L.stack[L.top - 1]); /* move argument */\n        lobject.setobjs2s(L, L.top - 2, errfunc); /* push function */\n        ldo.luaD_callnoyield(L, L.top - 2, 1);\n    }\n\n    ldo.luaD_throw(L, LUA_ERRRUN);\n};\n\n/*\n** Error when both values are convertible to numbers, but not to integers\n*/\nconst luaG_tointerror = function(L, p1, p2) {\n    let temp = lvm.tointeger(p1);\n    if (temp === false)\n        p2 = p1;\n    luaG_runerror(L, to_luastring(\"number%s has no integer representation\", true), varinfo(L, p2));\n};\n\nconst luaG_traceexec = function(L) {\n    let ci = L.ci;\n    let mask = L.hookmask;\n    let counthook = (--L.hookcount === 0 && (mask & LUA_MASKCOUNT));\n    if (counthook)\n        L.hookcount = L.basehookcount;  /* reset count */\n    else if (!(mask & LUA_MASKLINE))\n        return;  /* no line hook and count != 0; nothing to be done */\n    if (ci.callstatus & lstate.CIST_HOOKYIELD) {  /* called hook last time? */\n        ci.callstatus &= ~lstate.CIST_HOOKYIELD;  /* erase mark */\n        return;  /* do not call hook again (VM yielded, so it did not move) */\n    }\n    if (counthook)\n        ldo.luaD_hook(L, LUA_HOOKCOUNT, -1);  /* call count hook */\n    if (mask & LUA_MASKLINE) {\n        let p = ci.func.value.p;\n        let npc = ci.l_savedpc - 1; // pcRel(ci.u.l.savedpc, p);\n        let newline = p.lineinfo.length !== 0 ? p.lineinfo[npc] : -1;\n        if (npc === 0 ||  /* call linehook when enter a new function, */\n            ci.l_savedpc <= L.oldpc ||  /* when jump back (loop), or when */\n            newline !== (p.lineinfo.length !== 0 ? p.lineinfo[L.oldpc - 1] : -1))  /* enter a new line */\n            ldo.luaD_hook(L, LUA_HOOKLINE, newline);  /* call line hook */\n    }\n    L.oldpc = ci.l_savedpc;\n    if (L.status === LUA_YIELD) {  /* did hook yield? */\n        if (counthook)\n            L.hookcount = 1;  /* undo decrement to zero */\n        ci.l_savedpc--;  /* undo increment (resume will increment it again) */\n        ci.callstatus |= lstate.CIST_HOOKYIELD;  /* mark that it yielded */\n        ci.funcOff = L.top - 1;  /* protect stack below results */\n        ci.func = L.stack[ci.funcOff];\n        ldo.luaD_throw(L, LUA_YIELD);\n    }\n};\n\nmodule.exports.luaG_addinfo     = luaG_addinfo;\nmodule.exports.luaG_concaterror = luaG_concaterror;\nmodule.exports.luaG_errormsg    = luaG_errormsg;\nmodule.exports.luaG_opinterror  = luaG_opinterror;\nmodule.exports.luaG_ordererror  = luaG_ordererror;\nmodule.exports.luaG_runerror    = luaG_runerror;\nmodule.exports.luaG_tointerror  = luaG_tointerror;\nmodule.exports.luaG_traceexec   = luaG_traceexec;\nmodule.exports.luaG_typeerror   = luaG_typeerror;\nmodule.exports.lua_gethook      = lua_gethook;\nmodule.exports.lua_gethookcount = lua_gethookcount;\nmodule.exports.lua_gethookmask  = lua_gethookmask;\nmodule.exports.lua_getinfo      = lua_getinfo;\nmodule.exports.lua_getlocal     = lua_getlocal;\nmodule.exports.lua_getstack     = lua_getstack;\nmodule.exports.lua_sethook      = lua_sethook;\nmodule.exports.lua_setlocal     = lua_setlocal;\n", ";\n\nconst {\n    LUA_SIGNATURE,\n    LUA_VERSION_MAJOR,\n    LUA_VERSION_MINOR,\n    constant_types: {\n        LUA_TBOOLEAN,\n        LUA_TLNGSTR,\n        LUA_TNIL,\n        LUA_TNUMFLT,\n        LUA_TNUMINT,\n        LUA_TSHRSTR\n    },\n    luastring_of\n} = require('./defs.js');\n\nconst LUAC_DATA    = luastring_of(25, 147, 13, 10, 26, 10);\nconst LUAC_INT     = 0x5678;\nconst LUAC_NUM     = 370.5;\nconst LUAC_VERSION = Number(LUA_VERSION_MAJOR) * 16 + Number(LUA_VERSION_MINOR);\nconst LUAC_FORMAT  = 0;   /* this is the official format */\n\nclass DumpState {\n    constructor() {\n        this.L = null;\n        this.write = null;\n        this.data = null;\n        this.strip = NaN;\n        this.status = NaN;\n    }\n}\n\nconst DumpBlock = function(b, size, D) {\n    if (D.status === 0 && size > 0)\n        D.status = D.writer(D.L, b, size, D.data);\n};\n\nconst DumpByte = function(y, D) {\n    DumpBlock(luastring_of(y), 1, D);\n};\n\nconst DumpInt = function(x, D) {\n    let ab = new ArrayBuffer(4);\n    let dv = new DataView(ab);\n    dv.setInt32(0, x, true);\n    let t = new Uint8Array(ab);\n    DumpBlock(t, 4, D);\n};\n\nconst DumpInteger = function(x, D) {\n    let ab = new ArrayBuffer(4);\n    let dv = new DataView(ab);\n    dv.setInt32(0, x, true);\n    let t = new Uint8Array(ab);\n    DumpBlock(t, 4, D);\n};\n\nconst DumpNumber = function(x, D) {\n    let ab = new ArrayBuffer(8);\n    let dv = new DataView(ab);\n    dv.setFloat64(0, x, true);\n    let t = new Uint8Array(ab);\n    DumpBlock(t, 8, D);\n};\n\nconst DumpString = function(s, D) {\n    if (s === null)\n        DumpByte(0, D);\n    else {\n        let size = s.tsslen() + 1;\n        let str = s.getstr();\n        if (size < 0xFF)\n            DumpByte(size, D);\n        else {\n            DumpByte(0xFF, D);\n            DumpInteger(size, D);\n        }\n        DumpBlock(str, size - 1, D);  /* no need to save '\\0' */\n    }\n};\n\nconst DumpCode = function(f, D) {\n    let s = f.code.map(e => e.code);\n    DumpInt(s.length, D);\n\n    for (let i = 0; i < s.length; i++)\n        DumpInt(s[i], D);\n};\n\nconst DumpConstants = function(f, D) {\n    let n = f.k.length;\n    DumpInt(n, D);\n    for (let i = 0; i < n; i++) {\n        let o = f.k[i];\n        DumpByte(o.ttype(), D);\n        switch (o.ttype()) {\n            case LUA_TNIL:\n                break;\n            case LUA_TBOOLEAN:\n                DumpByte(o.value ? 1 : 0, D);\n                break;\n            case LUA_TNUMFLT:\n                DumpNumber(o.value, D);\n                break;\n            case LUA_TNUMINT:\n                DumpInteger(o.value, D);\n                break;\n            case LUA_TSHRSTR:\n            case LUA_TLNGSTR:\n                DumpString(o.tsvalue(), D);\n                break;\n        }\n    }\n};\n\nconst DumpProtos = function(f, D) {\n    let n = f.p.length;\n    DumpInt(n, D);\n    for (let i = 0; i < n; i++)\n        DumpFunction(f.p[i], f.source, D);\n};\n\nconst DumpUpvalues = function(f, D) {\n    let n = f.upvalues.length;\n    DumpInt(n, D);\n    for (let i = 0; i < n; i++) {\n        DumpByte(f.upvalues[i].instack ? 1 : 0, D);\n        DumpByte(f.upvalues[i].idx, D);\n    }\n};\n\nconst DumpDebug = function(f, D) {\n    let n = D.strip ? 0 : f.lineinfo.length;\n    DumpInt(n, D);\n    for (let i = 0; i < n; i++)\n        DumpInt(f.lineinfo[i], D);\n    n = D.strip ? 0 : f.locvars.length;\n    DumpInt(n, D);\n    for (let i = 0; i < n; i++) {\n        DumpString(f.locvars[i].varname, D);\n        DumpInt(f.locvars[i].startpc, D);\n        DumpInt(f.locvars[i].endpc, D);\n    }\n    n = D.strip ? 0 : f.upvalues.length;\n    DumpInt(n, D);\n    for (let i = 0; i < n; i++)\n        DumpString(f.upvalues[i].name, D);\n};\n\nconst DumpFunction = function(f, psource, D) {\n    if (D.strip || f.source === psource)\n        DumpString(null, D);  /* no debug info or same source as its parent */\n    else\n        DumpString(f.source, D);\n    DumpInt(f.linedefined, D);\n    DumpInt(f.lastlinedefined, D);\n    DumpByte(f.numparams, D);\n    DumpByte(f.is_vararg?1:0, D);\n    DumpByte(f.maxstacksize, D);\n    DumpCode(f, D);\n    DumpConstants(f, D);\n    DumpUpvalues(f, D);\n    DumpProtos(f, D);\n    DumpDebug(f, D);\n};\n\nconst DumpHeader = function(D) {\n    DumpBlock(LUA_SIGNATURE, LUA_SIGNATURE.length, D);\n    DumpByte(LUAC_VERSION, D);\n    DumpByte(LUAC_FORMAT, D);\n    DumpBlock(LUAC_DATA, LUAC_DATA.length, D);\n    DumpByte(4, D); // intSize\n    DumpByte(4, D); // size_tSize\n    DumpByte(4, D); // instructionSize\n    DumpByte(4, D); // integerSize\n    DumpByte(8, D); // numberSize\n    DumpInteger(LUAC_INT, D);\n    DumpNumber(LUAC_NUM, D);\n};\n\n/*\n** dump Lua function as precompiled chunk\n*/\nconst luaU_dump = function(L, f, w, data, strip) {\n    let D = new DumpState();\n    D.L = L;\n    D.writer = w;\n    D.data = data;\n    D.strip = strip;\n    D.status = 0;\n    DumpHeader(D);\n    DumpByte(f.upvalues.length, D);\n    DumpFunction(f, null, D);\n    return D.status;\n};\n\nmodule.exports.luaU_dump = luaU_dump;\n", ";\n\nconst {\n    LUA_MULTRET,\n    LUA_OPBNOT,\n    LUA_OPEQ,\n    LUA_OPLE,\n    LUA_OPLT,\n    LUA_OPUNM,\n    LUA_REGISTRYINDEX,\n    LUA_RIDX_GLOBALS,\n    LUA_VERSION_NUM,\n    constant_types: {\n        LUA_NUMTAGS,\n        LUA_TBOOLEAN,\n        LUA_TCCL,\n        LUA_TFUNCTION,\n        LUA_TLCF,\n        LUA_TLCL,\n        LUA_TLIGHTUSERDATA,\n        LUA_TLNGSTR,\n        LUA_TNIL,\n        LUA_TNONE,\n        LUA_TNUMFLT,\n        LUA_TNUMINT,\n        LUA_TSHRSTR,\n        LUA_TTABLE,\n        LUA_TTHREAD,\n        LUA_TUSERDATA\n    },\n    thread_status: { LUA_OK },\n    from_userstring,\n    to_luastring,\n} = require('./defs.js');\nconst { api_check } = require('./llimits.js');\nconst ldebug    = require('./ldebug.js');\nconst ldo       = require('./ldo.js');\nconst { luaU_dump } = require('./ldump.js');\nconst lfunc     = require('./lfunc.js');\nconst lobject   = require('./lobject.js');\nconst lstate    = require('./lstate.js');\nconst {\n    luaS_bless,\n    luaS_new,\n    luaS_newliteral\n} = require('./lstring.js');\nconst ltm       = require('./ltm.js');\nconst { LUAI_MAXSTACK } = require('./luaconf.js');\nconst lvm       = require('./lvm.js');\nconst ltable    = require('./ltable.js');\nconst { ZIO } = require('./lzio.js');\nconst TValue    = lobject.TValue;\nconst CClosure  = lobject.CClosure;\n\nconst api_incr_top = function(L) {\n    L.top++;\n    api_check(L, L.top <= L.ci.top, \"stack overflow\");\n};\n\nconst api_checknelems = function(L, n) {\n    api_check(L, n < (L.top - L.ci.funcOff), \"not enough elements in the stack\");\n};\n\nconst fengari_argcheck = function(c) {\n    if (!c) throw TypeError(\"invalid argument\");\n};\n\nconst fengari_argcheckinteger = function(n) {\n    fengari_argcheck(typeof n === \"number\" && (n|0) === n);\n};\n\nconst isvalid = function(o) {\n    return o !== lobject.luaO_nilobject;\n};\n\nconst lua_version = function(L) {\n    if (L === null) return LUA_VERSION_NUM;\n    else return L.l_G.version;\n};\n\nconst lua_atpanic = function(L, panicf) {\n    let old = L.l_G.panic;\n    L.l_G.panic = panicf;\n    return old;\n};\n\nconst lua_atnativeerror = function(L, errorf) {\n    let old = L.l_G.atnativeerror;\n    L.l_G.atnativeerror = errorf;\n    return old;\n};\n\n// Return value for idx on stack\nconst index2addr = function(L, idx) {\n    let ci = L.ci;\n    if (idx > 0) {\n        let o = ci.funcOff + idx;\n        api_check(L, idx <= ci.top - (ci.funcOff + 1), \"unacceptable index\");\n        if (o >= L.top) return lobject.luaO_nilobject;\n        else return L.stack[o];\n    } else if (idx > LUA_REGISTRYINDEX) {\n        api_check(L, idx !== 0 && -idx <= L.top, \"invalid index\");\n        return L.stack[L.top + idx];\n    } else if (idx === LUA_REGISTRYINDEX) {\n        return L.l_G.l_registry;\n    } else { /* upvalues */\n        idx = LUA_REGISTRYINDEX - idx;\n        api_check(L, idx <= lfunc.MAXUPVAL + 1, \"upvalue index too large\");\n        if (ci.func.ttislcf()) /* light C function? */\n            return lobject.luaO_nilobject; /* it has no upvalues */\n        else {\n            return idx <= ci.func.value.nupvalues ? ci.func.value.upvalue[idx - 1] : lobject.luaO_nilobject;\n        }\n    }\n};\n\n// Like index2addr but returns the index on stack; doesn't allow pseudo indices\nconst index2addr_ = function(L, idx) {\n    let ci = L.ci;\n    if (idx > 0) {\n        let o = ci.funcOff + idx;\n        api_check(L, idx <= ci.top - (ci.funcOff + 1), \"unacceptable index\");\n        if (o >= L.top) return null;\n        else return o;\n    } else if (idx > LUA_REGISTRYINDEX) {\n        api_check(L, idx !== 0 && -idx <= L.top, \"invalid index\");\n        return L.top + idx;\n    } else { /* registry or upvalue */\n        throw Error(\"attempt to use pseudo-index\");\n    }\n};\n\nconst lua_checkstack = function(L, n) {\n    let res;\n    let ci = L.ci;\n    api_check(L, n >= 0, \"negative 'n'\");\n    if (L.stack_last - L.top > n) /* stack large enough? */\n        res = true;\n    else { /* no; need to grow stack */\n        let inuse = L.top + lstate.EXTRA_STACK;\n        if (inuse > LUAI_MAXSTACK - n)  /* can grow without overflow? */\n            res = false;  /* no */\n        else { /* try to grow stack */\n            ldo.luaD_growstack(L, n);\n            res = true;\n        }\n    }\n\n    if (res && ci.top < L.top + n)\n        ci.top = L.top + n;  /* adjust frame top */\n\n    return res;\n};\n\nconst lua_xmove = function(from, to, n) {\n    if (from === to) return;\n    api_checknelems(from, n);\n    api_check(from, from.l_G === to.l_G, \"moving among independent states\");\n    api_check(from, to.ci.top - to.top >= n, \"stack overflow\");\n    from.top -= n;\n    for (let i = 0; i < n; i++) {\n        to.stack[to.top] = new lobject.TValue();\n        lobject.setobj2s(to, to.top, from.stack[from.top + i]);\n        delete from.stack[from.top + i];\n        to.top++;\n    }\n};\n\n/*\n** basic stack manipulation\n*/\n\n/*\n** convert an acceptable stack index into an absolute index\n*/\nconst lua_absindex = function(L, idx) {\n    return (idx > 0 || idx <= LUA_REGISTRYINDEX)\n        ? idx\n        : (L.top - L.ci.funcOff) + idx;\n};\n\nconst lua_gettop = function(L) {\n    return L.top - (L.ci.funcOff + 1);\n};\n\nconst lua_pushvalue = function(L, idx) {\n    lobject.pushobj2s(L, index2addr(L, idx));\n    api_check(L, L.top <= L.ci.top, \"stack overflow\");\n};\n\nconst lua_settop = function(L, idx) {\n    let func = L.ci.funcOff;\n    let newtop;\n    if (idx >= 0) {\n        api_check(L, idx <= L.stack_last - (func + 1), \"new top too large\");\n        newtop = func + 1 + idx;\n    } else {\n        api_check(L, -(idx + 1) <= L.top - (func + 1), \"invalid new top\");\n        newtop = L.top + idx + 1; /* 'subtract' index (index is negative) */\n    }\n    ldo.adjust_top(L, newtop);\n};\n\nconst lua_pop = function(L, n) {\n    lua_settop(L, -n - 1);\n};\n\nconst reverse = function(L, from, to) {\n    for (; from < to; from++, to--) {\n        let fromtv = L.stack[from];\n        let temp = new TValue(fromtv.type, fromtv.value);\n        lobject.setobjs2s(L, from, to);\n        lobject.setobj2s(L, to, temp);\n    }\n};\n\n/*\n** Let x = AB, where A is a prefix of length 'n'. Then,\n** rotate x n === BA. But BA === (A^r . B^r)^r.\n*/\nconst lua_rotate = function(L, idx, n) {\n    let t = L.top - 1;\n    let pIdx = index2addr_(L, idx);\n    let p = L.stack[pIdx];\n    api_check(L, isvalid(p) && idx > LUA_REGISTRYINDEX, \"index not in the stack\");\n    api_check(L, (n >= 0 ? n : -n) <= (t - pIdx + 1), \"invalid 'n'\");\n    let m = n >= 0 ? t - n : pIdx - n - 1;  /* end of prefix */\n    reverse(L, pIdx, m);\n    reverse(L, m + 1, L.top - 1);\n    reverse(L, pIdx, L.top - 1);\n};\n\nconst lua_copy = function(L, fromidx, toidx) {\n    let from = index2addr(L, fromidx);\n    index2addr(L, toidx).setfrom(from);\n};\n\nconst lua_remove = function(L, idx) {\n    lua_rotate(L, idx, -1);\n    lua_pop(L, 1);\n};\n\nconst lua_insert = function(L, idx) {\n    lua_rotate(L, idx, 1);\n};\n\nconst lua_replace = function(L, idx) {\n    lua_copy(L, -1, idx);\n    lua_pop(L, 1);\n};\n\n/*\n** push functions (JS -> stack)\n*/\n\nconst lua_pushnil = function(L) {\n    L.stack[L.top] = new TValue(LUA_TNIL, null);\n    api_incr_top(L);\n};\n\nconst lua_pushnumber = function(L, n) {\n    fengari_argcheck(typeof n === \"number\");\n    L.stack[L.top] = new TValue(LUA_TNUMFLT, n);\n    api_incr_top(L);\n};\n\nconst lua_pushinteger = function(L, n) {\n    fengari_argcheckinteger(n);\n    L.stack[L.top] = new TValue(LUA_TNUMINT, n);\n    api_incr_top(L);\n};\n\nconst lua_pushlstring = function(L, s, len) {\n    fengari_argcheckinteger(len);\n    let ts;\n    if (len === 0) {\n        s = to_luastring(\"\", true);\n        ts = luaS_bless(L, s);\n    } else {\n        s = from_userstring(s);\n        api_check(L, s.length >= len, \"invalid length to lua_pushlstring\");\n        ts = luaS_new(L, s.subarray(0, len));\n    }\n    lobject.pushsvalue2s(L, ts);\n    api_check(L, L.top <= L.ci.top, \"stack overflow\");\n    return ts.value;\n};\n\nconst lua_pushstring = function (L, s) {\n    if (s === undefined || s === null) {\n        L.stack[L.top] = new TValue(LUA_TNIL, null);\n        L.top++;\n    } else {\n        let ts = luaS_new(L, from_userstring(s));\n        lobject.pushsvalue2s(L, ts);\n        s = ts.getstr(); /* internal copy */\n    }\n    api_check(L, L.top <= L.ci.top, \"stack overflow\");\n    return s;\n};\n\nconst lua_pushvfstring = function (L, fmt, argp) {\n    fmt = from_userstring(fmt);\n    return lobject.luaO_pushvfstring(L, fmt, argp);\n};\n\nconst lua_pushfstring = function (L, fmt, ...argp) {\n    fmt = from_userstring(fmt);\n    return lobject.luaO_pushvfstring(L, fmt, argp);\n};\n\n/* Similar to lua_pushstring, but takes a JS string */\nconst lua_pushliteral = function (L, s) {\n    if (s === undefined || s === null) {\n        L.stack[L.top] = new TValue(LUA_TNIL, null);\n        L.top++;\n    } else {\n        fengari_argcheck(typeof s === \"string\");\n        let ts = luaS_newliteral(L, s);\n        lobject.pushsvalue2s(L, ts);\n        s = ts.getstr(); /* internal copy */\n    }\n    api_check(L, L.top <= L.ci.top, \"stack overflow\");\n\n    return s;\n};\n\nconst lua_pushcclosure = function(L, fn, n) {\n    fengari_argcheck(typeof fn === \"function\");\n    fengari_argcheckinteger(n);\n    if (n === 0)\n        L.stack[L.top] = new TValue(LUA_TLCF, fn);\n    else {\n        api_checknelems(L, n);\n        api_check(L, n <= lfunc.MAXUPVAL, \"upvalue index too large\");\n        let cl = new CClosure(L, fn, n);\n        for (let i=0; i<n; i++)\n            cl.upvalue[i].setfrom(L.stack[L.top - n + i]);\n        for (let i=1; i<n; i++)\n            delete L.stack[--L.top];\n        if (n>0)\n            --L.top;\n        L.stack[L.top].setclCvalue(cl);\n    }\n    api_incr_top(L);\n};\n\nconst lua_pushjsclosure = lua_pushcclosure;\n\nconst lua_pushcfunction = function(L, fn) {\n    lua_pushcclosure(L, fn, 0);\n};\n\nconst lua_pushjsfunction = lua_pushcfunction;\n\nconst lua_pushboolean = function(L, b) {\n    L.stack[L.top] = new TValue(LUA_TBOOLEAN, !!b);\n    api_incr_top(L);\n};\n\nconst lua_pushlightuserdata = function(L, p) {\n    L.stack[L.top] = new TValue(LUA_TLIGHTUSERDATA, p);\n    api_incr_top(L);\n};\n\nconst lua_pushthread = function(L) {\n    L.stack[L.top] = new TValue(LUA_TTHREAD, L);\n    api_incr_top(L);\n    return L.l_G.mainthread === L;\n};\n\nconst lua_pushglobaltable = function(L) {\n    lua_rawgeti(L, LUA_REGISTRYINDEX, LUA_RIDX_GLOBALS);\n};\n\n/*\n** set functions (stack -> Lua)\n*/\n\n/*\n** t[k] = value at the top of the stack (where 'k' is a string)\n*/\nconst auxsetstr = function(L, t, k) {\n    let str = luaS_new(L, from_userstring(k));\n    api_checknelems(L, 1);\n    lobject.pushsvalue2s(L, str); /* push 'str' (to make it a TValue) */\n    api_check(L, L.top <= L.ci.top, \"stack overflow\");\n    lvm.settable(L, t, L.stack[L.top - 1], L.stack[L.top - 2]);\n    /* pop value and key */\n    delete L.stack[--L.top];\n    delete L.stack[--L.top];\n};\n\nconst lua_setglobal = function(L, name) {\n    auxsetstr(L, ltable.luaH_getint(L.l_G.l_registry.value, LUA_RIDX_GLOBALS), name);\n};\n\nconst lua_setmetatable = function(L, objindex) {\n    api_checknelems(L, 1);\n    let mt;\n    let obj = index2addr(L, objindex);\n    if (L.stack[L.top - 1].ttisnil())\n        mt = null;\n    else {\n        api_check(L, L.stack[L.top - 1].ttistable(), \"table expected\");\n        mt = L.stack[L.top - 1].value;\n    }\n\n    switch (obj.ttnov()) {\n        case LUA_TUSERDATA:\n        case LUA_TTABLE: {\n            obj.value.metatable = mt;\n            break;\n        }\n        default: {\n            L.l_G.mt[obj.ttnov()] = mt;\n            break;\n        }\n    }\n\n    delete L.stack[--L.top];\n    return true;\n};\n\nconst lua_settable = function(L, idx) {\n    api_checknelems(L, 2);\n    let t = index2addr(L, idx);\n    lvm.settable(L, t, L.stack[L.top - 2], L.stack[L.top - 1]);\n    delete L.stack[--L.top];\n    delete L.stack[--L.top];\n};\n\nconst lua_setfield = function(L, idx, k) {\n    auxsetstr(L, index2addr(L, idx), k);\n};\n\nconst lua_seti = function(L, idx, n) {\n    fengari_argcheckinteger(n);\n    api_checknelems(L, 1);\n    let t = index2addr(L, idx);\n    L.stack[L.top] = new TValue(LUA_TNUMINT, n);\n    api_incr_top(L);\n    lvm.settable(L, t, L.stack[L.top - 1], L.stack[L.top - 2]);\n    /* pop value and key */\n    delete L.stack[--L.top];\n    delete L.stack[--L.top];\n};\n\nconst lua_rawset = function(L, idx) {\n    api_checknelems(L, 2);\n    let o = index2addr(L, idx);\n    api_check(L, o.ttistable(), \"table expected\");\n    let k = L.stack[L.top - 2];\n    let v = L.stack[L.top - 1];\n    ltable.luaH_setfrom(L, o.value, k, v);\n    ltable.invalidateTMcache(o.value);\n    delete L.stack[--L.top];\n    delete L.stack[--L.top];\n};\n\nconst lua_rawseti = function(L, idx, n) {\n    fengari_argcheckinteger(n);\n    api_checknelems(L, 1);\n    let o = index2addr(L, idx);\n    api_check(L, o.ttistable(), \"table expected\");\n    ltable.luaH_setint(o.value, n, L.stack[L.top - 1]);\n    delete L.stack[--L.top];\n};\n\nconst lua_rawsetp = function(L, idx, p) {\n    api_checknelems(L, 1);\n    let o = index2addr(L, idx);\n    api_check(L, o.ttistable(), \"table expected\");\n    let k = new TValue(LUA_TLIGHTUSERDATA, p);\n    let v = L.stack[L.top - 1];\n    ltable.luaH_setfrom(L, o.value, k, v);\n    delete L.stack[--L.top];\n};\n\n/*\n** get functions (Lua -> stack)\n*/\n\nconst auxgetstr = function(L, t, k) {\n    let str = luaS_new(L, from_userstring(k));\n    lobject.pushsvalue2s(L, str);\n    api_check(L, L.top <= L.ci.top, \"stack overflow\");\n    lvm.luaV_gettable(L, t, L.stack[L.top - 1], L.top - 1);\n    return L.stack[L.top - 1].ttnov();\n};\n\nconst lua_rawgeti = function(L, idx, n) {\n    let t = index2addr(L, idx);\n    fengari_argcheckinteger(n);\n    api_check(L, t.ttistable(), \"table expected\");\n    lobject.pushobj2s(L, ltable.luaH_getint(t.value, n));\n    api_check(L, L.top <= L.ci.top, \"stack overflow\");\n    return L.stack[L.top - 1].ttnov();\n};\n\nconst lua_rawgetp = function(L, idx, p) {\n    let t = index2addr(L, idx);\n    api_check(L, t.ttistable(), \"table expected\");\n    let k = new TValue(LUA_TLIGHTUSERDATA, p);\n    lobject.pushobj2s(L, ltable.luaH_get(L, t.value, k));\n    api_check(L, L.top <= L.ci.top, \"stack overflow\");\n    return L.stack[L.top - 1].ttnov();\n};\n\nconst lua_rawget = function(L, idx) {\n    let t = index2addr(L, idx);\n    api_check(L, t.ttistable(t), \"table expected\");\n    lobject.setobj2s(L, L.top - 1, ltable.luaH_get(L, t.value, L.stack[L.top - 1]));\n    return L.stack[L.top - 1].ttnov();\n};\n\n// narray and nrec are mostly useless for this implementation\nconst lua_createtable = function(L, narray, nrec) {\n    let t = new lobject.TValue(LUA_TTABLE, ltable.luaH_new(L));\n    L.stack[L.top] = t;\n    api_incr_top(L);\n};\n\nconst luaS_newudata = function(L, size) {\n    return new lobject.Udata(L, size);\n};\n\nconst lua_newuserdata = function(L, size) {\n    let u = luaS_newudata(L, size);\n    L.stack[L.top] = new lobject.TValue(LUA_TUSERDATA, u);\n    api_incr_top(L);\n    return u.data;\n};\n\nconst aux_upvalue = function(L, fi, n) {\n    fengari_argcheckinteger(n);\n    switch(fi.ttype()) {\n        case LUA_TCCL: {  /* C closure */\n            let f = fi.value;\n            if (!(1 <= n && n <= f.nupvalues)) return null;\n            return {\n                name: to_luastring(\"\", true),\n                val: f.upvalue[n-1]\n            };\n        }\n        case LUA_TLCL: {  /* Lua closure */\n            let f = fi.value;\n            let p = f.p;\n            if (!(1 <= n && n <= p.upvalues.length)) return null;\n            let name = p.upvalues[n-1].name;\n            return {\n                name: name ? name.getstr() : to_luastring(\"(*no name)\", true),\n                val: f.upvals[n-1]\n            };\n        }\n        default: return null;  /* not a closure */\n    }\n};\n\nconst lua_getupvalue = function(L, funcindex, n) {\n    let up = aux_upvalue(L, index2addr(L, funcindex), n);\n    if (up) {\n        let name = up.name;\n        let val = up.val;\n        lobject.pushobj2s(L, val);\n        api_check(L, L.top <= L.ci.top, \"stack overflow\");\n        return name;\n    }\n    return null;\n};\n\nconst lua_setupvalue = function(L, funcindex, n) {\n    let fi = index2addr(L, funcindex);\n    api_checknelems(L, 1);\n    let aux = aux_upvalue(L, fi, n);\n    if (aux) {\n        let name = aux.name;\n        let val = aux.val;\n        val.setfrom(L.stack[L.top-1]);\n        delete L.stack[--L.top];\n        return name;\n    }\n    return null;\n};\n\nconst lua_newtable = function(L) {\n    lua_createtable(L, 0, 0);\n};\n\nconst lua_register = function(L, n, f) {\n    lua_pushcfunction(L, f);\n    lua_setglobal(L, n);\n};\n\nconst lua_getmetatable = function(L, objindex) {\n    let obj = index2addr(L, objindex);\n    let mt;\n    let res = false;\n    switch (obj.ttnov()) {\n        case LUA_TTABLE:\n        case LUA_TUSERDATA:\n            mt = obj.value.metatable;\n            break;\n        default:\n            mt = L.l_G.mt[obj.ttnov()];\n            break;\n    }\n\n    if (mt !== null && mt !== undefined) {\n        L.stack[L.top] = new TValue(LUA_TTABLE, mt);\n        api_incr_top(L);\n        res = true;\n    }\n\n    return res;\n};\n\nconst lua_getuservalue = function(L, idx) {\n    let o = index2addr(L, idx);\n    api_check(L, o.ttisfulluserdata(), \"full userdata expected\");\n    let uv = o.value.uservalue;\n    L.stack[L.top] = new TValue(uv.type, uv.value);\n    api_incr_top(L);\n    return L.stack[L.top - 1].ttnov();\n};\n\nconst lua_gettable = function(L, idx) {\n    let t = index2addr(L, idx);\n    lvm.luaV_gettable(L, t, L.stack[L.top - 1], L.top - 1);\n    return L.stack[L.top - 1].ttnov();\n};\n\nconst lua_getfield = function(L, idx, k) {\n    return auxgetstr(L, index2addr(L, idx), k);\n};\n\nconst lua_geti = function(L, idx, n) {\n    let t = index2addr(L, idx);\n    fengari_argcheckinteger(n);\n    L.stack[L.top] = new TValue(LUA_TNUMINT, n);\n    api_incr_top(L);\n    lvm.luaV_gettable(L, t, L.stack[L.top - 1], L.top - 1);\n    return L.stack[L.top - 1].ttnov();\n};\n\nconst lua_getglobal = function(L, name) {\n    return auxgetstr(L, ltable.luaH_getint(L.l_G.l_registry.value, LUA_RIDX_GLOBALS), name);\n};\n\n/*\n** access functions (stack -> JS)\n*/\n\nconst lua_toboolean = function(L, idx) {\n    let o = index2addr(L, idx);\n    return !o.l_isfalse();\n};\n\nconst lua_tolstring = function(L, idx) {\n    let o = index2addr(L, idx);\n\n    if (!o.ttisstring()) {\n        if (!lvm.cvt2str(o)) {  /* not convertible? */\n            return null;\n        }\n        lobject.luaO_tostring(L, o);\n    }\n    return o.svalue();\n};\n\nconst lua_tostring =  lua_tolstring;\n\nconst lua_tojsstring = function(L, idx) {\n    let o = index2addr(L, idx);\n\n    if (!o.ttisstring()) {\n        if (!lvm.cvt2str(o)) {  /* not convertible? */\n            return null;\n        }\n        lobject.luaO_tostring(L, o);\n    }\n    return o.jsstring();\n};\n\nconst lua_todataview = function(L, idx) {\n    let u8 = lua_tolstring(L, idx);\n    return new DataView(u8.buffer, u8.byteOffset, u8.byteLength);\n};\n\nconst lua_rawlen = function(L, idx) {\n    let o = index2addr(L, idx);\n    switch (o.ttype()) {\n        case LUA_TSHRSTR:\n        case LUA_TLNGSTR:\n            return o.vslen();\n        case LUA_TUSERDATA:\n            return o.value.len;\n        case LUA_TTABLE:\n            return ltable.luaH_getn(o.value);\n        default:\n            return 0;\n    }\n};\n\nconst lua_tocfunction = function(L, idx) {\n    let o = index2addr(L, idx);\n    if (o.ttislcf() || o.ttisCclosure()) return o.value;\n    else return null;  /* not a C function */\n};\n\nconst lua_tointeger = function(L, idx) {\n    let n = lua_tointegerx(L, idx);\n    return n === false ? 0 : n;\n};\n\nconst lua_tointegerx = function(L, idx) {\n    return lvm.tointeger(index2addr(L, idx));\n};\n\nconst lua_tonumber = function(L, idx) {\n    let n = lua_tonumberx(L, idx);\n    return n === false ? 0 : n;\n};\n\nconst lua_tonumberx = function(L, idx) {\n    return lvm.tonumber(index2addr(L, idx));\n};\n\nconst lua_touserdata = function(L, idx) {\n    let o = index2addr(L, idx);\n    switch (o.ttnov()) {\n        case LUA_TUSERDATA:\n            return o.value.data;\n        case LUA_TLIGHTUSERDATA:\n            return o.value;\n        default: return null;\n    }\n};\n\nconst lua_tothread = function(L, idx) {\n    let o = index2addr(L, idx);\n    return o.ttisthread() ? o.value : null;\n};\n\nconst lua_topointer = function(L, idx) {\n    let o = index2addr(L, idx);\n    switch (o.ttype()) {\n        case LUA_TTABLE:\n        case LUA_TLCL:\n        case LUA_TCCL:\n        case LUA_TLCF:\n        case LUA_TTHREAD:\n        case LUA_TUSERDATA: /* note: this differs in behaviour to reference lua implementation */\n        case LUA_TLIGHTUSERDATA:\n            return o.value;\n        default:\n            return null;\n    }\n};\n\n\n/* A proxy is a function that the same lua value to the given lua state. */\n\n/* Having a weakmap of created proxies was only way I could think of to provide an 'isproxy' function */\nconst seen = new WeakMap();\n\n/* is the passed object a proxy? is it from the given state? (if passed) */\nconst lua_isproxy = function(p, L) {\n    let G = seen.get(p);\n    if (!G)\n        return false;\n    return (L === null) || (L.l_G === G);\n};\n\n/* Use 'create_proxy' helper function so that 'L' is not in scope */\nconst create_proxy = function(G, type, value) {\n    let proxy = function(L) {\n        api_check(L, L instanceof lstate.lua_State && G === L.l_G, \"must be from same global state\");\n        L.stack[L.top] = new TValue(type, value);\n        api_incr_top(L);\n    };\n    seen.set(proxy, G);\n    return proxy;\n};\n\nconst lua_toproxy = function(L, idx) {\n    let tv = index2addr(L, idx);\n    /* pass broken down tv incase it is an upvalue index */\n    return create_proxy(L.l_G, tv.type, tv.value);\n};\n\n\nconst lua_compare = function(L, index1, index2, op) {\n    let o1 = index2addr(L, index1);\n    let o2 = index2addr(L, index2);\n\n    let i = 0;\n\n    if (isvalid(o1) && isvalid(o2)) {\n        switch (op) {\n            case LUA_OPEQ: i = lvm.luaV_equalobj(L, o1, o2); break;\n            case LUA_OPLT: i = lvm.luaV_lessthan(L, o1, o2); break;\n            case LUA_OPLE: i = lvm.luaV_lessequal(L, o1, o2); break;\n            default: api_check(L, false, \"invalid option\");\n        }\n    }\n\n    return i;\n};\n\nconst lua_stringtonumber = function(L, s) {\n    let tv = new TValue();\n    let sz = lobject.luaO_str2num(s, tv);\n    if (sz !== 0) {\n        L.stack[L.top] = tv;\n        api_incr_top(L);\n    }\n    return sz;\n};\n\nconst f_call = function(L, ud) {\n    ldo.luaD_callnoyield(L, ud.funcOff, ud.nresults);\n};\n\nconst lua_type = function(L, idx) {\n    let o = index2addr(L, idx);\n    return isvalid(o) ?  o.ttnov() : LUA_TNONE;\n};\n\nconst lua_typename = function(L, t) {\n    api_check(L, LUA_TNONE <= t && t < LUA_NUMTAGS, \"invalid tag\");\n    return ltm.ttypename(t);\n};\n\nconst lua_iscfunction = function(L, idx) {\n    let o = index2addr(L, idx);\n    return o.ttislcf(o) || o.ttisCclosure();\n};\n\nconst lua_isnil = function(L, n) {\n    return lua_type(L, n) === LUA_TNIL;\n};\n\nconst lua_isboolean = function(L, n) {\n    return lua_type(L, n) === LUA_TBOOLEAN;\n};\n\nconst lua_isnone = function(L, n) {\n    return lua_type(L, n) === LUA_TNONE;\n};\n\nconst lua_isnoneornil = function(L, n) {\n    return lua_type(L, n) <= 0;\n};\n\nconst lua_istable = function(L, idx) {\n    return index2addr(L, idx).ttistable();\n};\n\nconst lua_isinteger = function(L, idx) {\n    return index2addr(L, idx).ttisinteger();\n};\n\nconst lua_isnumber = function(L, idx) {\n    return lvm.tonumber(index2addr(L, idx)) !== false;\n};\n\nconst lua_isstring = function(L, idx) {\n    let o = index2addr(L, idx);\n    return o.ttisstring() || lvm.cvt2str(o);\n};\n\nconst lua_isuserdata = function(L, idx) {\n    let o = index2addr(L, idx);\n    return o.ttisfulluserdata(o) || o.ttislightuserdata();\n};\n\nconst lua_isthread = function(L, idx) {\n    return lua_type(L, idx) === LUA_TTHREAD;\n};\n\nconst lua_isfunction = function(L, idx) {\n    return lua_type(L, idx) === LUA_TFUNCTION;\n};\n\nconst lua_islightuserdata = function(L, idx) {\n    return lua_type(L, idx) === LUA_TLIGHTUSERDATA;\n};\n\nconst lua_rawequal = function(L, index1, index2) {\n    let o1 = index2addr(L, index1);\n    let o2 = index2addr(L, index2);\n    return isvalid(o1) && isvalid(o2) ? lvm.luaV_equalobj(null, o1, o2) : 0;\n};\n\nconst lua_arith = function(L, op) {\n    if (op !== LUA_OPUNM && op !== LUA_OPBNOT)\n        api_checknelems(L, 2);  /* all other operations expect two operands */\n    else {  /* for unary operations, add fake 2nd operand */\n        api_checknelems(L, 1);\n        lobject.pushobj2s(L, L.stack[L.top-1]);\n        api_check(L, L.top <= L.ci.top, \"stack overflow\");\n    }\n    /* first operand at top - 2, second at top - 1; result go to top - 2 */\n    lobject.luaO_arith(L, op, L.stack[L.top - 2], L.stack[L.top - 1], L.stack[L.top - 2]);\n    delete L.stack[--L.top];  /* remove second operand */\n};\n\n/*\n** 'load' and 'call' functions (run Lua code)\n*/\n\nconst default_chunkname = to_luastring(\"?\");\nconst lua_load = function(L, reader, data, chunkname, mode) {\n    if (!chunkname) chunkname = default_chunkname;\n    else chunkname = from_userstring(chunkname);\n    if (mode !== null) mode = from_userstring(mode);\n    let z = new ZIO(L, reader, data);\n    let status = ldo.luaD_protectedparser(L, z, chunkname, mode);\n    if (status === LUA_OK) {  /* no errors? */\n        let f = L.stack[L.top - 1].value; /* get newly created function */\n        if (f.nupvalues >= 1) {  /* does it have an upvalue? */\n            /* get global table from registry */\n            let gt = ltable.luaH_getint(L.l_G.l_registry.value, LUA_RIDX_GLOBALS);\n            /* set global table as 1st upvalue of 'f' (may be LUA_ENV) */\n            f.upvals[0].setfrom(gt);\n        }\n    }\n    return status;\n};\n\nconst lua_dump = function(L, writer, data, strip) {\n    api_checknelems(L, 1);\n    let o = L.stack[L.top -1];\n    if (o.ttisLclosure())\n        return luaU_dump(L, o.value.p, writer, data, strip);\n    return 1;\n};\n\nconst lua_status = function(L) {\n    return L.status;\n};\n\nconst lua_setuservalue = function(L, idx) {\n    api_checknelems(L, 1);\n    let o = index2addr(L, idx);\n    api_check(L, o.ttisfulluserdata(), \"full userdata expected\");\n    o.value.uservalue.setfrom(L.stack[L.top - 1]);\n    delete L.stack[--L.top];\n};\n\nconst checkresults = function(L,na,nr) {\n    api_check(L, nr === LUA_MULTRET || (L.ci.top - L.top >= (nr) - (na)),\n        \"results from function overflow current stack size\");\n};\n\nconst lua_callk = function(L, nargs, nresults, ctx, k) {\n    api_check(L, k === null || !(L.ci.callstatus & lstate.CIST_LUA), \"cannot use continuations inside hooks\");\n    api_checknelems(L, nargs + 1);\n    api_check(L, L.status === LUA_OK, \"cannot do calls on non-normal thread\");\n    checkresults(L, nargs, nresults);\n    let func = L.top - (nargs + 1);\n    if (k !== null && L.nny === 0) { /* need to prepare continuation? */\n        L.ci.c_k = k;\n        L.ci.c_ctx = ctx;\n        ldo.luaD_call(L, func, nresults);\n    } else { /* no continuation or no yieldable */\n        ldo.luaD_callnoyield(L, func, nresults);\n    }\n\n    if (nresults === LUA_MULTRET && L.ci.top < L.top)\n        L.ci.top = L.top;\n};\n\nconst lua_call = function(L, n, r) {\n    lua_callk(L, n, r, 0, null);\n};\n\nconst lua_pcallk = function(L, nargs, nresults, errfunc, ctx, k) {\n    api_check(L, k === null || !(L.ci.callstatus & lstate.CIST_LUA), \"cannot use continuations inside hooks\");\n    api_checknelems(L, nargs + 1);\n    api_check(L, L.status === LUA_OK, \"cannot do calls on non-normal thread\");\n    checkresults(L, nargs, nresults);\n    let status;\n    let func;\n    if (errfunc === 0)\n        func = 0;\n    else {\n        func = index2addr_(L, errfunc);\n    }\n    let funcOff = L.top - (nargs + 1); /* function to be called */\n    if (k === null || L.nny > 0) { /* no continuation or no yieldable? */\n        let c = {\n            funcOff: funcOff,\n            nresults: nresults /* do a 'conventional' protected call */\n        };\n        status = ldo.luaD_pcall(L, f_call, c, funcOff, func);\n    } else { /* prepare continuation (call is already protected by 'resume') */\n        let ci = L.ci;\n        ci.c_k = k;  /* prepare continuation (call is already protected by 'resume') */\n        ci.c_ctx = ctx;  /* prepare continuation (call is already protected by 'resume') */\n        /* save information for error recovery */\n        ci.extra = funcOff;\n        ci.c_old_errfunc = L.errfunc;\n        L.errfunc = func;\n        ci.callstatus &= ~lstate.CIST_OAH | L.allowhook;\n        ci.callstatus |= lstate.CIST_YPCALL;  /* function can do error recovery */\n        ldo.luaD_call(L, funcOff, nresults);  /* do the call */\n        ci.callstatus &= ~lstate.CIST_YPCALL;\n        L.errfunc = ci.c_old_errfunc;\n        status = LUA_OK;\n    }\n\n    if (nresults === LUA_MULTRET && L.ci.top < L.top)\n        L.ci.top = L.top;\n\n    return status;\n};\n\nconst lua_pcall = function(L, n, r, f) {\n    return lua_pcallk(L, n, r, f, 0, null);\n};\n\n/*\n** miscellaneous functions\n*/\n\nconst lua_error = function(L) {\n    api_checknelems(L, 1);\n    ldebug.luaG_errormsg(L);\n};\n\nconst lua_next = function(L, idx) {\n    let t = index2addr(L, idx);\n    api_check(L, t.ttistable(), \"table expected\");\n    L.stack[L.top] = new TValue();\n    let more = ltable.luaH_next(L, t.value, L.top - 1);\n    if (more) {\n        api_incr_top(L);\n        return 1;\n    } else {\n        delete L.stack[L.top];\n        delete L.stack[--L.top];\n        return 0;\n    }\n};\n\nconst lua_concat = function(L, n) {\n    api_checknelems(L, n);\n    if (n >= 2)\n        lvm.luaV_concat(L, n);\n    else if (n === 0) {\n        lobject.pushsvalue2s(L, luaS_bless(L, to_luastring(\"\", true)));\n        api_check(L, L.top <= L.ci.top, \"stack overflow\");\n    }\n};\n\nconst lua_len = function(L, idx) {\n    let t = index2addr(L, idx);\n    let tv = new TValue();\n    lvm.luaV_objlen(L, tv, t);\n    L.stack[L.top] = tv;\n    api_incr_top(L);\n};\n\nconst getupvalref = function(L, fidx, n) {\n    let fi = index2addr(L, fidx);\n    api_check(L, fi.ttisLclosure(), \"Lua function expected\");\n    let f = fi.value;\n    fengari_argcheckinteger(n);\n    api_check(L, 1 <= n && n <= f.p.upvalues.length, \"invalid upvalue index\");\n    return {\n        f: f,\n        i: n - 1\n    };\n};\n\nconst lua_upvalueid = function(L, fidx, n) {\n    let fi = index2addr(L, fidx);\n    switch (fi.ttype()) {\n        case LUA_TLCL: {  /* lua closure */\n            let ref = getupvalref(L, fidx, n);\n            return ref.f.upvals[ref.i];\n        }\n        case LUA_TCCL: {  /* C closure */\n            let f = fi.value;\n            api_check(L, (n|0) === n && n > 0 && n <= f.nupvalues, \"invalid upvalue index\");\n            return f.upvalue[n - 1];\n        }\n        default: {\n            api_check(L, false, \"closure expected\");\n            return null;\n        }\n    }\n};\n\nconst lua_upvaluejoin = function(L, fidx1, n1, fidx2, n2) {\n    let ref1 = getupvalref(L, fidx1, n1);\n    let ref2 = getupvalref(L, fidx2, n2);\n    let up2 = ref2.f.upvals[ref2.i];\n    ref1.f.upvals[ref1.i] = up2;\n};\n\n// This functions are only there for compatibility purposes\nconst lua_gc = function () {};\n\nconst lua_getallocf = function () {\n    console.warn(\"lua_getallocf is not available\");\n    return 0;\n};\n\nconst lua_setallocf = function () {\n    console.warn(\"lua_setallocf is not available\");\n    return 0;\n};\n\nconst lua_getextraspace = function () {\n    console.warn(\"lua_getextraspace is not available\");\n    return 0;\n};\n\nmodule.exports.api_incr_top          = api_incr_top;\nmodule.exports.api_checknelems       = api_checknelems;\nmodule.exports.lua_absindex          = lua_absindex;\nmodule.exports.lua_arith             = lua_arith;\nmodule.exports.lua_atpanic           = lua_atpanic;\nmodule.exports.lua_atnativeerror     = lua_atnativeerror;\nmodule.exports.lua_call              = lua_call;\nmodule.exports.lua_callk             = lua_callk;\nmodule.exports.lua_checkstack        = lua_checkstack;\nmodule.exports.lua_compare           = lua_compare;\nmodule.exports.lua_concat            = lua_concat;\nmodule.exports.lua_copy              = lua_copy;\nmodule.exports.lua_createtable       = lua_createtable;\nmodule.exports.lua_dump              = lua_dump;\nmodule.exports.lua_error             = lua_error;\nmodule.exports.lua_gc                = lua_gc;\nmodule.exports.lua_getallocf         = lua_getallocf;\nmodule.exports.lua_getextraspace     = lua_getextraspace;\nmodule.exports.lua_getfield          = lua_getfield;\nmodule.exports.lua_getglobal         = lua_getglobal;\nmodule.exports.lua_geti              = lua_geti;\nmodule.exports.lua_getmetatable      = lua_getmetatable;\nmodule.exports.lua_gettable          = lua_gettable;\nmodule.exports.lua_gettop            = lua_gettop;\nmodule.exports.lua_getupvalue        = lua_getupvalue;\nmodule.exports.lua_getuservalue      = lua_getuservalue;\nmodule.exports.lua_insert            = lua_insert;\nmodule.exports.lua_isboolean         = lua_isboolean;\nmodule.exports.lua_iscfunction       = lua_iscfunction;\nmodule.exports.lua_isfunction        = lua_isfunction;\nmodule.exports.lua_isinteger         = lua_isinteger;\nmodule.exports.lua_islightuserdata   = lua_islightuserdata;\nmodule.exports.lua_isnil             = lua_isnil;\nmodule.exports.lua_isnone            = lua_isnone;\nmodule.exports.lua_isnoneornil       = lua_isnoneornil;\nmodule.exports.lua_isnumber          = lua_isnumber;\nmodule.exports.lua_isproxy           = lua_isproxy;\nmodule.exports.lua_isstring          = lua_isstring;\nmodule.exports.lua_istable           = lua_istable;\nmodule.exports.lua_isthread          = lua_isthread;\nmodule.exports.lua_isuserdata        = lua_isuserdata;\nmodule.exports.lua_len               = lua_len;\nmodule.exports.lua_load              = lua_load;\nmodule.exports.lua_newtable          = lua_newtable;\nmodule.exports.lua_newuserdata       = lua_newuserdata;\nmodule.exports.lua_next              = lua_next;\nmodule.exports.lua_pcall             = lua_pcall;\nmodule.exports.lua_pcallk            = lua_pcallk;\nmodule.exports.lua_pop               = lua_pop;\nmodule.exports.lua_pushboolean       = lua_pushboolean;\nmodule.exports.lua_pushcclosure      = lua_pushcclosure;\nmodule.exports.lua_pushcfunction     = lua_pushcfunction;\nmodule.exports.lua_pushfstring       = lua_pushfstring;\nmodule.exports.lua_pushglobaltable   = lua_pushglobaltable;\nmodule.exports.lua_pushinteger       = lua_pushinteger;\nmodule.exports.lua_pushjsclosure     = lua_pushjsclosure;\nmodule.exports.lua_pushjsfunction    = lua_pushjsfunction;\nmodule.exports.lua_pushlightuserdata = lua_pushlightuserdata;\nmodule.exports.lua_pushliteral       = lua_pushliteral;\nmodule.exports.lua_pushlstring       = lua_pushlstring;\nmodule.exports.lua_pushnil           = lua_pushnil;\nmodule.exports.lua_pushnumber        = lua_pushnumber;\nmodule.exports.lua_pushstring        = lua_pushstring;\nmodule.exports.lua_pushthread        = lua_pushthread;\nmodule.exports.lua_pushvalue         = lua_pushvalue;\nmodule.exports.lua_pushvfstring      = lua_pushvfstring;\nmodule.exports.lua_rawequal          = lua_rawequal;\nmodule.exports.lua_rawget            = lua_rawget;\nmodule.exports.lua_rawgeti           = lua_rawgeti;\nmodule.exports.lua_rawgetp           = lua_rawgetp;\nmodule.exports.lua_rawlen            = lua_rawlen;\nmodule.exports.lua_rawset            = lua_rawset;\nmodule.exports.lua_rawseti           = lua_rawseti;\nmodule.exports.lua_rawsetp           = lua_rawsetp;\nmodule.exports.lua_register          = lua_register;\nmodule.exports.lua_remove            = lua_remove;\nmodule.exports.lua_replace           = lua_replace;\nmodule.exports.lua_rotate            = lua_rotate;\nmodule.exports.lua_setallocf         = lua_setallocf;\nmodule.exports.lua_setfield          = lua_setfield;\nmodule.exports.lua_setglobal         = lua_setglobal;\nmodule.exports.lua_seti              = lua_seti;\nmodule.exports.lua_setmetatable      = lua_setmetatable;\nmodule.exports.lua_settable          = lua_settable;\nmodule.exports.lua_settop            = lua_settop;\nmodule.exports.lua_setupvalue        = lua_setupvalue;\nmodule.exports.lua_setuservalue      = lua_setuservalue;\nmodule.exports.lua_status            = lua_status;\nmodule.exports.lua_stringtonumber    = lua_stringtonumber;\nmodule.exports.lua_toboolean         = lua_toboolean;\nmodule.exports.lua_tocfunction       = lua_tocfunction;\nmodule.exports.lua_todataview        = lua_todataview;\nmodule.exports.lua_tointeger         = lua_tointeger;\nmodule.exports.lua_tointegerx        = lua_tointegerx;\nmodule.exports.lua_tojsstring        = lua_tojsstring;\nmodule.exports.lua_tolstring         = lua_tolstring;\nmodule.exports.lua_tonumber          = lua_tonumber;\nmodule.exports.lua_tonumberx         = lua_tonumberx;\nmodule.exports.lua_topointer         = lua_topointer;\nmodule.exports.lua_toproxy           = lua_toproxy;\nmodule.exports.lua_tostring          = lua_tostring;\nmodule.exports.lua_tothread          = lua_tothread;\nmodule.exports.lua_touserdata        = lua_touserdata;\nmodule.exports.lua_type              = lua_type;\nmodule.exports.lua_typename          = lua_typename;\nmodule.exports.lua_upvalueid         = lua_upvalueid;\nmodule.exports.lua_upvaluejoin       = lua_upvaluejoin;\nmodule.exports.lua_version           = lua_version;\nmodule.exports.lua_xmove             = lua_xmove;\n", ";\n\nconst defs   = require(\"./defs.js\");\nconst lapi   = require(\"./lapi.js\");\nconst ldebug = require(\"./ldebug.js\");\nconst ldo    = require(\"./ldo.js\");\nconst lstate = require(\"./lstate.js\");\n\nmodule.exports.LUA_AUTHORS             = defs.LUA_AUTHORS;\nmodule.exports.LUA_COPYRIGHT           = defs.LUA_COPYRIGHT;\nmodule.exports.LUA_ERRERR              = defs.thread_status.LUA_ERRERR;\nmodule.exports.LUA_ERRGCMM             = defs.thread_status.LUA_ERRGCMM;\nmodule.exports.LUA_ERRMEM              = defs.thread_status.LUA_ERRMEM;\nmodule.exports.LUA_ERRRUN              = defs.thread_status.LUA_ERRRUN;\nmodule.exports.LUA_ERRSYNTAX           = defs.thread_status.LUA_ERRSYNTAX;\nmodule.exports.LUA_HOOKCALL            = defs.LUA_HOOKCALL;\nmodule.exports.LUA_HOOKCOUNT           = defs.LUA_HOOKCOUNT;\nmodule.exports.LUA_HOOKLINE            = defs.LUA_HOOKLINE;\nmodule.exports.LUA_HOOKRET             = defs.LUA_HOOKRET;\nmodule.exports.LUA_HOOKTAILCALL        = defs.LUA_HOOKTAILCALL;\nmodule.exports.LUA_MASKCALL            = defs.LUA_MASKCALL;\nmodule.exports.LUA_MASKCOUNT           = defs.LUA_MASKCOUNT;\nmodule.exports.LUA_MASKLINE            = defs.LUA_MASKLINE;\nmodule.exports.LUA_MASKRET             = defs.LUA_MASKRET;\nmodule.exports.LUA_MINSTACK            = defs.LUA_MINSTACK;\nmodule.exports.LUA_MULTRET             = defs.LUA_MULTRET;\nmodule.exports.LUA_NUMTAGS             = defs.constant_types.LUA_NUMTAGS;\nmodule.exports.LUA_OK                  = defs.thread_status.LUA_OK;\nmodule.exports.LUA_OPADD               = defs.LUA_OPADD;\nmodule.exports.LUA_OPBAND              = defs.LUA_OPBAND;\nmodule.exports.LUA_OPBNOT              = defs.LUA_OPBNOT;\nmodule.exports.LUA_OPBOR               = defs.LUA_OPBOR;\nmodule.exports.LUA_OPBXOR              = defs.LUA_OPBXOR;\nmodule.exports.LUA_OPDIV               = defs.LUA_OPDIV;\nmodule.exports.LUA_OPEQ                = defs.LUA_OPEQ;\nmodule.exports.LUA_OPIDIV              = defs.LUA_OPIDIV;\nmodule.exports.LUA_OPLE                = defs.LUA_OPLE;\nmodule.exports.LUA_OPLT                = defs.LUA_OPLT;\nmodule.exports.LUA_OPMOD               = defs.LUA_OPMOD;\nmodule.exports.LUA_OPMUL               = defs.LUA_OPMUL;\nmodule.exports.LUA_OPPOW               = defs.LUA_OPPOW;\nmodule.exports.LUA_OPSHL               = defs.LUA_OPSHL;\nmodule.exports.LUA_OPSHR               = defs.LUA_OPSHR;\nmodule.exports.LUA_OPSUB               = defs.LUA_OPSUB;\nmodule.exports.LUA_OPUNM               = defs.LUA_OPUNM;\nmodule.exports.LUA_REGISTRYINDEX       = defs.LUA_REGISTRYINDEX;\nmodule.exports.LUA_RELEASE             = defs.LUA_RELEASE;\nmodule.exports.LUA_RIDX_GLOBALS        = defs.LUA_RIDX_GLOBALS;\nmodule.exports.LUA_RIDX_LAST           = defs.LUA_RIDX_LAST;\nmodule.exports.LUA_RIDX_MAINTHREAD     = defs.LUA_RIDX_MAINTHREAD;\nmodule.exports.LUA_SIGNATURE           = defs.LUA_SIGNATURE;\nmodule.exports.LUA_TNONE               = defs.constant_types.LUA_TNONE;\nmodule.exports.LUA_TNIL                = defs.constant_types.LUA_TNIL;\nmodule.exports.LUA_TBOOLEAN            = defs.constant_types.LUA_TBOOLEAN;\nmodule.exports.LUA_TLIGHTUSERDATA      = defs.constant_types.LUA_TLIGHTUSERDATA;\nmodule.exports.LUA_TNUMBER             = defs.constant_types.LUA_TNUMBER;\nmodule.exports.LUA_TSTRING             = defs.constant_types.LUA_TSTRING;\nmodule.exports.LUA_TTABLE              = defs.constant_types.LUA_TTABLE;\nmodule.exports.LUA_TFUNCTION           = defs.constant_types.LUA_TFUNCTION;\nmodule.exports.LUA_TUSERDATA           = defs.constant_types.LUA_TUSERDATA;\nmodule.exports.LUA_TTHREAD             = defs.constant_types.LUA_TTHREAD;\nmodule.exports.LUA_VERSION             = defs.LUA_VERSION;\nmodule.exports.LUA_VERSION_MAJOR       = defs.LUA_VERSION_MAJOR;\nmodule.exports.LUA_VERSION_MINOR       = defs.LUA_VERSION_MINOR;\nmodule.exports.LUA_VERSION_NUM         = defs.LUA_VERSION_NUM;\nmodule.exports.LUA_VERSION_RELEASE     = defs.LUA_VERSION_RELEASE;\nmodule.exports.LUA_YIELD               = defs.thread_status.LUA_YIELD;\nmodule.exports.lua_Debug               = defs.lua_Debug;\nmodule.exports.lua_upvalueindex        = defs.lua_upvalueindex;\nmodule.exports.lua_absindex            = lapi.lua_absindex;\nmodule.exports.lua_arith               = lapi.lua_arith;\nmodule.exports.lua_atpanic             = lapi.lua_atpanic;\nmodule.exports.lua_atnativeerror       = lapi.lua_atnativeerror;\nmodule.exports.lua_call                = lapi.lua_call;\nmodule.exports.lua_callk               = lapi.lua_callk;\nmodule.exports.lua_checkstack          = lapi.lua_checkstack;\nmodule.exports.lua_close               = lstate.lua_close;\nmodule.exports.lua_compare             = lapi.lua_compare;\nmodule.exports.lua_concat              = lapi.lua_concat;\nmodule.exports.lua_copy                = lapi.lua_copy;\nmodule.exports.lua_createtable         = lapi.lua_createtable;\nmodule.exports.lua_dump                = lapi.lua_dump;\nmodule.exports.lua_error               = lapi.lua_error;\nmodule.exports.lua_gc                  = lapi.lua_gc;\nmodule.exports.lua_getallocf           = lapi.lua_getallocf;\nmodule.exports.lua_getextraspace       = lapi.lua_getextraspace;\nmodule.exports.lua_getfield            = lapi.lua_getfield;\nmodule.exports.lua_getglobal           = lapi.lua_getglobal;\nmodule.exports.lua_gethook             = ldebug.lua_gethook;\nmodule.exports.lua_gethookcount        = ldebug.lua_gethookcount;\nmodule.exports.lua_gethookmask         = ldebug.lua_gethookmask;\nmodule.exports.lua_geti                = lapi.lua_geti;\nmodule.exports.lua_getinfo             = ldebug.lua_getinfo;\nmodule.exports.lua_getlocal            = ldebug.lua_getlocal;\nmodule.exports.lua_getmetatable        = lapi.lua_getmetatable;\nmodule.exports.lua_getstack            = ldebug.lua_getstack;\nmodule.exports.lua_gettable            = lapi.lua_gettable;\nmodule.exports.lua_gettop              = lapi.lua_gettop;\nmodule.exports.lua_getupvalue          = lapi.lua_getupvalue;\nmodule.exports.lua_getuservalue        = lapi.lua_getuservalue;\nmodule.exports.lua_insert              = lapi.lua_insert;\nmodule.exports.lua_isboolean           = lapi.lua_isboolean;\nmodule.exports.lua_iscfunction         = lapi.lua_iscfunction;\nmodule.exports.lua_isfunction          = lapi.lua_isfunction;\nmodule.exports.lua_isinteger           = lapi.lua_isinteger;\nmodule.exports.lua_islightuserdata     = lapi.lua_islightuserdata;\nmodule.exports.lua_isnil               = lapi.lua_isnil;\nmodule.exports.lua_isnone              = lapi.lua_isnone;\nmodule.exports.lua_isnoneornil         = lapi.lua_isnoneornil;\nmodule.exports.lua_isnumber            = lapi.lua_isnumber;\nmodule.exports.lua_isproxy             = lapi.lua_isproxy;\nmodule.exports.lua_isstring            = lapi.lua_isstring;\nmodule.exports.lua_istable             = lapi.lua_istable;\nmodule.exports.lua_isthread            = lapi.lua_isthread;\nmodule.exports.lua_isuserdata          = lapi.lua_isuserdata;\nmodule.exports.lua_isyieldable         = ldo.lua_isyieldable;\nmodule.exports.lua_len                 = lapi.lua_len;\nmodule.exports.lua_load                = lapi.lua_load;\nmodule.exports.lua_newstate            = lstate.lua_newstate;\nmodule.exports.lua_newtable            = lapi.lua_newtable;\nmodule.exports.lua_newthread           = lstate.lua_newthread;\nmodule.exports.lua_newuserdata         = lapi.lua_newuserdata;\nmodule.exports.lua_next                = lapi.lua_next;\nmodule.exports.lua_pcall               = lapi.lua_pcall;\nmodule.exports.lua_pcallk              = lapi.lua_pcallk;\nmodule.exports.lua_pop                 = lapi.lua_pop;\nmodule.exports.lua_pushboolean         = lapi.lua_pushboolean;\nmodule.exports.lua_pushcclosure        = lapi.lua_pushcclosure;\nmodule.exports.lua_pushcfunction       = lapi.lua_pushcfunction;\nmodule.exports.lua_pushfstring         = lapi.lua_pushfstring;\nmodule.exports.lua_pushglobaltable     = lapi.lua_pushglobaltable;\nmodule.exports.lua_pushinteger         = lapi.lua_pushinteger;\nmodule.exports.lua_pushjsclosure       = lapi.lua_pushjsclosure;\nmodule.exports.lua_pushjsfunction      = lapi.lua_pushjsfunction;\nmodule.exports.lua_pushlightuserdata   = lapi.lua_pushlightuserdata;\nmodule.exports.lua_pushliteral         = lapi.lua_pushliteral;\nmodule.exports.lua_pushlstring         = lapi.lua_pushlstring;\nmodule.exports.lua_pushnil             = lapi.lua_pushnil;\nmodule.exports.lua_pushnumber          = lapi.lua_pushnumber;\nmodule.exports.lua_pushstring          = lapi.lua_pushstring;\nmodule.exports.lua_pushthread          = lapi.lua_pushthread;\nmodule.exports.lua_pushvalue           = lapi.lua_pushvalue;\nmodule.exports.lua_pushvfstring        = lapi.lua_pushvfstring;\nmodule.exports.lua_rawequal            = lapi.lua_rawequal;\nmodule.exports.lua_rawget              = lapi.lua_rawget;\nmodule.exports.lua_rawgeti             = lapi.lua_rawgeti;\nmodule.exports.lua_rawgetp             = lapi.lua_rawgetp;\nmodule.exports.lua_rawlen              = lapi.lua_rawlen;\nmodule.exports.lua_rawset              = lapi.lua_rawset;\nmodule.exports.lua_rawseti             = lapi.lua_rawseti;\nmodule.exports.lua_rawsetp             = lapi.lua_rawsetp;\nmodule.exports.lua_register            = lapi.lua_register;\nmodule.exports.lua_remove              = lapi.lua_remove;\nmodule.exports.lua_replace             = lapi.lua_replace;\nmodule.exports.lua_resume              = ldo.lua_resume;\nmodule.exports.lua_rotate              = lapi.lua_rotate;\nmodule.exports.lua_setallof            = ldo.lua_setallof;\nmodule.exports.lua_setfield            = lapi.lua_setfield;\nmodule.exports.lua_setglobal           = lapi.lua_setglobal;\nmodule.exports.lua_sethook             = ldebug.lua_sethook;\nmodule.exports.lua_seti                = lapi.lua_seti;\nmodule.exports.lua_setlocal            = ldebug.lua_setlocal;\nmodule.exports.lua_setmetatable        = lapi.lua_setmetatable;\nmodule.exports.lua_settable            = lapi.lua_settable;\nmodule.exports.lua_settop              = lapi.lua_settop;\nmodule.exports.lua_setupvalue          = lapi.lua_setupvalue;\nmodule.exports.lua_setuservalue        = lapi.lua_setuservalue;\nmodule.exports.lua_status              = lapi.lua_status;\nmodule.exports.lua_stringtonumber      = lapi.lua_stringtonumber;\nmodule.exports.lua_toboolean           = lapi.lua_toboolean;\nmodule.exports.lua_todataview          = lapi.lua_todataview;\nmodule.exports.lua_tointeger           = lapi.lua_tointeger;\nmodule.exports.lua_tointegerx          = lapi.lua_tointegerx;\nmodule.exports.lua_tojsstring          = lapi.lua_tojsstring;\nmodule.exports.lua_tolstring           = lapi.lua_tolstring;\nmodule.exports.lua_tonumber            = lapi.lua_tonumber;\nmodule.exports.lua_tonumberx           = lapi.lua_tonumberx;\nmodule.exports.lua_topointer           = lapi.lua_topointer;\nmodule.exports.lua_toproxy             = lapi.lua_toproxy;\nmodule.exports.lua_tostring            = lapi.lua_tostring;\nmodule.exports.lua_tothread            = lapi.lua_tothread;\nmodule.exports.lua_touserdata          = lapi.lua_touserdata;\nmodule.exports.lua_type                = lapi.lua_type;\nmodule.exports.lua_typename            = lapi.lua_typename;\nmodule.exports.lua_upvalueid           = lapi.lua_upvalueid;\nmodule.exports.lua_upvaluejoin         = lapi.lua_upvaluejoin;\nmodule.exports.lua_version             = lapi.lua_version;\nmodule.exports.lua_xmove               = lapi.lua_xmove;\nmodule.exports.lua_yield               = ldo.lua_yield;\nmodule.exports.lua_yieldk              = ldo.lua_yieldk;\nmodule.exports.lua_tocfunction         = lapi.lua_tocfunction;\n", ";\n\nconst {\n    LUAL_BUFFERSIZE\n} = require('./luaconf.js');\nconst {\n    LUA_ERRERR,\n    LUA_MULTRET,\n    LUA_REGISTRYINDEX,\n    LUA_SIGNATURE,\n    LUA_TBOOLEAN,\n    LUA_TLIGHTUSERDATA,\n    LUA_TNIL,\n    LUA_TNONE,\n    LUA_TNUMBER,\n    LUA_TSTRING,\n    LUA_TTABLE,\n    LUA_VERSION_NUM,\n    lua_Debug,\n    lua_absindex,\n    lua_atpanic,\n    lua_call,\n    lua_checkstack,\n    lua_concat,\n    lua_copy,\n    lua_createtable,\n    lua_error,\n    lua_getfield,\n    lua_getinfo,\n    lua_getmetatable,\n    lua_getstack,\n    lua_gettop,\n    lua_insert,\n    lua_isinteger,\n    lua_isnil,\n    lua_isnumber,\n    lua_isstring,\n    lua_istable,\n    lua_len,\n    lua_load,\n    lua_newstate,\n    lua_newtable,\n    lua_next,\n    lua_pcall,\n    lua_pop,\n    lua_pushboolean,\n    lua_pushcclosure,\n    lua_pushcfunction,\n    lua_pushfstring,\n    lua_pushinteger,\n    lua_pushliteral,\n    lua_pushlstring,\n    lua_pushnil,\n    lua_pushstring,\n    lua_pushvalue,\n    lua_pushvfstring,\n    lua_rawequal,\n    lua_rawget,\n    lua_rawgeti,\n    lua_rawlen,\n    lua_rawseti,\n    lua_remove,\n    lua_setfield,\n    lua_setglobal,\n    lua_setmetatable,\n    lua_settop,\n    lua_toboolean,\n    lua_tointeger,\n    lua_tointegerx,\n    lua_tojsstring,\n    lua_tolstring,\n    lua_tonumber,\n    lua_tonumberx,\n    lua_topointer,\n    lua_tostring,\n    lua_touserdata,\n    lua_type,\n    lua_typename,\n    lua_version\n} = require('./lua.js');\nconst {\n    from_userstring,\n    luastring_eq,\n    to_luastring,\n    to_uristring\n} = require(\"./fengaricore.js\");\n\n/* extra error code for 'luaL_loadfilex' */\nconst LUA_ERRFILE = LUA_ERRERR+1;\n\n/* key, in the registry, for table of loaded modules */\nconst LUA_LOADED_TABLE = to_luastring(\"_LOADED\");\n\n/* key, in the registry, for table of preloaded loaders */\nconst LUA_PRELOAD_TABLE = to_luastring(\"_PRELOAD\");\n\nconst LUA_FILEHANDLE = to_luastring(\"FILE*\");\n\nconst LUAL_NUMSIZES  = 4*16 + 8;\n\nconst __name = to_luastring(\"__name\");\nconst __tostring = to_luastring(\"__tostring\");\n\nconst empty = new Uint8Array(0);\n\nclass luaL_Buffer {\n    constructor() {\n        this.L = null;\n        this.b = empty;\n        this.n = 0;\n    }\n}\n\nconst LEVELS1 = 10;  /* size of the first part of the stack */\nconst LEVELS2 = 11;  /* size of the second part of the stack */\n\n/*\n** search for 'objidx' in table at index -1.\n** return 1 + string at top if find a good name.\n*/\nconst findfield = function(L, objidx, level) {\n    if (level === 0 || !lua_istable(L, -1))\n        return 0;  /* not found */\n\n    lua_pushnil(L);  /* start 'next' loop */\n\n    while (lua_next(L, -2)) {  /* for each pair in table */\n        if (lua_type(L, -2) === LUA_TSTRING) {  /* ignore non-string keys */\n            if (lua_rawequal(L, objidx, -1)) {  /* found object? */\n                lua_pop(L, 1);  /* remove value (but keep name) */\n                return 1;\n            } else if (findfield(L, objidx, level - 1)) {  /* try recursively */\n                lua_remove(L, -2);  /* remove table (but keep name) */\n                lua_pushliteral(L, \".\");\n                lua_insert(L, -2);  /* place '.' between the two names */\n                lua_concat(L, 3);\n                return 1;\n            }\n        }\n        lua_pop(L, 1);  /* remove value */\n    }\n\n    return 0;  /* not found */\n};\n\n/*\n** Search for a name for a function in all loaded modules\n*/\nconst pushglobalfuncname = function(L, ar) {\n    let top = lua_gettop(L);\n    lua_getinfo(L, to_luastring(\"f\"), ar);  /* push function */\n    lua_getfield(L, LUA_REGISTRYINDEX, LUA_LOADED_TABLE);\n    if (findfield(L, top + 1, 2)) {\n        let name = lua_tostring(L, -1);\n        if (name[0] === 95 /* '_'.charCodeAt(0) */ &&\n            name[1] === 71 /* 'G'.charCodeAt(0) */ &&\n            name[2] === 46 /* '.'.charCodeAt(0) */\n        ) {  /* name start with '_G.'? */\n            lua_pushstring(L, name.subarray(3));  /* push name without prefix */\n            lua_remove(L, -2);  /* remove original name */\n        }\n        lua_copy(L, -1, top + 1);  /* move name to proper place */\n        lua_pop(L, 2);  /* remove pushed values */\n        return 1;\n    } else {\n        lua_settop(L, top);  /* remove function and global table */\n        return 0;\n    }\n};\n\nconst pushfuncname = function(L, ar) {\n    if (pushglobalfuncname(L, ar)) {  /* try first a global name */\n        lua_pushfstring(L, to_luastring(\"function '%s'\"), lua_tostring(L, -1));\n        lua_remove(L, -2);  /* remove name */\n    }\n    else if (ar.namewhat.length !== 0)  /* is there a name from code? */\n        lua_pushfstring(L, to_luastring(\"%s '%s'\"), ar.namewhat, ar.name);  /* use it */\n    else if (ar.what && ar.what[0] === 109 /* 'm'.charCodeAt(0) */)  /* main? */\n        lua_pushliteral(L, \"main chunk\");\n    else if (ar.what && ar.what[0] === 76 /* 'L'.charCodeAt(0) */)  /* for Lua functions, use <file:line> */\n        lua_pushfstring(L, to_luastring(\"function <%s:%d>\"), ar.short_src, ar.linedefined);\n    else  /* nothing left... */\n        lua_pushliteral(L, \"?\");\n};\n\nconst lastlevel = function(L) {\n    let ar = new lua_Debug();\n    let li = 1;\n    let le = 1;\n    /* find an upper bound */\n    while (lua_getstack(L, le, ar)) { li = le; le *= 2; }\n    /* do a binary search */\n    while (li < le) {\n        let m = Math.floor((li + le)/2);\n        if (lua_getstack(L, m, ar)) li = m + 1;\n        else le = m;\n    }\n    return le - 1;\n};\n\nconst luaL_traceback = function(L, L1, msg, level) {\n    let ar = new lua_Debug();\n    let top = lua_gettop(L);\n    let last = lastlevel(L1);\n    let n1 = last - level > LEVELS1 + LEVELS2 ? LEVELS1 : -1;\n    if (msg)\n        lua_pushfstring(L, to_luastring(\"%s\\n\"), msg);\n    luaL_checkstack(L, 10, null);\n    lua_pushliteral(L, \"stack traceback:\");\n    while (lua_getstack(L1, level++, ar)) {\n        if (n1-- === 0) {  /* too many levels? */\n            lua_pushliteral(L, \"\\n\\t...\");  /* add a '...' */\n            level = last - LEVELS2 + 1;  /* and skip to last ones */\n        } else {\n            lua_getinfo(L1, to_luastring(\"Slnt\", true), ar);\n            lua_pushfstring(L, to_luastring(\"\\n\\t%s:\"), ar.short_src);\n            if (ar.currentline > 0)\n                lua_pushliteral(L, `${ar.currentline}:`);\n            lua_pushliteral(L, \" in \");\n            pushfuncname(L, ar);\n            if (ar.istailcall)\n                lua_pushliteral(L, \"\\n\\t(...tail calls..)\");\n            lua_concat(L, lua_gettop(L) - top);\n        }\n    }\n    lua_concat(L, lua_gettop(L) - top);\n};\n\nconst panic = function(L) {\n    let msg = \"PANIC: unprotected error in call to Lua API (\" + lua_tojsstring(L, -1) + \")\";\n    throw new Error(msg);\n};\n\nconst luaL_argerror = function(L, arg, extramsg) {\n    let ar = new lua_Debug();\n\n    if (!lua_getstack(L, 0, ar))  /* no stack frame? */\n        return luaL_error(L, to_luastring(\"bad argument #%d (%s)\"), arg, extramsg);\n\n    lua_getinfo(L, to_luastring(\"n\"), ar);\n\n    if (luastring_eq(ar.namewhat, to_luastring(\"method\"))) {\n        arg--;  /* do not count 'self' */\n        if (arg === 0)  /* error is in the self argument itself? */\n            return luaL_error(L, to_luastring(\"calling '%s' on bad self (%s)\"), ar.name, extramsg);\n    }\n\n    if (ar.name === null)\n        ar.name = pushglobalfuncname(L, ar) ? lua_tostring(L, -1) : to_luastring(\"?\");\n\n    return luaL_error(L, to_luastring(\"bad argument #%d to '%s' (%s)\"), arg, ar.name, extramsg);\n};\n\nconst typeerror = function(L, arg, tname) {\n    let typearg;\n    if (luaL_getmetafield(L, arg, __name) === LUA_TSTRING)\n        typearg = lua_tostring(L, -1);\n    else if (lua_type(L, arg) === LUA_TLIGHTUSERDATA)\n        typearg = to_luastring(\"light userdata\", true);\n    else\n        typearg = luaL_typename(L, arg);\n\n    let msg = lua_pushfstring(L, to_luastring(\"%s expected, got %s\"), tname, typearg);\n    return luaL_argerror(L, arg, msg);\n};\n\nconst luaL_where = function(L, level) {\n    let ar = new lua_Debug();\n    if (lua_getstack(L, level, ar)) {\n        lua_getinfo(L, to_luastring(\"Sl\", true), ar);\n        if (ar.currentline > 0) {\n            lua_pushfstring(L, to_luastring(\"%s:%d: \"), ar.short_src, ar.currentline);\n            return;\n        }\n    }\n    lua_pushstring(L, to_luastring(\"\"));\n};\n\nconst luaL_error = function(L, fmt, ...argp) {\n    luaL_where(L, 1);\n    lua_pushvfstring(L, fmt, argp);\n    lua_concat(L, 2);\n    return lua_error(L);\n};\n\n/* Unlike normal lua, we pass in an error object */\nconst luaL_fileresult = function(L, stat, fname, e) {\n    if (stat) {\n        lua_pushboolean(L, 1);\n        return 1;\n    } else {\n        lua_pushnil(L);\n        let message, errno;\n        if (e) {\n            message = e.message;\n            errno = -e.errno;\n        } else {\n            message = \"Success\"; /* what strerror(0) returns */\n            errno = 0;\n        }\n        if (fname)\n            lua_pushfstring(L, to_luastring(\"%s: %s\"), fname, to_luastring(message));\n        else\n            lua_pushstring(L, to_luastring(message));\n        lua_pushinteger(L, errno);\n        return 3;\n    }\n};\n\n/* Unlike normal lua, we pass in an error object */\nconst luaL_execresult = function(L, e) {\n    let what, stat;\n    if (e === null) {\n        lua_pushboolean(L, 1);\n        lua_pushliteral(L, \"exit\");\n        lua_pushinteger(L, 0);\n        return 3;\n    } else if (e.status) {\n        what = \"exit\";\n        stat = e.status;\n    } else if (e.signal) {\n        what = \"signal\";\n        stat = e.signal;\n    } else {\n        /* XXX: node seems to have e.errno as a string instead of a number */\n        return luaL_fileresult(L, 0, null, e);\n    }\n    lua_pushnil(L);\n    lua_pushliteral(L, what);\n    lua_pushinteger(L, stat);\n    return 3;\n};\n\nconst luaL_getmetatable = function(L, n) {\n    return lua_getfield(L, LUA_REGISTRYINDEX, n);\n};\n\nconst luaL_newmetatable = function(L, tname) {\n    if (luaL_getmetatable(L, tname) !== LUA_TNIL)  /* name already in use? */\n        return 0;  /* leave previous value on top, but return 0 */\n    lua_pop(L, 1);\n    lua_createtable(L, 0, 2);  /* create metatable */\n    lua_pushstring(L, tname);\n    lua_setfield(L, -2, __name);  /* metatable.__name = tname */\n    lua_pushvalue(L, -1);\n    lua_setfield(L, LUA_REGISTRYINDEX, tname);  /* registry.name = metatable */\n    return 1;\n\n};\n\nconst luaL_setmetatable = function(L, tname) {\n    luaL_getmetatable(L, tname);\n    lua_setmetatable(L, -2);\n};\n\nconst luaL_testudata = function(L, ud, tname) {\n    let p = lua_touserdata(L, ud);\n    if (p !== null) {  /* value is a userdata? */\n        if (lua_getmetatable(L, ud)) {  /* does it have a metatable? */\n            luaL_getmetatable(L, tname);  /* get correct metatable */\n            if (!lua_rawequal(L, -1, -2))  /* not the same? */\n                p = null;  /* value is a userdata with wrong metatable */\n            lua_pop(L, 2);  /* remove both metatables */\n            return p;\n        }\n    }\n    return null;  /* value is not a userdata with a metatable */\n};\n\nconst luaL_checkudata = function(L, ud, tname) {\n    let p = luaL_testudata(L, ud, tname);\n    if (p === null) typeerror(L, ud, tname);\n    return p;\n};\n\nconst luaL_checkoption = function(L, arg, def, lst) {\n    let name = def !== null ? luaL_optstring(L, arg, def) : luaL_checkstring(L, arg);\n    for (let i = 0; lst[i]; i++)\n        if (luastring_eq(lst[i], name))\n            return i;\n    return luaL_argerror(L, arg, lua_pushfstring(L, to_luastring(\"invalid option '%s'\"), name));\n};\n\nconst tag_error = function(L, arg, tag) {\n    typeerror(L, arg, lua_typename(L, tag));\n};\n\nconst luaL_newstate = function() {\n    let L = lua_newstate();\n    if (L) lua_atpanic(L, panic);\n    return L;\n};\n\n\nconst luaL_typename = function(L, i) {\n    return lua_typename(L, lua_type(L, i));\n};\n\nconst luaL_argcheck = function(L, cond, arg, extramsg) {\n    if (!cond) luaL_argerror(L, arg, extramsg);\n};\n\nconst luaL_checkany = function(L, arg) {\n    if (lua_type(L, arg) === LUA_TNONE)\n        luaL_argerror(L, arg, to_luastring(\"value expected\", true));\n};\n\nconst luaL_checktype = function(L, arg, t) {\n    if (lua_type(L, arg) !== t)\n        tag_error(L, arg, t);\n};\n\nconst luaL_checklstring = function(L, arg) {\n    let s = lua_tolstring(L, arg);\n    if (s === null || s === undefined) tag_error(L, arg, LUA_TSTRING);\n    return s;\n};\n\nconst luaL_checkstring = luaL_checklstring;\n\nconst luaL_optlstring = function(L, arg, def) {\n    if (lua_type(L, arg) <= 0) {\n        return def === null ? null : from_userstring(def);\n    } else return luaL_checklstring(L, arg);\n};\n\nconst luaL_optstring = luaL_optlstring;\n\nconst interror = function(L, arg) {\n    if (lua_isnumber(L, arg))\n        luaL_argerror(L, arg, to_luastring(\"number has no integer representation\", true));\n    else\n        tag_error(L, arg, LUA_TNUMBER);\n};\n\nconst luaL_checknumber = function(L, arg) {\n    let d = lua_tonumberx(L, arg);\n    if (d === false)\n        tag_error(L, arg, LUA_TNUMBER);\n    return d;\n};\n\nconst luaL_optnumber = function(L, arg, def) {\n    return luaL_opt(L, luaL_checknumber, arg, def);\n};\n\nconst luaL_checkinteger = function(L, arg) {\n    let d = lua_tointegerx(L, arg);\n    if (d === false)\n        interror(L, arg);\n    return d;\n};\n\nconst luaL_optinteger = function(L, arg, def) {\n    return luaL_opt(L, luaL_checkinteger, arg, def);\n};\n\nconst luaL_prepbuffsize = function(B, sz) {\n    let newend = B.n + sz;\n    if (B.b.length < newend) {\n        let newsize = Math.max(B.b.length * 2, newend);  /* double buffer size */\n        let newbuff = new Uint8Array(newsize);  /* create larger buffer */\n        newbuff.set(B.b);  /* copy original content */\n        B.b = newbuff;\n    }\n    return B.b.subarray(B.n, newend);\n};\n\nconst luaL_buffinit = function(L, B) {\n    B.L = L;\n    B.b = empty;\n};\n\nconst luaL_buffinitsize = function(L, B, sz) {\n    luaL_buffinit(L, B);\n    return luaL_prepbuffsize(B, sz);\n};\n\nconst luaL_prepbuffer = function(B) {\n    return luaL_prepbuffsize(B, LUAL_BUFFERSIZE);\n};\n\nconst luaL_addlstring = function(B, s, l) {\n    if (l > 0) {\n        s = from_userstring(s);\n        let b = luaL_prepbuffsize(B, l);\n        b.set(s.subarray(0, l));\n        luaL_addsize(B, l);\n    }\n};\n\nconst luaL_addstring = function(B, s) {\n    s = from_userstring(s);\n    luaL_addlstring(B, s, s.length);\n};\n\nconst luaL_pushresult = function(B) {\n    lua_pushlstring(B.L, B.b, B.n);\n    /* delete old buffer */\n    B.n = 0;\n    B.b = empty;\n};\n\nconst luaL_addchar = function(B, c) {\n    luaL_prepbuffsize(B, 1);\n    B.b[B.n++] = c;\n};\n\nconst luaL_addsize = function(B, s) {\n    B.n += s;\n};\n\nconst luaL_pushresultsize = function(B, sz) {\n    luaL_addsize(B, sz);\n    luaL_pushresult(B);\n};\n\nconst luaL_addvalue = function(B) {\n    let L = B.L;\n    let s = lua_tostring(L, -1);\n    luaL_addlstring(B, s, s.length);\n    lua_pop(L, 1);  /* remove value */\n};\n\nconst luaL_opt = function(L, f, n, d) {\n    return lua_type(L, n) <= 0 ? d : f(L, n);\n};\n\nconst getS = function(L, ud) {\n    let s = ud.string;\n    ud.string = null;\n    return s;\n};\n\nconst luaL_loadbufferx = function(L, buff, size, name, mode) {\n    return lua_load(L, getS, {string: buff}, name, mode);\n};\n\nconst luaL_loadbuffer = function(L, s, sz, n) {\n    return luaL_loadbufferx(L, s, sz, n, null);\n};\n\nconst luaL_loadstring = function(L, s) {\n    return luaL_loadbuffer(L, s, s.length, s);\n};\n\nconst luaL_dostring = function(L, s) {\n    return (luaL_loadstring(L, s) || lua_pcall(L, 0, LUA_MULTRET, 0));\n};\n\nconst luaL_getmetafield = function(L, obj, event) {\n    if (!lua_getmetatable(L, obj))  /* no metatable? */\n        return LUA_TNIL;\n    else {\n        lua_pushstring(L, event);\n        let tt = lua_rawget(L, -2);\n        if (tt === LUA_TNIL)  /* is metafield nil? */\n            lua_pop(L, 2);  /* remove metatable and metafield */\n        else\n            lua_remove(L, -2);  /* remove only metatable */\n        return tt;  /* return metafield type */\n    }\n};\n\nconst luaL_callmeta = function(L, obj, event) {\n    obj = lua_absindex(L, obj);\n    if (luaL_getmetafield(L, obj, event) === LUA_TNIL)\n        return false;\n\n    lua_pushvalue(L, obj);\n    lua_call(L, 1, 1);\n\n    return true;\n};\n\nconst luaL_len = function(L, idx) {\n    lua_len(L, idx);\n    let l = lua_tointegerx(L, -1);\n    if (l === false)\n        luaL_error(L, to_luastring(\"object length is not an integer\", true));\n    lua_pop(L, 1);  /* remove object */\n    return l;\n};\n\nconst p_I = to_luastring(\"%I\");\nconst p_f = to_luastring(\"%f\");\nconst luaL_tolstring = function(L, idx) {\n    if (luaL_callmeta(L, idx, __tostring)) {\n        if (!lua_isstring(L, -1))\n            luaL_error(L, to_luastring(\"'__tostring' must return a string\"));\n    } else {\n        let t = lua_type(L, idx);\n        switch(t) {\n            case LUA_TNUMBER: {\n                if (lua_isinteger(L, idx))\n                    lua_pushfstring(L, p_I, lua_tointeger(L, idx));\n                else\n                    lua_pushfstring(L, p_f, lua_tonumber(L, idx));\n                break;\n            }\n            case LUA_TSTRING:\n                lua_pushvalue(L, idx);\n                break;\n            case LUA_TBOOLEAN:\n                lua_pushliteral(L, (lua_toboolean(L, idx) ? \"true\" : \"false\"));\n                break;\n            case LUA_TNIL:\n                lua_pushliteral(L, \"nil\");\n                break;\n            default: {\n                let tt = luaL_getmetafield(L, idx, __name);\n                let kind = tt === LUA_TSTRING ? lua_tostring(L, -1) : luaL_typename(L, idx);\n                lua_pushfstring(L, to_luastring(\"%s: %p\"), kind, lua_topointer(L, idx));\n                if (tt !== LUA_TNIL)\n                    lua_remove(L, -2);\n                break;\n            }\n        }\n    }\n\n    return lua_tolstring(L, -1);\n};\n\n/*\n** Stripped-down 'require': After checking \"loaded\" table, calls 'openf'\n** to open a module, registers the result in 'package.loaded' table and,\n** if 'glb' is true, also registers the result in the global table.\n** Leaves resulting module on the top.\n*/\nconst luaL_requiref = function(L, modname, openf, glb) {\n    luaL_getsubtable(L, LUA_REGISTRYINDEX, LUA_LOADED_TABLE);\n    lua_getfield(L, -1, modname); /* LOADED[modname] */\n    if (!lua_toboolean(L, -1)) {  /* package not already loaded? */\n        lua_pop(L, 1);  /* remove field */\n        lua_pushcfunction(L, openf);\n        lua_pushstring(L, modname);  /* argument to open function */\n        lua_call(L, 1, 1);  /* call 'openf' to open module */\n        lua_pushvalue(L, -1);  /* make copy of module (call result) */\n        lua_setfield(L, -3, modname);  /* LOADED[modname] = module */\n    }\n    lua_remove(L, -2);  /* remove LOADED table */\n    if (glb) {\n        lua_pushvalue(L, -1);  /* copy of module */\n        lua_setglobal(L, modname);  /* _G[modname] = module */\n    }\n};\n\nconst find_subarray = function(arr, subarr, from_index) {\n    var i = from_index >>> 0,\n        sl = subarr.length,\n        l = arr.length + 1 - sl;\n\n    loop: for (; i < l; i++) {\n        for (let j = 0; j < sl; j++)\n            if (arr[i+j] !== subarr[j])\n                continue loop;\n        return i;\n    }\n    return -1;\n};\n\nconst luaL_gsub = function(L, s, p, r) {\n    let wild;\n    let b = new luaL_Buffer();\n    luaL_buffinit(L, b);\n    while ((wild = find_subarray(s, p)) >= 0) {\n        luaL_addlstring(b, s, wild);  /* push prefix */\n        luaL_addstring(b, r);  /* push replacement in place of pattern */\n        s = s.subarray(wild + p.length);  /* continue after 'p' */\n    }\n    luaL_addstring(b, s);  /* push last suffix */\n    luaL_pushresult(b);\n    return lua_tostring(L, -1);\n};\n\n/*\n** ensure that stack[idx][fname] has a table and push that table\n** into the stack\n*/\nconst luaL_getsubtable = function(L, idx, fname) {\n    if (lua_getfield(L, idx, fname) === LUA_TTABLE)\n        return true;  /* table already there */\n    else {\n        lua_pop(L, 1);  /* remove previous result */\n        idx = lua_absindex(L, idx);\n        lua_newtable(L);\n        lua_pushvalue(L, -1);  /* copy to be left at top */\n        lua_setfield(L, idx, fname);  /* assign new table to field */\n        return false;  /* false, because did not find table there */\n    }\n};\n\n/*\n** set functions from list 'l' into table at top - 'nup'; each\n** function gets the 'nup' elements at the top as upvalues.\n** Returns with only the table at the stack.\n*/\nconst luaL_setfuncs = function(L, l, nup) {\n    luaL_checkstack(L, nup, to_luastring(\"too many upvalues\", true));\n    for (let lib in l) {  /* fill the table with given functions */\n        for (let i = 0; i < nup; i++)  /* copy upvalues to the top */\n            lua_pushvalue(L, -nup);\n        lua_pushcclosure(L, l[lib], nup);  /* closure with those upvalues */\n        lua_setfield(L, -(nup + 2), to_luastring(lib));\n    }\n    lua_pop(L, nup);  /* remove upvalues */\n};\n\n/*\n** Ensures the stack has at least 'space' extra slots, raising an error\n** if it cannot fulfill the request. (The error handling needs a few\n** extra slots to format the error message. In case of an error without\n** this extra space, Lua will generate the same 'stack overflow' error,\n** but without 'msg'.)\n*/\nconst luaL_checkstack = function(L, space, msg) {\n    if (!lua_checkstack(L, space)) {\n        if (msg)\n            luaL_error(L, to_luastring(\"stack overflow (%s)\"), msg);\n        else\n            luaL_error(L, to_luastring('stack overflow', true));\n    }\n};\n\nconst luaL_newlibtable = function(L) {\n    lua_createtable(L);\n};\n\nconst luaL_newlib = function(L, l) {\n    lua_createtable(L);\n    luaL_setfuncs(L, l, 0);\n};\n\n/* predefined references */\nconst LUA_NOREF  = -2;\nconst LUA_REFNIL = -1;\n\nconst luaL_ref = function(L, t) {\n    let ref;\n    if (lua_isnil(L, -1)) {\n        lua_pop(L, 1);  /* remove from stack */\n        return LUA_REFNIL;  /* 'nil' has a unique fixed reference */\n    }\n    t = lua_absindex(L, t);\n    lua_rawgeti(L, t, 0);  /* get first free element */\n    ref = lua_tointeger(L, -1);  /* ref = t[freelist] */\n    lua_pop(L, 1);  /* remove it from stack */\n    if (ref !== 0) {  /* any free element? */\n        lua_rawgeti(L, t, ref);  /* remove it from list */\n        lua_rawseti(L, t, 0);  /* (t[freelist] = t[ref]) */\n    }\n    else  /* no free elements */\n        ref = lua_rawlen(L, t) + 1;  /* get a new reference */\n    lua_rawseti(L, t, ref);\n    return ref;\n};\n\n\nconst luaL_unref = function(L, t, ref) {\n    if (ref >= 0) {\n        t = lua_absindex(L, t);\n        lua_rawgeti(L, t, 0);\n        lua_rawseti(L, t, ref);  /* t[ref] = t[freelist] */\n        lua_pushinteger(L, ref);\n        lua_rawseti(L, t, 0);  /* t[freelist] = ref */\n    }\n};\n\n\nconst errfile = function(L, what, fnameindex, error) {\n    let serr = error.message;\n    let filename = lua_tostring(L, fnameindex).subarray(1);\n    lua_pushfstring(L, to_luastring(\"cannot %s %s: %s\"), to_luastring(what), filename, to_luastring(serr));\n    lua_remove(L, fnameindex);\n    return LUA_ERRFILE;\n};\n\nlet getc;\n\nconst utf8_bom = [0XEF, 0XBB, 0XBF];  /* UTF-8 BOM mark */\nconst skipBOM = function(lf) {\n    lf.n = 0;\n    let c;\n    let p = 0;\n    do {\n        c = getc(lf);\n        if (c === null || c !== utf8_bom[p]) return c;\n        p++;\n        lf.buff[lf.n++] = c;  /* to be read by the parser */\n    } while (p < utf8_bom.length);\n    lf.n = 0;  /* prefix matched; discard it */\n    return getc(lf);  /* return next character */\n};\n\n/*\n** reads the first character of file 'f' and skips an optional BOM mark\n** in its beginning plus its first line if it starts with '#'. Returns\n** true if it skipped the first line.  In any case, '*cp' has the\n** first \"valid\" character of the file (after the optional BOM and\n** a first-line comment).\n*/\nconst skipcomment = function(lf) {\n    let c = skipBOM(lf);\n    if (c === 35 /* '#'.charCodeAt(0) */) {  /* first line is a comment (Unix exec. file)? */\n        do {  /* skip first line */\n            c = getc(lf);\n        } while (c && c !== 10 /* '\\n'.charCodeAt(0) */);\n\n        return {\n            skipped: true,\n            c: getc(lf)  /* skip end-of-line, if present */\n        };\n    } else {\n        return {\n            skipped: false,\n            c: c\n        };\n    }\n};\n\nlet luaL_loadfilex;\n\nif (typeof process === \"undefined\") {\n    class LoadF {\n        constructor() {\n            this.n = NaN;  /* number of pre-read characters */\n            this.f = null;  /* file being read */\n            this.buff = new Uint8Array(1024);  /* area for reading file */\n            this.pos = 0;  /* current position in file */\n            this.err = void 0;\n        }\n    }\n\n    const getF = function(L, ud) {\n        let lf = ud;\n\n        if (lf.f !== null && lf.n > 0) {  /* are there pre-read characters to be read? */\n            let bytes = lf.n; /* return them (chars already in buffer) */\n            lf.n = 0;  /* no more pre-read characters */\n            lf.f = lf.f.subarray(lf.pos);  /* we won't use lf.buff anymore */\n            return lf.buff.subarray(0, bytes);\n        }\n\n        let f = lf.f;\n        lf.f = null;\n        return f;\n    };\n\n    getc = function(lf) {\n        return lf.pos < lf.f.length ? lf.f[lf.pos++] : null;\n    };\n\n    luaL_loadfilex = function(L, filename, mode) {\n        let lf = new LoadF();\n        let fnameindex = lua_gettop(L) + 1;  /* index of filename on the stack */\n        if (filename === null) {\n            throw new Error(\"Can't read stdin in the browser\");\n        } else {\n            lua_pushfstring(L, to_luastring(\"@%s\"), filename);\n            let path = to_uristring(filename);\n            let xhr = new XMLHttpRequest();\n            xhr.open(\"GET\", path, false);\n            /*\n            Synchronous xhr in main thread always returns a js string.\n            Some browsers make console noise if you even attempt to set responseType\n            */\n            if (typeof window === \"undefined\") {\n                xhr.responseType = \"arraybuffer\";\n            }\n            xhr.send();\n            if (xhr.status >= 200 && xhr.status <= 299) {\n                if (typeof xhr.response === \"string\") {\n                    lf.f = to_luastring(xhr.response);\n                } else {\n                    lf.f = new Uint8Array(xhr.response);\n                }\n            } else {\n                lf.err = xhr.status;\n                return errfile(L, \"open\", fnameindex, { message: `${xhr.status}: ${xhr.statusText}` });\n            }\n        }\n        let com = skipcomment(lf);\n        /* check for signature first, as we don't want to add line number corrections in binary case */\n        if (com.c === LUA_SIGNATURE[0] && filename) {  /* binary file? */\n            /* no need to re-open */\n        } else if (com.skipped) { /* read initial portion */\n            lf.buff[lf.n++] = 10 /* '\\n'.charCodeAt(0) */;  /* add line to correct line numbers */\n        }\n        if (com.c !== null)\n            lf.buff[lf.n++] = com.c; /* 'c' is the first character of the stream */\n        let status = lua_load(L, getF, lf, lua_tostring(L, -1), mode);\n        let readstatus = lf.err;\n        if (readstatus) {\n            lua_settop(L, fnameindex);  /* ignore results from 'lua_load' */\n            return errfile(L, \"read\", fnameindex, readstatus);\n        }\n        lua_remove(L, fnameindex);\n        return status;\n    };\n} else {\n    const fs = require('fs');\n\n    class LoadF {\n        constructor() {\n            this.n = NaN;  /* number of pre-read characters */\n            this.f = null;  /* file being read */\n            this.buff = Buffer.alloc(1024);  /* area for reading file */\n            this.pos = 0;  /* current position in file */\n            this.err = void 0;\n        }\n    }\n\n    const getF = function(L, ud) {\n        let lf = ud;\n        let bytes = 0;\n        if (lf.n > 0) {  /* are there pre-read characters to be read? */\n            bytes = lf.n; /* return them (chars already in buffer) */\n            lf.n = 0;  /* no more pre-read characters */\n        } else {  /* read a block from file */\n            try {\n                bytes = fs.readSync(lf.f, lf.buff, 0, lf.buff.length, lf.pos); /* read block */\n            } catch(e) {\n                lf.err = e;\n                bytes = 0;\n            }\n            lf.pos += bytes;\n        }\n        if (bytes > 0)\n            return lf.buff.subarray(0, bytes);\n        else return null;\n    };\n\n    getc = function(lf) {\n        let b = Buffer.alloc(1);\n        let bytes;\n        try {\n            bytes = fs.readSync(lf.f, b, 0, 1, lf.pos);\n        } catch(e) {\n            lf.err = e;\n            return null;\n        }\n        lf.pos += bytes;\n        return bytes > 0 ? b.readUInt8() : null;\n    };\n\n    luaL_loadfilex = function(L, filename, mode) {\n        let lf = new LoadF();\n        let fnameindex = lua_gettop(L) + 1;  /* index of filename on the stack */\n        if (filename === null) {\n            lua_pushliteral(L, \"=stdin\");\n            lf.f = process.stdin.fd;\n        } else {\n            lua_pushfstring(L, to_luastring(\"@%s\"), filename);\n            try {\n                lf.f = fs.openSync(filename, \"r\");\n            } catch (e) {\n                return errfile(L, \"open\", fnameindex, e);\n            }\n        }\n        let com = skipcomment(lf);\n        /* check for signature first, as we don't want to add line number corrections in binary case */\n        if (com.c === LUA_SIGNATURE[0] && filename) {  /* binary file? */\n            /* no need to re-open */\n        } else if (com.skipped) { /* read initial portion */\n            lf.buff[lf.n++] = 10 /* '\\n'.charCodeAt(0) */;  /* add line to correct line numbers */\n        }\n        if (com.c !== null)\n            lf.buff[lf.n++] = com.c; /* 'c' is the first character of the stream */\n        let status = lua_load(L, getF, lf, lua_tostring(L, -1), mode);\n        let readstatus = lf.err;\n        if (filename) try { fs.closeSync(lf.f); } catch(e) {}  /* close file (even in case of errors) */\n        if (readstatus) {\n            lua_settop(L, fnameindex);  /* ignore results from 'lua_load' */\n            return errfile(L, \"read\", fnameindex, readstatus);\n        }\n        lua_remove(L, fnameindex);\n        return status;\n    };\n}\n\nconst luaL_loadfile = function(L, filename) {\n    return luaL_loadfilex(L, filename, null);\n};\n\nconst luaL_dofile = function(L, filename) {\n    return (luaL_loadfile(L, filename) || lua_pcall(L, 0, LUA_MULTRET, 0));\n};\n\nconst lua_writestringerror = function() {\n    for (let i=0; i<arguments.length; i++) {\n        let a = arguments[i];\n        if (typeof process === \"undefined\") {\n            /* split along new lines for separate console.error invocations */\n            do {\n                /* regexp uses [\\d\\D] to work around matching new lines\n                   the 's' flag is non-standard */\n                let r = /([^\\n]*)\\n?([\\d\\D]*)/.exec(a);\n                console.error(r[1]);\n                a = r[2];\n            } while (a !== \"\");\n        } else {\n            process.stderr.write(a);\n        }\n    }\n};\n\nconst luaL_checkversion_ = function(L, ver, sz) {\n    let v = lua_version(L);\n    if (sz != LUAL_NUMSIZES)  /* check numeric types */\n        luaL_error(L, to_luastring(\"core and library have incompatible numeric types\"));\n    if (v != lua_version(null))\n        luaL_error(L, to_luastring(\"multiple Lua VMs detected\"));\n    else if (v !== ver)\n        luaL_error(L, to_luastring(\"version mismatch: app. needs %f, Lua core provides %f\"), ver, v);\n};\n\n/* There is no point in providing this function... */\nconst luaL_checkversion = function(L) {\n    luaL_checkversion_(L, LUA_VERSION_NUM, LUAL_NUMSIZES);\n};\n\nmodule.exports.LUA_ERRFILE          = LUA_ERRFILE;\nmodule.exports.LUA_FILEHANDLE       = LUA_FILEHANDLE;\nmodule.exports.LUA_LOADED_TABLE     = LUA_LOADED_TABLE;\nmodule.exports.LUA_NOREF            = LUA_NOREF;\nmodule.exports.LUA_PRELOAD_TABLE    = LUA_PRELOAD_TABLE;\nmodule.exports.LUA_REFNIL           = LUA_REFNIL;\nmodule.exports.luaL_Buffer          = luaL_Buffer;\nmodule.exports.luaL_addchar         = luaL_addchar;\nmodule.exports.luaL_addlstring      = luaL_addlstring;\nmodule.exports.luaL_addsize         = luaL_addsize;\nmodule.exports.luaL_addstring       = luaL_addstring;\nmodule.exports.luaL_addvalue        = luaL_addvalue;\nmodule.exports.luaL_argcheck        = luaL_argcheck;\nmodule.exports.luaL_argerror        = luaL_argerror;\nmodule.exports.luaL_buffinit        = luaL_buffinit;\nmodule.exports.luaL_buffinitsize    = luaL_buffinitsize;\nmodule.exports.luaL_callmeta        = luaL_callmeta;\nmodule.exports.luaL_checkany        = luaL_checkany;\nmodule.exports.luaL_checkinteger    = luaL_checkinteger;\nmodule.exports.luaL_checklstring    = luaL_checklstring;\nmodule.exports.luaL_checknumber     = luaL_checknumber;\nmodule.exports.luaL_checkoption     = luaL_checkoption;\nmodule.exports.luaL_checkstack      = luaL_checkstack;\nmodule.exports.luaL_checkstring     = luaL_checkstring;\nmodule.exports.luaL_checktype       = luaL_checktype;\nmodule.exports.luaL_checkudata      = luaL_checkudata;\nmodule.exports.luaL_checkversion    = luaL_checkversion;\nmodule.exports.luaL_checkversion_   = luaL_checkversion_;\nmodule.exports.luaL_dofile          = luaL_dofile;\nmodule.exports.luaL_dostring        = luaL_dostring;\nmodule.exports.luaL_error           = luaL_error;\nmodule.exports.luaL_execresult      = luaL_execresult;\nmodule.exports.luaL_fileresult      = luaL_fileresult;\nmodule.exports.luaL_getmetafield    = luaL_getmetafield;\nmodule.exports.luaL_getmetatable    = luaL_getmetatable;\nmodule.exports.luaL_getsubtable     = luaL_getsubtable;\nmodule.exports.luaL_gsub            = luaL_gsub;\nmodule.exports.luaL_len             = luaL_len;\nmodule.exports.luaL_loadbuffer      = luaL_loadbuffer;\nmodule.exports.luaL_loadbufferx     = luaL_loadbufferx;\nmodule.exports.luaL_loadfile        = luaL_loadfile;\nmodule.exports.luaL_loadfilex       = luaL_loadfilex;\nmodule.exports.luaL_loadstring      = luaL_loadstring;\nmodule.exports.luaL_newlib          = luaL_newlib;\nmodule.exports.luaL_newlibtable     = luaL_newlibtable;\nmodule.exports.luaL_newmetatable    = luaL_newmetatable;\nmodule.exports.luaL_newstate        = luaL_newstate;\nmodule.exports.luaL_opt             = luaL_opt;\nmodule.exports.luaL_optinteger      = luaL_optinteger;\nmodule.exports.luaL_optlstring      = luaL_optlstring;\nmodule.exports.luaL_optnumber       = luaL_optnumber;\nmodule.exports.luaL_optstring       = luaL_optstring;\nmodule.exports.luaL_prepbuffer      = luaL_prepbuffer;\nmodule.exports.luaL_prepbuffsize    = luaL_prepbuffsize;\nmodule.exports.luaL_pushresult      = luaL_pushresult;\nmodule.exports.luaL_pushresultsize  = luaL_pushresultsize;\nmodule.exports.luaL_ref             = luaL_ref;\nmodule.exports.luaL_requiref        = luaL_requiref;\nmodule.exports.luaL_setfuncs        = luaL_setfuncs;\nmodule.exports.luaL_setmetatable    = luaL_setmetatable;\nmodule.exports.luaL_testudata       = luaL_testudata;\nmodule.exports.luaL_tolstring       = luaL_tolstring;\nmodule.exports.luaL_traceback       = luaL_traceback;\nmodule.exports.luaL_typename        = luaL_typename;\nmodule.exports.luaL_unref           = luaL_unref;\nmodule.exports.luaL_where           = luaL_where;\nmodule.exports.lua_writestringerror = lua_writestringerror;\n", ";\n\nconst {\n    LUA_MULTRET,\n    LUA_OK,\n    LUA_TFUNCTION,\n    LUA_TNIL,\n    LUA_TNONE,\n    LUA_TNUMBER,\n    LUA_TSTRING,\n    LUA_TTABLE,\n    LUA_VERSION,\n    LUA_YIELD,\n    lua_call,\n    lua_callk,\n    lua_concat,\n    lua_error,\n    lua_getglobal,\n    lua_geti,\n    lua_getmetatable,\n    lua_gettop,\n    lua_insert,\n    lua_isnil,\n    lua_isnone,\n    lua_isstring,\n    lua_load,\n    lua_next,\n    lua_pcallk,\n    lua_pop,\n    lua_pushboolean,\n    lua_pushcfunction,\n    lua_pushglobaltable,\n    lua_pushinteger,\n    lua_pushliteral,\n    lua_pushnil,\n    lua_pushstring,\n    lua_pushvalue,\n    lua_rawequal,\n    lua_rawget,\n    lua_rawlen,\n    lua_rawset,\n    lua_remove,\n    lua_replace,\n    lua_rotate,\n    lua_setfield,\n    lua_setmetatable,\n    lua_settop,\n    lua_setupvalue,\n    lua_stringtonumber,\n    lua_toboolean,\n    lua_tolstring,\n    lua_tostring,\n    lua_type,\n    lua_typename\n} = require('./lua.js');\nconst {\n    luaL_argcheck,\n    luaL_checkany,\n    luaL_checkinteger,\n    luaL_checkoption,\n    luaL_checkstack,\n    luaL_checktype,\n    luaL_error,\n    luaL_getmetafield,\n    luaL_loadbufferx,\n    luaL_loadfile,\n    luaL_loadfilex,\n    luaL_optinteger,\n    luaL_optstring,\n    luaL_setfuncs,\n    luaL_tolstring,\n    luaL_where\n} = require('./lauxlib.js');\nconst {\n    to_jsstring,\n    to_luastring\n} = require(\"./fengaricore.js\");\n\nlet lua_writestring;\nlet lua_writeline;\nif (typeof process === \"undefined\") {\n    if (typeof TextDecoder === \"function\") { /* Older browsers don't have TextDecoder */\n        let buff = \"\";\n        let decoder = new TextDecoder(\"utf-8\");\n        lua_writestring = function(s) {\n            buff += decoder.decode(s, {stream: true});\n        };\n        let empty = new Uint8Array(0);\n        lua_writeline = function() {\n            buff += decoder.decode(empty);\n            console.log(buff);\n            buff = \"\";\n        };\n    } else {\n        let buff = [];\n        lua_writestring = function(s) {\n            try {\n                /* If the string is valid utf8, then we can use to_jsstring */\n                s = to_jsstring(s);\n            } catch(e) {\n                /* otherwise push copy of raw array */\n                let copy = new Uint8Array(s.length);\n                copy.set(s);\n                s = copy;\n            }\n            buff.push(s);\n        };\n        lua_writeline = function() {\n            console.log.apply(console.log, buff);\n            buff = [];\n        };\n    }\n} else {\n    lua_writestring = function(s) {\n        process.stdout.write(Buffer.from(s));\n    };\n    lua_writeline = function() {\n        process.stdout.write(\"\\n\");\n    };\n}\nconst luaB_print = function(L) {\n    let n = lua_gettop(L); /* number of arguments */\n    lua_getglobal(L, to_luastring(\"tostring\", true));\n    for (let i = 1; i <= n; i++) {\n        lua_pushvalue(L, -1);  /* function to be called */\n        lua_pushvalue(L, i);  /* value to print */\n        lua_call(L, 1, 1);\n        let s = lua_tolstring(L, -1);\n        if (s === null)\n            return luaL_error(L, to_luastring(\"'tostring' must return a string to 'print'\"));\n        if (i > 1) lua_writestring(to_luastring(\"\\t\"));\n        lua_writestring(s);\n        lua_pop(L, 1);\n    }\n    lua_writeline();\n    return 0;\n};\n\nconst luaB_tostring = function(L) {\n    luaL_checkany(L, 1);\n    luaL_tolstring(L, 1);\n\n    return 1;\n};\n\nconst luaB_getmetatable = function(L) {\n    luaL_checkany(L, 1);\n    if (!lua_getmetatable(L, 1)) {\n        lua_pushnil(L);\n        return 1;  /* no metatable */\n    }\n    luaL_getmetafield(L, 1, to_luastring(\"__metatable\", true));\n    return 1;  /* returns either __metatable field (if present) or metatable */\n};\n\nconst luaB_setmetatable = function(L) {\n    let t = lua_type(L, 2);\n    luaL_checktype(L, 1, LUA_TTABLE);\n    luaL_argcheck(L, t === LUA_TNIL || t === LUA_TTABLE, 2, \"nil or table expected\");\n    if (luaL_getmetafield(L, 1, to_luastring(\"__metatable\", true)) !== LUA_TNIL)\n        return luaL_error(L, to_luastring(\"cannot change a protected metatable\"));\n    lua_settop(L, 2);\n    lua_setmetatable(L, 1);\n    return 1;\n};\n\nconst luaB_rawequal = function(L) {\n    luaL_checkany(L, 1);\n    luaL_checkany(L, 2);\n    lua_pushboolean(L, lua_rawequal(L, 1, 2));\n    return 1;\n};\n\nconst luaB_rawlen = function(L) {\n    let t = lua_type(L, 1);\n    luaL_argcheck(L, t === LUA_TTABLE || t === LUA_TSTRING, 1, \"table or string expected\");\n    lua_pushinteger(L, lua_rawlen(L, 1));\n    return 1;\n};\n\nconst luaB_rawget = function(L) {\n    luaL_checktype(L, 1, LUA_TTABLE);\n    luaL_checkany(L, 2);\n    lua_settop(L, 2);\n    lua_rawget(L, 1);\n    return 1;\n};\n\nconst luaB_rawset = function(L) {\n    luaL_checktype(L, 1, LUA_TTABLE);\n    luaL_checkany(L, 2);\n    luaL_checkany(L, 3);\n    lua_settop(L, 3);\n    lua_rawset(L, 1);\n    return 1;\n};\n\nconst opts = [\n    \"stop\", \"restart\", \"collect\",\n    \"count\", \"step\", \"setpause\", \"setstepmul\",\n    \"isrunning\"\n].map((e) => to_luastring(e));\nconst luaB_collectgarbage = function(L) {\n    luaL_checkoption(L, 1, \"collect\", opts);\n    luaL_optinteger(L, 2, 0);\n    luaL_error(L, to_luastring(\"lua_gc not implemented\"));\n};\n\nconst luaB_type = function(L) {\n    let t = lua_type(L, 1);\n    luaL_argcheck(L, t !== LUA_TNONE, 1, \"value expected\");\n    lua_pushstring(L, lua_typename(L, t));\n    return 1;\n};\n\nconst pairsmeta = function(L, method, iszero, iter) {\n    luaL_checkany(L, 1);\n    if (luaL_getmetafield(L, 1, method) === LUA_TNIL) {  /* no metamethod? */\n        lua_pushcfunction(L, iter);  /* will return generator, */\n        lua_pushvalue(L, 1);  /* state, */\n        if (iszero) lua_pushinteger(L, 0);  /* and initial value */\n        else lua_pushnil(L);\n    } else {\n        lua_pushvalue(L, 1);  /* argument 'self' to metamethod */\n        lua_call(L, 1, 3);  /* get 3 values from metamethod */\n    }\n    return 3;\n};\n\nconst luaB_next = function(L) {\n    luaL_checktype(L, 1, LUA_TTABLE);\n    lua_settop(L, 2);  /* create a 2nd argument if there isn't one */\n    if (lua_next(L, 1))\n        return 2;\n    else {\n        lua_pushnil(L);\n        return 1;\n    }\n};\n\nconst luaB_pairs = function(L) {\n    return pairsmeta(L, to_luastring(\"__pairs\", true), 0, luaB_next);\n};\n\n/*\n** Traversal function for 'ipairs'\n*/\nconst ipairsaux = function(L) {\n    let i = luaL_checkinteger(L, 2) + 1;\n    lua_pushinteger(L, i);\n    return lua_geti(L, 1, i) === LUA_TNIL ? 1 : 2;\n};\n\n/*\n** 'ipairs' function. Returns 'ipairsaux', given \"table\", 0.\n** (The given \"table\" may not be a table.)\n*/\nconst luaB_ipairs = function(L) {\n    // Lua 5.2\n    // return pairsmeta(L, \"__ipairs\", 1, ipairsaux);\n\n    luaL_checkany(L, 1);\n    lua_pushcfunction(L, ipairsaux);  /* iteration function */\n    lua_pushvalue(L, 1);  /* state */\n    lua_pushinteger(L, 0);  /* initial value */\n    return 3;\n};\n\nconst b_str2int = function(s, base) {\n    try {\n        s = to_jsstring(s);\n    } catch (e) {\n        return null;\n    }\n    let r = /^[\\t\\v\\f \\n\\r]*([+-]?)0*([0-9A-Za-z]+)[\\t\\v\\f \\n\\r]*$/.exec(s);\n    if (!r) return null;\n    let v = parseInt(r[1]+r[2], base);\n    if (isNaN(v)) return null;\n    return v|0;\n};\n\nconst luaB_tonumber = function(L) {\n    if (lua_type(L, 2) <= 0) {  /* standard conversion? */\n        luaL_checkany(L, 1);\n        if (lua_type(L, 1) === LUA_TNUMBER) {  /* already a number? */\n            lua_settop(L, 1);\n            return 1;\n        } else {\n            let s = lua_tostring(L, 1);\n            if (s !== null && lua_stringtonumber(L, s) === s.length+1)\n                return 1;  /* successful conversion to number */\n        }\n    } else {\n        let base = luaL_checkinteger(L, 2);\n        luaL_checktype(L, 1, LUA_TSTRING);  /* no numbers as strings */\n        let s = lua_tostring(L, 1);\n        luaL_argcheck(L, 2 <= base && base <= 36, 2, \"base out of range\");\n        let n = b_str2int(s, base);\n        if (n !== null) {\n            lua_pushinteger(L, n);\n            return 1;\n        }\n    }\n\n    lua_pushnil(L);\n    return 1;\n};\n\nconst luaB_error = function(L) {\n    let level = luaL_optinteger(L, 2, 1);\n    lua_settop(L, 1);\n    if (lua_type(L, 1) === LUA_TSTRING && level > 0) {\n        luaL_where(L, level);  /* add extra information */\n        lua_pushvalue(L, 1);\n        lua_concat(L, 2);\n    }\n    return lua_error(L);\n};\n\nconst luaB_assert = function(L) {\n    if (lua_toboolean(L, 1))  /* condition is true? */\n        return lua_gettop(L);  /* return all arguments */\n    else {\n        luaL_checkany(L, 1);  /* there must be a condition */\n        lua_remove(L, 1);  /* remove it */\n        lua_pushliteral(L, \"assertion failed!\");  /* default message */\n        lua_settop(L, 1);  /* leave only message (default if no other one) */\n        return luaB_error(L);  /* call 'error' */\n    }\n};\n\nconst luaB_select = function(L) {\n    let n = lua_gettop(L);\n    if (lua_type(L, 1) === LUA_TSTRING && lua_tostring(L, 1)[0] === 35 /* '#'.charCodeAt(0) */) {\n        lua_pushinteger(L, n - 1);\n        return 1;\n    } else {\n        let i = luaL_checkinteger(L, 1);\n        if (i < 0) i = n + i;\n        else if (i > n) i = n;\n        luaL_argcheck(L, 1 <= i, 1, \"index out of range\");\n        return n - i;\n    }\n};\n\n/*\n** Continuation function for 'pcall' and 'xpcall'. Both functions\n** already pushed a 'true' before doing the call, so in case of success\n** 'finishpcall' only has to return everything in the stack minus\n** 'extra' values (where 'extra' is exactly the number of items to be\n** ignored).\n*/\nconst finishpcall = function(L, status, extra) {\n    if (status !== LUA_OK && status !== LUA_YIELD) {  /* error? */\n        lua_pushboolean(L, 0);  /* first result (false) */\n        lua_pushvalue(L, -2);  /* error message */\n        return 2;  /* return false, msg */\n    } else\n        return lua_gettop(L) - extra;\n};\n\nconst luaB_pcall = function(L) {\n    luaL_checkany(L, 1);\n    lua_pushboolean(L, 1);  /* first result if no errors */\n    lua_insert(L, 1);  /* put it in place */\n    let status = lua_pcallk(L, lua_gettop(L) - 2, LUA_MULTRET, 0, 0, finishpcall);\n    return finishpcall(L, status, 0);\n};\n\n/*\n** Do a protected call with error handling. After 'lua_rotate', the\n** stack will have <f, err, true, f, [args...]>; so, the function passes\n** 2 to 'finishpcall' to skip the 2 first values when returning results.\n*/\nconst luaB_xpcall = function(L) {\n    let n = lua_gettop(L);\n    luaL_checktype(L, 2, LUA_TFUNCTION);  /* check error function */\n    lua_pushboolean(L, 1);  /* first result */\n    lua_pushvalue(L, 1);  /* function */\n    lua_rotate(L, 3, 2);  /* move them below function's arguments */\n    let status = lua_pcallk(L, n - 2, LUA_MULTRET, 2, 2, finishpcall);\n    return finishpcall(L, status, 2);\n};\n\nconst load_aux = function(L, status, envidx) {\n    if (status === LUA_OK) {\n        if (envidx !== 0) {  /* 'env' parameter? */\n            lua_pushvalue(L, envidx);  /* environment for loaded function */\n            if (!lua_setupvalue(L, -2, 1))  /* set it as 1st upvalue */\n                lua_pop(L, 1);  /* remove 'env' if not used by previous call */\n        }\n        return 1;\n    } else {  /* error (message is on top of the stack) */\n        lua_pushnil(L);\n        lua_insert(L, -2);  /* put before error message */\n        return 2;  /* return nil plus error message */\n    }\n};\n\n/*\n** reserved slot, above all arguments, to hold a copy of the returned\n** string to avoid it being collected while parsed. 'load' has four\n** optional arguments (chunk, source name, mode, and environment).\n*/\nconst RESERVEDSLOT = 5;\n\n/*\n** Reader for generic 'load' function: 'lua_load' uses the\n** stack for internal stuff, so the reader cannot change the\n** stack top. Instead, it keeps its resulting string in a\n** reserved slot inside the stack.\n*/\nconst generic_reader = function(L, ud) {\n    luaL_checkstack(L, 2, \"too many nested functions\");\n    lua_pushvalue(L, 1);  /* get function */\n    lua_call(L, 0, 1);  /* call it */\n    if (lua_isnil(L, -1)) {\n        lua_pop(L, 1);  /* pop result */\n        return null;\n    } else if (!lua_isstring(L, -1))\n        luaL_error(L, to_luastring(\"reader function must return a string\"));\n    lua_replace(L, RESERVEDSLOT);  /* save string in reserved slot */\n    return lua_tostring(L, RESERVEDSLOT);\n};\n\nconst luaB_load = function(L) {\n    let s = lua_tostring(L, 1);\n    let mode = luaL_optstring(L, 3, \"bt\");\n    let env = !lua_isnone(L, 4) ? 4 : 0;  /* 'env' index or 0 if no 'env' */\n    let status;\n    if (s !== null) {  /* loading a string? */\n        let chunkname = luaL_optstring(L, 2, s);\n        status = luaL_loadbufferx(L, s, s.length, chunkname, mode);\n    } else {  /* loading from a reader function */\n        let chunkname = luaL_optstring(L, 2, \"=(load)\");\n        luaL_checktype(L, 1, LUA_TFUNCTION);\n        lua_settop(L, RESERVEDSLOT);  /* create reserved slot */\n        status = lua_load(L, generic_reader, null, chunkname, mode);\n    }\n    return load_aux(L, status, env);\n};\n\nconst luaB_loadfile = function(L) {\n    let fname = luaL_optstring(L, 1, null);\n    let mode = luaL_optstring(L, 2, null);\n    let env = !lua_isnone(L, 3) ? 3 : 0;  /* 'env' index or 0 if no 'env' */\n    let status = luaL_loadfilex(L, fname, mode);\n    return load_aux(L, status, env);\n};\n\nconst dofilecont = function(L, d1, d2) {\n    return lua_gettop(L) - 1;\n};\n\nconst luaB_dofile = function(L) {\n    let fname = luaL_optstring(L, 1, null);\n    lua_settop(L, 1);\n    if (luaL_loadfile(L, fname) !== LUA_OK)\n        return lua_error(L);\n    lua_callk(L, 0, LUA_MULTRET, 0, dofilecont);\n    return dofilecont(L, 0, 0);\n};\n\nconst base_funcs = {\n    \"assert\":         luaB_assert,\n    \"collectgarbage\": luaB_collectgarbage,\n    \"dofile\":         luaB_dofile,\n    \"error\":          luaB_error,\n    \"getmetatable\":   luaB_getmetatable,\n    \"ipairs\":         luaB_ipairs,\n    \"load\":           luaB_load,\n    \"loadfile\":       luaB_loadfile,\n    \"next\":           luaB_next,\n    \"pairs\":          luaB_pairs,\n    \"pcall\":          luaB_pcall,\n    \"print\":          luaB_print,\n    \"rawequal\":       luaB_rawequal,\n    \"rawget\":         luaB_rawget,\n    \"rawlen\":         luaB_rawlen,\n    \"rawset\":         luaB_rawset,\n    \"select\":         luaB_select,\n    \"setmetatable\":   luaB_setmetatable,\n    \"tonumber\":       luaB_tonumber,\n    \"tostring\":       luaB_tostring,\n    \"type\":           luaB_type,\n    \"xpcall\":         luaB_xpcall\n};\n\nconst luaopen_base = function(L) {\n    /* open lib into global table */\n    lua_pushglobaltable(L);\n    luaL_setfuncs(L, base_funcs, 0);\n    /* set global _G */\n    lua_pushvalue(L, -1);\n    lua_setfield(L, -2, to_luastring(\"_G\"));\n    /* set global _VERSION */\n    lua_pushliteral(L, LUA_VERSION);\n    lua_setfield(L, -2, to_luastring(\"_VERSION\"));\n    return 1;\n};\n\nmodule.exports.luaopen_base = luaopen_base;\n", ";\n\nconst {\n    LUA_OK,\n    LUA_TFUNCTION,\n    LUA_TSTRING,\n    LUA_YIELD,\n    lua_Debug,\n    lua_checkstack,\n    lua_concat,\n    lua_error,\n    lua_getstack,\n    lua_gettop,\n    lua_insert,\n    lua_isyieldable,\n    lua_newthread,\n    lua_pop,\n    lua_pushboolean,\n    lua_pushcclosure,\n    lua_pushliteral,\n    lua_pushthread,\n    lua_pushvalue,\n    lua_resume,\n    lua_status,\n    lua_tothread,\n    lua_type,\n    lua_upvalueindex,\n    lua_xmove,\n    lua_yield\n} = require('./lua.js');\nconst {\n    luaL_argcheck,\n    luaL_checktype,\n    luaL_newlib,\n    luaL_where\n} = require('./lauxlib.js');\n\nconst getco = function(L) {\n    let co = lua_tothread(L, 1);\n    luaL_argcheck(L, co, 1, \"thread expected\");\n    return co;\n};\n\nconst auxresume = function(L, co, narg) {\n    if (!lua_checkstack(co, narg)) {\n        lua_pushliteral(L, \"too many arguments to resume\");\n        return -1;  /* error flag */\n    }\n\n    if (lua_status(co) === LUA_OK && lua_gettop(co) === 0) {\n        lua_pushliteral(L, \"cannot resume dead coroutine\");\n        return -1;  /* error flag */\n    }\n\n    lua_xmove(L, co, narg);\n    let status = lua_resume(co, L, narg);\n    if (status === LUA_OK || status === LUA_YIELD) {\n        let nres = lua_gettop(co);\n        if (!lua_checkstack(L, nres + 1)) {\n            lua_pop(co, nres);  /* remove results anyway */\n            lua_pushliteral(L, \"too many results to resume\");\n            return -1;  /* error flag */\n        }\n\n        lua_xmove(co,  L, nres);  /* move yielded values */\n        return nres;\n    } else {\n        lua_xmove(co, L, 1);  /* move error message */\n        return -1;  /* error flag */\n    }\n};\n\nconst luaB_coresume = function(L) {\n    let co = getco(L);\n    let r = auxresume(L, co, lua_gettop(L) - 1);\n    if (r < 0) {\n        lua_pushboolean(L, 0);\n        lua_insert(L, -2);\n        return 2;  /* return false + error message */\n    } else {\n        lua_pushboolean(L, 1);\n        lua_insert(L, -(r + 1));\n        return r + 1;  /* return true + 'resume' returns */\n    }\n};\n\nconst luaB_auxwrap = function(L) {\n    let co = lua_tothread(L, lua_upvalueindex(1));\n    let r = auxresume(L, co, lua_gettop(L));\n    if (r < 0) {\n        if (lua_type(L, -1) === LUA_TSTRING) {  /* error object is a string? */\n            luaL_where(L, 1);  /* add extra info */\n            lua_insert(L, -2);\n            lua_concat(L, 2);\n        }\n\n        return lua_error(L);  /* propagate error */\n    }\n\n    return r;\n};\n\nconst luaB_cocreate = function(L) {\n    luaL_checktype(L, 1, LUA_TFUNCTION);\n    let NL = lua_newthread(L);\n    lua_pushvalue(L, 1);  /* move function to top */\n    lua_xmove(L, NL, 1);  /* move function from L to NL */\n    return 1;\n};\n\nconst luaB_cowrap = function(L) {\n    luaB_cocreate(L);\n    lua_pushcclosure(L, luaB_auxwrap, 1);\n    return 1;\n};\n\nconst luaB_yield = function(L) {\n    return lua_yield(L, lua_gettop(L));\n};\n\nconst luaB_costatus = function(L) {\n    let co = getco(L);\n    if (L === co) lua_pushliteral(L, \"running\");\n    else {\n        switch (lua_status(co)) {\n            case LUA_YIELD:\n                lua_pushliteral(L, \"suspended\");\n                break;\n            case LUA_OK: {\n                let ar = new lua_Debug();\n                if (lua_getstack(co, 0, ar) > 0)  /* does it have frames? */\n                    lua_pushliteral(L, \"normal\");  /* it is running */\n                else if (lua_gettop(co) === 0)\n                    lua_pushliteral(L, \"dead\");\n                else\n                    lua_pushliteral(L, \"suspended\");  /* initial state */\n                break;\n            }\n            default:  /* some error occurred */\n                lua_pushliteral(L, \"dead\");\n                break;\n        }\n    }\n\n    return 1;\n};\n\nconst luaB_yieldable = function(L) {\n    lua_pushboolean(L, lua_isyieldable(L));\n    return 1;\n};\n\nconst luaB_corunning = function(L) {\n    lua_pushboolean(L, lua_pushthread(L));\n    return 2;\n};\n\nconst co_funcs = {\n    \"create\":      luaB_cocreate,\n    \"isyieldable\": luaB_yieldable,\n    \"resume\":      luaB_coresume,\n    \"running\":     luaB_corunning,\n    \"status\":      luaB_costatus,\n    \"wrap\":        luaB_cowrap,\n    \"yield\":       luaB_yield\n};\n\nconst luaopen_coroutine = function(L) {\n    luaL_newlib(L, co_funcs);\n    return 1;\n};\n\nmodule.exports.luaopen_coroutine = luaopen_coroutine;\n", ";\n\nconst { LUA_MAXINTEGER } = require('./luaconf.js');\nconst {\n    LUA_OPEQ,\n    LUA_OPLT,\n    LUA_TFUNCTION,\n    LUA_TNIL,\n    LUA_TTABLE,\n    lua_call,\n    lua_checkstack,\n    lua_compare,\n    lua_createtable,\n    lua_geti,\n    lua_getmetatable,\n    lua_gettop,\n    lua_insert,\n    lua_isnil,\n    lua_isnoneornil,\n    lua_isstring,\n    lua_pop,\n    lua_pushinteger,\n    lua_pushnil,\n    lua_pushstring,\n    lua_pushvalue,\n    lua_rawget,\n    lua_setfield,\n    lua_seti,\n    lua_settop,\n    lua_toboolean,\n    lua_type\n} = require('./lua.js');\nconst {\n    luaL_Buffer,\n    luaL_addlstring,\n    luaL_addvalue,\n    luaL_argcheck,\n    luaL_buffinit,\n    luaL_checkinteger,\n    luaL_checktype,\n    luaL_error,\n    luaL_len,\n    luaL_newlib,\n    luaL_opt,\n    luaL_optinteger,\n    luaL_optlstring,\n    luaL_pushresult,\n    luaL_typename\n} = require('./lauxlib.js');\nconst lualib = require('./lualib.js');\nconst { to_luastring } = require(\"./fengaricore.js\");\n\n/*\n** Operations that an object must define to mimic a table\n** (some functions only need some of them)\n*/\nconst TAB_R  = 1;               /* read */\nconst TAB_W  = 2;               /* write */\nconst TAB_L  = 4;               /* length */\nconst TAB_RW = (TAB_R | TAB_W); /* read/write */\n\nconst checkfield = function(L, key, n) {\n    lua_pushstring(L, key);\n    return lua_rawget(L, -n) !== LUA_TNIL;\n};\n\n/*\n** Check that 'arg' either is a table or can behave like one (that is,\n** has a metatable with the required metamethods)\n*/\nconst checktab = function(L, arg, what) {\n    if (lua_type(L, arg) !== LUA_TTABLE) {  /* is it not a table? */\n        let n = 1;\n        if (lua_getmetatable(L, arg) &&  /* must have metatable */\n            (!(what & TAB_R) || checkfield(L, to_luastring(\"__index\", true), ++n)) &&\n            (!(what & TAB_W) || checkfield(L, to_luastring(\"__newindex\", true), ++n)) &&\n            (!(what & TAB_L) || checkfield(L, to_luastring(\"__len\", true), ++n))) {\n            lua_pop(L, n);  /* pop metatable and tested metamethods */\n        }\n        else\n            luaL_checktype(L, arg, LUA_TTABLE);  /* force an error */\n    }\n};\n\nconst aux_getn = function(L, n, w) {\n    checktab(L, n, w | TAB_L);\n    return luaL_len(L, n);\n};\n\nconst addfield = function(L, b, i) {\n    lua_geti(L, 1, i);\n    if (!lua_isstring(L, -1))\n        luaL_error(L, to_luastring(\"invalid value (%s) at index %d in table for 'concat'\"),\n            luaL_typename(L, -1), i);\n\n    luaL_addvalue(b);\n};\n\nconst tinsert = function(L) {\n    let e = aux_getn(L, 1, TAB_RW) + 1;  /* first empty element */\n    let pos;\n    switch (lua_gettop(L)) {\n        case 2:\n            pos = e;\n            break;\n        case 3: {\n            pos = luaL_checkinteger(L, 2);  /* 2nd argument is the position */\n            luaL_argcheck(L, 1 <= pos && pos <= e, 2, \"position out of bounds\");\n            for (let i = e; i > pos; i--) {  /* move up elements */\n                lua_geti(L, 1, i - 1);\n                lua_seti(L, 1, i);  /* t[i] = t[i - 1] */\n            }\n            break;\n        }\n        default: {\n            return luaL_error(L, \"wrong number of arguments to 'insert'\");\n        }\n    }\n\n    lua_seti(L, 1, pos);  /* t[pos] = v */\n    return 0;\n};\n\nconst tremove = function(L) {\n    let size = aux_getn(L, 1, TAB_RW);\n    let pos = luaL_optinteger(L, 2, size);\n    if (pos !== size)  /* validate 'pos' if given */\n        luaL_argcheck(L, 1 <= pos && pos <= size + 1, 1, \"position out of bounds\");\n    lua_geti(L, 1, pos);  /* result = t[pos] */\n    for (; pos < size; pos++) {\n        lua_geti(L, 1, pos + 1);\n        lua_seti(L, 1, pos);  /* t[pos] = t[pos + 1] */\n    }\n    lua_pushnil(L);\n    lua_seti(L, 1, pos);  /* t[pos] = nil */\n    return 1;\n};\n\n/*\n** Copy elements (1[f], ..., 1[e]) into (tt[t], tt[t+1], ...). Whenever\n** possible, copy in increasing order, which is better for rehashing.\n** \"possible\" means destination after original range, or smaller\n** than origin, or copying to another table.\n*/\nconst tmove = function(L) {\n    let f = luaL_checkinteger(L, 2);\n    let e = luaL_checkinteger(L, 3);\n    let t = luaL_checkinteger(L, 4);\n    let tt = !lua_isnoneornil(L, 5) ? 5 : 1;  /* destination table */\n    checktab(L, 1, TAB_R);\n    checktab(L, tt, TAB_W);\n    if (e >= f) {  /* otherwise, nothing to move */\n        luaL_argcheck(L, f > 0 || e < LUA_MAXINTEGER + f, 3, \"too many elements to move\");\n        let n = e - f + 1;  /* number of elements to move */\n        luaL_argcheck(L, t <= LUA_MAXINTEGER - n + 1, 4, \"destination wrap around\");\n\n        if (t > e || t <= f || (tt !== 1 && lua_compare(L, 1, tt, LUA_OPEQ) !== 1)) {\n            for (let i = 0; i < n; i++) {\n                lua_geti(L, 1, f + i);\n                lua_seti(L, tt, t + i);\n            }\n        } else {\n            for (let i = n - 1; i >= 0; i--) {\n                lua_geti(L, 1, f + i);\n                lua_seti(L, tt, t + i);\n            }\n        }\n    }\n\n    lua_pushvalue(L, tt);  /* return destination table */\n    return 1;\n};\n\nconst tconcat = function(L) {\n    let last = aux_getn(L, 1, TAB_R);\n    let sep = luaL_optlstring(L, 2, \"\");\n    let lsep = sep.length;\n    let i = luaL_optinteger(L, 3, 1);\n    last = luaL_optinteger(L, 4, last);\n\n    let b = new luaL_Buffer();\n    luaL_buffinit(L, b);\n\n    for (; i < last; i++) {\n        addfield(L, b, i);\n        luaL_addlstring(b, sep, lsep);\n    }\n\n    if (i === last)\n        addfield(L, b, i);\n\n    luaL_pushresult(b);\n\n    return 1;\n};\n\nconst pack = function(L) {\n    let n = lua_gettop(L);  /* number of elements to pack */\n    lua_createtable(L, n, 1);  /* create result table */\n    lua_insert(L, 1);  /* put it at index 1 */\n    for (let i = n; i >= 1; i--)  /* assign elements */\n        lua_seti(L, 1, i);\n    lua_pushinteger(L, n);\n    lua_setfield(L, 1, to_luastring(\"n\"));  /* t.n = number of elements */\n    return 1;  /* return table */\n};\n\nconst unpack = function(L) {\n    let i = luaL_optinteger(L, 2, 1);\n    let e = luaL_opt(L, luaL_checkinteger, 3, luaL_len(L, 1));\n    if (i > e) return 0;  /* empty range */\n    let n = e - i;  /* number of elements minus 1 (avoid overflows) */\n    if (n >= Number.MAX_SAFE_INTEGER || !lua_checkstack(L, ++n))\n        return luaL_error(L, to_luastring(\"too many results to unpack\"));\n    for (; i < e; i++)  /* push arg[i..e - 1] (to avoid overflows) */\n        lua_geti(L, 1, i);\n    lua_geti(L, 1, e);  /* push last element */\n    return n;\n};\n\nconst l_randomizePivot = function() {\n    return Math.floor(Math.random()*0x100000000);\n};\n\nconst RANLIMIT = 100;\n\nconst set2 = function(L, i, j) {\n    lua_seti(L, 1, i);\n    lua_seti(L, 1, j);\n};\n\nconst sort_comp = function(L, a, b) {\n    if (lua_isnil(L, 2))  /* no function? */\n        return lua_compare(L, a, b, LUA_OPLT);  /* a < b */\n    else {  /* function */\n        lua_pushvalue(L, 2);    /* push function */\n        lua_pushvalue(L, a-1);  /* -1 to compensate function */\n        lua_pushvalue(L, b-2);  /* -2 to compensate function and 'a' */\n        lua_call(L, 2, 1);      /* call function */\n        let res = lua_toboolean(L, -1);  /* get result */\n        lua_pop(L, 1);          /* pop result */\n        return res;\n    }\n};\n\nconst partition = function(L, lo, up) {\n    let i = lo;  /* will be incremented before first use */\n    let j = up - 1;  /* will be decremented before first use */\n    /* loop invariant: a[lo .. i] <= P <= a[j .. up] */\n    for (;;) {\n        /* next loop: repeat ++i while a[i] < P */\n        while (lua_geti(L, 1, ++i), sort_comp(L, -1, -2)) {\n            if (i == up - 1)  /* a[i] < P  but a[up - 1] == P  ?? */\n                luaL_error(L, to_luastring(\"invalid order function for sorting\"));\n            lua_pop(L, 1);  /* remove a[i] */\n        }\n        /* after the loop, a[i] >= P and a[lo .. i - 1] < P */\n        /* next loop: repeat --j while P < a[j] */\n        while (lua_geti(L, 1, --j), sort_comp(L, -3, -1)) {\n            if (j < i)  /* j < i  but  a[j] > P ?? */\n                luaL_error(L, to_luastring(\"invalid order function for sorting\"));\n            lua_pop(L, 1);  /* remove a[j] */\n        }\n        /* after the loop, a[j] <= P and a[j + 1 .. up] >= P */\n        if (j < i) {  /* no elements out of place? */\n            /* a[lo .. i - 1] <= P <= a[j + 1 .. i .. up] */\n            lua_pop(L, 1);  /* pop a[j] */\n            /* swap pivot (a[up - 1]) with a[i] to satisfy pos-condition */\n            set2(L, up - 1, i);\n            return i;\n        }\n        /* otherwise, swap a[i] - a[j] to restore invariant and repeat */\n        set2(L, i, j);\n    }\n};\n\nconst choosePivot = function(lo, up, rnd) {\n    let r4 = Math.floor((up - lo) / 4);  /* range/4 */\n    let p = rnd % (r4 * 2) + (lo + r4);\n    lualib.lua_assert(lo + r4 <= p && p <= up - r4);\n    return p;\n};\n\nconst auxsort = function(L, lo, up, rnd) {\n    while (lo < up) {  /* loop for tail recursion */\n        /* sort elements 'lo', 'p', and 'up' */\n        lua_geti(L, 1, lo);\n        lua_geti(L, 1, up);\n        if (sort_comp(L, -1, -2))  /* a[up] < a[lo]? */\n            set2(L, lo, up);  /* swap a[lo] - a[up] */\n        else\n            lua_pop(L, 2);  /* remove both values */\n        if (up - lo == 1)  /* only 2 elements? */\n            return;  /* already sorted */\n        let p;  /* Pivot index */\n        if (up - lo < RANLIMIT || rnd === 0)  /* small interval or no randomize? */\n            p = Math.floor((lo + up)/2);  /* middle element is a good pivot */\n        else  /* for larger intervals, it is worth a random pivot */\n            p = choosePivot(lo, up, rnd);\n        lua_geti(L, 1, p);\n        lua_geti(L, 1, lo);\n        if (sort_comp(L, -2, -1))  /* a[p] < a[lo]? */\n            set2(L, p, lo);  /* swap a[p] - a[lo] */\n        else {\n            lua_pop(L, 1);  /* remove a[lo] */\n            lua_geti(L, 1, up);\n            if (sort_comp(L, -1, -2))  /* a[up] < a[p]? */\n                set2(L, p, up);  /* swap a[up] - a[p] */\n            else\n                lua_pop(L, 2);\n        }\n        if (up - lo == 2)  /* only 3 elements? */\n            return;  /* already sorted */\n        lua_geti(L, 1, p);  /* get middle element (Pivot) */\n        lua_pushvalue(L, -1);  /* push Pivot */\n        lua_geti(L, 1, up - 1);  /* push a[up - 1] */\n        set2(L, p, up - 1);  /* swap Pivot (a[p]) with a[up - 1] */\n        p = partition(L, lo, up);\n        let n;\n        /* a[lo .. p - 1] <= a[p] == P <= a[p + 1 .. up] */\n        if (p - lo < up - p) {  /* lower interval is smaller? */\n            auxsort(L, lo, p - 1, rnd);  /* call recursively for lower interval */\n            n = p - lo;  /* size of smaller interval */\n            lo = p + 1;  /* tail call for [p + 1 .. up] (upper interval) */\n        } else {\n            auxsort(L, p + 1, up, rnd);  /* call recursively for upper interval */\n            n = up - p;  /* size of smaller interval */\n            up = p - 1;  /* tail call for [lo .. p - 1]  (lower interval) */\n        }\n        if ((up - lo) / 128 > n) /* partition too imbalanced? */\n            rnd = l_randomizePivot();  /* try a new randomization */\n    }  /* tail call auxsort(L, lo, up, rnd) */\n};\n\nconst sort = function(L) {\n    let n = aux_getn(L, 1, TAB_RW);\n    if (n > 1) {  /* non-trivial interval? */\n        luaL_argcheck(L, n < LUA_MAXINTEGER, 1, \"array too big\");\n        if (!lua_isnoneornil(L, 2))  /* is there a 2nd argument? */\n            luaL_checktype(L, 2, LUA_TFUNCTION);  /* must be a function */\n        lua_settop(L, 2);  /* make sure there are two arguments */\n        auxsort(L, 1, n, 0);\n    }\n    return 0;\n};\n\nconst tab_funcs = {\n    \"concat\": tconcat,\n    \"insert\": tinsert,\n    \"move\":   tmove,\n    \"pack\":   pack,\n    \"remove\": tremove,\n    \"sort\":   sort,\n    \"unpack\": unpack\n};\n\nconst luaopen_table = function(L) {\n    luaL_newlib(L, tab_funcs);\n    return 1;\n};\n\nmodule.exports.luaopen_table = luaopen_table;\n", ";\n\nconst {\n    LUA_TNIL,\n    LUA_TTABLE,\n    lua_close,\n    lua_createtable,\n    lua_getfield,\n    lua_isboolean,\n    lua_isnoneornil,\n    lua_pop,\n    lua_pushboolean,\n    lua_pushfstring,\n    lua_pushinteger,\n    lua_pushliteral,\n    lua_pushnil,\n    lua_pushnumber,\n    lua_pushstring,\n    lua_setfield,\n    lua_settop,\n    lua_toboolean,\n    lua_tointegerx\n} = require('./lua.js');\nconst {\n    luaL_Buffer,\n    luaL_addchar,\n    luaL_addstring,\n    // luaL_argcheck,\n    luaL_argerror,\n    luaL_buffinit,\n    luaL_checkinteger,\n    luaL_checkstring,\n    luaL_checktype,\n    luaL_error,\n    luaL_execresult,\n    luaL_fileresult,\n    luaL_newlib,\n    luaL_optinteger,\n    luaL_optlstring,\n    luaL_optstring,\n    luaL_pushresult\n} = require('./lauxlib.js');\nconst {\n    luastring_eq,\n    to_jsstring,\n    to_luastring\n} = require(\"./fengaricore.js\");\n\n/* options for ANSI C 89 (only 1-char options) */\n// const L_STRFTIMEC89 = to_luastring(\"aAbBcdHIjmMpSUwWxXyYZ%\");\n// const LUA_STRFTIMEOPTIONS = L_STRFTIMEC89;\n\n/* options for ISO C 99 and POSIX */\n// const L_STRFTIMEC99 = to_luastring(\"aAbBcCdDeFgGhHIjmMnprRStTuUVwWxXyYzZ%||EcECExEXEyEYOdOeOHOIOmOMOSOuOUOVOwOWOy\");  /* two-char options */\n// const LUA_STRFTIMEOPTIONS = L_STRFTIMEC99;\n\n/* options for Windows */\n// const L_STRFTIMEWIN = to_luastring(\"aAbBcdHIjmMpSUwWxXyYzZ%||#c#x#d#H#I#j#m#M#S#U#w#W#y#Y\");  /* two-char options */\n// const LUA_STRFTIMEOPTIONS = L_STRFTIMEWIN;\n\n/* options for our own strftime implementation\n  - should be superset of C89 options for compat\n  - missing from C99:\n      - ISO 8601 week specifiers: gGV\n      - > single char specifiers\n  - beyond C99:\n      - %k: TZ extension: space-padded 24-hour\n      - %l: TZ extension: space-padded 12-hour\n      - %P: GNU extension: lower-case am/pm\n*/\nconst LUA_STRFTIMEOPTIONS = to_luastring(\"aAbBcCdDeFhHIjklmMnpPrRStTuUwWxXyYzZ%\");\n\n\nconst setfield = function(L, key, value) {\n    lua_pushinteger(L, value);\n    lua_setfield(L, -2, to_luastring(key, true));\n};\n\nconst setallfields = function(L, time, utc) {\n    setfield(L, \"sec\",   utc ? time.getUTCSeconds()  : time.getSeconds());\n    setfield(L, \"min\",   utc ? time.getUTCMinutes()  : time.getMinutes());\n    setfield(L, \"hour\",  utc ? time.getUTCHours()    : time.getHours());\n    setfield(L, \"day\",   utc ? time.getUTCDate()     : time.getDate());\n    setfield(L, \"month\", (utc ? time.getUTCMonth()   : time.getMonth()) + 1);\n    setfield(L, \"year\",  utc ? time.getUTCFullYear() : time.getFullYear());\n    setfield(L, \"wday\",  (utc ? time.getUTCDay()     : time.getDay()) + 1);\n    setfield(L, \"yday\", Math.floor((time - (new Date(time.getFullYear(), 0, 0 /* shortcut to correct day by one */))) / 86400000));\n    // setboolfield(L, \"isdst\", time.get);\n};\n\nconst L_MAXDATEFIELD = (Number.MAX_SAFE_INTEGER / 2);\n\nconst getfield = function(L, key, d, delta) {\n    let t = lua_getfield(L, -1, to_luastring(key, true));  /* get field and its type */\n    let res = lua_tointegerx(L, -1);\n    if (res === false) {  /* field is not an integer? */\n        if (t !== LUA_TNIL)  /* some other value? */\n            return luaL_error(L, to_luastring(\"field '%s' is not an integer\"), key);\n        else if (d < 0)  /* absent field; no default? */\n            return luaL_error(L, to_luastring(\"field '%s' missing in date table\"), key);\n        res = d;\n    }\n    else {\n        if (!(-L_MAXDATEFIELD <= res && res <= L_MAXDATEFIELD))\n            return luaL_error(L, to_luastring(\"field '%s' is out-of-bound\"), key);\n        res -= delta;\n    }\n    lua_pop(L, 1);\n    return res;\n};\n\n\nconst locale = {\n    days: [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\" ].map((s) => to_luastring(s)),\n    shortDays: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"].map((s) => to_luastring(s)),\n    months: [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"].map((s) => to_luastring(s)),\n    shortMonths: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"].map((s) => to_luastring(s)),\n    AM: to_luastring(\"AM\"),\n    PM: to_luastring(\"PM\"),\n    am: to_luastring(\"am\"),\n    pm: to_luastring(\"pm\"),\n    formats: {\n        c: to_luastring(\"%a %b %e %H:%M:%S %Y\"),\n        D: to_luastring(\"%m/%d/%y\"),\n        F: to_luastring(\"%Y-%m-%d\"),\n        R: to_luastring(\"%H:%M\"),\n        r: to_luastring(\"%I:%M:%S %p\"),\n        T: to_luastring(\"%H:%M:%S\"),\n        X: to_luastring(\"%T\"),\n        x: to_luastring(\"%D\")\n    }\n};\n\nconst week_number = function(date, start_of_week) {\n    // This works by shifting the weekday back by one day if we\n    // are treating Monday as the first day of the week.\n    let weekday = date.getDay();\n    if (start_of_week === 'monday') {\n        if (weekday === 0) // Sunday\n            weekday = 6;\n        else\n            weekday--;\n    }\n    let yday = (date - new Date(date.getFullYear(), 0, 1)) / 86400000;\n    return Math.floor((yday + 7 - weekday) / 7);\n};\n\nconst push_pad_2 = function(b, n, pad) {\n    if (n < 10)\n        luaL_addchar(b, pad);\n    luaL_addstring(b, to_luastring(String(n)));\n};\n\nconst strftime = function(L, b, s, date) {\n    let i = 0;\n    while (i < s.length) {\n        if (s[i] !== 37 /* % */) {  /* not a conversion specifier? */\n            luaL_addchar(b, s[i++]);\n        } else {\n            i++;  /* skip '%' */\n            let len = checkoption(L, s, i);\n            /* each `case` has an example output above it for the UTC epoch */\n            switch(s[i]) {\n                // '%'\n                case 37 /* % */:\n                    luaL_addchar(b, 37);\n                    break;\n\n                // 'Thursday'\n                case 65 /* A */:\n                    luaL_addstring(b, locale.days[date.getDay()]);\n                    break;\n\n                // 'January'\n                case 66 /* B */:\n                    luaL_addstring(b, locale.months[date.getMonth()]);\n                    break;\n\n                // '19'\n                case 67 /* C */:\n                    push_pad_2(b, Math.floor(date.getFullYear() / 100), 48 /* 0 */);\n                    break;\n\n                // '01/01/70'\n                case 68 /* D */:\n                    strftime(L, b, locale.formats.D, date);\n                    break;\n\n                // '1970-01-01'\n                case 70 /* F */:\n                    strftime(L, b, locale.formats.F, date);\n                    break;\n\n                // '00'\n                case 72 /* H */:\n                    push_pad_2(b, date.getHours(), 48 /* 0 */);\n                    break;\n\n                // '12'\n                case 73 /* I */:\n                    push_pad_2(b, (date.getHours() + 11) % 12 + 1, 48 /* 0 */);\n                    break;\n\n                // '00'\n                case 77 /* M */:\n                    push_pad_2(b, date.getMinutes(), 48 /* 0 */);\n                    break;\n\n                // 'am'\n                case 80 /* P */:\n                    luaL_addstring(b, date.getHours() < 12 ? locale.am : locale.pm);\n                    break;\n\n                // '00:00'\n                case 82 /* R */:\n                    strftime(L, b, locale.formats.R, date);\n                    break;\n\n                // '00'\n                case 83 /* S */:\n                    push_pad_2(b, date.getSeconds(), 48 /* 0 */);\n                    break;\n\n                // '00:00:00'\n                case 84 /* T */:\n                    strftime(L, b, locale.formats.T, date);\n                    break;\n\n                // '00'\n                case 85 /* U */:\n                    push_pad_2(b, week_number(date, \"sunday\"), 48 /* 0 */);\n                    break;\n\n                // '00'\n                case 87 /* W */:\n                    push_pad_2(b, week_number(date, \"monday\"), 48 /* 0 */);\n                    break;\n\n                // '16:00:00'\n                case 88 /* X */:\n                    strftime(L, b, locale.formats.X, date);\n                    break;\n\n                // '1970'\n                case 89 /* Y */:\n                    luaL_addstring(b, to_luastring(String(date.getFullYear())));\n                    break;\n\n                // 'GMT'\n                case 90 /* Z */: {\n                    let tzString = date.toString().match(/\\(([\\w\\s]+)\\)/);\n                    if (tzString)\n                        luaL_addstring(b, to_luastring(tzString[1]));\n                    break;\n                }\n\n                // 'Thu'\n                case 97 /* a */:\n                    luaL_addstring(b, locale.shortDays[date.getDay()]);\n                    break;\n\n                // 'Jan'\n                case 98 /* b */:\n                case 104 /* h */:\n                    luaL_addstring(b, locale.shortMonths[date.getMonth()]);\n                    break;\n\n                // ''\n                case 99 /* c */:\n                    strftime(L, b, locale.formats.c, date);\n                    break;\n\n                // '01'\n                case 100 /* d */:\n                    push_pad_2(b, date.getDate(), 48 /* 0 */);\n                    break;\n\n                // ' 1'\n                case 101 /* e */:\n                    push_pad_2(b, date.getDate(), 32 /* space */);\n                    break;\n\n                // '000'\n                case 106 /* j */: {\n                    let yday = Math.floor((date - new Date(date.getFullYear(), 0, 1)) / 86400000);\n                    if (yday < 100) {\n                        if (yday < 10)\n                            luaL_addchar(b, 48 /* 0 */);\n                        luaL_addchar(b, 48 /* 0 */);\n                    }\n                    luaL_addstring(b, to_luastring(String(yday)));\n                    break;\n                }\n\n                // ' 0'\n                case 107 /* k */:\n                    push_pad_2(b, date.getHours(), 32 /* space */);\n                    break;\n\n                // '12'\n                case 108 /* l */:\n                    push_pad_2(b, (date.getHours() + 11) % 12 + 1, 32 /* space */);\n                    break;\n\n                // '01'\n                case 109 /* m */:\n                    push_pad_2(b, date.getMonth() + 1, 48 /* 0 */);\n                    break;\n\n                // '\\n'\n                case 110 /* n */:\n                    luaL_addchar(b, 10);\n                    break;\n\n                // 'AM'\n                case 112 /* p */:\n                    luaL_addstring(b, date.getHours() < 12 ? locale.AM : locale.PM);\n                    break;\n\n                // '12:00:00 AM'\n                case 114 /* r */:\n                    strftime(L, b, locale.formats.r, date);\n                    break;\n\n                // '0'\n                case 115 /* s */:\n                    luaL_addstring(b, to_luastring(String(Math.floor(date / 1000))));\n                    break;\n\n                // '\\t'\n                case 116 /* t */:\n                    luaL_addchar(b, 8);\n                    break;\n\n                // '4'\n                case 117 /* u */: {\n                    let day = date.getDay();\n                    luaL_addstring(b, to_luastring(String(day === 0 ? 7 : day)));\n                    break;\n                }\n\n                // '4'\n                case 119 /* w */:\n                    luaL_addstring(b, to_luastring(String(date.getDay())));\n                    break;\n\n                // '12/31/69'\n                case 120 /* x */:\n                    strftime(L, b, locale.formats.x, date);\n                    break;\n\n                // '70'\n                case 121 /* y */:\n                    push_pad_2(b, date.getFullYear() % 100, 48 /* 0 */);\n                    break;\n\n                // '+0000'\n                case 122 /* z */: {\n                    let off = date.getTimezoneOffset();\n                    if (off > 0) {\n                        luaL_addchar(b, 45 /* - */);\n                    } else {\n                        off = -off;\n                        luaL_addchar(b, 43 /* + */);\n                    }\n                    push_pad_2(b, Math.floor(off/60), 48 /* 0 */);\n                    push_pad_2(b, off % 60, 48 /* 0 */);\n                    break;\n                }\n            }\n            i += len;\n        }\n    }\n};\n\n\nconst checkoption = function(L, conv, i) {\n    let option = LUA_STRFTIMEOPTIONS;\n    let o = 0;\n    let oplen = 1;  /* length of options being checked */\n    for (; o < option.length && oplen <= (conv.length - i); o += oplen) {\n        if (option[o] === '|'.charCodeAt(0))  /* next block? */\n            oplen++;  /* will check options with next length (+1) */\n        else if (luastring_eq(conv.subarray(i, i+oplen), option.subarray(o, o+oplen))) {  /* match? */\n            return oplen;  /* return length */\n        }\n    }\n    luaL_argerror(L, 1,\n        lua_pushfstring(L, to_luastring(\"invalid conversion specifier '%%%s'\"), conv));\n};\n\n/* maximum size for an individual 'strftime' item */\n// const SIZETIMEFMT = 250;\n\n\nconst os_date = function(L) {\n    let s = luaL_optlstring(L, 1, \"%c\");\n    let stm = lua_isnoneornil(L, 2) ? new Date() : new Date(l_checktime(L, 2) * 1000);\n    let utc = false;\n    let i = 0;\n    if (s[i] === '!'.charCodeAt(0)) {  /* UTC? */\n        utc = true;\n        i++;  /* skip '!' */\n    }\n    if (s[i] === \"*\".charCodeAt(0) && s[i+1] === \"t\".charCodeAt(0)) {\n        lua_createtable(L, 0, 9);  /* 9 = number of fields */\n        setallfields(L, stm, utc);\n    } else {\n        let cc = new Uint8Array(4);\n        cc[0] = \"%\".charCodeAt(0);\n        let b = new luaL_Buffer();\n        luaL_buffinit(L, b);\n        strftime(L, b, s, stm);\n        luaL_pushresult(b);\n    }\n    return 1;\n};\n\nconst os_time = function(L) {\n    let t;\n    if (lua_isnoneornil(L, 1))  /* called without args? */\n        t = new Date();  /* get current time */\n    else {\n        luaL_checktype(L, 1, LUA_TTABLE);\n        lua_settop(L, 1);  /* make sure table is at the top */\n        t = new Date(\n            getfield(L, \"year\", -1, 0),\n            getfield(L, \"month\", -1, 1),\n            getfield(L, \"day\", -1, 0),\n            getfield(L, \"hour\", 12, 0),\n            getfield(L, \"min\", 0, 0),\n            getfield(L, \"sec\", 0, 0)\n        );\n        setallfields(L, t);\n    }\n\n    lua_pushinteger(L, Math.floor(t / 1000));\n    return 1;\n};\n\nconst l_checktime = function(L, arg) {\n    let t = luaL_checkinteger(L, arg);\n    // luaL_argcheck(L, t, arg, \"time out-of-bounds\");\n    return t;\n};\n\nconst os_difftime = function(L) {\n    let t1 = l_checktime(L, 1);\n    let t2 = l_checktime(L, 2);\n    lua_pushnumber(L, t1 - t2);\n    return 1;\n};\n\nconst syslib = {\n    \"date\": os_date,\n    \"difftime\": os_difftime,\n    \"time\": os_time\n};\n\nif (typeof process === \"undefined\") {\n    syslib.clock = function(L) {\n        lua_pushnumber(L, performance.now()/1000);\n        return 1;\n    };\n} else {\n    /* Only with Node */\n    const fs = require('fs');\n    const tmp = require('tmp');\n    const child_process = require('child_process');\n\n    syslib.exit = function(L) {\n        let status;\n        if (lua_isboolean(L, 1))\n            status = (lua_toboolean(L, 1) ? 0 : 1);\n        else\n            status = luaL_optinteger(L, 1, 0);\n        if (lua_toboolean(L, 2))\n            lua_close(L);\n        if (L) process.exit(status);  /* 'if' to avoid warnings for unreachable 'return' */\n        return 0;\n    };\n\n    syslib.getenv = function(L) {\n        let key = luaL_checkstring(L, 1);\n        key = to_jsstring(key); /* https://github.com/nodejs/node/issues/16961 */\n        if (Object.prototype.hasOwnProperty.call(process.env, key)) {\n            lua_pushliteral(L, process.env[key]);\n        } else {\n            lua_pushnil(L);\n        }\n        return 1;\n    };\n\n    syslib.clock = function(L) {\n        lua_pushnumber(L, process.uptime());\n        return 1;\n    };\n\n    const lua_tmpname = function() {\n        return tmp.tmpNameSync();\n    };\n\n    syslib.remove = function(L) {\n        let filename = luaL_checkstring(L, 1);\n        try {\n            fs.unlinkSync(filename);\n        } catch (e) {\n            if (e.code === 'EISDIR') {\n                try {\n                    fs.rmdirSync(filename);\n                } catch (e) {\n                    return luaL_fileresult(L, false, filename, e);\n                }\n            } else {\n                return luaL_fileresult(L, false, filename, e);\n            }\n        }\n        return luaL_fileresult(L, true);\n    };\n\n    syslib.rename = function(L) {\n        let fromname = luaL_checkstring(L, 1);\n        let toname = luaL_checkstring(L, 2);\n        try {\n            fs.renameSync(fromname, toname);\n        } catch (e) {\n            return luaL_fileresult(L, false, false, e);\n        }\n        return luaL_fileresult(L, true);\n    };\n\n    syslib.tmpname = function(L) {\n        let name = lua_tmpname();\n        if (!name)\n            return luaL_error(L, to_luastring(\"unable to generate a unique filename\"));\n        lua_pushstring(L, to_luastring(name));\n        return 1;\n    };\n\n    syslib.execute = function(L) {\n        let cmd = luaL_optstring(L, 1, null);\n        if (cmd !== null) {\n            try {\n                child_process.execSync(\n                    cmd,\n                    {\n                        stdio: [process.stdin, process.stdout, process.stderr]\n                    }\n                );\n            } catch (e) {\n                return luaL_execresult(L, e);\n            }\n\n            return luaL_execresult(L, null);\n        } else {\n            /* Assume a shell is available.\n               If it's good enough for musl it's good enough for us.\n               http://git.musl-libc.org/cgit/musl/tree/src/process/system.c?id=ac45692a53a1b8d2ede329d91652d43c1fb5dc8d#n22\n            */\n            lua_pushboolean(L, 1);\n            return 1;\n        }\n    };\n}\n\nconst luaopen_os = function(L) {\n    luaL_newlib(L, syslib);\n    return 1;\n};\n\nmodule.exports.luaopen_os = luaopen_os;\n", "/* global window, exports, define */\n\n!function() {\n    \n\n    var re = {\n        not_string: /[^s]/,\n        not_bool: /[^t]/,\n        not_type: /[^T]/,\n        not_primitive: /[^v]/,\n        number: /[diefg]/,\n        numeric_arg: /[bcdiefguxX]/,\n        json: /[j]/,\n        not_json: /[^j]/,\n        text: /^[^\\x25]+/,\n        modulo: /^\\x25{2}/,\n        placeholder: /^\\x25(?:([1-9]\\d*)\\$|\\(([^)]+)\\))?(\\+)?(0|'[^$])?(-)?(\\d+)?(?:\\.(\\d+))?([b-gijostTuvxX])/,\n        key: /^([a-z_][a-z_\\d]*)/i,\n        key_access: /^\\.([a-z_][a-z_\\d]*)/i,\n        index_access: /^\\[(\\d+)\\]/,\n        sign: /^[+-]/\n    }\n\n    function sprintf(key) {\n        // `arguments` is not an array, but should be fine for this call\n        return sprintf_format(sprintf_parse(key), arguments)\n    }\n\n    function vsprintf(fmt, argv) {\n        return sprintf.apply(null, [fmt].concat(argv || []))\n    }\n\n    function sprintf_format(parse_tree, argv) {\n        var cursor = 1, tree_length = parse_tree.length, arg, output = '', i, k, ph, pad, pad_character, pad_length, is_positive, sign\n        for (i = 0; i < tree_length; i++) {\n            if (typeof parse_tree[i] === 'string') {\n                output += parse_tree[i]\n            }\n            else if (typeof parse_tree[i] === 'object') {\n                ph = parse_tree[i] // convenience purposes only\n                if (ph.keys) { // keyword argument\n                    arg = argv[cursor]\n                    for (k = 0; k < ph.keys.length; k++) {\n                        if (arg == undefined) {\n                            throw new Error(sprintf('[sprintf] Cannot access property \"%s\" of undefined value \"%s\"', ph.keys[k], ph.keys[k-1]))\n                        }\n                        arg = arg[ph.keys[k]]\n                    }\n                }\n                else if (ph.param_no) { // positional argument (explicit)\n                    arg = argv[ph.param_no]\n                }\n                else { // positional argument (implicit)\n                    arg = argv[cursor++]\n                }\n\n                if (re.not_type.test(ph.type) && re.not_primitive.test(ph.type) && arg instanceof Function) {\n                    arg = arg()\n                }\n\n                if (re.numeric_arg.test(ph.type) && (typeof arg !== 'number' && isNaN(arg))) {\n                    throw new TypeError(sprintf('[sprintf] expecting number but found %T', arg))\n                }\n\n                if (re.number.test(ph.type)) {\n                    is_positive = arg >= 0\n                }\n\n                switch (ph.type) {\n                    case 'b':\n                        arg = parseInt(arg, 10).toString(2)\n                        break\n                    case 'c':\n                        arg = String.fromCharCode(parseInt(arg, 10))\n                        break\n                    case 'd':\n                    case 'i':\n                        arg = parseInt(arg, 10)\n                        break\n                    case 'j':\n                        arg = JSON.stringify(arg, null, ph.width ? parseInt(ph.width) : 0)\n                        break\n                    case 'e':\n                        arg = ph.precision ? parseFloat(arg).toExponential(ph.precision) : parseFloat(arg).toExponential()\n                        break\n                    case 'f':\n                        arg = ph.precision ? parseFloat(arg).toFixed(ph.precision) : parseFloat(arg)\n                        break\n                    case 'g':\n                        arg = ph.precision ? String(Number(arg.toPrecision(ph.precision))) : parseFloat(arg)\n                        break\n                    case 'o':\n                        arg = (parseInt(arg, 10) >>> 0).toString(8)\n                        break\n                    case 's':\n                        arg = String(arg)\n                        arg = (ph.precision ? arg.substring(0, ph.precision) : arg)\n                        break\n                    case 't':\n                        arg = String(!!arg)\n                        arg = (ph.precision ? arg.substring(0, ph.precision) : arg)\n                        break\n                    case 'T':\n                        arg = Object.prototype.toString.call(arg).slice(8, -1).toLowerCase()\n                        arg = (ph.precision ? arg.substring(0, ph.precision) : arg)\n                        break\n                    case 'u':\n                        arg = parseInt(arg, 10) >>> 0\n                        break\n                    case 'v':\n                        arg = arg.valueOf()\n                        arg = (ph.precision ? arg.substring(0, ph.precision) : arg)\n                        break\n                    case 'x':\n                        arg = (parseInt(arg, 10) >>> 0).toString(16)\n                        break\n                    case 'X':\n                        arg = (parseInt(arg, 10) >>> 0).toString(16).toUpperCase()\n                        break\n                }\n                if (re.json.test(ph.type)) {\n                    output += arg\n                }\n                else {\n                    if (re.number.test(ph.type) && (!is_positive || ph.sign)) {\n                        sign = is_positive ? '+' : '-'\n                        arg = arg.toString().replace(re.sign, '')\n                    }\n                    else {\n                        sign = ''\n                    }\n                    pad_character = ph.pad_char ? ph.pad_char === '0' ? '0' : ph.pad_char.charAt(1) : ' '\n                    pad_length = ph.width - (sign + arg).length\n                    pad = ph.width ? (pad_length > 0 ? pad_character.repeat(pad_length) : '') : ''\n                    output += ph.align ? sign + arg + pad : (pad_character === '0' ? sign + pad + arg : pad + sign + arg)\n                }\n            }\n        }\n        return output\n    }\n\n    var sprintf_cache = Object.create(null)\n\n    function sprintf_parse(fmt) {\n        if (sprintf_cache[fmt]) {\n            return sprintf_cache[fmt]\n        }\n\n        var _fmt = fmt, match, parse_tree = [], arg_names = 0\n        while (_fmt) {\n            if ((match = re.text.exec(_fmt)) !== null) {\n                parse_tree.push(match[0])\n            }\n            else if ((match = re.modulo.exec(_fmt)) !== null) {\n                parse_tree.push('%')\n            }\n            else if ((match = re.placeholder.exec(_fmt)) !== null) {\n                if (match[2]) {\n                    arg_names |= 1\n                    var field_list = [], replacement_field = match[2], field_match = []\n                    if ((field_match = re.key.exec(replacement_field)) !== null) {\n                        field_list.push(field_match[1])\n                        while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {\n                            if ((field_match = re.key_access.exec(replacement_field)) !== null) {\n                                field_list.push(field_match[1])\n                            }\n                            else if ((field_match = re.index_access.exec(replacement_field)) !== null) {\n                                field_list.push(field_match[1])\n                            }\n                            else {\n                                throw new SyntaxError('[sprintf] failed to parse named argument key')\n                            }\n                        }\n                    }\n                    else {\n                        throw new SyntaxError('[sprintf] failed to parse named argument key')\n                    }\n                    match[2] = field_list\n                }\n                else {\n                    arg_names |= 2\n                }\n                if (arg_names === 3) {\n                    throw new Error('[sprintf] mixing positional and named placeholders is not (yet) supported')\n                }\n\n                parse_tree.push(\n                    {\n                        placeholder: match[0],\n                        param_no:    match[1],\n                        keys:        match[2],\n                        sign:        match[3],\n                        pad_char:    match[4],\n                        align:       match[5],\n                        width:       match[6],\n                        precision:   match[7],\n                        type:        match[8]\n                    }\n                )\n            }\n            else {\n                throw new SyntaxError('[sprintf] unexpected placeholder')\n            }\n            _fmt = _fmt.substring(match[0].length)\n        }\n        return sprintf_cache[fmt] = parse_tree\n    }\n\n    /**\n     * export to either browser or node.js\n     */\n    /* eslint-disable quote-props */\n    if (typeof exports !== 'undefined') {\n        exports['sprintf'] = sprintf\n        exports['vsprintf'] = vsprintf\n    }\n    if (typeof window !== 'undefined') {\n        window['sprintf'] = sprintf\n        window['vsprintf'] = vsprintf\n\n        if (typeof define === 'function' && define['amd']) {\n            define(function() {\n                return {\n                    'sprintf': sprintf,\n                    'vsprintf': vsprintf\n                }\n            })\n        }\n    }\n    /* eslint-enable quote-props */\n}(); // eslint-disable-line\n", ";\n\nconst { sprintf } = require('sprintf-js');\n\nconst {\n    LUA_INTEGER_FMT,\n    LUA_INTEGER_FRMLEN,\n    LUA_MININTEGER,\n    LUA_NUMBER_FMT,\n    LUA_NUMBER_FRMLEN,\n    frexp,\n    lua_getlocaledecpoint\n} = require('./luaconf.js');\nconst {\n    LUA_TBOOLEAN,\n    LUA_TFUNCTION,\n    LUA_TNIL,\n    LUA_TNUMBER,\n    LUA_TSTRING,\n    LUA_TTABLE,\n    lua_call,\n    lua_createtable,\n    lua_dump,\n    lua_gettable,\n    lua_gettop,\n    lua_isinteger,\n    lua_isstring,\n    lua_pop,\n    lua_pushcclosure,\n    lua_pushinteger,\n    lua_pushlightuserdata,\n    lua_pushliteral,\n    lua_pushlstring,\n    lua_pushnil,\n    lua_pushnumber,\n    lua_pushstring,\n    lua_pushvalue,\n    lua_remove,\n    lua_setfield,\n    lua_setmetatable,\n    lua_settop,\n    lua_toboolean,\n    lua_tointeger,\n    lua_tonumber,\n    lua_tostring,\n    lua_touserdata,\n    lua_type,\n    lua_upvalueindex\n} = require('./lua.js');\nconst {\n    luaL_Buffer,\n    luaL_addchar,\n    luaL_addlstring,\n    luaL_addsize,\n    luaL_addstring,\n    luaL_addvalue,\n    luaL_argcheck,\n    luaL_argerror,\n    luaL_buffinit,\n    luaL_buffinitsize,\n    luaL_checkinteger,\n    luaL_checknumber,\n    luaL_checkstack,\n    luaL_checkstring,\n    luaL_checktype,\n    luaL_error,\n    luaL_newlib,\n    luaL_optinteger,\n    luaL_optstring,\n    luaL_prepbuffsize,\n    luaL_pushresult,\n    luaL_pushresultsize,\n    luaL_tolstring,\n    luaL_typename\n} = require('./lauxlib.js');\nconst lualib = require('./lualib.js');\nconst {\n    luastring_eq,\n    luastring_indexOf,\n    to_jsstring,\n    to_luastring\n} = require(\"./fengaricore.js\");\n\nconst sL_ESC  = '%';\nconst L_ESC   = sL_ESC.charCodeAt(0);\n\n/*\n** maximum number of captures that a pattern can do during\n** pattern-matching. This limit is arbitrary, but must fit in\n** an unsigned char.\n*/\nconst LUA_MAXCAPTURES = 32;\n\n// (sizeof(size_t) < sizeof(int) ? MAX_SIZET : (size_t)(INT_MAX))\nconst MAXSIZE = 2147483647;\n\n/* Give natural (i.e. strings end at the first \\0) length of a string represented by an array of bytes */\nconst strlen = function(s) {\n    let len = luastring_indexOf(s, 0);\n    return len > -1 ? len : s.length;\n};\n\n/* translate a relative string position: negative means back from end */\nconst posrelat = function(pos, len) {\n    if (pos >= 0) return pos;\n    else if (0 - pos > len) return 0;\n    else return len + pos + 1;\n};\n\nconst str_sub = function(L) {\n    let s = luaL_checkstring(L, 1);\n    let l = s.length;\n    let start = posrelat(luaL_checkinteger(L, 2), l);\n    let end = posrelat(luaL_optinteger(L, 3, -1), l);\n    if (start < 1) start = 1;\n    if (end > l) end = l;\n    if (start <= end)\n        lua_pushstring(L, s.subarray(start - 1, (start - 1) + (end - start + 1)));\n    else lua_pushliteral(L, \"\");\n    return 1;\n};\n\nconst str_len = function(L) {\n    lua_pushinteger(L, luaL_checkstring(L, 1).length);\n    return 1;\n};\n\nconst str_char = function(L) {\n    let n = lua_gettop(L);  /* number of arguments */\n    let b = new luaL_Buffer();\n    let p = luaL_buffinitsize(L, b, n);\n    for (let i = 1; i <= n; i++) {\n        let c = luaL_checkinteger(L, i);\n        luaL_argcheck(L, c >= 0 && c <= 255, \"value out of range\"); // Strings are 8-bit clean\n        p[i-1] = c;\n    }\n    luaL_pushresultsize(b, n);\n    return 1;\n};\n\nconst writer = function(L, b, size, B) {\n    luaL_addlstring(B, b, size);\n    return 0;\n};\n\nconst str_dump = function(L) {\n    let b = new luaL_Buffer();\n    let strip = lua_toboolean(L, 2);\n    luaL_checktype(L, 1, LUA_TFUNCTION);\n    lua_settop(L, 1);\n    luaL_buffinit(L, b);\n    if (lua_dump(L, writer, b, strip) !== 0)\n        return luaL_error(L, to_luastring(\"unable to dump given function\"));\n    luaL_pushresult(b);\n    return 1;\n};\n\nconst SIZELENMOD = LUA_NUMBER_FRMLEN.length + 1;\n\nconst L_NBFD = 1;\n\nconst num2straux = function(x) {\n    /* if 'inf' or 'NaN', format it like '%g' */\n    if (Object.is(x, Infinity))\n        return to_luastring('inf');\n    else if (Object.is(x, -Infinity))\n        return to_luastring('-inf');\n    else if (Number.isNaN(x))\n        return to_luastring('nan');\n    else if (x === 0) {  /* can be -0... */\n        /* create \"0\" or \"-0\" followed by exponent */\n        let zero = sprintf(LUA_NUMBER_FMT + \"x0p+0\", x);\n        if (Object.is(x, -0))\n            zero = \"-\" + zero;\n        return to_luastring(zero);\n    } else {\n        let buff = \"\";\n        let fe = frexp(x);  /* 'x' fraction and exponent */\n        let m = fe[0];\n        let e = fe[1];\n        if (m < 0) {  /* is number negative? */\n            buff += '-';  /* add signal */\n            m = -m;  /* make it positive */\n        }\n        buff += \"0x\";  /* add \"0x\" */\n        buff += (m * (1<<L_NBFD)).toString(16);\n        e -= L_NBFD;  /* this digit goes before the radix point */\n        buff += sprintf(\"p%+d\", e);  /* add exponent */\n        return to_luastring(buff);\n    }\n};\n\nconst lua_number2strx = function(L, fmt, x) {\n    let buff = num2straux(x);\n    if (fmt[SIZELENMOD] === 65 /* 'A'.charCodeAt(0) */) {\n        for (let i = 0; i < buff.length; i++) {\n            let c = buff[i];\n            if (c >= 97) /* toupper */\n                buff[i] = c & 0xdf;\n        }\n    } else if (fmt[SIZELENMOD] !== 97 /* 'a'.charCodeAt(0) */)\n        luaL_error(L, to_luastring(\"modifiers for format '%%a'/'%%A' not implemented\"));\n    return buff;\n};\n\n/*\n** Maximum size of each formatted item. This maximum size is produced\n** by format('%.99f', -maxfloat), and is equal to 99 + 3 ('-', '.',\n** and '\\0') + number of decimal digits to represent maxfloat (which\n** is maximum exponent + 1). (99+3+1 then rounded to 120 for \"extra\n** expenses\", such as locale-dependent stuff)\n*/\n// const MAX_ITEM   = 120;// TODO: + l_mathlim(MAX_10_EXP);\n\n\n/* valid flags in a format specification */\nconst FLAGS = to_luastring(\"-+ #0\");\n\n/*\n** maximum size of each format specification (such as \"%-099.99d\")\n*/\n// const MAX_FORMAT = 32;\n\nconst isalpha = e => (97 <= e && e <= 122) || (65 <= e && e <= 90);\nconst isdigit = e => 48 <= e && e <= 57;\nconst iscntrl = e => (0x00 <= e && e <= 0x1f) || e === 0x7f;\nconst isgraph = e => 33 <= e && e <= 126;\nconst islower = e => 97 <= e && e <= 122;\nconst isupper = e => 65 <= e && e <= 90;\nconst isalnum = e => (97 <= e && e <= 122) || (65 <= e && e <= 90) || (48 <= e && e <= 57);\nconst ispunct = e => isgraph(e) && !isalnum(e);\nconst isspace = e => e === 32 || (e >= 9 && e <= 13);\nconst isxdigit = e => (48 <= e && e <= 57) || (65 <= e && e <= 70) || (97 <= e && e <= 102);\n\nconst addquoted = function(b, s, len) {\n    luaL_addchar(b, 34 /* '\"'.charCodeAt(0) */);\n    let i = 0;\n    while (len--) {\n        if (s[i] === 34 /* '\"'.charCodeAt(0) */ ||\n            s[i] === 92 /* '\\\\'.charCodeAt(0) */ ||\n            s[i] === 10 /* '\\n'.charCodeAt(0) */) {\n            luaL_addchar(b, 92 /* '\\\\'.charCodeAt(0) */);\n            luaL_addchar(b, s[i]);\n        } else if (iscntrl(s[i])) {\n            let buff = ''+s[i];\n            if (isdigit(s[i+1]))\n                buff = '0'.repeat(3-buff.length) + buff; /* pad to 3 '0's */\n            luaL_addstring(b, to_luastring(\"\\\\\" + buff));\n        } else\n            luaL_addchar(b, s[i]);\n        i++;\n    }\n    luaL_addchar(b, 34 /* '\"'.charCodeAt(0) */);\n};\n\n/*\n** Ensures the 'buff' string uses a dot as the radix character.\n*/\nconst checkdp = function(buff) {\n    if (luastring_indexOf(buff, 46 /* ('.').charCodeAt(0) */) < 0) {  /* no dot? */\n        let point = lua_getlocaledecpoint();  /* try locale point */\n        let ppoint = luastring_indexOf(buff, point);\n        if (ppoint) buff[ppoint] = 46 /* ('.').charCodeAt(0) */;  /* change it to a dot */\n    }\n};\n\nconst addliteral = function(L, b, arg) {\n    switch(lua_type(L, arg)) {\n        case LUA_TSTRING: {\n            let s = lua_tostring(L, arg);\n            addquoted(b, s, s.length);\n            break;\n        }\n        case LUA_TNUMBER: {\n            let buff;\n            if (!lua_isinteger(L, arg)) {  /* float? */\n                let n = lua_tonumber(L, arg);  /* write as hexa ('%a') */\n                buff = lua_number2strx(L, to_luastring(`%${LUA_INTEGER_FRMLEN}a`), n);\n                checkdp(buff);  /* ensure it uses a dot */\n            } else {  /* integers */\n                let n = lua_tointeger(L, arg);\n                let format = (n === LUA_MININTEGER)  /* corner case? */\n                    ? \"0x%\" + LUA_INTEGER_FRMLEN + \"x\"  /* use hexa */\n                    : LUA_INTEGER_FMT;  /* else use default format */\n                buff = to_luastring(sprintf(format, n));\n            }\n            luaL_addstring(b, buff);\n            break;\n        }\n        case LUA_TNIL: case LUA_TBOOLEAN: {\n            luaL_tolstring(L, arg);\n            luaL_addvalue(b);\n            break;\n        }\n        default: {\n            luaL_argerror(L, arg, to_luastring(\"value has no literal form\"));\n        }\n    }\n};\n\nconst scanformat = function(L, strfrmt, i, form) {\n    let p = i;\n    while (strfrmt[p] !== 0 && luastring_indexOf(FLAGS, strfrmt[p]) >= 0) p++;  /* skip flags */\n    if (p - i >= FLAGS.length)\n        luaL_error(L, to_luastring(\"invalid format (repeated flags)\"));\n    if (isdigit(strfrmt[p])) p++;  /* skip width */\n    if (isdigit(strfrmt[p])) p++;  /* (2 digits at most) */\n    if (strfrmt[p] === 46 /* '.'.charCodeAt(0) */) {\n        p++;\n        if (isdigit(strfrmt[p])) p++;  /* skip precision */\n        if (isdigit(strfrmt[p])) p++;  /* (2 digits at most) */\n    }\n    if (isdigit(strfrmt[p]))\n        luaL_error(L, to_luastring(\"invalid format (width or precision too long)\"));\n    form[0] = 37 /* \"%\".charCodeAt(0) */;\n    for (let j = 0; j < p - i + 1; j++)\n        form[j+1] = strfrmt[i+j];\n    return p;\n};\n\n/*\n** add length modifier into formats\n*/\nconst addlenmod = function(form, lenmod) {\n    let l = form.length;\n    let lm = lenmod.length;\n    let spec = form[l - 1];\n    for (let i = 0; i < lm; i++)\n        form[i + l - 1] = lenmod[i];\n    form[l + lm - 1] = spec;\n    // form[l + lm] = 0;\n};\n\nconst str_format = function(L) {\n    let top = lua_gettop(L);\n    let arg = 1;\n    let strfrmt = luaL_checkstring(L, arg);\n    let i = 0;\n    let b = new luaL_Buffer();\n    luaL_buffinit(L, b);\n    while (i < strfrmt.length) {\n        if (strfrmt[i] !== L_ESC) {\n            luaL_addchar(b, strfrmt[i++]);\n        } else if (strfrmt[++i] === L_ESC) {\n            luaL_addchar(b, strfrmt[i++]); /* %% */\n        } else { /* format item */\n            let form = [];  /* to store the format ('%...') */\n            if (++arg > top)\n                luaL_argerror(L, arg, to_luastring(\"no value\"));\n            i = scanformat(L, strfrmt, i, form);\n            switch (String.fromCharCode(strfrmt[i++])) {\n                case 'c': {\n                    // sprintf(String.fromCharCode(...form), luaL_checkinteger(L, arg));\n                    luaL_addchar(b, luaL_checkinteger(L, arg));\n                    break;\n                }\n                case 'd': case 'i':\n                case 'o': case 'u': case 'x': case 'X': {\n                    let n = luaL_checkinteger(L, arg);\n                    addlenmod(form, to_luastring(LUA_INTEGER_FRMLEN, true));\n                    luaL_addstring(b, to_luastring(sprintf(String.fromCharCode(...form), n)));\n                    break;\n                }\n                case 'a': case 'A': {\n                    addlenmod(form, to_luastring(LUA_INTEGER_FRMLEN, true));\n                    luaL_addstring(b, lua_number2strx(L, form, luaL_checknumber(L, arg)));\n                    break;\n                }\n                case 'e': case 'E': case 'f':\n                case 'g': case 'G': {\n                    let n = luaL_checknumber(L, arg);\n                    addlenmod(form, to_luastring(LUA_INTEGER_FRMLEN, true));\n                    luaL_addstring(b, to_luastring(sprintf(String.fromCharCode(...form), n)));\n                    break;\n                }\n                case 'q': {\n                    addliteral(L, b, arg);\n                    break;\n                }\n                case 's': {\n                    let s = luaL_tolstring(L, arg);\n                    if (form.length <= 2 || form[2] === 0) {  /* no modifiers? */\n                        luaL_addvalue(b);  /* keep entire string */\n                    } else {\n                        luaL_argcheck(L, s.length === strlen(s), arg, \"string contains zeros\");\n                        if (luastring_indexOf(form, 46 /* '.'.charCodeAt(0) */) < 0 && s.length >= 100) {\n                            /* no precision and string is too long to be formatted */\n                            luaL_addvalue(b);  /* keep entire string */\n                        } else {  /* format the string into 'buff' */\n                            // TODO: will fail if s is not valid UTF-8\n                            luaL_addstring(b, to_luastring(sprintf(String.fromCharCode(...form), to_jsstring(s))));\n                            lua_pop(L, 1);  /* remove result from 'luaL_tolstring' */\n                        }\n                    }\n                    break;\n                }\n                default: {  /* also treat cases 'pnLlh' */\n                    return luaL_error(L, to_luastring(\"invalid option '%%%c' to 'format'\"), strfrmt[i-1]);\n                }\n            }\n        }\n    }\n    luaL_pushresult(b);\n    return 1;\n};\n\n/* value used for padding */\nconst LUAL_PACKPADBYTE = 0x00;\n\n/* maximum size for the binary representation of an integer */\nconst MAXINTSIZE = 16;\n\nconst SZINT = 4; // Size of lua_Integer\n\n/* number of bits in a character */\nconst NB = 8;\n\n/* mask for one character (NB 1's) */\nconst MC = ((1 << NB) - 1);\n\nconst MAXALIGN = 8;\n\n/*\n** information to pack/unpack stuff\n*/\nclass Header {\n    constructor(L) {\n        this.L = L;\n        this.islittle = true;\n        this.maxalign = 1;\n    }\n}\n\n/*\n** options for pack/unpack\n*/\nconst Kint       = 0; /* signed integers */\nconst Kuint      = 1; /* unsigned integers */\nconst Kfloat     = 2; /* floating-point numbers */\nconst Kchar      = 3; /* fixed-length strings */\nconst Kstring    = 4; /* strings with prefixed length */\nconst Kzstr      = 5; /* zero-terminated strings */\nconst Kpadding   = 6; /* padding */\nconst Kpaddalign = 7; /* padding for alignment */\nconst Knop       = 8; /* no-op (configuration or spaces) */\n\nconst digit = isdigit;\n\nconst getnum = function(fmt, df) {\n    if (fmt.off >= fmt.s.length || !digit(fmt.s[fmt.off]))  /* no number? */\n        return df;  /* return default value */\n    else {\n        let a = 0;\n        do {\n            a = a * 10 + (fmt.s[fmt.off++] - 48 /* '0'.charCodeAt(0) */);\n        } while (fmt.off < fmt.s.length && digit(fmt.s[fmt.off]) && a <= (MAXSIZE - 9)/10);\n        return a;\n    }\n};\n\n/*\n** Read an integer numeral and raises an error if it is larger\n** than the maximum size for integers.\n*/\nconst getnumlimit = function(h, fmt, df) {\n    let sz = getnum(fmt, df);\n    if (sz > MAXINTSIZE || sz <= 0)\n        luaL_error(h.L, to_luastring(\"integral size (%d) out of limits [1,%d]\"), sz, MAXINTSIZE);\n    return sz;\n};\n\n/*\n** Read and classify next option. 'size' is filled with option's size.\n*/\nconst getoption = function(h, fmt) {\n    let r = {\n        opt: fmt.s[fmt.off++],\n        size: 0  /* default */\n    };\n    switch (r.opt) {\n        case 98  /*'b'*/: r.size = 1; r.opt = Kint;   return r; // sizeof(char): 1\n        case 66  /*'B'*/: r.size = 1; r.opt = Kuint;  return r;\n        case 104 /*'h'*/: r.size = 2; r.opt = Kint;   return r; // sizeof(short): 2\n        case 72  /*'H'*/: r.size = 2; r.opt = Kuint;  return r;\n        case 108 /*'l'*/: r.size = 4; r.opt = Kint;   return r; // sizeof(long): 4\n        case 76  /*'L'*/: r.size = 4; r.opt = Kuint;  return r;\n        case 106 /*'j'*/: r.size = 4; r.opt = Kint;   return r; // sizeof(lua_Integer): 4\n        case 74  /*'J'*/: r.size = 4; r.opt = Kuint;  return r;\n        case 84  /*'T'*/: r.size = 4; r.opt = Kuint;  return r; // sizeof(size_t): 4\n        case 102 /*'f'*/: r.size = 4; r.opt = Kfloat; return r; // sizeof(float): 4\n        case 100 /*'d'*/: r.size = 8; r.opt = Kfloat; return r; // sizeof(double): 8\n        case 110 /*'n'*/: r.size = 8; r.opt = Kfloat; return r; // sizeof(lua_Number): 8\n        case 105 /*'i'*/: r.size = getnumlimit(h, fmt, 4); r.opt = Kint;    return r; // sizeof(int): 4\n        case 73  /*'I'*/: r.size = getnumlimit(h, fmt, 4); r.opt = Kuint;   return r;\n        case 115 /*'s'*/: r.size = getnumlimit(h, fmt, 4); r.opt = Kstring; return r;\n        case 99  /*'c'*/: {\n            r.size = getnum(fmt, -1);\n            if (r.size === -1)\n                luaL_error(h.L, to_luastring(\"missing size for format option 'c'\"));\n            r.opt = Kchar;\n            return r;\n        }\n        case 122 /*'z'*/:             r.opt = Kzstr;      return r;\n        case 120 /*'x'*/: r.size = 1; r.opt = Kpadding;   return r;\n        case 88  /*'X'*/:             r.opt = Kpaddalign; return r;\n        case 32  /*' '*/: break;\n        case 60  /*'<'*/: h.islittle = true; break;\n        case 62  /*'>'*/: h.islittle = false; break;\n        case 61  /*'='*/: h.islittle = true; break;\n        case 33  /*'!'*/: h.maxalign = getnumlimit(h, fmt, MAXALIGN); break;\n        default: luaL_error(h.L, to_luastring(\"invalid format option '%c'\"), r.opt);\n    }\n    r.opt = Knop;\n    return r;\n};\n\n/*\n** Read, classify, and fill other details about the next option.\n** 'psize' is filled with option's size, 'notoalign' with its\n** alignment requirements.\n** Local variable 'size' gets the size to be aligned. (Kpadal option\n** always gets its full alignment, other options are limited by\n** the maximum alignment ('maxalign'). Kchar option needs no alignment\n** despite its size.\n*/\nconst getdetails = function(h, totalsize, fmt) {\n    let r = {\n        opt: NaN,\n        size: NaN,\n        ntoalign: NaN\n    };\n\n    let opt = getoption(h, fmt);\n    r.size = opt.size;\n    r.opt = opt.opt;\n    let align = r.size;  /* usually, alignment follows size */\n    if (r.opt === Kpaddalign) {  /* 'X' gets alignment from following option */\n        if (fmt.off >= fmt.s.length || fmt.s[fmt.off] === 0)\n            luaL_argerror(h.L, 1, to_luastring(\"invalid next option for option 'X'\"));\n        else {\n            let o = getoption(h, fmt);\n            align = o.size;\n            o = o.opt;\n            if (o === Kchar || align === 0)\n                luaL_argerror(h.L, 1, to_luastring(\"invalid next option for option 'X'\"));\n        }\n    }\n    if (align <= 1 || r.opt === Kchar)  /* need no alignment? */\n        r.ntoalign = 0;\n    else {\n        if (align > h.maxalign)  /* enforce maximum alignment */\n            align = h.maxalign;\n        if ((align & (align -1)) !== 0)  /* is 'align' not a power of 2? */\n            luaL_argerror(h.L, 1, to_luastring(\"format asks for alignment not power of 2\"));\n        r.ntoalign = (align - (totalsize & (align - 1))) & (align - 1);\n    }\n    return r;\n};\n\n/*\n** Pack integer 'n' with 'size' bytes and 'islittle' endianness.\n** The final 'if' handles the case when 'size' is larger than\n** the size of a Lua integer, correcting the extra sign-extension\n** bytes if necessary (by default they would be zeros).\n*/\nconst packint = function(b, n, islittle, size, neg) {\n    let buff = luaL_prepbuffsize(b, size);\n    buff[islittle ? 0 : size - 1] = n & MC;  /* first byte */\n    for (let i = 1; i < size; i++) {\n        n >>= NB;\n        buff[islittle ? i : size - 1 - i] = n & MC;\n    }\n    if (neg && size > SZINT) {  /* negative number need sign extension? */\n        for (let i = SZINT; i < size; i++)  /* correct extra bytes */\n            buff[islittle ? i : size - 1 - i] = MC;\n    }\n    luaL_addsize(b, size);  /* add result to buffer */\n};\n\nconst str_pack = function(L) {\n    let b = new luaL_Buffer();\n    let h = new Header(L);\n    let fmt = {\n        s: luaL_checkstring(L, 1),  /* format string */\n        off: 0\n    };\n    let arg = 1;  /* current argument to pack */\n    let totalsize = 0;  /* accumulate total size of result */\n    lua_pushnil(L);  /* mark to separate arguments from string buffer */\n    luaL_buffinit(L, b);\n    while (fmt.off < fmt.s.length) {\n        let details = getdetails(h, totalsize, fmt);\n        let opt = details.opt;\n        let size = details.size;\n        let ntoalign = details.ntoalign;\n        totalsize += ntoalign + size;\n        while (ntoalign-- > 0)\n            luaL_addchar(b, LUAL_PACKPADBYTE);  /* fill alignment */\n        arg++;\n        switch (opt) {\n            case Kint: {  /* signed integers */\n                let n = luaL_checkinteger(L, arg);\n                if (size < SZINT) {  /* need overflow check? */\n                    let lim = 1 << (size * 8) - 1;\n                    luaL_argcheck(L, -lim <= n && n < lim, arg, \"integer overflow\");\n                }\n                packint(b, n, h.islittle, size, n < 0);\n                break;\n            }\n            case Kuint: {  /* unsigned integers */\n                let n = luaL_checkinteger(L, arg);\n                if (size < SZINT)\n                    luaL_argcheck(L, (n>>>0) < (1 << (size * NB)), arg, \"unsigned overflow\");\n                packint(b, n>>>0, h.islittle, size, false);\n                break;\n            }\n            case Kfloat: {  /* floating-point options */\n                let buff = luaL_prepbuffsize(b, size);\n                let n = luaL_checknumber(L, arg);  /* get argument */\n                let dv = new DataView(buff.buffer, buff.byteOffset, buff.byteLength);\n                if (size === 4) dv.setFloat32(0, n, h.islittle);\n                else dv.setFloat64(0, n, h.islittle);\n                luaL_addsize(b, size);\n                break;\n            }\n            case Kchar: {  /* fixed-size string */\n                let s = luaL_checkstring(L, arg);\n                let len = s.length;\n                luaL_argcheck(L, len <= size, arg, \"string longer than given size\");\n                luaL_addlstring(b, s, len);  /* add string */\n                while (len++ < size)  /* pad extra space */\n                    luaL_addchar(b, LUAL_PACKPADBYTE);\n                break;\n            }\n            case Kstring: {  /* strings with length count */\n                let s = luaL_checkstring(L, arg);\n                let len = s.length;\n                luaL_argcheck(L,\n                    size >= 4 /* sizeof(size_t) */ || len < (1 << (size * NB)),\n                    arg, \"string length does not fit in given size\");\n                packint(b, len, h.islittle, size, 0);  /* pack length */\n                luaL_addlstring(b, s, len);\n                totalsize += len;\n                break;\n            }\n            case Kzstr: {  /* zero-terminated string */\n                let s = luaL_checkstring(L, arg);\n                let len = s.length;\n                luaL_argcheck(L, luastring_indexOf(s, 0) < 0, arg, \"strings contains zeros\");\n                luaL_addlstring(b, s, len);\n                luaL_addchar(b, 0);  /* add zero at the end */\n                totalsize += len + 1;\n                break;\n            }\n            case Kpadding: luaL_addchar(b, LUAL_PACKPADBYTE); /* fall through */\n            case Kpaddalign: case Knop:\n                arg--;  /* undo increment */\n                break;\n        }\n    }\n    luaL_pushresult(b);\n    return 1;\n};\n\nconst str_reverse = function(L) {\n    let s = luaL_checkstring(L, 1);\n    let l = s.length;\n    let r = new Uint8Array(l);\n    for (let i=0; i<l; i++)\n        r[i] = s[l-1-i];\n    lua_pushstring(L, r);\n    return 1;\n};\n\nconst str_lower = function(L) {\n    let s = luaL_checkstring(L, 1);\n    let l = s.length;\n    let r = new Uint8Array(l);\n    for (let i=0; i<l; i++) {\n        let c = s[i];\n        if (isupper(c))\n            c = c | 0x20;\n        r[i] = c;\n    }\n    lua_pushstring(L, r);\n    return 1;\n};\n\nconst str_upper = function(L) {\n    let s = luaL_checkstring(L, 1);\n    let l = s.length;\n    let r = new Uint8Array(l);\n    for (let i=0; i<l; i++) {\n        let c = s[i];\n        if (islower(c))\n            c = c & 0xdf;\n        r[i] = c;\n    }\n    lua_pushstring(L, r);\n    return 1;\n};\n\nconst str_rep = function(L) {\n    let s = luaL_checkstring(L, 1);\n    let l = s.length;\n    let n = luaL_checkinteger(L, 2);\n    let sep = luaL_optstring(L, 3, \"\");\n    let lsep = sep.length;\n    if (n <= 0) lua_pushliteral(L, \"\");\n    else if (l + lsep < l || l + lsep > MAXSIZE / n)  /* may overflow? */\n        return luaL_error(L, to_luastring(\"resulting string too large\"));\n    else {\n        let totallen = n * l + (n - 1) * lsep;\n        let b = new luaL_Buffer();\n        let p = luaL_buffinitsize(L, b, totallen);\n        let pi = 0;\n        while (n-- > 1) {  /* first n-1 copies (followed by separator) */\n            p.set(s, pi);\n            pi += l;\n            if (lsep > 0) {  /* empty 'memcpy' is not that cheap */\n                p.set(sep, pi);\n                pi += lsep;\n            }\n        }\n        p.set(s, pi);  /* last copy (not followed by separator) */\n        luaL_pushresultsize(b, totallen);\n    }\n    return 1;\n};\n\nconst str_byte = function(L) {\n    let s = luaL_checkstring(L, 1);\n    let l = s.length;\n    let posi = posrelat(luaL_optinteger(L, 2, 1), l);\n    let pose = posrelat(luaL_optinteger(L, 3, posi), l);\n\n    if (posi < 1) posi = 1;\n    if (pose > l) pose = l;\n    if (posi > pose) return 0;  /* empty interval; return no values */\n    if (pose - posi >= Number.MAX_SAFE_INTEGER)  /* arithmetic overflow? */\n        return luaL_error(L, \"string slice too long\");\n\n    let n = (pose - posi) + 1;\n    luaL_checkstack(L, n, \"string slice too long\");\n    for (let i = 0; i < n; i++)\n        lua_pushinteger(L, s[posi + i - 1]);\n    return n;\n};\n\nconst str_packsize = function(L) {\n    let h = new Header(L);\n    let fmt = {\n        s: luaL_checkstring(L, 1),\n        off: 0\n    };\n    let totalsize = 0;  /* accumulate total size of result */\n    while (fmt.off < fmt.s.length) {\n        let details = getdetails(h, totalsize, fmt);\n        let opt = details.opt;\n        let size = details.size;\n        let ntoalign = details.ntoalign;\n        size += ntoalign;  /* total space used by option */\n        luaL_argcheck(L, totalsize <= MAXSIZE - size, 1, \"format result too large\");\n        totalsize += size;\n        switch (opt) {\n            case Kstring:  /* strings with length count */\n            case Kzstr:    /* zero-terminated string */\n                luaL_argerror(L, 1, \"variable-length format\");\n                /* call never return, but to avoid warnings: *//* fall through */\n            default:  break;\n        }\n    }\n    lua_pushinteger(L, totalsize);\n    return 1;\n};\n\n/*\n** Unpack an integer with 'size' bytes and 'islittle' endianness.\n** If size is smaller than the size of a Lua integer and integer\n** is signed, must do sign extension (propagating the sign to the\n** higher bits); if size is larger than the size of a Lua integer,\n** it must check the unread bytes to see whether they do not cause an\n** overflow.\n*/\nconst unpackint = function(L, str, islittle, size, issigned) {\n    let res = 0;\n    let limit = size <= SZINT ? size : SZINT;\n    for (let i = limit - 1; i >= 0; i--) {\n        res <<= NB;\n        res |= str[islittle ? i : size - 1 - i];\n    }\n    if (size < SZINT) {  /* real size smaller than lua_Integer? */\n        if (issigned) {  /* needs sign extension? */\n            let mask = 1 << (size * NB - 1);\n            res = ((res ^ mask) - mask);  /* do sign extension */\n        }\n    } else if (size > SZINT) {  /* must check unread bytes */\n        let mask = !issigned || res >= 0 ? 0 : MC;\n        for (let i = limit; i < size; i++) {\n            if (str[islittle ? i : size - 1 - i] !== mask)\n                luaL_error(L, to_luastring(\"%d-byte integer does not fit into Lua Integer\"), size);\n        }\n    }\n    return res;\n};\n\nconst unpacknum = function(L, b, islittle, size) {\n    lualib.lua_assert(b.length >= size);\n\n    let dv = new DataView(new ArrayBuffer(size));\n    for (let i = 0; i < size; i++)\n        dv.setUint8(i, b[i], islittle);\n\n    if (size == 4) return dv.getFloat32(0, islittle);\n    else return dv.getFloat64(0, islittle);\n};\n\nconst str_unpack = function(L) {\n    let h = new Header(L);\n    let fmt = {\n        s: luaL_checkstring(L, 1),\n        off: 0\n    };\n    let data = luaL_checkstring(L, 2);\n    let ld = data.length;\n    let pos = posrelat(luaL_optinteger(L, 3, 1), ld) - 1;\n    let n = 0;  /* number of results */\n    luaL_argcheck(L, pos <= ld && pos >= 0, 3, \"initial position out of string\");\n    while (fmt.off < fmt.s.length) {\n        let details = getdetails(h, pos, fmt);\n        let opt = details.opt;\n        let size = details.size;\n        let ntoalign = details.ntoalign;\n        if (/*ntoalign + size > ~pos ||*/ pos + ntoalign + size > ld)\n            luaL_argerror(L, 2, to_luastring(\"data string too short\"));\n        pos += ntoalign;  /* skip alignment */\n        /* stack space for item + next position */\n        luaL_checkstack(L, 2, \"too many results\");\n        n++;\n        switch (opt) {\n            case Kint:\n            case Kuint: {\n                let res = unpackint(L, data.subarray(pos), h.islittle, size, opt === Kint);\n                lua_pushinteger(L, res);\n                break;\n            }\n            case Kfloat: {\n                let res = unpacknum(L, data.subarray(pos), h.islittle, size);\n                lua_pushnumber(L, res);\n                break;\n            }\n            case Kchar: {\n                lua_pushstring(L, data.subarray(pos, pos + size));\n                break;\n            }\n            case Kstring: {\n                let len = unpackint(L, data.subarray(pos), h.islittle, size, 0);\n                luaL_argcheck(L, pos + len + size <= ld, 2, \"data string too short\");\n                lua_pushstring(L, data.subarray(pos + size, pos + size + len));\n                pos += len;  /* skip string */\n                break;\n            }\n            case Kzstr: {\n                let e = luastring_indexOf(data, 0, pos);\n                if (e === -1) e = data.length - pos;\n                lua_pushstring(L, data.subarray(pos, e));\n                pos = e + 1;  /* skip string plus final '\\0' */\n                break;\n            }\n            case Kpaddalign: case Kpadding: case Knop:\n                n--;  /* undo increment */\n                break;\n        }\n        pos += size;\n    }\n    lua_pushinteger(L, pos + 1);  /* next position */\n    return n + 1;\n};\n\nconst CAP_UNFINISHED = -1;\nconst CAP_POSITION   = -2;\nconst MAXCCALLS      = 200;\nconst SPECIALS       = to_luastring(\"^$*+?.([%-\");\n\nclass MatchState {\n    constructor(L) {\n        this.src = null;  /* unmodified source string */\n        this.src_init = null;  /* init of source string */\n        this.src_end = null;  /* end ('\\0') of source string */\n        this.p = null;  /* unmodified pattern string */\n        this.p_end = null;  /* end ('\\0') of pattern */\n        this.L = L;\n        this.matchdepth = NaN;  /* control for recursive depth */\n        this.level = NaN;  /* total number of captures (finished or unfinished) */\n        this.capture = [];\n    }\n}\n\nconst check_capture = function(ms, l) {\n    l = l - 49 /* '1'.charCodeAt(0) */;\n    if (l < 0 || l >= ms.level || ms.capture[l].len === CAP_UNFINISHED)\n        return luaL_error(ms.L, to_luastring(\"invalid capture index %%%d\"), l + 1);\n    return l;\n};\n\nconst capture_to_close = function(ms) {\n    let level = ms.level;\n    for (level--; level >= 0; level--)\n        if (ms.capture[level].len === CAP_UNFINISHED) return level;\n    return luaL_error(ms.L, to_luastring(\"invalid pattern capture\"));\n};\n\nconst classend = function(ms, p) {\n    switch(ms.p[p++]) {\n        case L_ESC: {\n            if (p === ms.p_end)\n                luaL_error(ms.L, to_luastring(\"malformed pattern (ends with '%%')\"));\n            return p + 1;\n        }\n        case 91 /* '['.charCodeAt(0) */: {\n            if (ms.p[p] === 94 /* '^'.charCodeAt(0) */) p++;\n            do {  /* look for a ']' */\n                if (p === ms.p_end)\n                    luaL_error(ms.L, to_luastring(\"malformed pattern (missing ']')\"));\n                if (ms.p[p++] === L_ESC && p < ms.p_end)\n                    p++;  /* skip escapes (e.g. '%]') */\n            } while (ms.p[p] !== 93 /* ']'.charCodeAt(0) */);\n            return p + 1;\n        }\n        default: {\n            return p;\n        }\n    }\n};\n\nconst match_class = function(c, cl) {\n    switch (cl) {\n        case 97  /* 'a'.charCodeAt(0) */: return  isalpha(c);\n        case 65  /* 'A'.charCodeAt(0) */: return !isalpha(c);\n        case 99  /* 'c'.charCodeAt(0) */: return  iscntrl(c);\n        case 67  /* 'C'.charCodeAt(0) */: return !iscntrl(c);\n        case 100 /* 'd'.charCodeAt(0) */: return  isdigit(c);\n        case 68  /* 'D'.charCodeAt(0) */: return !isdigit(c);\n        case 103 /* 'g'.charCodeAt(0) */: return  isgraph(c);\n        case 71  /* 'G'.charCodeAt(0) */: return !isgraph(c);\n        case 108 /* 'l'.charCodeAt(0) */: return  islower(c);\n        case 76  /* 'L'.charCodeAt(0) */: return !islower(c);\n        case 112 /* 'p'.charCodeAt(0) */: return  ispunct(c);\n        case 80  /* 'P'.charCodeAt(0) */: return !ispunct(c);\n        case 115 /* 's'.charCodeAt(0) */: return  isspace(c);\n        case 83  /* 'S'.charCodeAt(0) */: return !isspace(c);\n        case 117 /* 'u'.charCodeAt(0) */: return  isupper(c);\n        case 85  /* 'U'.charCodeAt(0) */: return !isupper(c);\n        case 119 /* 'w'.charCodeAt(0) */: return  isalnum(c);\n        case 87  /* 'W'.charCodeAt(0) */: return !isalnum(c);\n        case 120 /* 'x'.charCodeAt(0) */: return  isxdigit(c);\n        case 88  /* 'X'.charCodeAt(0) */: return !isxdigit(c);\n        case 122 /* 'z'.charCodeAt(0) */: return (c === 0);  /* deprecated option */\n        case 90  /* 'z'.charCodeAt(0) */: return (c !== 0);  /* deprecated option */\n        default: return (cl === c);\n    }\n};\n\nconst matchbracketclass = function(ms, c, p, ec) {\n    let sig = true;\n    if (ms.p[p + 1] === 94 /* '^'.charCodeAt(0) */) {\n        sig = false;\n        p++;  /* skip the '^' */\n    }\n    while (++p < ec) {\n        if (ms.p[p] === L_ESC) {\n            p++;\n            if (match_class(c, ms.p[p]))\n                return sig;\n        } else if (ms.p[p + 1] === 45 /* '-'.charCodeAt(0) */ && p + 2 < ec) {\n            p += 2;\n            if (ms.p[p - 2] <= c && c <= ms.p[p])\n                return sig;\n        } else if (ms.p[p] === c) return sig;\n    }\n    return !sig;\n};\n\nconst singlematch = function(ms, s, p, ep) {\n    if (s >= ms.src_end)\n        return false;\n    else {\n        let c = ms.src[s];\n        switch (ms.p[p]) {\n            case 46 /* '.'.charCodeAt(0) */: return true;  /* matches any char */\n            case L_ESC: return match_class(c, ms.p[p + 1]);\n            case 91 /* '['.charCodeAt(0) */: return matchbracketclass(ms, c, p, ep - 1);\n            default: return ms.p[p] === c;\n        }\n    }\n};\n\nconst matchbalance = function(ms, s, p) {\n    if (p >= ms.p_end - 1)\n        luaL_error(ms.L, to_luastring(\"malformed pattern (missing arguments to '%%b'\"));\n    if (ms.src[s] !== ms.p[p])\n        return null;\n    else {\n        let b = ms.p[p];\n        let e = ms.p[p + 1];\n        let cont = 1;\n        while (++s < ms.src_end) {\n            if (ms.src[s] === e) {\n                if (--cont === 0) return s + 1;\n            }\n            else if (ms.src[s] === b) cont++;\n        }\n    }\n    return null;  /* string ends out of balance */\n};\n\nconst max_expand = function(ms, s, p, ep) {\n    let i = 0;  /* counts maximum expand for item */\n    while (singlematch(ms, s + i, p, ep))\n        i++;\n    /* keeps trying to match with the maximum repetitions */\n    while (i >= 0) {\n        let res = match(ms, s + i, ep + 1);\n        if (res) return res;\n        i--;  /* else didn't match; reduce 1 repetition to try again */\n    }\n    return null;\n};\n\nconst min_expand = function(ms, s, p, ep) {\n    for (;;) {\n        let res = match(ms, s, ep + 1);\n        if (res !== null)\n            return res;\n        else if (singlematch(ms, s, p, ep))\n            s++;  /* try with one more repetition */\n        else return null;\n    }\n};\n\nconst start_capture = function(ms, s, p, what) {\n    let level = ms.level;\n    if (level >= LUA_MAXCAPTURES) luaL_error(ms.L, to_luastring(\"too many captures\"));\n    ms.capture[level] = ms.capture[level] ? ms.capture[level] : {};\n    ms.capture[level].init = s;\n    ms.capture[level].len = what;\n    ms.level = level + 1;\n    let res;\n    if ((res = match(ms, s, p)) === null)  /* match failed? */\n        ms.level--;  /* undo capture */\n    return res;\n};\n\nconst end_capture = function(ms, s, p) {\n    let l = capture_to_close(ms);\n    ms.capture[l].len = s - ms.capture[l].init;  /* close capture */\n    let res;\n    if ((res = match(ms, s, p)) === null)  /* match failed? */\n        ms.capture[l].len = CAP_UNFINISHED;  /* undo capture */\n    return res;\n};\n\n/* Compare the elements of arrays 'a' and 'b' to see if they contain the same elements */\nconst array_cmp = function(a, ai, b, bi, len) {\n    return luastring_eq(a.subarray(ai, ai+len), b.subarray(bi, bi+len));\n};\n\nconst match_capture = function(ms, s, l) {\n    l = check_capture(ms, l);\n    let len = ms.capture[l].len;\n    if ((ms.src_end-s) >= len && array_cmp(ms.src, ms.capture[l].init, ms.src, s, len))\n        return s+len;\n    else return null;\n};\n\nconst match = function(ms, s, p) {\n    let gotodefault = false;\n    let gotoinit = true;\n\n    if (ms.matchdepth-- === 0)\n        luaL_error(ms.L, to_luastring(\"pattern too complex\"));\n\n    while (gotoinit || gotodefault) {\n        gotoinit = false;\n        if (p !== ms.p_end) {  /* end of pattern? */\n            switch (gotodefault ? void 0 : ms.p[p]) {\n                case 40 /* '('.charCodeAt(0) */: {  /* start capture */\n                    if (ms.p[p + 1] === 41 /* ')'.charCodeAt(0) */)  /* position capture? */\n                        s = start_capture(ms, s, p + 2, CAP_POSITION);\n                    else\n                        s = start_capture(ms, s, p + 1, CAP_UNFINISHED);\n                    break;\n                }\n                case 41 /* ')'.charCodeAt(0) */: {  /* end capture */\n                    s = end_capture(ms, s, p + 1);\n                    break;\n                }\n                case 36 /* '$'.charCodeAt(0) */: {\n                    if (p + 1 !== ms.p_end) {  /* is the '$' the last char in pattern? */\n                        gotodefault = true;  /* no; go to default */\n                        break;\n                    }\n                    s = (ms.src.length - s) === 0 ? s : null;  /* check end of string */\n                    break;\n                }\n                case L_ESC: {  /* escaped sequences not in the format class[*+?-]? */\n                    switch (ms.p[p + 1]) {\n                        case 98 /* 'b'.charCodeAt(0) */: {  /* balanced string? */\n                            s = matchbalance(ms, s, p + 2);\n                            if (s !== null) {\n                                p += 4;\n                                gotoinit = true;\n                            }\n                            break;\n                        }\n                        case 102 /* 'f'.charCodeAt(0) */: {  /* frontier? */\n                            p += 2;\n                            if (ms.p[p] !== 91 /* '['.charCodeAt(0) */)\n                                luaL_error(ms.L, to_luastring(\"missing '[' after '%%f' in pattern\"));\n                            let ep = classend(ms, p);  /* points to what is next */\n                            let previous = s === ms.src_init ? 0 : ms.src[s-1];\n                            if (!matchbracketclass(ms, previous, p, ep - 1) && matchbracketclass(ms, (s===ms.src_end)?0:ms.src[s], p, ep - 1)) {\n                                p = ep; gotoinit = true; break;\n                            }\n                            s = null;  /* match failed */\n                            break;\n                        }\n                        case 48: case 49: case 50: case 51: case 52:\n                        case 53: case 54: case 55: case 56: case 57: {  /* capture results (%0-%9)? */\n                            s = match_capture(ms, s, ms.p[p + 1]);\n                            if (s !== null) {\n                                p += 2; gotoinit = true;\n                            }\n                            break;\n                        }\n                        default: gotodefault = true;\n                    }\n                    break;\n                }\n                default: {  /* pattern class plus optional suffix */\n                    gotodefault = false;\n                    let ep = classend(ms, p);  /* points to optional suffix */\n                    /* does not match at least once? */\n                    if (!singlematch(ms, s, p, ep)) {\n                        if (ms.p[ep] === 42 /* '*'.charCodeAt(0) */ ||\n                            ms.p[ep] === 63 /* '?'.charCodeAt(0) */ ||\n                            ms.p[ep] === 45 /* '-'.charCodeAt(0) */\n                        ) {  /* accept empty? */\n                            p = ep + 1; gotoinit = true; break;\n                        } else  /* '+' or no suffix */\n                            s = null;  /* fail */\n                    } else {  /* matched once */\n                        switch (ms.p[ep]) {  /* handle optional suffix */\n                            case 63 /* '?'.charCodeAt(0) */: {  /* optional */\n                                let res;\n                                if ((res = match(ms, s + 1, ep + 1)) !== null)\n                                    s = res;\n                                else {\n                                    p = ep + 1; gotoinit = true;\n                                }\n                                break;\n                            }\n                            case 43 /* '+'.charCodeAt(0) */:  /* 1 or more repetitions */\n                                s++;  /* 1 match already done */\n                                /* fall through */\n                            case 42 /* '*'.charCodeAt(0) */:  /* 0 or more repetitions */\n                                s = max_expand(ms, s, p, ep);\n                                break;\n                            case 45 /* '-'.charCodeAt(0) */:  /* 0 or more repetitions (minimum) */\n                                s = min_expand(ms, s, p, ep);\n                                break;\n                            default:  /* no suffix */\n                                s++; p = ep; gotoinit = true;\n                        }\n                    }\n                    break;\n                }\n            }\n        }\n    }\n    ms.matchdepth++;\n    return s;\n};\n\nconst push_onecapture = function(ms, i, s, e) {\n    if (i >= ms.level) {\n        if (i === 0)\n            lua_pushlstring(ms.L, ms.src.subarray(s, e), e - s);  /* add whole match */\n        else\n            luaL_error(ms.L, to_luastring(\"invalid capture index %%%d\"), i + 1);\n    } else {\n        let l = ms.capture[i].len;\n        if (l === CAP_UNFINISHED) luaL_error(ms.L, to_luastring(\"unfinished capture\"));\n        if (l === CAP_POSITION)\n            lua_pushinteger(ms.L, ms.capture[i].init - ms.src_init + 1);\n        else\n            lua_pushlstring(ms.L, ms.src.subarray(ms.capture[i].init), l);\n    }\n};\n\nconst push_captures = function(ms, s, e) {\n    let nlevels = ms.level === 0 && ms.src.subarray(s) ? 1 : ms.level;\n    luaL_checkstack(ms.L, nlevels, \"too many captures\");\n    for (let i = 0; i < nlevels; i++)\n        push_onecapture(ms, i, s, e);\n    return nlevels;  /* number of strings pushed */\n};\n\nconst nospecials = function(p, l) {\n    for (let i=0; i<l; i++) {\n        if (luastring_indexOf(SPECIALS, p[i]) !== -1)\n            return false;\n    }\n    return true;\n};\n\nconst prepstate = function(ms, L, s, ls, p, lp) {\n    ms.L = L;\n    ms.matchdepth = MAXCCALLS;\n    ms.src = s;\n    ms.src_init = 0;\n    ms.src_end = ls;\n    ms.p = p;\n    ms.p_end = lp;\n};\n\nconst reprepstate = function(ms) {\n    ms.level = 0;\n    lualib.lua_assert(ms.matchdepth === MAXCCALLS);\n};\n\nconst find_subarray = function(arr, subarr, from_index) {\n    var i = from_index >>> 0,\n        sl = subarr.length;\n\n    if (sl === 0)\n        return i;\n\n    for (; (i = arr.indexOf(subarr[0], i)) !== -1; i++) {\n        if (luastring_eq(arr.subarray(i, i+sl), subarr))\n            return i;\n    }\n\n    return -1;\n};\n\nconst str_find_aux = function(L, find) {\n    let s = luaL_checkstring(L, 1);\n    let p = luaL_checkstring(L, 2);\n    let ls = s.length;\n    let lp = p.length;\n    let init = posrelat(luaL_optinteger(L, 3, 1), ls);\n    if (init < 1) init = 1;\n    else if (init > ls + 1) {  /* start after string's end? */\n        lua_pushnil(L);  /* cannot find anything */\n        return 1;\n    }\n    /* explicit request or no special characters? */\n    if (find && (lua_toboolean(L, 4) || nospecials(p, lp))) {\n        /* do a plain search */\n        let f = find_subarray(s.subarray(init - 1), p, 0);\n        if (f > -1) {\n            lua_pushinteger(L, init + f);\n            lua_pushinteger(L, init + f + lp - 1);\n            return 2;\n        }\n    } else {\n        let ms = new MatchState(L);\n        let s1 = init - 1;\n        let anchor = p[0] === 94 /* '^'.charCodeAt(0) */;\n        if (anchor) {\n            p = p.subarray(1); lp--;  /* skip anchor character */\n        }\n        prepstate(ms, L, s, ls, p, lp);\n        do {\n            let res;\n            reprepstate(ms);\n            if ((res = match(ms, s1, 0)) !== null) {\n                if (find) {\n                    lua_pushinteger(L, s1 + 1);  /* start */\n                    lua_pushinteger(L, res);   /* end */\n                    return push_captures(ms, null, 0) + 2;\n                } else\n                    return push_captures(ms, s1, res);\n            }\n        } while (s1++ < ms.src_end && !anchor);\n    }\n    lua_pushnil(L);  /* not found */\n    return 1;\n};\n\nconst str_find = function(L) {\n    return str_find_aux(L, 1);\n};\n\nconst str_match = function(L) {\n    return str_find_aux(L, 0);\n};\n\n/* state for 'gmatch' */\nclass GMatchState {\n    constructor() {\n        this.src = NaN;  /* current position */\n        this.p = NaN;  /* pattern */\n        this.lastmatch = NaN;  /* end of last match */\n        this.ms = new MatchState();  /* match state */\n    }\n}\n\nconst gmatch_aux = function(L) {\n    let gm = lua_touserdata(L, lua_upvalueindex(3));\n    gm.ms.L = L;\n    for (let src = gm.src; src <= gm.ms.src_end; src++) {\n        reprepstate(gm.ms);\n        let e;\n        if ((e = match(gm.ms, src, gm.p)) !== null && e !== gm.lastmatch) {\n            gm.src = gm.lastmatch = e;\n            return push_captures(gm.ms, src, e);\n        }\n    }\n    return 0;  /* not found */\n};\n\nconst str_gmatch = function(L) {\n    let s = luaL_checkstring(L, 1);\n    let p = luaL_checkstring(L, 2);\n    let ls = s.length;\n    let lp = p.length;\n    lua_settop(L, 2);  /* keep them on closure to avoid being collected */\n    let gm = new GMatchState();\n    lua_pushlightuserdata(L, gm);\n    prepstate(gm.ms, L, s, ls, p, lp);\n    gm.src = 0;\n    gm.p = 0;\n    gm.lastmatch = null;\n    lua_pushcclosure(L, gmatch_aux, 3);\n    return 1;\n};\n\nconst add_s = function(ms, b, s, e) {\n    let L = ms.L;\n    let news = lua_tostring(L, 3);\n    let l = news.length;\n    for (let i = 0; i < l; i++) {\n        if (news[i] !== L_ESC)\n            luaL_addchar(b, news[i]);\n        else {\n            i++;  /* skip ESC */\n            if (!isdigit(news[i])) {\n                if (news[i] !== L_ESC)\n                    luaL_error(L, to_luastring(\"invalid use of '%c' in replacement string\"), L_ESC);\n                luaL_addchar(b, news[i]);\n            } else if (news[i] === 48 /* '0'.charCodeAt(0) */)\n                luaL_addlstring(b, ms.src.subarray(s, e), e - s);\n            else {\n                push_onecapture(ms, news[i] - 49 /* '1'.charCodeAt(0) */, s, e);\n                luaL_tolstring(L, -1);\n                lua_remove(L, -2);  /* remove original value */\n                luaL_addvalue(b);  /* add capture to accumulated result */\n            }\n        }\n    }\n};\n\nconst add_value = function(ms, b, s, e, tr) {\n    let L = ms.L;\n    switch (tr) {\n        case LUA_TFUNCTION: {\n            lua_pushvalue(L, 3);\n            let n = push_captures(ms, s, e);\n            lua_call(L, n, 1);\n            break;\n        }\n        case LUA_TTABLE: {\n            push_onecapture(ms, 0, s, e);\n            lua_gettable(L, 3);\n            break;\n        }\n        default: {  /* LUA_TNUMBER or LUA_TSTRING */\n            add_s(ms, b, s, e);\n            return;\n        }\n    }\n    if (!lua_toboolean(L, -1)) {  /* nil or false? */\n        lua_pop(L, 1);\n        lua_pushlstring(L, ms.src.subarray(s, e), e - s);  /* keep original text */\n    } else if (!lua_isstring(L, -1))\n        luaL_error(L, to_luastring(\"invalid replacement value (a %s)\"), luaL_typename(L, -1));\n    luaL_addvalue(b);  /* add result to accumulator */\n};\n\nconst str_gsub = function(L) {\n    let src = luaL_checkstring(L, 1);  /* subject */\n    let srcl = src.length;\n    let p = luaL_checkstring(L, 2);  /* pattern */\n    let lp = p.length;\n    let lastmatch = null;  /* end of last match */\n    let tr = lua_type(L, 3);  /* replacement type */\n    let max_s = luaL_optinteger(L, 4, srcl + 1);  /* max replacements */\n    let anchor = p[0] === 94 /* '^'.charCodeAt(0) */;\n    let n = 0;  /* replacement count */\n    let ms = new MatchState(L);\n    let b = new luaL_Buffer();\n    luaL_argcheck(L, tr === LUA_TNUMBER || tr === LUA_TSTRING || tr === LUA_TFUNCTION || tr === LUA_TTABLE, 3,\n        \"string/function/table expected\");\n    luaL_buffinit(L, b);\n    if (anchor) {\n        p = p.subarray(1); lp--;  /* skip anchor character */\n    }\n    prepstate(ms, L, src, srcl, p, lp);\n    src = 0; p = 0;\n    while (n < max_s) {\n        let e;\n        reprepstate(ms);\n        if ((e = match(ms, src, p)) !== null && e !== lastmatch) {  /* match? */\n            n++;\n            add_value(ms, b, src, e, tr);  /* add replacement to buffer */\n            src = lastmatch = e;\n        } else if (src < ms.src_end)  /* otherwise, skip one character */\n            luaL_addchar(b, ms.src[src++]);\n        else break;  /* end of subject */\n        if (anchor) break;\n    }\n    luaL_addlstring(b, ms.src.subarray(src, ms.src_end), ms.src_end - src);\n    luaL_pushresult(b);\n    lua_pushinteger(L, n);  /* number of substitutions */\n    return 2;\n};\n\nconst strlib = {\n    \"byte\":     str_byte,\n    \"char\":     str_char,\n    \"dump\":     str_dump,\n    \"find\":     str_find,\n    \"format\":   str_format,\n    \"gmatch\":   str_gmatch,\n    \"gsub\":     str_gsub,\n    \"len\":      str_len,\n    \"lower\":    str_lower,\n    \"match\":    str_match,\n    \"pack\":     str_pack,\n    \"packsize\": str_packsize,\n    \"rep\":      str_rep,\n    \"reverse\":  str_reverse,\n    \"sub\":      str_sub,\n    \"unpack\":   str_unpack,\n    \"upper\":    str_upper\n};\n\nconst createmetatable = function(L) {\n    lua_createtable(L, 0, 1);  /* table to be metatable for strings */\n    lua_pushliteral(L, \"\");  /* dummy string */\n    lua_pushvalue(L, -2);  /* copy table */\n    lua_setmetatable(L, -2);  /* set table as metatable for strings */\n    lua_pop(L, 1);  /* pop dummy string */\n    lua_pushvalue(L, -2);  /* get string library */\n    lua_setfield(L, -2, to_luastring(\"__index\", true));  /* metatable.__index = string */\n    lua_pop(L, 1);  /* pop metatable */\n};\n\nconst luaopen_string = function(L) {\n    luaL_newlib(L, strlib);\n    createmetatable(L);\n    return 1;\n};\n\nmodule.exports.luaopen_string = luaopen_string;\n", ";\n\nconst {\n    lua_gettop,\n    lua_pushcfunction,\n    lua_pushfstring,\n    lua_pushinteger,\n    lua_pushnil,\n    lua_pushstring,\n    lua_pushvalue,\n    lua_setfield,\n    lua_tointeger\n} = require('./lua.js');\nconst {\n    luaL_Buffer,\n    luaL_addvalue,\n    luaL_argcheck,\n    luaL_buffinit,\n    luaL_checkinteger,\n    luaL_checkstack,\n    luaL_checkstring,\n    luaL_error,\n    luaL_newlib,\n    luaL_optinteger,\n    luaL_pushresult\n} = require('./lauxlib.js');\nconst {\n    luastring_of,\n    to_luastring\n} = require(\"./fengaricore.js\");\n\nconst MAXUNICODE = 0x10FFFF;\n\nconst iscont = function(p) {\n    let c = p & 0xC0;\n    return c === 0x80;\n};\n\n/* translate a relative string position: negative means back from end */\nconst u_posrelat = function(pos, len) {\n    if (pos >= 0) return pos;\n    else if (0 - pos > len) return 0;\n    else return len + pos + 1;\n};\n\n/*\n** Decode one UTF-8 sequence, returning NULL if byte sequence is invalid.\n*/\nconst limits = [0xFF, 0x7F, 0x7FF, 0xFFFF];\nconst utf8_decode = function(s, pos) {\n    let c = s[pos];\n    let res = 0;  /* final result */\n    if (c < 0x80)  /* ascii? */\n        res = c;\n    else {\n        let count = 0;  /* to count number of continuation bytes */\n        while (c & 0x40) {  /* still have continuation bytes? */\n            let cc = s[pos + (++count)];  /* read next byte */\n            if ((cc & 0xC0) !== 0x80)  /* not a continuation byte? */\n                return null;  /* invalid byte sequence */\n            res = (res << 6) | (cc & 0x3F);  /* add lower 6 bits from cont. byte */\n            c <<= 1;  /* to test next bit */\n        }\n        res |= ((c & 0x7F) << (count * 5));  /* add first byte */\n        if (count > 3 || res > MAXUNICODE || res <= limits[count])\n            return null;  /* invalid byte sequence */\n        pos += count;  /* skip continuation bytes read */\n    }\n\n    return {\n        code: res,\n        pos: pos + 1\n    };\n};\n\n/*\n** utf8len(s [, i [, j]]) --> number of characters that start in the\n** range [i,j], or nil + current position if 's' is not well formed in\n** that interval\n*/\nconst utflen = function(L) {\n    let n = 0;\n    let s = luaL_checkstring(L, 1);\n    let len = s.length;\n    let posi = u_posrelat(luaL_optinteger(L, 2, 1), len);\n    let posj = u_posrelat(luaL_optinteger(L, 3, -1), len);\n\n    luaL_argcheck(L, 1 <= posi && --posi <= len, 2, \"initial position out of string\");\n    luaL_argcheck(L, --posj < len, 3, \"final position out of string\");\n\n    while (posi <= posj) {\n        let dec = utf8_decode(s, posi);\n        if (dec === null) { /* conversion error? */\n            lua_pushnil(L);  /* return nil ... */\n            lua_pushinteger(L, posi + 1);  /* ... and current position */\n            return 2;\n        }\n        posi = dec.pos;\n        n++;\n    }\n    lua_pushinteger(L, n);\n    return 1;\n};\n\nconst p_U = to_luastring(\"%U\");\nconst pushutfchar = function(L, arg) {\n    let code = luaL_checkinteger(L, arg);\n    luaL_argcheck(L, 0 <= code && code <= MAXUNICODE, arg, \"value out of range\");\n    lua_pushfstring(L, p_U, code);\n};\n\n/*\n** utfchar(n1, n2, ...)  -> char(n1)..char(n2)...\n*/\nconst utfchar = function(L) {\n    let n = lua_gettop(L);  /* number of arguments */\n    if (n === 1)  /* optimize common case of single char */\n        pushutfchar(L, 1);\n    else {\n        let b = new luaL_Buffer();\n        luaL_buffinit(L, b);\n        for (let i = 1; i <= n; i++) {\n            pushutfchar(L, i);\n            luaL_addvalue(b);\n        }\n        luaL_pushresult(b);\n    }\n    return 1;\n};\n\n/*\n** offset(s, n, [i])  -> index where n-th character counting from\n**   position 'i' starts; 0 means character at 'i'.\n*/\nconst byteoffset = function(L) {\n    let s = luaL_checkstring(L, 1);\n    let n = luaL_checkinteger(L, 2);\n    let posi = n >= 0 ? 1 : s.length + 1;\n    posi = u_posrelat(luaL_optinteger(L, 3, posi), s.length);\n\n    luaL_argcheck(L, 1 <= posi && --posi <= s.length, 3, \"position out of range\");\n\n    if (n === 0) {\n        /* find beginning of current byte sequence */\n        while (posi > 0 && iscont(s[posi])) posi--;\n    } else {\n        if (iscont(s[posi]))\n            luaL_error(L, \"initial position is a continuation byte\");\n\n        if (n < 0) {\n            while (n < 0 && posi > 0) {  /* move back */\n                do {  /* find beginning of previous character */\n                    posi--;\n                } while (posi > 0 && iscont(s[posi]));\n                n++;\n            }\n        } else {\n            n--;  /* do not move for 1st character */\n            while (n > 0 && posi < s.length) {\n                do {  /* find beginning of next character */\n                    posi++;\n                } while (iscont(s[posi]));  /* (cannot pass final '\\0') */\n                n--;\n            }\n        }\n    }\n\n    if (n === 0)  /* did it find given character? */\n        lua_pushinteger(L, posi + 1);\n    else  /* no such character */\n        lua_pushnil(L);\n\n    return 1;\n};\n\n/*\n** codepoint(s, [i, [j]])  -> returns codepoints for all characters\n** that start in the range [i,j]\n*/\nconst codepoint = function(L) {\n    let s = luaL_checkstring(L, 1);\n    let posi = u_posrelat(luaL_optinteger(L, 2, 1), s.length);\n    let pose = u_posrelat(luaL_optinteger(L, 3, posi), s.length);\n\n    luaL_argcheck(L, posi >= 1, 2, \"out of range\");\n    luaL_argcheck(L, pose <= s.length, 3, \"out of range\");\n\n    if (posi > pose) return 0;  /* empty interval; return no values */\n    if (pose - posi >= Number.MAX_SAFE_INTEGER)\n        return luaL_error(L, \"string slice too long\");\n    let n = (pose - posi) + 1;\n    luaL_checkstack(L, n, \"string slice too long\");\n    n = 0;\n    for (posi -= 1; posi < pose;) {\n        let dec = utf8_decode(s, posi);\n        if (dec === null)\n            return luaL_error(L, \"invalid UTF-8 code\");\n        lua_pushinteger(L, dec.code);\n        posi = dec.pos;\n        n++;\n    }\n    return n;\n};\n\nconst iter_aux = function(L) {\n    let s = luaL_checkstring(L, 1);\n    let len = s.length;\n    let n = lua_tointeger(L, 2) - 1;\n\n    if (n < 0)  /* first iteration? */\n        n = 0;  /* start from here */\n    else if (n < len) {\n        n++;  /* skip current byte */\n        while (iscont(s[n])) n++;  /* and its continuations */\n    }\n\n    if (n >= len)\n        return 0;  /* no more codepoints */\n    else {\n        let dec = utf8_decode(s, n);\n        if (dec === null || iscont(s[dec.pos]))\n            return luaL_error(L, to_luastring(\"invalid UTF-8 code\"));\n        lua_pushinteger(L, n + 1);\n        lua_pushinteger(L, dec.code);\n        return 2;\n    }\n};\n\nconst iter_codes = function(L) {\n    luaL_checkstring(L, 1);\n    lua_pushcfunction(L, iter_aux);\n    lua_pushvalue(L, 1);\n    lua_pushinteger(L, 0);\n    return 3;\n};\n\nconst funcs = {\n    \"char\":      utfchar,\n    \"codepoint\": codepoint,\n    \"codes\":     iter_codes,\n    \"len\":       utflen,\n    \"offset\":    byteoffset\n};\n\n/* pattern to match a single UTF-8 character */\nconst UTF8PATT = luastring_of(91, 0, 45, 127, 194, 45, 244, 93, 91, 128, 45, 191, 93, 42);\n\nconst luaopen_utf8 = function(L) {\n    luaL_newlib(L, funcs);\n    lua_pushstring(L, UTF8PATT);\n    lua_setfield(L, -2, to_luastring(\"charpattern\", true));\n    return 1;\n};\n\nmodule.exports.luaopen_utf8 = luaopen_utf8;\n", ";\n\nconst {\n    LUA_OPLT,\n    LUA_TNUMBER,\n    lua_compare,\n    lua_gettop,\n    lua_isinteger,\n    lua_isnoneornil,\n    lua_pushboolean,\n    lua_pushinteger,\n    lua_pushliteral,\n    lua_pushnil,\n    lua_pushnumber,\n    lua_pushvalue,\n    lua_setfield,\n    lua_settop,\n    lua_tointeger,\n    lua_tointegerx,\n    lua_type\n} = require('./lua.js');\nconst {\n    luaL_argcheck,\n    luaL_argerror,\n    luaL_checkany,\n    luaL_checkinteger,\n    luaL_checknumber,\n    luaL_error,\n    luaL_newlib,\n    luaL_optnumber\n} = require('./lauxlib.js');\nconst {\n    LUA_MAXINTEGER,\n    LUA_MININTEGER,\n    lua_numbertointeger\n} = require('./luaconf.js');\nconst { to_luastring } = require(\"./fengaricore.js\");\n\nlet rand_state;\n/* use same parameters as glibc LCG */\nconst l_rand = function() {\n    rand_state = (1103515245 * rand_state + 12345) & 0x7fffffff;\n    return rand_state;\n};\nconst l_srand = function(x) {\n    rand_state = x|0;\n    if (rand_state === 0)\n        rand_state = 1;\n};\n\nconst math_random = function(L) {\n    let low, up;\n    /* use Math.random until randomseed is called */\n    let r = (rand_state === void 0)?Math.random():(l_rand() / 0x80000000);\n    switch (lua_gettop(L)) {  /* check number of arguments */\n        case 0:\n            lua_pushnumber(L, r);  /* Number between 0 and 1 */\n            return 1;\n        case 1: {\n            low = 1;\n            up = luaL_checkinteger(L, 1);\n            break;\n        }\n        case 2: {\n            low = luaL_checkinteger(L, 1);\n            up = luaL_checkinteger(L, 2);\n            break;\n        }\n        default: return luaL_error(L, \"wrong number of arguments\");\n    }\n\n    /* random integer in the interval [low, up] */\n    luaL_argcheck(L, low <= up, 1, \"interval is empty\");\n    luaL_argcheck(L, low >= 0 || up <= LUA_MAXINTEGER + low, 1,\n        \"interval too large\");\n\n    r *= (up - low) + 1;\n    lua_pushinteger(L, Math.floor(r) + low);\n    return 1;\n};\n\nconst math_randomseed = function(L) {\n    l_srand(luaL_checknumber(L, 1));\n    l_rand(); /* discard first value to avoid undesirable correlations */\n    return 0;\n};\n\nconst math_abs = function(L) {\n    if (lua_isinteger(L, 1)) {\n        let n = lua_tointeger(L, 1);\n        if (n < 0) n = (-n)|0;\n        lua_pushinteger(L, n);\n    }\n    else\n        lua_pushnumber(L, Math.abs(luaL_checknumber(L, 1)));\n    return 1;\n};\n\nconst math_sin = function(L) {\n    lua_pushnumber(L, Math.sin(luaL_checknumber(L, 1)));\n    return 1;\n};\n\nconst math_cos = function(L) {\n    lua_pushnumber(L, Math.cos(luaL_checknumber(L, 1)));\n    return 1;\n};\n\nconst math_tan = function(L) {\n    lua_pushnumber(L, Math.tan(luaL_checknumber(L, 1)));\n    return 1;\n};\n\nconst math_asin = function(L) {\n    lua_pushnumber(L, Math.asin(luaL_checknumber(L, 1)));\n    return 1;\n};\n\nconst math_acos = function(L) {\n    lua_pushnumber(L, Math.acos(luaL_checknumber(L, 1)));\n    return 1;\n};\n\nconst math_atan = function(L) {\n    let y = luaL_checknumber(L, 1);\n    let x = luaL_optnumber(L, 2, 1);\n    lua_pushnumber(L, Math.atan2(y, x));\n    return 1;\n};\n\nconst math_toint = function(L) {\n    let n = lua_tointegerx(L, 1);\n    if (n !== false)\n        lua_pushinteger(L, n);\n    else {\n        luaL_checkany(L, 1);\n        lua_pushnil(L);  /* value is not convertible to integer */\n    }\n    return 1;\n};\n\nconst pushnumint = function(L, d) {\n    let n = lua_numbertointeger(d);\n    if (n !== false)  /* does 'd' fit in an integer? */\n        lua_pushinteger(L, n);  /* result is integer */\n    else\n        lua_pushnumber(L, d);  /* result is float */\n};\n\nconst math_floor = function(L) {\n    if (lua_isinteger(L, 1))\n        lua_settop(L, 1);\n    else\n        pushnumint(L, Math.floor(luaL_checknumber(L, 1)));\n\n    return 1;\n};\n\nconst math_ceil = function(L) {\n    if (lua_isinteger(L, 1))\n        lua_settop(L, 1);\n    else\n        pushnumint(L, Math.ceil(luaL_checknumber(L, 1)));\n\n    return 1;\n};\n\nconst math_sqrt = function(L) {\n    lua_pushnumber(L, Math.sqrt(luaL_checknumber(L, 1)));\n    return 1;\n};\n\nconst math_ult = function(L) {\n    let a = luaL_checkinteger(L, 1);\n    let b = luaL_checkinteger(L, 2);\n    lua_pushboolean(L, (a >= 0)?(b<0 || a<b):(b<0 && a<b));\n    return 1;\n};\n\nconst math_log = function(L) {\n    let x = luaL_checknumber(L, 1);\n    let res;\n    if (lua_isnoneornil(L, 2))\n        res = Math.log(x);\n    else {\n        let base = luaL_checknumber(L, 2);\n        if (base === 2)\n            res = Math.log2(x);\n        else if (base === 10)\n            res = Math.log10(x);\n        else\n            res = Math.log(x)/Math.log(base);\n    }\n    lua_pushnumber(L, res);\n    return 1;\n};\n\nconst math_exp = function(L) {\n    lua_pushnumber(L, Math.exp(luaL_checknumber(L, 1)));\n    return 1;\n};\n\nconst math_deg = function(L) {\n    lua_pushnumber(L, luaL_checknumber(L, 1) * (180 / Math.PI));\n    return 1;\n};\n\nconst math_rad = function(L) {\n    lua_pushnumber(L, luaL_checknumber(L, 1) * (Math.PI / 180));\n    return 1;\n};\n\nconst math_min = function(L) {\n    let n = lua_gettop(L);  /* number of arguments */\n    let imin = 1;  /* index of current minimum value */\n    luaL_argcheck(L, n >= 1, 1, \"value expected\");\n    for (let i = 2; i <= n; i++){\n        if (lua_compare(L, i, imin, LUA_OPLT))\n            imin = i;\n    }\n    lua_pushvalue(L, imin);\n    return 1;\n};\n\nconst math_max = function(L) {\n    let n = lua_gettop(L);  /* number of arguments */\n    let imax = 1;  /* index of current minimum value */\n    luaL_argcheck(L, n >= 1, 1, \"value expected\");\n    for (let i = 2; i <= n; i++){\n        if (lua_compare(L, imax, i, LUA_OPLT))\n            imax = i;\n    }\n    lua_pushvalue(L, imax);\n    return 1;\n};\n\nconst math_type = function(L) {\n    if (lua_type(L, 1) === LUA_TNUMBER) {\n        if (lua_isinteger(L, 1))\n            lua_pushliteral(L, \"integer\");\n        else\n            lua_pushliteral(L, \"float\");\n    } else {\n        luaL_checkany(L, 1);\n        lua_pushnil(L);\n    }\n    return 1;\n};\n\nconst math_fmod = function(L) {\n    if (lua_isinteger(L, 1) && lua_isinteger(L, 2)) {\n        let d = lua_tointeger(L, 2);\n        /* no special case needed for -1 in javascript */\n        if (d === 0) {\n            luaL_argerror(L, 2, \"zero\");\n        } else\n            lua_pushinteger(L, (lua_tointeger(L, 1) % d)|0);\n    } else {\n        let a = luaL_checknumber(L, 1);\n        let b = luaL_checknumber(L, 2);\n        lua_pushnumber(L, a%b);\n    }\n    return 1;\n};\n\nconst math_modf = function(L) {\n    if (lua_isinteger(L, 1)) {\n        lua_settop(L, 1);  /* number is its own integer part */\n        lua_pushnumber(L, 0);  /* no fractional part */\n    } else {\n        let n = luaL_checknumber(L, 1);\n        let ip = n < 0 ? Math.ceil(n) : Math.floor(n);\n        pushnumint(L, ip);\n        lua_pushnumber(L, n === ip ? 0 : n - ip);\n    }\n    return 2;\n};\n\nconst mathlib = {\n    \"abs\":        math_abs,\n    \"acos\":       math_acos,\n    \"asin\":       math_asin,\n    \"atan\":       math_atan,\n    \"ceil\":       math_ceil,\n    \"cos\":        math_cos,\n    \"deg\":        math_deg,\n    \"exp\":        math_exp,\n    \"floor\":      math_floor,\n    \"fmod\":       math_fmod,\n    \"log\":        math_log,\n    \"max\":        math_max,\n    \"min\":        math_min,\n    \"modf\":       math_modf,\n    \"rad\":        math_rad,\n    \"random\":     math_random,\n    \"randomseed\": math_randomseed,\n    \"sin\":        math_sin,\n    \"sqrt\":       math_sqrt,\n    \"tan\":        math_tan,\n    \"tointeger\":  math_toint,\n    \"type\":       math_type,\n    \"ult\":        math_ult\n};\n\nconst luaopen_math = function(L) {\n    luaL_newlib(L, mathlib);\n    lua_pushnumber(L, Math.PI);\n    lua_setfield(L, -2, to_luastring(\"pi\", true));\n    lua_pushnumber(L, Infinity);\n    lua_setfield(L, -2, to_luastring(\"huge\", true));\n    lua_pushinteger(L, LUA_MAXINTEGER);\n    lua_setfield(L, -2, to_luastring(\"maxinteger\", true));\n    lua_pushinteger(L, LUA_MININTEGER);\n    lua_setfield(L, -2, to_luastring(\"mininteger\", true));\n    return 1;\n};\n\nmodule.exports.luaopen_math = luaopen_math;\n", ";\n\nconst {\n    LUA_MASKCALL,\n    LUA_MASKCOUNT,\n    LUA_MASKLINE,\n    LUA_MASKRET,\n    LUA_REGISTRYINDEX,\n    LUA_TFUNCTION,\n    LUA_TNIL,\n    LUA_TTABLE,\n    LUA_TUSERDATA,\n    lua_Debug,\n    lua_call,\n    lua_checkstack,\n    lua_gethook,\n    lua_gethookcount,\n    lua_gethookmask,\n    lua_getinfo,\n    lua_getlocal,\n    lua_getmetatable,\n    lua_getstack,\n    lua_getupvalue,\n    lua_getuservalue,\n    lua_insert,\n    lua_iscfunction,\n    lua_isfunction,\n    lua_isnoneornil,\n    lua_isthread,\n    lua_newtable,\n    lua_pcall,\n    lua_pop,\n    lua_pushboolean,\n    lua_pushfstring,\n    lua_pushinteger,\n    lua_pushlightuserdata,\n    lua_pushliteral,\n    lua_pushnil,\n    lua_pushstring,\n    lua_pushvalue,\n    lua_rawgetp,\n    lua_rawsetp,\n    lua_rotate,\n    lua_setfield,\n    lua_sethook,\n    lua_setlocal,\n    lua_setmetatable,\n    lua_settop,\n    lua_setupvalue,\n    lua_setuservalue,\n    lua_tojsstring,\n    lua_toproxy,\n    lua_tostring,\n    lua_tothread,\n    lua_touserdata,\n    lua_type,\n    lua_upvalueid,\n    lua_upvaluejoin,\n    lua_xmove\n} = require('./lua.js');\nconst {\n    luaL_argcheck,\n    luaL_argerror,\n    luaL_checkany,\n    luaL_checkinteger,\n    luaL_checkstring,\n    luaL_checktype,\n    luaL_error,\n    luaL_loadbuffer,\n    luaL_newlib,\n    luaL_optinteger,\n    luaL_optstring,\n    luaL_traceback,\n    lua_writestringerror\n} = require('./lauxlib.js');\nconst lualib = require('./lualib.js');\nconst {\n    luastring_indexOf,\n    to_luastring\n} = require(\"./fengaricore.js\");\n\n/*\n** If L1 != L, L1 can be in any state, and therefore there are no\n** guarantees about its stack space; any push in L1 must be\n** checked.\n*/\nconst checkstack = function(L, L1, n) {\n    if (L !== L1 && !lua_checkstack(L1, n))\n        luaL_error(L, to_luastring(\"stack overflow\", true));\n};\n\nconst db_getregistry = function(L) {\n    lua_pushvalue(L, LUA_REGISTRYINDEX);\n    return 1;\n};\n\nconst db_getmetatable = function(L) {\n    luaL_checkany(L, 1);\n    if (!lua_getmetatable(L, 1)) {\n        lua_pushnil(L);  /* no metatable */\n    }\n    return 1;\n};\n\nconst db_setmetatable = function(L) {\n    const t = lua_type(L, 2);\n    luaL_argcheck(L, t == LUA_TNIL || t == LUA_TTABLE, 2, \"nil or table expected\");\n    lua_settop(L, 2);\n    lua_setmetatable(L, 1);\n    return 1;  /* return 1st argument */\n};\n\nconst db_getuservalue = function(L) {\n    if (lua_type(L, 1) !== LUA_TUSERDATA)\n        lua_pushnil(L);\n    else\n        lua_getuservalue(L, 1);\n    return 1;\n};\n\n\nconst db_setuservalue = function(L) {\n    luaL_checktype(L, 1, LUA_TUSERDATA);\n    luaL_checkany(L, 2);\n    lua_settop(L, 2);\n    lua_setuservalue(L, 1);\n    return 1;\n};\n\n/*\n** Auxiliary function used by several library functions: check for\n** an optional thread as function's first argument and set 'arg' with\n** 1 if this argument is present (so that functions can skip it to\n** access their other arguments)\n*/\nconst getthread = function(L) {\n    if (lua_isthread(L, 1)) {\n        return {\n            arg: 1,\n            thread: lua_tothread(L, 1)\n        };\n    } else {\n        return {\n            arg: 0,\n            thread: L\n        };  /* function will operate over current thread */\n    }\n};\n\n/*\n** Variations of 'lua_settable', used by 'db_getinfo' to put results\n** from 'lua_getinfo' into result table. Key is always a string;\n** value can be a string, an int, or a boolean.\n*/\nconst settabss = function(L, k, v) {\n    lua_pushstring(L, v);\n    lua_setfield(L, -2, k);\n};\n\nconst settabsi = function(L, k, v) {\n    lua_pushinteger(L, v);\n    lua_setfield(L, -2, k);\n};\n\nconst settabsb = function(L, k, v) {\n    lua_pushboolean(L, v);\n    lua_setfield(L, -2, k);\n};\n\n\n/*\n** In function 'db_getinfo', the call to 'lua_getinfo' may push\n** results on the stack; later it creates the result table to put\n** these objects. Function 'treatstackoption' puts the result from\n** 'lua_getinfo' on top of the result table so that it can call\n** 'lua_setfield'.\n*/\nconst treatstackoption = function(L, L1, fname) {\n    if (L == L1)\n        lua_rotate(L, -2, 1);  /* exchange object and table */\n    else\n        lua_xmove(L1, L, 1);  /* move object to the \"main\" stack */\n    lua_setfield(L, -2, fname);  /* put object into table */\n};\n\n/*\n** Calls 'lua_getinfo' and collects all results in a new table.\n** L1 needs stack space for an optional input (function) plus\n** two optional outputs (function and line table) from function\n** 'lua_getinfo'.\n*/\nconst db_getinfo = function(L) {\n    let ar = new lua_Debug();\n    let thread = getthread(L);\n    let arg = thread.arg;\n    let L1 = thread.thread;\n    let options = luaL_optstring(L, arg + 2, \"flnStu\");\n    checkstack(L, L1, 3);\n    if (lua_isfunction(L, arg + 1)) {  /* info about a function? */\n        options = lua_pushfstring(L, to_luastring(\">%s\"), options);  /* add '>' to 'options' */\n        lua_pushvalue(L, arg + 1);  /* move function to 'L1' stack */\n        lua_xmove(L, L1, 1);\n    } else {  /* stack level */\n        if (!lua_getstack(L1, luaL_checkinteger(L, arg + 1), ar)) {\n            lua_pushnil(L);  /* level out of range */\n            return 1;\n        }\n    }\n\n    if (!lua_getinfo(L1, options, ar))\n        luaL_argerror(L, arg + 2, \"invalid option\");\n    lua_newtable(L);  /* table to collect results */\n    if (luastring_indexOf(options, 83 /* 'S'.charCodeAt(0) */) > -1) {\n        settabss(L, to_luastring(\"source\", true), ar.source);\n        settabss(L, to_luastring(\"short_src\", true), ar.short_src);\n        settabsi(L, to_luastring(\"linedefined\", true), ar.linedefined);\n        settabsi(L, to_luastring(\"lastlinedefined\", true), ar.lastlinedefined);\n        settabss(L, to_luastring(\"what\", true), ar.what);\n    }\n    if (luastring_indexOf(options, 108 /* 'l'.charCodeAt(0) */) > -1)\n        settabsi(L, to_luastring(\"currentline\", true), ar.currentline);\n    if (luastring_indexOf(options, 117 /* 'u'.charCodeAt(0) */) > -1) {\n        settabsi(L, to_luastring(\"nups\", true), ar.nups);\n        settabsi(L, to_luastring(\"nparams\", true), ar.nparams);\n        settabsb(L, to_luastring(\"isvararg\", true), ar.isvararg);\n    }\n    if (luastring_indexOf(options, 110 /* 'n'.charCodeAt(0) */) > -1) {\n        settabss(L, to_luastring(\"name\", true), ar.name);\n        settabss(L, to_luastring(\"namewhat\", true), ar.namewhat);\n    }\n    if (luastring_indexOf(options, 116 /* 't'.charCodeAt(0) */) > -1)\n        settabsb(L, to_luastring(\"istailcall\", true), ar.istailcall);\n    if (luastring_indexOf(options, 76 /* 'L'.charCodeAt(0) */) > -1)\n        treatstackoption(L, L1, to_luastring(\"activelines\", true));\n    if (luastring_indexOf(options, 102 /* 'f'.charCodeAt(0) */) > -1)\n        treatstackoption(L, L1, to_luastring(\"func\", true));\n    return 1;  /* return table */\n};\n\nconst db_getlocal = function(L) {\n    let thread = getthread(L);\n    let L1 = thread.thread;\n    let arg = thread.arg;\n    let ar = new lua_Debug();\n    let nvar = luaL_checkinteger(L, arg + 2);  /* local-variable index */\n    if (lua_isfunction(L, arg + 1)) {\n        lua_pushvalue(L, arg + 1);  /* push function */\n        lua_pushstring(L, lua_getlocal(L, null, nvar));  /* push local name */\n        return 1;  /* return only name (there is no value) */\n    } else {  /* stack-level argument */\n        let level = luaL_checkinteger(L, arg + 1);\n        if (!lua_getstack(L1, level, ar))  /* out of range? */\n            return luaL_argerror(L, arg+1, \"level out of range\");\n        checkstack(L, L1, 1);\n        let name = lua_getlocal(L1, ar, nvar);\n        if (name) {\n            lua_xmove(L1, L, 1);  /* move local value */\n            lua_pushstring(L, name);  /* push name */\n            lua_rotate(L, -2, 1);  /* re-order */\n            return 2;\n        }\n        else {\n            lua_pushnil(L);  /* no name (nor value) */\n            return 1;\n        }\n    }\n};\n\nconst db_setlocal = function(L) {\n    let thread = getthread(L);\n    let L1 = thread.thread;\n    let arg = thread.arg;\n    let ar = new lua_Debug();\n    let level = luaL_checkinteger(L, arg + 1);\n    let nvar = luaL_checkinteger(L, arg + 2);\n    if (!lua_getstack(L1, level, ar))  /* out of range? */\n        return luaL_argerror(L, arg + 1, \"level out of range\");\n    luaL_checkany(L, arg + 3);\n    lua_settop(L, arg + 3);\n    checkstack(L, L1, 1);\n    lua_xmove(L, L1, 1);\n    let name = lua_setlocal(L1, ar, nvar);\n    if (name === null)\n        lua_pop(L1, 1);  /* pop value (if not popped by 'lua_setlocal') */\n    lua_pushstring(L, name);\n    return 1;\n};\n\n/*\n** get (if 'get' is true) or set an upvalue from a closure\n*/\nconst auxupvalue = function(L, get) {\n    let n = luaL_checkinteger(L, 2);  /* upvalue index */\n    luaL_checktype(L, 1, LUA_TFUNCTION);  /* closure */\n    let name = get ? lua_getupvalue(L, 1, n) : lua_setupvalue(L, 1, n);\n    if (name === null) return 0;\n    lua_pushstring(L, name);\n    lua_insert(L, -(get+1));  /* no-op if get is false */\n    return get + 1;\n};\n\n\nconst db_getupvalue = function(L) {\n    return auxupvalue(L, 1);\n};\n\nconst db_setupvalue = function(L) {\n    luaL_checkany(L, 3);\n    return auxupvalue(L, 0);\n};\n\n/*\n** Check whether a given upvalue from a given closure exists and\n** returns its index\n*/\nconst checkupval = function(L, argf, argnup) {\n    let nup = luaL_checkinteger(L, argnup);  /* upvalue index */\n    luaL_checktype(L, argf, LUA_TFUNCTION);  /* closure */\n    luaL_argcheck(L, (lua_getupvalue(L, argf, nup) !== null), argnup, \"invalid upvalue index\");\n    return nup;\n};\n\nconst db_upvalueid = function(L) {\n    let n = checkupval(L, 1, 2);\n    lua_pushlightuserdata(L, lua_upvalueid(L, 1, n));\n    return 1;\n};\n\nconst db_upvaluejoin = function(L) {\n    let n1 = checkupval(L, 1, 2);\n    let n2 = checkupval(L, 3, 4);\n    luaL_argcheck(L, !lua_iscfunction(L, 1), 1, \"Lua function expected\");\n    luaL_argcheck(L, !lua_iscfunction(L, 3), 3, \"Lua function expected\");\n    lua_upvaluejoin(L, 1, n1, 3, n2);\n    return 0;\n};\n\n/*\n** The hook table at registry[HOOKKEY] maps threads to their current\n** hook function. (We only need the unique address of 'HOOKKEY'.)\n*/\nconst HOOKKEY = to_luastring(\"__hooks__\", true);\n\nconst hooknames = [\"call\", \"return\", \"line\", \"count\", \"tail call\"].map(e => to_luastring(e));\n\n/*\n** Call hook function registered at hook table for the current\n** thread (if there is one)\n*/\nconst hookf = function(L, ar) {\n    lua_rawgetp(L, LUA_REGISTRYINDEX, HOOKKEY);\n    let hooktable = lua_touserdata(L, -1);\n    let proxy = hooktable.get(L);\n    if (proxy) {  /* is there a hook function? */\n        proxy(L);\n        lua_pushstring(L, hooknames[ar.event]);  /* push event name */\n        if (ar.currentline >= 0)\n            lua_pushinteger(L, ar.currentline);  /* push current line */\n        else lua_pushnil(L);\n        lualib.lua_assert(lua_getinfo(L, to_luastring(\"lS\"), ar));\n        lua_call(L, 2, 0);  /* call hook function */\n    }\n};\n\n/*\n** Convert a string mask (for 'sethook') into a bit mask\n*/\nconst makemask = function(smask, count) {\n    let mask = 0;\n    if (luastring_indexOf(smask, 99 /* 'c'.charCodeAt(0) */) > -1) mask |= LUA_MASKCALL;\n    if (luastring_indexOf(smask, 114 /* 'r'.charCodeAt(0) */) > -1) mask |= LUA_MASKRET;\n    if (luastring_indexOf(smask, 108 /* 'l'.charCodeAt(0) */) > -1) mask |= LUA_MASKLINE;\n    if (count > 0) mask |= LUA_MASKCOUNT;\n    return mask;\n};\n\n/*\n** Convert a bit mask (for 'gethook') into a string mask\n*/\nconst unmakemask = function(mask, smask) {\n    let i = 0;\n    if (mask & LUA_MASKCALL) smask[i++] = 99 /* 'c'.charCodeAt(0) */;\n    if (mask & LUA_MASKRET) smask[i++] = 114 /* 'r'.charCodeAt(0) */;\n    if (mask & LUA_MASKLINE) smask[i++] = 108 /* 'l'.charCodeAt(0) */;\n    return smask.subarray(0, i);\n};\n\nconst db_sethook = function(L) {\n    let mask, count, func;\n    let thread = getthread(L);\n    let L1 = thread.thread;\n    let arg = thread.arg;\n    if (lua_isnoneornil(L, arg+1)) {  /* no hook? */\n        lua_settop(L, arg+1);\n        func = null; mask = 0; count = 0;  /* turn off hooks */\n    }\n    else {\n        const smask = luaL_checkstring(L, arg + 2);\n        luaL_checktype(L, arg+1, LUA_TFUNCTION);\n        count = luaL_optinteger(L, arg + 3, 0);\n        func = hookf; mask = makemask(smask, count);\n    }\n    /* as weak tables are not supported; use a JS weak-map */\n    let hooktable;\n    if (lua_rawgetp(L, LUA_REGISTRYINDEX, HOOKKEY) === LUA_TNIL) {\n        hooktable = new WeakMap();\n        lua_pushlightuserdata(L, hooktable);\n        lua_rawsetp(L, LUA_REGISTRYINDEX, HOOKKEY);  /* set it in position */\n    } else {\n        hooktable = lua_touserdata(L, -1);\n    }\n    let proxy = lua_toproxy(L, arg + 1);  /* value (hook function) */\n    hooktable.set(L1, proxy);\n    lua_sethook(L1, func, mask, count);\n    return 0;\n};\n\nconst db_gethook = function(L) {\n    let thread = getthread(L);\n    let L1 = thread.thread;\n    let buff = new Uint8Array(5);\n    let mask = lua_gethookmask(L1);\n    let hook = lua_gethook(L1);\n    if (hook === null)  /* no hook? */\n        lua_pushnil(L);\n    else if (hook !== hookf)  /* external hook? */\n        lua_pushliteral(L, \"external hook\");\n    else {  /* hook table must exist */\n        lua_rawgetp(L, LUA_REGISTRYINDEX, HOOKKEY);\n        let hooktable = lua_touserdata(L, -1);\n        let proxy = hooktable.get(L1);\n        proxy(L);\n    }\n    lua_pushstring(L, unmakemask(mask, buff));  /* 2nd result = mask */\n    lua_pushinteger(L, lua_gethookcount(L1));  /* 3rd result = count */\n    return 3;\n};\n\nconst db_traceback = function(L) {\n    let thread = getthread(L);\n    let L1 = thread.thread;\n    let arg = thread.arg;\n    let msg = lua_tostring(L, arg + 1);\n    if (msg === null && !lua_isnoneornil(L, arg + 1))  /* non-string 'msg'? */\n        lua_pushvalue(L, arg + 1);  /* return it untouched */\n    else {\n        let level = luaL_optinteger(L, arg + 2, L === L1 ? 1 : 0);\n        luaL_traceback(L, L1, msg, level);\n    }\n    return 1;\n};\n\nconst dblib = {\n    \"gethook\":      db_gethook,\n    \"getinfo\":      db_getinfo,\n    \"getlocal\":     db_getlocal,\n    \"getmetatable\": db_getmetatable,\n    \"getregistry\":  db_getregistry,\n    \"getupvalue\":   db_getupvalue,\n    \"getuservalue\": db_getuservalue,\n    \"sethook\":      db_sethook,\n    \"setlocal\":     db_setlocal,\n    \"setmetatable\": db_setmetatable,\n    \"setupvalue\":   db_setupvalue,\n    \"setuservalue\": db_setuservalue,\n    \"traceback\":    db_traceback,\n    \"upvalueid\":    db_upvalueid,\n    \"upvaluejoin\":  db_upvaluejoin\n};\n\nlet getinput;\nif (typeof process !== \"undefined\") { // Only with Node\n    const readlineSync = require('readline-sync');\n    readlineSync.setDefaultOptions({\n        prompt: 'lua_debug> '\n    });\n    getinput = function() {\n        return readlineSync.prompt();\n    };\n} else if (typeof window !== \"undefined\") {\n    /* if in browser use window.prompt. Doesn't work from web workers.\n       See https://developer.mozilla.org/en-US/docs/Web/API/Window/prompt\n    */\n    getinput = function() {\n        let input = prompt(\"lua_debug>\", \"\");\n        return (input !== null) ? input : \"\";\n    };\n}\nif (getinput) {\n    dblib.debug = function(L) {\n        for (;;) {\n            let input = getinput();\n\n            if (input === \"cont\")\n                return 0;\n\n            if (input.length === 0)\n                continue;\n\n            let buffer = to_luastring(input);\n            if (luaL_loadbuffer(L, buffer, buffer.length, to_luastring(\"=(debug command)\", true))\n                || lua_pcall(L, 0, 0, 0)) {\n                lua_writestringerror(lua_tojsstring(L, -1), \"\\n\");\n            }\n            lua_settop(L, 0);  /* remove eventual returns */\n        }\n    };\n}\n\nconst luaopen_debug = function(L) {\n    luaL_newlib(L, dblib);\n    return 1;\n};\n\nmodule.exports.luaopen_debug = luaopen_debug;\n", ";\n\nconst {\n    LUA_DIRSEP,\n    LUA_EXEC_DIR,\n    LUA_JSPATH_DEFAULT,\n    LUA_PATH_DEFAULT,\n    LUA_PATH_MARK,\n    LUA_PATH_SEP\n} = require('./luaconf.js');\nconst {\n    LUA_OK,\n    LUA_REGISTRYINDEX,\n    LUA_TNIL,\n    LUA_TTABLE,\n    lua_callk,\n    lua_createtable,\n    lua_getfield,\n    lua_insert,\n    lua_isfunction,\n    lua_isnil,\n    lua_isstring,\n    lua_newtable,\n    lua_pop,\n    lua_pushboolean,\n    lua_pushcclosure,\n    lua_pushcfunction,\n    lua_pushfstring,\n    lua_pushglobaltable,\n    lua_pushlightuserdata,\n    lua_pushliteral,\n    lua_pushlstring,\n    lua_pushnil,\n    lua_pushstring,\n    lua_pushvalue,\n    lua_rawgeti,\n    lua_rawgetp,\n    lua_rawseti,\n    lua_rawsetp,\n    lua_remove,\n    lua_setfield,\n    lua_setmetatable,\n    lua_settop,\n    lua_toboolean,\n    lua_tostring,\n    lua_touserdata,\n    lua_upvalueindex\n} = require('./lua.js');\nconst {\n    LUA_LOADED_TABLE,\n    LUA_PRELOAD_TABLE,\n    luaL_Buffer,\n    luaL_addvalue,\n    luaL_buffinit,\n    luaL_checkstring,\n    luaL_error,\n    luaL_getsubtable,\n    luaL_gsub,\n    luaL_len,\n    luaL_loadfile,\n    luaL_newlib,\n    luaL_optstring,\n    luaL_pushresult,\n    luaL_setfuncs\n} = require('./lauxlib.js');\nconst lualib = require('./lualib.js');\nconst {\n    luastring_indexOf,\n    to_jsstring,\n    to_luastring,\n    to_uristring\n} = require(\"./fengaricore.js\");\nconst fengari  = require('./fengari.js');\n\nconst global_env = (function() {\n    if (typeof process !== \"undefined\") {\n        /* node */\n        return global;\n    } else if (typeof window !== \"undefined\") {\n        /* browser window */\n        return window;\n    } else if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {\n        /* web worker */\n        return self;\n    } else {\n        /* unknown global env */\n        return (0, eval)('this'); /* use non-strict mode to get global env */\n    }\n})();\n\nconst JSLIBS = to_luastring(\"__JSLIBS__\");\nconst LUA_PATH_VAR = \"LUA_PATH\";\nconst LUA_JSPATH_VAR = \"LUA_JSPATH\";\n\nconst LUA_IGMARK = \"-\";\n\n/*\n** LUA_CSUBSEP is the character that replaces dots in submodule names\n** when searching for a JS loader.\n** LUA_LSUBSEP is the character that replaces dots in submodule names\n** when searching for a Lua loader.\n*/\nconst LUA_CSUBSEP = LUA_DIRSEP;\nconst LUA_LSUBSEP = LUA_DIRSEP;\n\n/* prefix for open functions in JS libraries */\nconst LUA_POF = to_luastring(\"luaopen_\");\n\n/* separator for open functions in JS libraries */\nconst LUA_OFSEP = to_luastring(\"_\");\nconst LIB_FAIL = \"open\";\n\nconst AUXMARK = to_luastring(\"\\x01\");\n\n\n/*\n** load JS library in file 'path'. If 'seeglb', load with all names in\n** the library global.\n** Returns the library; in case of error, returns NULL plus an\n** error string in the stack.\n*/\nlet lsys_load;\nif (typeof process === \"undefined\") {\n    lsys_load = function(L, path, seeglb) {\n        path = to_uristring(path);\n        let xhr = new XMLHttpRequest();\n        xhr.open(\"GET\", path, false);\n        xhr.send();\n\n        if (xhr.status < 200 || xhr.status >= 300) {\n            lua_pushstring(L, to_luastring(`${xhr.status}: ${xhr.statusText}`));\n            return null;\n        }\n\n        let code = xhr.response;\n        /* Add sourceURL comment to get path in debugger+tracebacks */\n        if (!/\\/\\/[#@] sourceURL=/.test(code))\n            code += \" //# sourceURL=\" + path;\n        let func;\n        try {\n            func = Function(\"fengari\", code);\n        } catch (e) {\n            lua_pushstring(L, to_luastring(`${e.name}: ${e.message}`));\n            return null;\n        }\n        let res = func(fengari);\n        if (typeof res === \"function\" || (typeof res === \"object\" && res !== null)) {\n            return res;\n        } else if (res === void 0) { /* assume library added symbols to global environment */\n            return global_env;\n        } else {\n            lua_pushstring(L, to_luastring(`library returned unexpected type (${typeof res})`));\n            return null;\n        }\n    };\n} else {\n    const pathlib = require('path');\n    lsys_load = function(L, path, seeglb) {\n        path = to_jsstring(path);\n        /* relative paths should be relative to cwd, not this js file */\n        path = pathlib.resolve(process.cwd(), path);\n        try {\n            return require(path);\n        } catch (e) {\n            lua_pushstring(L, to_luastring(e.message));\n            return null;\n        }\n    };\n}\n\n/*\n** Try to find a function named 'sym' in library 'lib'.\n** Returns the function; in case of error, returns NULL plus an\n** error string in the stack.\n*/\nconst lsys_sym = function(L, lib, sym) {\n    let f = lib[to_jsstring(sym)];\n\n    if (f && typeof f === 'function')\n        return f;\n    else {\n        lua_pushfstring(L, to_luastring(\"undefined symbol: %s\"), sym);\n        return null;\n    }\n};\n\n/*\n** return registry.LUA_NOENV as a boolean\n*/\nconst noenv = function(L) {\n    lua_getfield(L, LUA_REGISTRYINDEX, to_luastring(\"LUA_NOENV\"));\n    let b = lua_toboolean(L, -1);\n    lua_pop(L, 1);  /* remove value */\n    return b;\n};\n\nlet readable;\nif (typeof process !== \"undefined\") { // Only with Node\n    const fs = require('fs');\n\n    readable = function(filename) {\n        try {\n            let fd = fs.openSync(filename, 'r');\n            fs.closeSync(fd);\n        } catch (e) {\n            return false;\n        }\n        return true;\n    };\n} else {\n    readable = function(path) {\n        path = to_uristring(path);\n        let xhr = new XMLHttpRequest();\n        /* Following GET request done by searcher_Web will be cached */\n        xhr.open(\"GET\", path, false);\n        xhr.send();\n\n        return xhr.status >= 200 && xhr.status <= 299;\n    };\n}\n\n\n/* error codes for 'lookforfunc' */\nconst ERRLIB  = 1;\nconst ERRFUNC = 2;\n\n/*\n** Look for a C function named 'sym' in a dynamically loaded library\n** 'path'.\n** First, check whether the library is already loaded; if not, try\n** to load it.\n** Then, if 'sym' is '*', return true (as library has been loaded).\n** Otherwise, look for symbol 'sym' in the library and push a\n** C function with that symbol.\n** Return 0 and 'true' or a function in the stack; in case of\n** errors, return an error code and an error message in the stack.\n*/\nconst lookforfunc = function(L, path, sym) {\n    let reg = checkjslib(L, path);  /* check loaded JS libraries */\n    if (reg === null) {  /* must load library? */\n        reg = lsys_load(L, path, sym[0] === '*'.charCodeAt(0));  /* a global symbols if 'sym'=='*' */\n        if (reg === null) return ERRLIB;  /* unable to load library */\n        addtojslib(L, path, reg);\n    }\n    if (sym[0] === '*'.charCodeAt(0)) {  /* loading only library (no function)? */\n        lua_pushboolean(L, 1);  /* return 'true' */\n        return 0;  /* no errors */\n    }\n    else {\n        let f = lsys_sym(L, reg, sym);\n        if (f === null)\n            return ERRFUNC;  /* unable to find function */\n        lua_pushcfunction(L, f);  /* else create new function */\n        return 0;  /* no errors */\n    }\n};\n\nconst ll_loadlib = function(L) {\n    let path = luaL_checkstring(L, 1);\n    let init = luaL_checkstring(L, 2);\n    let stat = lookforfunc(L, path, init);\n    if (stat === 0)  /* no errors? */\n        return 1;  /* return the loaded function */\n    else {  /* error; error message is on stack top */\n        lua_pushnil(L);\n        lua_insert(L, -2);\n        lua_pushliteral(L, (stat === ERRLIB) ? LIB_FAIL : \"init\");\n        return 3;  /* return nil, error message, and where */\n    }\n};\n\nconst env = (function() {\n    if (typeof process !== \"undefined\") {\n        /* node */\n        return process.env;\n    } else {\n        return global_env;\n    }\n})();\n\n/*\n** Set a path\n*/\nconst setpath = function(L, fieldname, envname, dft) {\n    let nver = `${envname}${lualib.LUA_VERSUFFIX}`;\n    lua_pushstring(L, to_luastring(nver));\n    let path = env[nver];  /* use versioned name */\n    if (path === undefined)  /* no environment variable? */\n        path = env[envname];  /* try unversioned name */\n    if (path === undefined || noenv(L))  /* no environment variable? */\n        lua_pushstring(L, dft);  /* use default */\n    else {\n        /* replace \";;\" by \";AUXMARK;\" and then AUXMARK by default path */\n        path = luaL_gsub(\n            L,\n            to_luastring(path),\n            to_luastring(LUA_PATH_SEP + LUA_PATH_SEP, true),\n            to_luastring(LUA_PATH_SEP + to_jsstring(AUXMARK) + LUA_PATH_SEP, true)\n        );\n        luaL_gsub(L, path, AUXMARK, dft);\n        lua_remove(L, -2); /* remove result from 1st 'gsub' */\n    }\n    lua_setfield(L, -3, fieldname);  /* package[fieldname] = path value */\n    lua_pop(L, 1);  /* pop versioned variable name */\n};\n\n/*\n** return registry.JSLIBS[path]\n*/\nconst checkjslib = function(L, path) {\n    lua_rawgetp(L, LUA_REGISTRYINDEX, JSLIBS);\n    lua_getfield(L, -1, path);\n    let plib = lua_touserdata(L, -1);  /* plib = JSLIBS[path] */\n    lua_pop(L, 2);  /* pop JSLIBS table and 'plib' */\n    return plib;\n};\n\n/*\n** registry.JSLIBS[path] = plib        -- for queries\n** registry.JSLIBS[#JSLIBS + 1] = plib  -- also keep a list of all libraries\n*/\nconst addtojslib = function(L, path, plib) {\n    lua_rawgetp(L, LUA_REGISTRYINDEX, JSLIBS);\n    lua_pushlightuserdata(L, plib);\n    lua_pushvalue(L, -1);\n    lua_setfield(L, -3, path);  /* JSLIBS[path] = plib */\n    lua_rawseti(L, -2, luaL_len(L, -2) + 1);  /* JSLIBS[#JSLIBS + 1] = plib */\n    lua_pop(L, 1);  /* pop JSLIBS table */\n};\n\nconst pushnexttemplate = function(L, path) {\n    while (path[0] === LUA_PATH_SEP.charCodeAt(0)) path = path.subarray(1);  /* skip separators */\n    if (path.length === 0) return null;  /* no more templates */\n    let l = luastring_indexOf(path, LUA_PATH_SEP.charCodeAt(0));  /* find next separator */\n    if (l < 0) l = path.length;\n    lua_pushlstring(L, path, l);  /* template */\n    return path.subarray(l);\n};\n\nconst searchpath = function(L, name, path, sep, dirsep) {\n    let msg = new luaL_Buffer();  /* to build error message */\n    luaL_buffinit(L, msg);\n    if (sep[0] !== 0)  /* non-empty separator? */\n        name = luaL_gsub(L, name, sep, dirsep);  /* replace it by 'dirsep' */\n    while ((path = pushnexttemplate(L, path)) !== null) {\n        let filename = luaL_gsub(L, lua_tostring(L, -1), to_luastring(LUA_PATH_MARK, true), name);\n        lua_remove(L, -2);  /* remove path template */\n        if (readable(filename))  /* does file exist and is readable? */\n            return filename;  /* return that file name */\n        lua_pushfstring(L, to_luastring(\"\\n\\tno file '%s'\"), filename);\n        lua_remove(L, -2);  /* remove file name */\n        luaL_addvalue(msg);\n    }\n    luaL_pushresult(msg);  /* create error message */\n    return null;  /* not found */\n};\n\nconst ll_searchpath = function(L) {\n    let f = searchpath(\n        L,\n        luaL_checkstring(L, 1),\n        luaL_checkstring(L, 2),\n        luaL_optstring(L, 3, \".\"),\n        luaL_optstring(L, 4, LUA_DIRSEP)\n    );\n    if (f !== null) return 1;\n    else {  /* error message is on top of the stack */\n        lua_pushnil(L);\n        lua_insert(L, -2);\n        return 2;  /* return nil + error message */\n    }\n};\n\nconst findfile = function(L, name, pname, dirsep) {\n    lua_getfield(L, lua_upvalueindex(1), pname);\n    let path = lua_tostring(L, -1);\n    if (path === null)\n        luaL_error(L, to_luastring(\"'package.%s' must be a string\"), pname);\n    return searchpath(L, name, path, to_luastring(\".\"), dirsep);\n};\n\nconst checkload = function(L, stat, filename) {\n    if (stat) {  /* module loaded successfully? */\n        lua_pushstring(L, filename);  /* will be 2nd argument to module */\n        return 2;  /* return open function and file name */\n    } else\n        return luaL_error(L, to_luastring(\"error loading module '%s' from file '%s':\\n\\t%s\"),\n            lua_tostring(L, 1), filename, lua_tostring(L, -1));\n};\n\nconst searcher_Lua = function(L) {\n    let name = luaL_checkstring(L, 1);\n    let filename = findfile(L, name, to_luastring(\"path\", true), to_luastring(LUA_LSUBSEP, true));\n    if (filename === null) return 1;  /* module not found in this path */\n    return checkload(L, luaL_loadfile(L, filename) === LUA_OK, filename);\n};\n\n/*\n** Try to find a load function for module 'modname' at file 'filename'.\n** First, change '.' to '_' in 'modname'; then, if 'modname' has\n** the form X-Y (that is, it has an \"ignore mark\"), build a function\n** name \"luaopen_X\" and look for it. (For compatibility, if that\n** fails, it also tries \"luaopen_Y\".) If there is no ignore mark,\n** look for a function named \"luaopen_modname\".\n*/\nconst loadfunc = function(L, filename, modname) {\n    let openfunc;\n    modname = luaL_gsub(L, modname, to_luastring(\".\"), LUA_OFSEP);\n    let mark = luastring_indexOf(modname, LUA_IGMARK.charCodeAt(0));\n    if (mark >= 0) {\n        openfunc = lua_pushlstring(L, modname, mark);\n        openfunc = lua_pushfstring(L, to_luastring(\"%s%s\"), LUA_POF, openfunc);\n        let stat = lookforfunc(L, filename, openfunc);\n        if (stat !== ERRFUNC) return stat;\n        modname = mark + 1;  /* else go ahead and try old-style name */\n    }\n    openfunc = lua_pushfstring(L, to_luastring(\"%s%s\"), LUA_POF, modname);\n    return lookforfunc(L, filename, openfunc);\n};\n\nconst searcher_C = function(L) {\n    let name = luaL_checkstring(L, 1);\n    let filename = findfile(L, name, to_luastring(\"jspath\", true), to_luastring(LUA_CSUBSEP, true));\n    if (filename === null) return 1;  /* module not found in this path */\n    return checkload(L, (loadfunc(L, filename, name) === 0), filename);\n};\n\nconst searcher_Croot = function(L) {\n    let name = luaL_checkstring(L, 1);\n    let p = luastring_indexOf(name, '.'.charCodeAt(0));\n    let stat;\n    if (p < 0) return 0;  /* is root */\n    lua_pushlstring(L, name, p);\n    let filename = findfile(L, lua_tostring(L, -1), to_luastring(\"jspath\", true), to_luastring(LUA_CSUBSEP, true));\n    if (filename === null) return 1;  /* root not found */\n    if ((stat = loadfunc(L, filename, name)) !== 0) {\n        if (stat != ERRFUNC)\n            return checkload(L, 0, filename);  /* real error */\n        else {  /* open function not found */\n            lua_pushstring(L, to_luastring(\"\\n\\tno module '%s' in file '%s'\"), name, filename);\n            return 1;\n        }\n    }\n    lua_pushstring(L, filename);  /* will be 2nd argument to module */\n    return 2;\n};\n\nconst searcher_preload = function(L) {\n    let name = luaL_checkstring(L, 1);\n    lua_getfield(L, LUA_REGISTRYINDEX, LUA_PRELOAD_TABLE);\n    if (lua_getfield(L, -1, name) === LUA_TNIL)  /* not found? */\n        lua_pushfstring(L, to_luastring(\"\\n\\tno field package.preload['%s']\"), name);\n    return 1;\n};\n\nconst findloader = function(L, name, ctx, k) {\n    let msg = new luaL_Buffer();  /* to build error message */\n    luaL_buffinit(L, msg);\n    /* push 'package.searchers' to index 3 in the stack */\n    if (lua_getfield(L, lua_upvalueindex(1), to_luastring(\"searchers\", true)) !== LUA_TTABLE)\n        luaL_error(L, to_luastring(\"'package.searchers' must be a table\"));\n    let ctx2 = {name: name, i: 1, msg: msg, ctx: ctx, k: k};\n    return findloader_cont(L, LUA_OK, ctx2);\n};\n\nconst findloader_cont = function(L, status, ctx) {\n    /*  iterate over available searchers to find a loader */\n    for (; ; ctx.i++) {\n        if (status === LUA_OK) {\n            if (lua_rawgeti(L, 3, ctx.i) === LUA_TNIL) {  /* no more searchers? */\n                lua_pop(L, 1);  /* remove nil */\n                luaL_pushresult(ctx.msg);  /* create error message */\n                luaL_error(L, to_luastring(\"module '%s' not found:%s\"), ctx.name, lua_tostring(L, -1));\n            }\n            lua_pushstring(L, ctx.name);\n            lua_callk(L, 1, 2, ctx, findloader_cont);  /* call it */\n        } else {\n            status = LUA_OK;\n        }\n        if (lua_isfunction(L, -2))  /* did it find a loader? */\n            break;  /* module loader found */\n        else if (lua_isstring(L, -2)) {  /* searcher returned error message? */\n            lua_pop(L, 1);  /* remove extra return */\n            luaL_addvalue(ctx.msg);  /* concatenate error message */\n        }\n        else\n            lua_pop(L, 2);  /* remove both returns */\n    }\n    return ctx.k(L, LUA_OK, ctx.ctx);\n};\n\nconst ll_require = function(L) {\n    let name = luaL_checkstring(L, 1);\n    lua_settop(L, 1);  /* LOADED table will be at index 2 */\n    lua_getfield(L, LUA_REGISTRYINDEX, LUA_LOADED_TABLE);\n    lua_getfield(L, 2, name);  /* LOADED[name] */\n    if (lua_toboolean(L, -1))  /* is it there? */\n        return 1;  /* package is already loaded */\n    /* else must load package */\n    lua_pop(L, 1);  /* remove 'getfield' result */\n    let ctx = name;\n    return findloader(L, name, ctx, ll_require_cont);\n};\n\nconst ll_require_cont = function(L, status, ctx) {\n    let name = ctx;\n    lua_pushstring(L, name);  /* pass name as argument to module loader */\n    lua_insert(L, -2);  /* name is 1st argument (before search data) */\n    lua_callk(L, 2, 1, ctx, ll_require_cont2);\n    return ll_require_cont2(L, LUA_OK, ctx);  /* run loader to load module */\n};\n\nconst ll_require_cont2 = function(L, status, ctx) {\n    let name = ctx;\n    if (!lua_isnil(L, -1))  /* non-nil return? */\n        lua_setfield(L, 2, name);  /* LOADED[name] = returned value */\n    if (lua_getfield(L, 2, name) == LUA_TNIL) {   /* module set no value? */\n        lua_pushboolean(L, 1);  /* use true as result */\n        lua_pushvalue(L, -1);  /* extra copy to be returned */\n        lua_setfield(L, 2, name);  /* LOADED[name] = true */\n    }\n    return 1;\n};\n\nconst pk_funcs = {\n    \"loadlib\": ll_loadlib,\n    \"searchpath\": ll_searchpath\n};\n\nconst ll_funcs = {\n    \"require\": ll_require\n};\n\nconst createsearcherstable = function(L) {\n    let searchers = [searcher_preload, searcher_Lua, searcher_C, searcher_Croot, null];\n    /* create 'searchers' table */\n    lua_createtable(L);\n    /* fill it with predefined searchers */\n    for (let i = 0; searchers[i]; i++) {\n        lua_pushvalue(L, -2);  /* set 'package' as upvalue for all searchers */\n        lua_pushcclosure(L, searchers[i], 1);\n        lua_rawseti(L, -2, i+1);\n    }\n    lua_setfield(L, -2, to_luastring(\"searchers\", true));  /* put it in field 'searchers' */\n};\n\n/*\n** create table JSLIBS to keep track of loaded JS libraries,\n** setting a finalizer to close all libraries when closing state.\n*/\nconst createjslibstable = function(L) {\n    lua_newtable(L);  /* create JSLIBS table */\n    lua_createtable(L, 0, 1);  /* create metatable for JSLIBS */\n    lua_setmetatable(L, -2);\n    lua_rawsetp(L, LUA_REGISTRYINDEX, JSLIBS);  /* set JSLIBS table in registry */\n};\n\nconst luaopen_package = function(L) {\n    createjslibstable(L);\n    luaL_newlib(L, pk_funcs);  /* create 'package' table */\n    createsearcherstable(L);\n    /* set paths */\n    setpath(L, to_luastring(\"path\", true), LUA_PATH_VAR, LUA_PATH_DEFAULT);\n    setpath(L, to_luastring(\"jspath\", true), LUA_JSPATH_VAR, LUA_JSPATH_DEFAULT);\n    /* store config information */\n    lua_pushliteral(L, LUA_DIRSEP + \"\\n\" + LUA_PATH_SEP + \"\\n\" + LUA_PATH_MARK + \"\\n\" +\n                        LUA_EXEC_DIR + \"\\n\" + LUA_IGMARK + \"\\n\");\n    lua_setfield(L, -2, to_luastring(\"config\", true));\n    /* set field 'loaded' */\n    luaL_getsubtable(L, LUA_REGISTRYINDEX, LUA_LOADED_TABLE);\n    lua_setfield(L, -2, to_luastring(\"loaded\", true));\n    /* set field 'preload' */\n    luaL_getsubtable(L, LUA_REGISTRYINDEX, LUA_PRELOAD_TABLE);\n    lua_setfield(L, -2, to_luastring(\"preload\", true));\n    lua_pushglobaltable(L);\n    lua_pushvalue(L, -2);  /* set 'package' as upvalue for next lib */\n    luaL_setfuncs(L, ll_funcs, 1);  /* open lib into global table */\n    lua_pop(L, 1);  /* pop global table */\n    return 1;  /* return 'package' table */\n};\n\nmodule.exports.luaopen_package = luaopen_package;\n", "const {\n    lua_pushinteger,\n    lua_pushliteral,\n    lua_setfield\n} = require('./lua.js');\nconst {\n    luaL_newlib\n} = require('./lauxlib.js');\nconst {\n    FENGARI_AUTHORS,\n    FENGARI_COPYRIGHT,\n    FENGARI_RELEASE,\n    FENGARI_VERSION,\n    FENGARI_VERSION_MAJOR,\n    FENGARI_VERSION_MINOR,\n    FENGARI_VERSION_NUM,\n    FENGARI_VERSION_RELEASE,\n    to_luastring\n} = require(\"./fengaricore.js\");\n\nconst luaopen_fengari = function(L) {\n    luaL_newlib(L, {});\n    lua_pushliteral(L, FENGARI_AUTHORS);\n    lua_setfield(L, -2, to_luastring(\"AUTHORS\"));\n    lua_pushliteral(L, FENGARI_COPYRIGHT);\n    lua_setfield(L, -2, to_luastring(\"COPYRIGHT\"));\n    lua_pushliteral(L, FENGARI_RELEASE);\n    lua_setfield(L, -2, to_luastring(\"RELEASE\"));\n    lua_pushliteral(L, FENGARI_VERSION);\n    lua_setfield(L, -2, to_luastring(\"VERSION\"));\n    lua_pushliteral(L, FENGARI_VERSION_MAJOR);\n    lua_setfield(L, -2, to_luastring(\"VERSION_MAJOR\"));\n    lua_pushliteral(L, FENGARI_VERSION_MINOR);\n    lua_setfield(L, -2, to_luastring(\"VERSION_MINOR\"));\n    lua_pushinteger(L, FENGARI_VERSION_NUM);\n    lua_setfield(L, -2, to_luastring(\"VERSION_NUM\"));\n    lua_pushliteral(L, FENGARI_VERSION_RELEASE);\n    lua_setfield(L, -2, to_luastring(\"VERSION_RELEASE\"));\n    return 1;\n};\n\nmodule.exports.luaopen_fengari = luaopen_fengari;\n", ";\n\nconst { lua_pop } = require('./lua.js');\nconst { luaL_requiref } = require('./lauxlib.js');\nconst { to_luastring } = require(\"./fengaricore.js\");\n\nconst loadedlibs = {};\n\n/* export before requiring lualib.js */\nconst luaL_openlibs = function(L) {\n    /* \"require\" functions from 'loadedlibs' and set results to global table */\n    for (let lib in loadedlibs) {\n        luaL_requiref(L, to_luastring(lib), loadedlibs[lib], 1);\n        lua_pop(L, 1); /* remove lib */\n    }\n};\nmodule.exports.luaL_openlibs = luaL_openlibs;\n\nconst lualib = require('./lualib.js');\nconst { luaopen_base }      = require('./lbaselib.js');\nconst { luaopen_coroutine } = require('./lcorolib.js');\nconst { luaopen_debug }     = require('./ldblib.js');\nconst { luaopen_math }      = require('./lmathlib.js');\nconst { luaopen_package }   = require('./loadlib.js');\nconst { luaopen_os }        = require('./loslib.js');\nconst { luaopen_string }    = require('./lstrlib.js');\nconst { luaopen_table }     = require('./ltablib.js');\nconst { luaopen_utf8 }      = require('./lutf8lib.js');\n\nloadedlibs[\"_G\"] = luaopen_base,\nloadedlibs[lualib.LUA_LOADLIBNAME] = luaopen_package;\nloadedlibs[lualib.LUA_COLIBNAME] = luaopen_coroutine;\nloadedlibs[lualib.LUA_TABLIBNAME] = luaopen_table;\nloadedlibs[lualib.LUA_OSLIBNAME] = luaopen_os;\nloadedlibs[lualib.LUA_STRLIBNAME] = luaopen_string;\nloadedlibs[lualib.LUA_MATHLIBNAME] = luaopen_math;\nloadedlibs[lualib.LUA_UTF8LIBNAME] = luaopen_utf8;\nloadedlibs[lualib.LUA_DBLIBNAME] = luaopen_debug;\nif (typeof process !== \"undefined\")\n    loadedlibs[lualib.LUA_IOLIBNAME] = require('./liolib.js').luaopen_io;\n\n/* Extension: fengari library */\nconst { luaopen_fengari } = require('./fengarilib.js');\nloadedlibs[lualib.LUA_FENGARILIBNAME] = luaopen_fengari;\n", ";\n\nconst {\n    LUA_VERSION_MAJOR,\n    LUA_VERSION_MINOR\n} = require(\"./lua.js\");\n\nconst LUA_VERSUFFIX = \"_\" + LUA_VERSION_MAJOR + \"_\" + LUA_VERSION_MINOR;\nmodule.exports.LUA_VERSUFFIX = LUA_VERSUFFIX;\n\nmodule.exports.lua_assert = function(c) {};\n\nmodule.exports.luaopen_base = require(\"./lbaselib.js\").luaopen_base;\n\nconst LUA_COLIBNAME = \"coroutine\";\nmodule.exports.LUA_COLIBNAME = LUA_COLIBNAME;\nmodule.exports.luaopen_coroutine = require(\"./lcorolib.js\").luaopen_coroutine;\n\nconst LUA_TABLIBNAME = \"table\";\nmodule.exports.LUA_TABLIBNAME = LUA_TABLIBNAME;\nmodule.exports.luaopen_table = require(\"./ltablib.js\").luaopen_table;\n\nif (typeof process !== \"undefined\") {\n    const LUA_IOLIBNAME = \"io\";\n    module.exports.LUA_IOLIBNAME = LUA_IOLIBNAME;\n    module.exports.luaopen_io = require(\"./liolib.js\").luaopen_io;\n}\n\nconst LUA_OSLIBNAME = \"os\";\nmodule.exports.LUA_OSLIBNAME = LUA_OSLIBNAME;\nmodule.exports.luaopen_os = require(\"./loslib.js\").luaopen_os;\n\nconst LUA_STRLIBNAME = \"string\";\nmodule.exports.LUA_STRLIBNAME = LUA_STRLIBNAME;\nmodule.exports.luaopen_string = require(\"./lstrlib.js\").luaopen_string;\n\nconst LUA_UTF8LIBNAME = \"utf8\";\nmodule.exports.LUA_UTF8LIBNAME = LUA_UTF8LIBNAME;\nmodule.exports.luaopen_utf8 = require(\"./lutf8lib.js\").luaopen_utf8;\n\nconst LUA_BITLIBNAME = \"bit32\";\nmodule.exports.LUA_BITLIBNAME = LUA_BITLIBNAME;\n// module.exports.luaopen_bit32 = require(\"./lbitlib.js\").luaopen_bit32;\n\nconst LUA_MATHLIBNAME = \"math\";\nmodule.exports.LUA_MATHLIBNAME = LUA_MATHLIBNAME;\nmodule.exports.luaopen_math = require(\"./lmathlib.js\").luaopen_math;\n\nconst LUA_DBLIBNAME = \"debug\";\nmodule.exports.LUA_DBLIBNAME = LUA_DBLIBNAME;\nmodule.exports.luaopen_debug = require(\"./ldblib.js\").luaopen_debug;\n\nconst LUA_LOADLIBNAME = \"package\";\nmodule.exports.LUA_LOADLIBNAME = LUA_LOADLIBNAME;\nmodule.exports.luaopen_package = require(\"./loadlib.js\").luaopen_package;\n\nconst LUA_FENGARILIBNAME = \"fengari\";\nmodule.exports.LUA_FENGARILIBNAME = LUA_FENGARILIBNAME;\nmodule.exports.luaopen_fengari = require(\"./fengarilib.js\").luaopen_fengari;\n\nconst linit = require('./linit.js');\nmodule.exports.luaL_openlibs = linit.luaL_openlibs;\n", "/**\n@license MIT\n\nCopyright \u00A9 2017-2018 Benoit Giannangeli\nCopyright \u00A9 2017-2018 Daurnimator\nCopyright \u00A9 1994\u20132017 Lua.org, PUC-Rio.\n*/\n\n;\n\nconst core = require(\"./fengaricore.js\");\n\nmodule.exports.FENGARI_AUTHORS         = core.FENGARI_AUTHORS;\nmodule.exports.FENGARI_COPYRIGHT       = core.FENGARI_COPYRIGHT;\nmodule.exports.FENGARI_RELEASE         = core.FENGARI_RELEASE;\nmodule.exports.FENGARI_VERSION         = core.FENGARI_VERSION;\nmodule.exports.FENGARI_VERSION_MAJOR   = core.FENGARI_VERSION_MAJOR;\nmodule.exports.FENGARI_VERSION_MINOR   = core.FENGARI_VERSION_MINOR;\nmodule.exports.FENGARI_VERSION_NUM     = core.FENGARI_VERSION_NUM;\nmodule.exports.FENGARI_VERSION_RELEASE = core.FENGARI_VERSION_RELEASE;\n\nmodule.exports.luastring_eq      = core.luastring_eq;\nmodule.exports.luastring_indexOf = core.luastring_indexOf;\nmodule.exports.luastring_of      = core.luastring_of;\nmodule.exports.to_jsstring       = core.to_jsstring;\nmodule.exports.to_luastring      = core.to_luastring;\nmodule.exports.to_uristring      = core.to_uristring;\n\nconst luaconf = require('./luaconf.js');\nconst lua     = require('./lua.js');\nconst lauxlib = require('./lauxlib.js');\nconst lualib  = require('./lualib.js');\n\nmodule.exports.luaconf = luaconf;\nmodule.exports.lua     = lua;\nmodule.exports.lauxlib = lauxlib;\nmodule.exports.lualib  = lualib;\n", "// Handle [nested [content blocks]]\nimport StateInline from 'markdown-it/lib/rules_inline/state_inline'\n\nexport default function (state: StateInline, silent: boolean): boolean {\n\n    if (state.src.charCodeAt(state.pos) === 0x5B /* [ */) {\n\n        // If we immediately followed a variable or expression, use it as a Changer for this content:\n        const prevToken = state.tokens[state.tokens.length - 1]\n        let changer: string | null\n        if (prevToken && (prevToken.type == 'code_variable' || prevToken.type == 'code_expression')) {\n            // Remove the expression token; we don't want it to be printed in the output\n            state.tokens.splice(state.tokens.length - 1, 1)\n            changer = prevToken.content\n        } else {\n            changer = null\n        }\n\n        state.push('content_open', '', 1).attrs = [['changer', changer!]]\n        state.pos++\n        return true\n    }\n\n    if (state.src.charCodeAt(state.pos) === 0x5D /* ] */) {\n        state.push('content_close', '', state.level <= 0 ? 0 : -1)\n        state.pos++\n        return true\n    }\n\n    return false\n}\n", "// Handle <$ lua_expression $>\nimport StateInline from 'markdown-it/lib/rules_inline/state_inline'\n\nexport default function (state: StateInline, silent: boolean): boolean {\n\n    const markerLength = 2\n    if (!state.src.startsWith('<$', state.pos)) {\n        return false\n    }\n    const endMarker = state.src.indexOf('$>', state.pos + markerLength)\n    let endBlock: number, endSyntax: number;\n    if (endMarker < 0) {\n        endBlock = state.src.length\n        endSyntax = state.src.length\n    } else {\n        endBlock = endMarker\n        endSyntax = endMarker + markerLength\n    }\n    let tok = state.push('code_expression', '', 0)\n    tok.content = state.src.slice(state.pos + markerLength, endBlock)\n    tok.meta = state.pos\n    state.pos = endSyntax\n    return true\n}", "// Handle [[passage->links]], all three forms\nimport StateInline from 'markdown-it/lib/rules_inline/state_inline'\n\nexport default function (state: StateInline, silent: boolean): boolean {\n\n    const markerLength = 2\n    if (!state.src.startsWith('[[', state.pos)) {\n        return false\n    }\n\n    const startPos = state.pos + markerLength\n    const srcEnd = state.posMax\n    let endPos = startPos\n    let ltrLink = -1\n    let rtlLink = -1\n    while (endPos < srcEnd && !state.src.startsWith(']]', endPos)) {\n        // For complex links, we always want to minimise the length of the 'target' and maximise the length of the 'label'\n        // So for RTL links, we want to take the left-most (first) occurrence, and for LTR, the right-most (last)\n        if (rtlLink === -1 && state.src.startsWith('<-', endPos)) {\n            rtlLink = endPos\n        } else if (state.src.startsWith('->', endPos)) {\n            ltrLink = endPos\n        }\n        endPos++\n    }\n\n    if (endPos === srcEnd) {\n        // No ']]' found; not a valid link\n        return false\n    }\n\n    if (ltrLink !== -1 && rtlLink !== -1) {\n        // In the first instance, prefer the form where the marker is closest to its 'end'\n        const rtlLength = rtlLink - startPos\n        const ltrLength = endPos - (ltrLink + markerLength)\n        // If it's something stupid like [[foo<- ->bar]] or [[foo-> <-bar]], prefer LTR links\n        if (rtlLength < ltrLength) {\n            ltrLink = -1\n        } else {\n            rtlLink = -1\n        }\n    }\n\n    // Slice up the target and label based on the link form\n    let target: string\n    if (ltrLink !== -1) {\n        target = state.src.slice(ltrLink + markerLength, endPos).trim()\n        state.pos = startPos\n        state.posMax = ltrLink\n    } else if (rtlLink !== -1) {\n        target = state.src.slice(startPos, rtlLink).trim()\n        state.pos = rtlLink + markerLength\n        state.posMax = endPos\n    } else {\n        target = state.src.slice(startPos, endPos).trim()\n        state.pos = startPos\n        state.posMax = endPos\n    }\n\n    // If we immediately followed a variable or expression, use it as a Changer for this content:\n    const prevToken = state.tokens[state.tokens.length - 1]\n    let changer: string | null\n    if (prevToken && (prevToken.type == 'code_variable' || prevToken.type == 'code_expression')) {\n        // Remove the expression token; we don't want it to be printed in the output\n        state.tokens.splice(state.tokens.length - 1, 1)\n        changer = prevToken.content\n    } else {\n        changer = null\n    }\n\n    // If the link matches [[ ->Foo]], then just display Foo inline\n    if (ltrLink !== -1 && state.src.slice(state.pos, state.posMax).trim() == \"\") {\n        state.push('link_inline', '', 0).attrs = [ ['href', target], ['changer', changer!] ]\n    } else {\n        // The label can contain tokens itself, so we need to call 'tokenize' here\n        state.push('link_open', 'a', 1).attrs = [ ['href', target], ['changer', changer!] ]\n        state.md.inline.tokenize(state)\n        state.push('link_close', 'a', -1)\n    }\n\n    // Restore the state to its original... state\n    state.pos = endPos + markerLength\n    state.posMax = srcEnd\n    return true\n\n}", "// Handle $variables\nimport StateInline from 'markdown-it/lib/rules_inline/state_inline'\n\nfunction isLetter(code: number): boolean {\n    return code === 0x5F || (code >= 0x41 && code <= 0x5A) || (code >= 0x61 && code <= 0x7A)\n}\n\nfunction isLetterOrNumber(code: number): boolean {\n    return isLetter(code) || (code >= 0x30 && code <= 0x39)\n}\n\nfunction propertyExpression(state: StateInline, output: string[]): boolean {\n    let start = state.pos\n    if (state.src.charCodeAt(state.pos) != 0x2E /* . */) {\n        return false\n    }\n    if (!isLetter(state.src.charCodeAt(state.pos + 1))) {\n        return false\n    }\n    state.pos++\n    do {\n        state.pos++\n    } while (state.pos < state.src.length && isLetterOrNumber(state.src.charCodeAt(state.pos)))\n    output.push(state.src.slice(start, state.pos))\n    return true\n}\n\nfunction callExpression(state: StateInline, output: string[], begin: number, end: number): boolean {\n    if (state.src.charCodeAt(state.pos) != begin) {\n        return false\n    }\n    let start = state.pos\n    let pos = state.pos\n    let level = 1\n    let code: Number\n    do {\n        pos++\n        code = state.src.charCodeAt(pos)\n        if (code == begin) {\n            level++\n        } else if (code == end) {\n            level--\n        }\n    } while (level > 0 && code != 0x0A && pos < state.src.length)\n    if (level == 0) {\n        state.pos = pos + 1\n        output.push(state.src.slice(start, state.pos))\n        return true\n    }\n    return false\n}\n\nfunction lambdaExpression(state: StateInline, output: string[]): boolean {\n    if (!state.src.startsWith(\"<<\", state.pos)) {\n        return false\n    }\n    let found = state.src.indexOf(\">>\", state.pos + 2)\n    if (found < 0) {\n        return false\n    }\n    output.push(\"(function() \")\n    output.push(state.src.slice(state.pos + 2, found))\n    output.push(\" end)\")\n    state.pos = found + 2\n    return true\n}\n\nexport default function (state: StateInline, silent: boolean): boolean {\n\n    if (state.src.charCodeAt(state.pos) !== 0x24 /* $ */) {\n        return false\n    }\n    if (!isLetter(state.src.charCodeAt(state.pos + 1))) {\n        return false\n    }\n    const start = state.pos = state.pos + 1\n    do {\n        state.pos++\n    } while (isLetterOrNumber(state.src.charCodeAt(state.pos)))\n    let output = [state.src.slice(start, state.pos)]\n    while (propertyExpression(state, output) // foo.bar\n        || callExpression(state, output, 0x28, 0x29) // foo(bar)\n        || callExpression(state, output, 0x7B, 0x7D) // foo{bar}\n        || lambdaExpression(state, output) // foo<<bar>>\n    ) {\n        // Continue\n    }\n    let tok = state.push('code_variable', '', 0)\n    tok.content = output.join('')\n    tok.meta = start\n    return true\n}", "// Handle {$ lua_script $}\nimport StateInline from 'markdown-it/lib/rules_inline/state_inline'\n\nexport default function (state: StateInline, silent: boolean): boolean {\n\n    const markerLength = 2\n    if (!state.src.startsWith('{$', state.pos)) {\n        return false\n    }\n    const endMarker = state.src.indexOf('$}', state.pos + markerLength)\n    let endBlock: number, endSyntax: number;\n    if (endMarker < 0) {\n        endBlock = state.src.length\n        endSyntax = state.src.length\n    } else {\n        endBlock = endMarker\n        endSyntax = endMarker + markerLength\n    }\n    let tok = state.push('code_block', '', 0)\n    tok.content = state.src.slice(state.pos + markerLength, endBlock)\n    tok.meta = state.pos\n    state.pos = endSyntax\n    return true\n}", "import content_block from '../rules/content_block'\nimport expression from '../rules/expression'\nimport passage_link from '../rules/passage_link'\nimport variable from '../rules/variable'\nimport script_block from '../rules/script_block'\nimport Token from 'markdown-it/lib/token'\nimport ParserInline from 'markdown-it/lib/parser_inline'\nimport ParserBlock from 'markdown-it/lib/parser_block'\nimport ParserCore from 'markdown-it/lib/parser_core'\nimport { isWhiteSpace } from 'markdown-it/lib/common/utils'\n\n// We construct our own MarkdownIt instance here to exclude the features we don't use\n// (which saves on the bundle size)\nconst md = {\n    inline: new ParserInline(),\n    block: new ParserBlock(),\n    core: new ParserCore(),\n    options: {\n        html:         false,\n        xhtmlOut:     false,\n        breaks:       false,\n        langPrefix:   'language-',\n        linkify:      false,\n        typographer:  true,\n        quotes: '\\u201c\\u201d\\u2018\\u2019', /* \u201C\u201D\u2018\u2019 */\n        highlight: null as null,\n        maxNesting:   100\n    },\n    parse: function(src: string, env: object) {\n        if (typeof src !== 'string') {\n            throw new Error('Input data should be a String');\n        }\n        var state = new this.core.State(src, this as any, env);\n        this.core.process(state);\n        return state.tokens;\n    } \n}\n\nconst rules = md.inline.ruler\nrules.disable(['link', 'image', 'autolink'])\nrules.push('passage_link', passage_link)\nrules.push('content_block', content_block)\nrules.push('expression', expression)\nrules.push('script_block', script_block)\nrules.push('variable', variable)\nmd.block.ruler.disable(['reference'])\n\nfunction escape(input: string): string {\n    return input\n        .replace(/\\'/g, '\\\\\\'')\n        .replace(/\\n/g, '\\\\\\n')\n}\n\nfunction renderOne(input: Token, output: string[], state: {level: number, links: string[]}) {\n\n    function add(str: string) {\n        output.push(`${'  '.repeat(state.level)}${str}`)\n    }\n    // Undo the placeholder character added in preprocess()\n    input.content = input.content?.replace(/\\f/g, '\\n')\n    const changer = input.attrGet('changer')?.replace(/\\f/g, '\\n')\n    const href = escape(input.attrGet('href') ?? '')\n    switch (input.type) {\n    case 'inline':\n        for (const child of input.children!) {\n            renderOne(child, output, state)\n        }\n        break\n    case 'text':\n        let content = input.content\n        if (content.length > 0) {\n            if (!isWhiteSpace(content.charCodeAt(content.length - 1))) {\n                content = content + ' '\n            }\n            add(`Text('${escape(content)}')`)\n        }\n        break\n    case 'link_open':\n        if (changer == null) {\n            add(`Link('${href}')(function()`)\n        } else {\n            add(`Combine(AsChanger(${changer}), Link('${href}'))(function()`)\n        }\n        state.level++\n        state.links.push(href)\n        break\n    case 'link_inline':\n        if (changer == null) {\n            add(`Display('${href}')`)\n        } else {\n            add(`AsChanger(${changer})(function() Display('${href}') end)`)\n        }\n        break\n    case 'content_open':\n        if (changer == null) {\n            add(`Show(function()`)\n        } else {\n            add(`AsChanger(${changer})(function()`)\n        }\n        state.level++\n        break\n    case 'code_variable':\n    case 'code_expression':\n        add(`Show(${input.content})`)\n        break\n    case 'code_block':\n        add(input.content)\n        break\n    default: \n        switch (input.nesting) {\n        case 1:\n            add(`Style.${input.tag}(function()`)\n            state.level++\n            break\n        case -1:\n            state.level--\n            add(`end)`)\n            break\n        case 0:\n            if (input.type == 'softbreak') {\n            } else if (input.tag != \"\") {\n                add(`Object('${input.tag}')`)\n            }\n            break\n        }\n    }\n}\n\nexport function parse(src: string) { return md.parse(preprocess(src), {}) }\n\nexport function markdownToLua(src: string, outputBuffer: string[], state: {level: number, links: string[]}) {\n    let startLevel = state.level\n    for(const token of md.parse(preprocess(src), {})) {\n        renderOne(token, outputBuffer, state)\n    }\n    while (state.level > startLevel) {\n        renderOne(new Token('content_close', '', -1), outputBuffer, state)\n    }\n}\n\nfunction preprocess(src: string): string {\n    let idx = 0\n    let out = \"\"\n    while (idx < src.length) {\n        let i1 = src.indexOf(\"{$\", idx)\n        let i2 = src.indexOf(\"<$\", idx)\n        let search: string\n        let start: number\n        if (i1 >= 0) {\n            start = i1\n            search = \"$}\"\n        } else if (i2 >= 0) {\n            start = i2\n            search = \"$>\"\n        } else {\n            out += src.substring(idx)\n            break\n        }\n        out += src.substring(idx, start)\n        let end = src.indexOf(search, idx + 2)\n        if (end < 0) {\n            end = src.length;\n        } else {\n            end = end + 2;\n        }\n        // Swap out newlines for a placeholder character, to force them to be 'inline'\n        out += src.substring(start, end).replace(/\\n/g, '\\f')\n        idx = end\n    }\n    return out\n}\n\nexport function storyToLua(story: Element): string {\n    let startNode = story.getAttribute('startnode')\n    let startNodeName: string | null = null\n    const buf: string[] = ['-- Generated with Moontale']\n    buf.push(`story = '${escape(story.getAttribute('name')!)}'`)\n    buf.push(`Passages = {`)\n    for (let i = 0; i < story.children.length; i++) {\n        let node = story.children[i]\n        if (node.tagName.toLowerCase() === \"tw-passagedata\") {\n            if (startNode === node.getAttribute('pid')) {\n                startNodeName = node.getAttribute('name')\n            }\n            buf.push(`  ['${escape(node.getAttribute('name')!)}'] = {`)\n            let tags = node.getAttribute('tags')!.split(' ')\n            if (tags.length === 1 && tags[0] === '') {\n                tags = []\n            }\n            buf.push(`    tags = { ${tags.map(t => `['${escape(t)}'] = true`).join(',')} },`)\n            buf.push(`    position = {${node.getAttribute('position')}},`)\n            buf.push(`    content = function()`)\n            let links: string[] = []\n            markdownToLua(node.textContent!, buf, {level: 3, links})\n            buf.push(`    end,`)\n            buf.push(`    links = { ${links.map(t => `'${escape(t)}'`).join(',')} }`)\n            buf.push(`  },`)\n        }\n    }\n    buf.push(`}`)\n    buf.push(`StartPassage = '${escape(startNodeName!)}'`)\n\n    return buf.join('\\n')\n}", "import { lua, lauxlib, lualib, lua_State } from 'fengari'\n\nconst enc = new TextEncoder()\nlet L: lua_State | null = null\nlet tags: string[] = []\nlet buf: string[] = []\nlet emit: (html: string, invalidate: boolean)=>void | undefined\nlet wasChanged = false\nlet invalidated = false\n\nexport function loadStory(src: string[], emitFn: (html: string, invalidate: boolean)=>void, logFn: (error: string, trace: string)=>void) {\n    emit = emitFn\n    L = lauxlib.luaL_newstate()\n\n    lua.lua_atpanic(L, L => {\n        logFn(lua.lua_tojsstring(L, lua.lua_gettop(L)), \"Panic\")\n        return 0\n    })\n\n    lualib.luaL_openlibs(L)\n\n    lua.lua_register(L, \"print\", L => {\n        let l = lua.lua_gettop(L)\n        let args: string[] = []\n        for (let i = 1; i <= l; i++) {\n            args.push(lua.lua_tojsstring(L, i))\n        }\n        console.log(...args)\n        return 0\n    })\n\n    lua.lua_register(L, \"Log\", L => {\n        let top = lua.lua_gettop(L)\n        logFn(lua.lua_tojsstring(L, 1), lua.lua_tojsstring(L, 2))\n        return 0\n    })\n\n    lua.lua_register(L, \"Push\", L => {\n        let str = lua.lua_tojsstring(L, 1)\n        tags.push(str)\n        if (str == 'a') {\n            buf.push(`<a href=\"#\" id=\"${lua.lua_tonumber(L, 2)}\">`)\n            lua.lua_pop(L, 1)\n        } else if (str == 'color') {\n            buf.push(`<span style=\"color: ${lua.lua_tojsstring(L, 2)};\">`)\n        } else {\n            buf.push(`<${str}>`)\n        }\n        wasChanged = true\n        return 0\n    })\n    lua.lua_register(L, \"Pop\", L => {\n        let str = tags.splice(tags.length - 1, 1)[0]\n        if (str) {\n            if (str === \"color\") {\n                buf.push(`</span>`)\n            } else {\n                buf.push(`</${str}>`)\n            }\n        }\n        wasChanged = true\n        return 0\n    })\n    lua.lua_register(L, \"Text\", L => {\n        let str = lua.lua_tojsstring(L, 1)\n        buf.push(str)\n        wasChanged = true\n        return 0\n    })\n    lua.lua_register(L, \"Object\", L => {\n        let str = lua.lua_tojsstring(L, 1)\n        buf.push(`<${str}>`)\n        wasChanged = true\n        return 0\n    })\n    lua.lua_register(L, \"Clear\", L => {\n        buf = []\n        wasChanged = true\n        return 0\n    })\n    lua.lua_register(L, \"Invalidate\", L => {\n        invalidated = true\n        wasChanged = true\n        return 0\n    })\n\n    src.map(x => lauxlib.luaL_dostring(L!, enc.encode(x)))\n}\n\nexport function raiseEvent(event: string, id: string) {\n    if (L == null) {\n        return;\n    }\n    lua.lua_getglobal(L, 'RaiseEvent')\n    lua.lua_pushstring(L, event)\n    lua.lua_pushstring(L, id)\n    lua.lua_call(L, 2, 0)\n    if (wasChanged) {\n        wasChanged = false\n        emit?.(buf.join(''), invalidated)\n        invalidated = false;\n    }\n}\n\nexport function start() {\n    if (L == null) {\n        return;\n    }\n    lua.lua_getglobal(L, 'SoftReset')\n    lua.lua_call(L, 0, 0)\n    emit?.(buf.join(''), invalidated)\n    invalidated = false\n    wasChanged = false\n}\n\nexport function update(deltaTime: number) {\n    if (L == null) {\n        return;\n    }\n    lua.lua_getglobal(L, 'Update')\n    lua.lua_pushnumber(L, deltaTime)\n    lua.lua_call(L, 1, 0)\n    if (wasChanged) {\n        wasChanged = false\n        emit?.(buf.join(''), invalidated)\n        invalidated = false;\n    }\n}", "\nimport { storyToLua } from '../common/convert'\nimport { loadStory, start, raiseEvent, update } from '../common/runtime'\nimport moontaleLib from '../../moontale-unity/Packages/com.hmilne.moontale/Runtime/moontale.lua'\n\nconst transitionTime = 200\n\nlet output = document.getElementById('output')!\nlet outputContainer = document.getElementById('outputContainer')!\nlet luaCode = document.getElementById('lua')!\nlet inputDisabled = false\n\nlet toggle = document.getElementById('outputToggleInput') as HTMLInputElement\nfunction outputDisplay() {\n    outputContainer.style.display = toggle.checked ? 'none' : 'block'\n    luaCode.style.display = toggle.checked ? 'block' : 'none'\n}\ntoggle.onchange = event => {\n    outputContainer.style.opacity = toggle.checked ? '0' : '1'\n    luaCode.style.opacity = toggle.checked ? '1' : '0'\n    setTimeout(outputDisplay, transitionTime)\n}\n\nlet luaSrc = storyToLua(document.getElementById('storyData')!.children[0])\nluaCode.textContent = luaSrc\n\nlet download = document.getElementById('download') as HTMLAreaElement\ndownload.href = window.URL.createObjectURL(new Blob([luaSrc], {type: \"octet/stream\"}))\ndownload.download = document.title + \".lua\"\n\nfunction onNewText(html: string) {\n    output.innerHTML = html\n    output.style.opacity = '1'\n    inputDisabled = false\n}\n\nloadStory([moontaleLib, luaSrc], (html, invalidate) => {\n    if (invalidate) {\n        inputDisabled = true\n        output.style.opacity = '0'\n        setTimeout(onNewText, transitionTime, html)\n    } else {\n        onNewText(html)\n    }\n}, (message) => {\n    console.error(message)\n})\n\nfunction getEventId(event: Event): string | null {\n    let target: Element | null = event.target as Element\n    while (target && !(Number(target.id) > 0)) {\n        target = target.parentElement\n    }\n    if (!target) {\n        return null\n    }\n    return target.id\n}\n\nlet hovering: string | null = null\n\nwindow.addEventListener('click', event => {\n    if (inputDisabled) {\n        return\n    }\n    let id = getEventId(event)\n    if (id !== null) {\n        hovering = null\n        raiseEvent(event.type, id)\n    }\n})\nwindow.addEventListener('mouseover', event => {\n    if (inputDisabled) {\n        return\n    }\n    let id = getEventId(event)\n    if (id === hovering) {\n        return\n    }\n    if (id !== null) {\n        if (hovering !== null) {\n            raiseEvent('mouseout', hovering)\n        }\n        hovering = id\n        raiseEvent(event.type, id)\n    }\n})\nwindow.addEventListener('mouseout', event => {\n    if (inputDisabled) {\n        return\n    }\n    let id = getEventId(event)\n    if (id !== null && id === hovering) {\n        hovering = null\n        raiseEvent(event.type, id)\n    }\n})\n\nlet lastTime = performance.now()\nlet callback: FrameRequestCallback = time => {\n    update((time - lastTime) * 1000)\n    lastTime = time\n    window.requestAnimationFrame(callback)\n}\nwindow.requestAnimationFrame(callback)\n\nstart()\n"],
  "mappings": "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U,EAAI,EAC9C,GAAK,EAAI,GAAK,EAAI,GAAU,EAAI,GAAU,EAAI,EAC9C,GAAK,EAAI,GAAK,EAAI,GAAU,EAAI,GAAU,EAAI,EAC9C,GAAK,EAAI,GAAK,EAAI,GAAU,EAAI,GAAU,EAAI,EAC9C,GAAK,EAAI,GAAK,EAAI,GAAU,EAAI,GAAU,EAAI,EAC9C,GAAK,EAAI,GAAK,EAAI,GAAU,EAAI,GAAU,EAAI,EAC9C,GAAK,EAAI,GAAK,EAAI,GAAU,EAAI,GAAU,EAAI,EAC9C,GAAK,EAAI,GAAK,EAAI,IAAU,EAAI,IAAU,EAAI,EAC9C,GAAK,EAAI,GAAK,EAAI,IAAU,EAAI,IAAU,EAAI,EAC9C,GAAK,EAAI,GAAK,EAAI,IAAU,EAAI,IAAU,EAAI,EAC9C,GAAK,EAAI,GAAK,EAAI,IAAU,EAAI,IAAU,EAAI,EAC9C,GAAK,EAAI,GAAK,EAAI,IAAU,EAAI,IAAU,EAAI,EAC9C,GAAK,EAAI,GAAK,EAAI,IAAU,EAAI,IAAU,EAAI,GAC9C,GAAK,EAAI,GAAK,EAAI,GAAU,EAAI,GAAU,EAAI,EAC9C,GAAK,EAAI,GAAK,EAAI,GAAU,EAAI,GAAU,EAAI,EAC9C,GAAK,EAAI,GAAK,EAAI,GAAU,EAAI,GAAU,EAAI,EAC9C,GAAK,EAAI,GAAK,EAAI,IAAU,EAAI,IAAU,EAAI,EAC9C,GAAK,EAAI,GAAK,EAAI,IAAU,EAAI,IAAU,EAAI,EAC9C,GAAK,EAAI,GAAK,EAAI,IAAU,EAAI,IAAU,EAAI,EAC9C,GAAK,EAAI,GAAK,EAAI,IAAU,EAAI,IAAU,EAAI,EAC9C,GAAK,EAAI,GAAK,EAAI,IAAU,EAAI,IAAU,EAAI,EAC9C,GAAK,EAAI,GAAK,EAAI,IAAU,EAAI,IAAU,EAAI,GAC9C,GAAK,EAAI,GAAK,EAAI,IAAU,EAAI,IAAU,EAAI,GAC9C,GAAK,EAAI,GAAK,EAAI,IAAU,EAAI,IAAU,EAAI,EAC9C,GAAK,EAAI,GAAK,EAAI,IAAU,EAAI,IAAU,EAAI,GAC9C,GAAK,EAAI,GAAK,EAAI,IAAU,EAAI,IAAU,EAAI,EAC9C,GAAK,EAAI,GAAK,EAAI,IAAU,EAAI,IAAU,EAAI,GAC9C,GAAK,EAAI,GAAK,EAAI,IAAU,EAAI,IAAU,EAAI,EAC9C,GAAK,EAAI,GAAK,EAAI,IAAU,EAAI,IAAU,EAAI,EAClD,EAEM,GAAY,SAAS,EAAG,CAC1B,MAAO,IAAa,GAAK,CAC7B,EAEM,GAAW,SAAS,EAAG,CACzB,MAAQ,IAAa,IAAM,EAAK,CACpC,EAEM,GAAW,SAAS,EAAG,CACzB,MAAQ,IAAa,IAAM,EAAK,CACpC,EAEM,GAAY,SAAS,EAAG,CAC1B,MAAO,IAAa,GAAM,GAAK,CACnC,EAEM,GAAY,SAAS,EAAG,CAC1B,MAAO,IAAa,GAAM,GAAK,CACnC,EAEM,GAAa,EACb,GAAa,EACb,GAAc,GAAS,GACvB,GAAa,EACb,GAAc,GAAS,GAAS,GAChC,GAAa,EACb,GAAa,EACb,GAAc,GAAS,GACvB,GAAc,GAAQ,GACtB,GAAc,GAAQ,GACtB,GAAa,GACb,GAAa,GACb,GAAe,IAAK,IAAW,EAC/B,GAAc,IAAa,EAC3B,GAAe,IAAG,IAAS,EAC3B,GAAe,IAAK,IAAU,EAC9B,GAAe,IAAK,IAAU,EAC9B,GAAe,IAAK,IAAU,EAG9B,GAAc,GAAM,GAAS,EAE7B,GAAc,GAAQ,EAKtB,GAAa,GAGb,GAAM,SAAU,EAAG,CACrB,MAAO,GAAI,EACf,EAGM,GAAS,SAAU,EAAG,CACxB,MAAO,GAAI,CAAC,EAChB,EAGM,GAAQ,SAAS,EAAG,CACtB,MAAO,GAAI,EACf,EAIM,GAAQ,SAAS,EAAG,EAAG,CACzB,MAAS,CAAG,KAAM,IAAO,CAC7B,EAGM,GAAQ,SAAS,EAAG,EAAG,CACzB,MAAQ,CAAC,GAAM,EAAG,CAAC,CACvB,EAEM,GAAa,SAAS,EAAG,CAC3B,MAAO,GAAE,MACb,EAEM,GAAa,SAAS,EAAG,EAAG,CAC9B,SAAE,KAAQ,EAAE,KAAO,GAAM,GAAS,EAAM,EAAO,GAAK,GAAU,GAAM,GAAS,EAAM,EAC5E,GAAQ,CAAC,CACpB,EAEM,GAAS,SAAS,EAAG,EAAG,EAAK,EAAM,CACrC,SAAE,KAAQ,EAAE,KAAO,GAAM,EAAM,CAAG,EAAO,GAAK,EAAO,GAAM,EAAM,CAAG,EAC7D,GAAQ,CAAC,CACpB,EAEM,GAAW,SAAS,EAAG,CACzB,MAAO,GAAE,CACb,EAEM,GAAW,SAAS,EAAE,EAAG,CAC3B,MAAO,IAAO,EAAG,EAAG,GAAO,EAAM,CACrC,EAEM,GAAW,SAAS,EAAG,CACzB,MAAO,GAAE,CACb,EAEM,GAAW,SAAS,EAAE,EAAG,CAC3B,MAAO,IAAO,EAAG,EAAG,GAAO,EAAM,CACrC,EAEM,GAAW,SAAS,EAAG,CACzB,MAAO,GAAE,CACb,EAEM,GAAW,SAAS,EAAE,EAAG,CAC3B,MAAO,IAAO,EAAG,EAAG,GAAO,EAAM,CACrC,EAEM,GAAY,SAAS,EAAG,CAC1B,MAAO,GAAE,EACb,EAEM,GAAY,SAAS,EAAE,EAAG,CAC5B,MAAO,IAAO,EAAG,EAAG,GAAQ,EAAO,CACvC,EAEM,GAAY,SAAS,EAAG,CAC1B,MAAO,GAAE,EACb,EAEM,GAAY,SAAS,EAAE,EAAG,CAC5B,MAAO,IAAO,EAAG,EAAG,GAAQ,EAAO,CACvC,EAEM,GAAa,SAAS,EAAG,CAC3B,MAAO,GAAE,GACb,EAEM,GAAa,SAAS,EAAG,EAAG,CAC9B,MAAO,IAAU,EAAG,EAAI,EAAU,CACtC,EAKM,GAAU,SAAS,EAAK,CAC1B,GAAI,MAAO,IAAQ,SACf,MAAO,CACH,KAAQ,EACR,OAAS,GAAO,GAAU,GAAM,GAAS,CAAC,EAC1C,EAAS,GAAO,GAAU,GAAM,GAAS,CAAC,EAC1C,EAAS,GAAO,GAAU,GAAM,GAAS,CAAC,EAC1C,EAAS,GAAO,GAAU,GAAM,GAAS,CAAC,EAC1C,GAAS,GAAO,GAAU,GAAM,GAAS,CAAC,EAC1C,GAAS,GAAO,GAAU,GAAM,GAAS,CAAC,EAC1C,IAAU,IAAO,GAAU,GAAM,GAAS,CAAC,GAAK,EACpD,EACG,CACH,GAAI,GAAI,EAAI,KACZ,SAAI,OAAU,GAAK,GAAU,GAAM,GAAS,CAAC,EAC7C,EAAI,EAAU,GAAK,GAAU,GAAM,GAAS,CAAC,EAC7C,EAAI,EAAU,GAAK,GAAU,GAAM,GAAS,CAAC,EAC7C,EAAI,EAAU,GAAK,GAAU,GAAM,GAAS,CAAC,EAC7C,EAAI,GAAU,GAAK,GAAU,GAAM,GAAS,CAAC,EAC7C,EAAI,GAAU,GAAK,GAAU,GAAM,GAAS,CAAC,EAC7C,EAAI,IAAW,IAAK,GAAU,GAAM,GAAS,CAAC,GAAK,GAC5C,CACX,CACJ,EAEM,GAAa,SAAS,EAAG,EAAG,EAAG,EAAG,CACpC,MAAO,IAAQ,GAAK,GAAS,GAAK,GAAQ,GAAK,GAAQ,GAAK,EAAK,CACrE,EAEM,GAAa,SAAS,EAAG,EAAG,EAAI,CAClC,MAAO,IAAQ,GAAK,GAAS,GAAK,GAAQ,GAAM,EAAM,CAC1D,EAEM,GAAY,SAAS,EAAG,EAAG,CAC7B,MAAO,IAAQ,GAAK,GAAS,GAAK,EAAM,CAC5C,EAGM,GAAoB,GAE1B,EAAO,QAAQ,MAAsB,GACrC,EAAO,QAAQ,WAAsB,GACrC,EAAO,QAAQ,WAAsB,GACrC,EAAO,QAAQ,UAAsB,GACrC,EAAO,QAAQ,WAAsB,GACrC,EAAO,QAAQ,SAAsB,GACrC,EAAO,QAAQ,SAAsB,GACrC,EAAO,QAAQ,SAAsB,GACrC,EAAO,QAAQ,UAAsB,GACrC,EAAO,QAAQ,UAAsB,GACrC,EAAO,QAAQ,WAAsB,GACrC,EAAO,QAAQ,OAAsB,GACrC,EAAO,QAAQ,IAAsB,GACrC,EAAO,QAAQ,kBAAsB,GACrC,EAAO,QAAQ,SAAsB,GACrC,EAAO,QAAQ,UAAsB,GACrC,EAAO,QAAQ,SAAsB,GACrC,EAAO,QAAQ,UAAsB,GACrC,EAAO,QAAQ,SAAsB,GACrC,EAAO,QAAQ,WAAsB,GACrC,EAAO,QAAQ,WAAsB,GACrC,EAAO,QAAQ,OAAsB,GACrC,EAAO,QAAQ,OAAsB,EACrC,EAAO,QAAQ,OAAsB,GACrC,EAAO,QAAQ,OAAsB,GACrC,EAAO,QAAQ,OAAsB,GACrC,EAAO,QAAQ,QAAsB,GACrC,EAAO,QAAQ,SAAsB,GACrC,EAAO,QAAQ,MAAsB,GACrC,EAAO,QAAQ,OAAsB,GACrC,EAAO,QAAQ,MAAsB,GACrC,EAAO,QAAQ,OAAsB,GACrC,EAAO,QAAQ,MAAsB,GACrC,EAAO,QAAQ,OAAsB,GACrC,EAAO,QAAQ,MAAsB,GACrC,EAAO,QAAQ,SAAsB,GACrC,EAAO,QAAQ,UAAsB,GACrC,EAAO,QAAQ,SAAsB,GACrC,EAAO,QAAQ,UAAsB,GACrC,EAAO,QAAQ,SAAsB,GACrC,EAAO,QAAQ,WAAsB,GACrC,EAAO,QAAQ,WAAsB,GACrC,EAAO,QAAQ,OAAsB,GACrC,EAAO,QAAQ,QAAsB,GACrC,EAAO,QAAQ,OAAsB,GACrC,EAAO,QAAQ,QAAsB,GACrC,EAAO,QAAQ,OAAsB,GACrC,EAAO,QAAQ,QAAsB,GACrC,EAAO,QAAQ,QAAsB,GACrC,EAAO,QAAQ,SAAsB,GACrC,EAAO,QAAQ,SAAsB,GACrC,EAAO,QAAQ,UAAsB,GACrC,EAAO,QAAQ,KAAsB,EACrC,EAAO,QAAQ,KAAsB,GACrC,EAAO,QAAQ,MAAsB,GACrC,EAAO,QAAQ,IAAsB,GACrC,EAAO,QAAQ,UAAsB,GACrC,EAAO,QAAQ,UAAsB,KCxZrC,mBAEA,GAAM,CACF,gBACA,iBACA,eACA,eAAgB,CACZ,gBACA,YACA,sBACA,eACA,YACA,eACA,eACA,eACA,eACA,cACA,kBAEJ,iBACA,KACE,CACF,UACA,OACA,qBACA,SAAU,CACN,UACA,WACA,WACA,UACA,WACA,WACA,cACA,aACA,UACA,SACA,eACA,cACA,cACA,eACA,eACA,eACA,WACA,UACA,SACA,UACA,eACA,YACA,aACA,cACA,SACA,UACA,WACA,UACA,eACA,UACA,UACA,aACA,WACA,cACA,eACA,eACA,eACA,UACA,UACA,UACA,eACA,WACA,cACA,eACA,eACA,UACA,eAEJ,KACE,CACF,kBACA,kBACA,wBACA,KACE,CACF,cACA,gBACA,KACE,GAAU,KACV,GAAU,KACV,GAAU,KACV,CACF,cACA,iBACA,qBACA,KACE,GAAU,KACV,EAAU,KACV,GAAU,KACV,GAAU,KAKV,GAAgB,SAAS,EAAG,CAC9B,GAAI,GAAK,EAAE,GACP,EAAO,EAAG,OACV,EAAO,EAAG,OAAO,EAAG,UAAY,GAChC,EAAK,EAAK,OAEd,OAAQ,OACC,QAAa,QAAa,QAAa,QAAa,QACpD,QAAc,QAAa,QAAc,QAAa,QACtD,QAAa,QACb,QAAa,QAAc,QAC3B,QAAkB,QAAkB,IAAS,CAC9C,GAAQ,UAAU,EAAG,EAAO,EAAK,EAAG,EAAE,IAAI,CAAC,EAC3C,MAAO,GAAE,MAAM,EAAE,EAAE,KACnB,KACJ,KACK,QAAY,QAAY,IAAO,CAChC,GAAI,GAAM,CAAC,EAAE,MAAM,EAAE,IAAM,GAAG,UAAU,EACxC,MAAO,GAAE,MAAM,EAAE,EAAE,KACf,EAAG,WAAa,GAAO,UACvB,IAAW,IAAO,EAAK,EACvB,EAAG,YAAc,GAAO,SACxB,EAAM,CAAC,GAEX,GAAW,EAAG,OAAO,EAAG,WAAW,SAAW,EAAM,EAChD,IAAS,IAAK,GACd,EAAG,YACP,KACJ,KACK,IAAW,CACZ,GAAI,GAAM,EAAE,IAAM,EACd,EAAI,EAAK,EACT,EAAQ,EAAM,EAAK,GAAO,GAC9B,GAAQ,UAAU,EAAG,EAAM,EAAG,CAAG,EAC7B,EAAQ,GACR,GAAE,IAAM,EAAM,EACd,GAAY,EAAG,CAAK,GAGxB,GAAQ,UAAU,EAAG,EAAG,OAAS,EAAK,EAAG,EAAE,IAAM,CAAC,EAClD,GAAI,WAAW,EAAG,EAAG,GAAG,EACxB,KACJ,KACK,IAAa,CACd,GAAW,EAAG,OAAO,EAAG,WAAW,SAAW,EAAW,EACzD,GAAI,WAAW,EAAG,EAAG,GAAG,EACxB,KACJ,KACK,IAAS,CACV,AAAI,EAAK,EAAI,GAAK,GACd,GAAI,WAAW,EAAG,EAAG,GAAG,EAC5B,KACJ,EAER,EAEM,GAAK,SAAS,EAAG,EAAM,EAAG,CAC5B,MAAO,GAAO,EAAE,CACpB,EAEM,GAAK,SAAS,EAAG,EAAM,EAAG,CAC5B,MAAO,GAAO,EAAE,CACpB,EAMM,GAAM,SAAS,EAAG,EAAM,EAAG,EAAG,CAChC,MAAO,IAAI,EAAE,CAAC,EAAI,EAAE,GAAO,EAAE,CAAC,GAAK,EAAE,MAAM,EAAO,EAAE,EACxD,EAEM,GAAM,SAAS,EAAG,EAAM,EAAG,EAAG,CAChC,MAAO,IAAI,EAAE,CAAC,EAAI,EAAE,GAAO,EAAE,CAAC,GAAK,EAAE,MAAM,EAAO,EAAE,EACxD,EAEM,GAAe,SAAS,EAAG,CAC7B,GAAI,GAAK,EAAE,GAEX,EAAG,YAAc,GAAO,WACxB,EACA,OAAS,CACL,GAAW,IAAO,EAAE,EAAE,EACtB,GAAI,GAAK,EAAG,KAAK,MACb,EAAI,EAAG,EAAE,EACT,EAAO,EAAG,OAEV,EAAI,EAAG,OAAO,EAAG,aAErB,AAAI,EAAE,SAAY,IAAe,KAC7B,GAAO,eAAe,CAAC,EAG3B,GAAI,GAAK,GAAG,EAAG,EAAM,CAAC,EAGtB,OAFa,EAAE,YAGN,IAAS,CACV,GAAQ,UAAU,EAAG,EAAI,GAAG,EAAG,EAAM,CAAC,CAAC,EACvC,KACJ,KACK,IAAU,CACX,GAAI,GAAQ,EAAE,EAAE,IAChB,GAAQ,SAAS,EAAG,EAAI,CAAK,EAC7B,KACJ,KACK,IAAW,CACZ,GAAW,EAAG,OAAO,EAAG,WAAW,SAAW,EAAW,EACzD,GAAI,GAAQ,EAAE,EAAG,OAAO,EAAG,aAAa,IACxC,GAAQ,SAAS,EAAG,EAAI,CAAK,EAC7B,KACJ,KACK,IAAa,CACd,EAAE,MAAM,GAAI,UAAU,EAAE,IAAM,CAAC,EAE3B,EAAE,IAAM,GACR,EAAG,YAEP,KACJ,KACK,IAAY,CACb,OAAS,GAAI,EAAG,GAAK,EAAE,EAAG,IACtB,EAAE,MAAM,EAAK,GAAG,YAAY,EAChC,KACJ,KACK,IAAa,CACd,GAAI,GAAI,EAAE,EACV,GAAQ,SAAS,EAAG,EAAI,EAAG,OAAO,EAAE,EACpC,KACJ,KACK,IAAa,CACd,GAAI,GAAQ,EAAG,OAAO,EAAE,GACpB,EAAK,GAAI,EAAG,EAAM,EAAG,CAAC,EAC1B,GAAc,EAAG,EAAO,EAAI,CAAE,EAC9B,KACJ,KACK,IAAa,CACd,GAAI,GAAK,EAAE,MAAM,GAAG,EAAG,EAAM,CAAC,GAC1B,EAAK,GAAI,EAAG,EAAM,EAAG,CAAC,EAC1B,GAAc,EAAG,EAAI,EAAI,CAAE,EAC3B,KACJ,KACK,IAAa,CACd,GAAI,GAAQ,EAAG,OAAO,EAAE,GACpB,EAAK,GAAI,EAAG,EAAM,EAAG,CAAC,EACtB,EAAK,GAAI,EAAG,EAAM,EAAG,CAAC,EAC1B,GAAS,EAAG,EAAO,EAAI,CAAE,EACzB,KACJ,KACK,IAAa,CAEd,AADS,EAAG,OAAO,EAAE,GAClB,QAAQ,EAAE,MAAM,EAAG,EACtB,KACJ,KACK,IAAa,CACd,GAAI,GAAQ,EAAE,MAAM,GAChB,EAAM,GAAI,EAAG,EAAM,EAAG,CAAC,EACvB,EAAI,GAAI,EAAG,EAAM,EAAG,CAAC,EAEzB,GAAS,EAAG,EAAO,EAAK,CAAC,EACzB,KACJ,KACK,IAAa,CACd,EAAE,MAAM,GAAI,UAAU,GAAO,SAAS,CAAC,CAAC,EACxC,KACJ,KACK,IAAS,CACV,GAAI,GAAK,GAAG,EAAG,EAAM,CAAC,EAClB,EAAK,GAAI,EAAG,EAAM,EAAG,CAAC,EAC1B,GAAQ,UAAU,EAAG,EAAK,EAAG,CAAE,EAC/B,GAAc,EAAG,EAAE,MAAM,GAAK,EAAI,CAAE,EACpC,KACJ,KACK,IAAQ,CACT,GAAI,GAAM,GAAI,EAAG,EAAM,EAAG,CAAC,EACvB,EAAM,GAAI,EAAG,EAAM,EAAG,CAAC,EACvB,EAAW,EAEf,AAAI,EAAI,YAAY,GAAK,EAAI,YAAY,EACrC,EAAE,MAAM,GAAI,UAAW,EAAI,MAAQ,EAAI,MAAO,CAAC,EAC5C,AAAK,GAAY,GAAS,CAAG,KAAO,IAAU,GAAY,GAAS,CAAG,KAAO,GAChF,EAAE,MAAM,GAAI,YAAY,EAAY,CAAS,EAE7C,EAAI,cAAc,EAAG,EAAK,EAAK,EAAE,MAAM,GAAK,EAAI,IAAI,MAAM,EAE9D,KACJ,KACK,IAAQ,CACT,GAAI,GAAM,GAAI,EAAG,EAAM,EAAG,CAAC,EACvB,EAAM,GAAI,EAAG,EAAM,EAAG,CAAC,EACvB,EAAW,EAEf,AAAI,EAAI,YAAY,GAAK,EAAI,YAAY,EACrC,EAAE,MAAM,GAAI,UAAW,EAAI,MAAQ,EAAI,MAAO,CAAC,EAC5C,AAAK,GAAY,GAAS,CAAG,KAAO,IAAU,GAAY,GAAS,CAAG,KAAO,GAChF,EAAE,MAAM,GAAI,YAAY,EAAY,CAAS,EAE7C,EAAI,cAAc,EAAG,EAAK,EAAK,EAAE,MAAM,GAAK,EAAI,IAAI,MAAM,EAE9D,KACJ,KACK,IAAQ,CACT,GAAI,GAAM,GAAI,EAAG,EAAM,EAAG,CAAC,EACvB,EAAM,GAAI,EAAG,EAAM,EAAG,CAAC,EACvB,EAAW,EAEf,AAAI,EAAI,YAAY,GAAK,EAAI,YAAY,EACrC,EAAE,MAAM,GAAI,UAAU,GAAU,EAAI,MAAO,EAAI,KAAK,CAAC,EAClD,AAAK,GAAY,GAAS,CAAG,KAAO,IAAU,GAAY,GAAS,CAAG,KAAO,GAChF,EAAE,MAAM,GAAI,YAAY,EAAY,CAAS,EAE7C,EAAI,cAAc,EAAG,EAAK,EAAK,EAAE,MAAM,GAAK,EAAI,IAAI,MAAM,EAE9D,KACJ,KACK,IAAQ,CACT,GAAI,GAAM,GAAI,EAAG,EAAM,EAAG,CAAC,EACvB,EAAM,GAAI,EAAG,EAAM,EAAG,CAAC,EACvB,EAAW,EAEf,AAAI,EAAI,YAAY,GAAK,EAAI,YAAY,EACrC,EAAE,MAAM,GAAI,UAAU,GAAS,EAAG,EAAI,MAAO,EAAI,KAAK,CAAC,EACpD,AAAK,GAAY,GAAS,CAAG,KAAO,IAAU,GAAY,GAAS,CAAG,KAAO,GAChF,EAAE,MAAM,GAAI,YAAY,GAAY,EAAG,EAAW,CAAS,CAAC,EAE5D,EAAI,cAAc,EAAG,EAAK,EAAK,EAAE,MAAM,GAAK,EAAI,IAAI,MAAM,EAE9D,KACJ,KACK,IAAQ,CACT,GAAI,GAAM,GAAI,EAAG,EAAM,EAAG,CAAC,EACvB,EAAM,GAAI,EAAG,EAAM,EAAG,CAAC,EACvB,EAAW,EAEf,AAAK,GAAY,GAAS,CAAG,KAAO,IAAU,GAAY,GAAS,CAAG,KAAO,GACzE,EAAE,MAAM,GAAI,YAAY,KAAK,IAAI,EAAW,CAAS,CAAC,EAEtD,EAAI,cAAc,EAAG,EAAK,EAAK,EAAE,MAAM,GAAK,EAAI,IAAI,MAAM,EAE9D,KACJ,KACK,IAAQ,CACT,GAAI,GAAM,GAAI,EAAG,EAAM,EAAG,CAAC,EACvB,EAAM,GAAI,EAAG,EAAM,EAAG,CAAC,EACvB,EAAW,EAEf,AAAK,GAAY,GAAS,CAAG,KAAO,IAAU,GAAY,GAAS,CAAG,KAAO,GACzE,EAAE,MAAM,GAAI,YAAY,EAAY,CAAS,EAE7C,EAAI,cAAc,EAAG,EAAK,EAAK,EAAE,MAAM,GAAK,EAAI,IAAI,MAAM,EAE9D,KACJ,KACK,IAAS,CACV,GAAI,GAAM,GAAI,EAAG,EAAM,EAAG,CAAC,EACvB,EAAM,GAAI,EAAG,EAAM,EAAG,CAAC,EACvB,EAAW,EAEf,AAAI,EAAI,YAAY,GAAK,EAAI,YAAY,EACrC,EAAE,MAAM,GAAI,UAAU,GAAS,EAAG,EAAI,MAAO,EAAI,KAAK,CAAC,EACpD,AAAK,GAAY,GAAS,CAAG,KAAO,IAAU,GAAY,GAAS,CAAG,KAAO,GAChF,EAAE,MAAM,GAAI,YAAY,KAAK,MAAM,EAAY,CAAS,CAAC,EAEzD,EAAI,cAAc,EAAG,EAAK,EAAK,EAAE,MAAM,GAAK,EAAI,IAAI,OAAO,EAE/D,KACJ,KACK,IAAS,CACV,GAAI,GAAM,GAAI,EAAG,EAAM,EAAG,CAAC,EACvB,EAAM,GAAI,EAAG,EAAM,EAAG,CAAC,EACvB,EAAW,EAEf,AAAK,GAAY,GAAU,CAAG,KAAO,IAAU,GAAY,GAAU,CAAG,KAAO,GAC3E,EAAE,MAAM,GAAI,UAAU,EAAY,CAAS,EAE3C,EAAI,cAAc,EAAG,EAAK,EAAK,EAAE,MAAM,GAAK,EAAI,IAAI,OAAO,EAE/D,KACJ,KACK,IAAQ,CACT,GAAI,GAAM,GAAI,EAAG,EAAM,EAAG,CAAC,EACvB,EAAM,GAAI,EAAG,EAAM,EAAG,CAAC,EACvB,EAAW,EAEf,AAAK,GAAY,GAAU,CAAG,KAAO,IAAU,GAAY,GAAU,CAAG,KAAO,GAC3E,EAAE,MAAM,GAAI,UAAU,EAAY,CAAS,EAE3C,EAAI,cAAc,EAAG,EAAK,EAAK,EAAE,MAAM,GAAK,EAAI,IAAI,MAAM,EAE9D,KACJ,KACK,IAAS,CACV,GAAI,GAAM,GAAI,EAAG,EAAM,EAAG,CAAC,EACvB,EAAM,GAAI,EAAG,EAAM,EAAG,CAAC,EACvB,EAAW,EAEf,AAAK,GAAY,GAAU,CAAG,KAAO,IAAU,GAAY,GAAU,CAAG,KAAO,GAC3E,EAAE,MAAM,GAAI,UAAU,EAAY,CAAS,EAE3C,EAAI,cAAc,EAAG,EAAK,EAAK,EAAE,MAAM,GAAK,EAAI,IAAI,OAAO,EAE/D,KACJ,KACK,IAAQ,CACT,GAAI,GAAM,GAAI,EAAG,EAAM,EAAG,CAAC,EACvB,EAAM,GAAI,EAAG,EAAM,EAAG,CAAC,EACvB,EAAW,EAEf,AAAK,GAAY,GAAU,CAAG,KAAO,IAAU,GAAY,GAAU,CAAG,KAAO,GAC3E,EAAE,MAAM,GAAI,UAAU,GAAY,EAAW,CAAS,CAAC,EAEvD,EAAI,cAAc,EAAG,EAAK,EAAK,EAAE,MAAM,GAAK,EAAI,IAAI,MAAM,EAE9D,KACJ,KACK,IAAQ,CACT,GAAI,GAAM,GAAI,EAAG,EAAM,EAAG,CAAC,EACvB,EAAM,GAAI,EAAG,EAAM,EAAG,CAAC,EACvB,EAAW,EAEf,AAAK,GAAY,GAAU,CAAG,KAAO,IAAU,GAAY,GAAU,CAAG,KAAO,GAC3E,EAAE,MAAM,GAAI,UAAU,GAAY,EAAW,CAAC,CAAS,CAAC,EAExD,EAAI,cAAc,EAAG,EAAK,EAAK,EAAE,MAAM,GAAK,EAAI,IAAI,MAAM,EAE9D,KACJ,KACK,IAAQ,CACT,GAAI,GAAK,EAAE,MAAM,GAAG,EAAG,EAAM,CAAC,GAC1B,EAEJ,AAAI,EAAG,YAAY,EACf,EAAE,MAAM,GAAI,UAAW,CAAC,EAAG,MAAO,CAAC,EAChC,AAAK,GAAW,GAAS,CAAE,KAAO,GACrC,EAAE,MAAM,GAAI,YAAY,CAAC,CAAQ,EAEjC,EAAI,cAAc,EAAG,EAAI,EAAI,EAAE,MAAM,GAAK,EAAI,IAAI,MAAM,EAE5D,KACJ,KACK,IAAS,CACV,GAAI,GAAK,EAAE,MAAM,GAAG,EAAG,EAAM,CAAC,GAE9B,AAAI,EAAG,YAAY,EACf,EAAE,MAAM,GAAI,UAAU,CAAC,EAAG,KAAK,EAE/B,EAAI,cAAc,EAAG,EAAI,EAAI,EAAE,MAAM,GAAK,EAAI,IAAI,OAAO,EAE7D,KACJ,KACK,IAAQ,CACT,GAAI,GAAK,EAAE,MAAM,GAAG,EAAG,EAAM,CAAC,GAC9B,EAAE,MAAM,GAAI,UAAU,EAAG,UAAU,CAAC,EACpC,KACJ,KACK,IAAQ,CACT,GAAY,EAAG,EAAE,MAAM,GAAK,EAAE,MAAM,GAAG,EAAG,EAAM,CAAC,EAAE,EACnD,KACJ,KACK,IAAW,CACZ,GAAI,GAAI,EAAE,EACN,EAAI,EAAE,EACV,EAAE,IAAM,EAAO,EAAI,EACnB,GAAY,EAAG,EAAI,EAAI,CAAC,EACxB,GAAI,GAAK,EAAO,EAChB,GAAQ,UAAU,EAAG,EAAI,CAAE,EAC3B,GAAI,WAAW,EAAG,EAAG,GAAG,EACxB,KACJ,KACK,IAAQ,CACT,GAAO,EAAG,EAAI,EAAG,CAAC,EAClB,KACJ,KACK,IAAO,CACR,AAAI,GAAc,EAAG,GAAI,EAAG,EAAM,EAAG,CAAC,EAAG,GAAI,EAAG,EAAM,EAAG,CAAC,CAAC,IAAM,EAAE,EAC/D,EAAG,YAEH,GAAW,EAAG,CAAE,EACpB,KACJ,KACK,IAAO,CACR,AAAI,GAAc,EAAG,GAAI,EAAG,EAAM,EAAG,CAAC,EAAG,GAAI,EAAG,EAAM,EAAG,CAAC,CAAC,IAAM,EAAE,EAC/D,EAAG,YAEH,GAAW,EAAG,CAAE,EACpB,KACJ,KACK,IAAO,CACR,AAAI,GAAe,EAAG,GAAI,EAAG,EAAM,EAAG,CAAC,EAAG,GAAI,EAAG,EAAM,EAAG,CAAC,CAAC,IAAM,EAAE,EAChE,EAAG,YAEH,GAAW,EAAG,CAAE,EACpB,KACJ,KACK,IAAS,CACV,AAAI,GAAE,EAAI,EAAE,MAAM,GAAI,UAAU,EAAI,CAAC,EAAE,MAAM,GAAI,UAAU,GACvD,EAAG,YAEH,GAAW,EAAG,CAAE,EACpB,KACJ,KACK,IAAY,CACb,GAAI,GAAQ,GAAG,EAAG,EAAM,CAAC,EACrB,EAAK,EAAE,MAAM,GACjB,AAAI,GAAE,EAAI,EAAG,UAAU,EAAI,CAAC,EAAG,UAAU,GACrC,EAAG,YAEH,IAAQ,UAAU,EAAG,EAAI,CAAK,EAC9B,GAAW,EAAG,CAAE,GAEpB,KACJ,KACK,IAAS,CACV,GAAI,GAAI,EAAE,EACN,EAAW,EAAE,EAAI,EAErB,GADI,IAAM,GAAG,GAAI,WAAW,EAAG,EAAG,CAAC,EAC/B,GAAI,aAAa,EAAG,EAAI,CAAQ,EAChC,AAAI,GAAY,GACZ,GAAI,WAAW,EAAG,EAAG,GAAG,MACzB,CACH,EAAK,EAAE,GACP,UACJ,CAEA,KACJ,KACK,IAAa,CACd,GAAI,GAAI,EAAE,EAEV,GADI,IAAM,GAAG,GAAI,WAAW,EAAG,EAAG,CAAC,EAC/B,IAAI,aAAa,EAAG,EAAI,EAAW,EAChC,CAEH,GAAI,GAAM,EAAE,GACR,EAAM,EAAI,SACV,EAAQ,EAAI,KACZ,EAAW,EAAI,QACf,EAAW,EAAI,QACf,EAAM,EAAI,OAAS,EAAM,MAAM,EAAE,UACrC,AAAI,EAAG,EAAE,EAAE,OAAS,GAAG,GAAM,WAAW,EAAG,EAAI,MAAM,EACrD,OAAS,GAAM,EAAG,EAAW,EAAM,EAAK,IACpC,GAAQ,UAAU,EAAG,EAAW,EAAK,EAAW,CAAG,EACvD,EAAI,OAAS,EAAY,GAAI,OAAS,GACtC,EAAI,IAAM,EAAY,GAAE,IAAM,GAC9B,GAAI,WAAW,EAAG,EAAI,GAAG,EACzB,EAAI,OAAS,EAAI,OACjB,EAAI,UAAY,EAAI,UACpB,EAAI,YAAc,GAAO,UACzB,EAAI,KAAO,KACX,EAAK,EAAE,GAAK,EAEZ,GAAW,EAAE,MAAQ,EAAI,OAAS,EAAE,MAAM,GAAU,MAAM,EAAE,YAAY,EAExE,UACJ,CACA,KACJ,KACK,IAAW,CACZ,AAAI,EAAG,EAAE,EAAE,OAAS,GAAG,GAAM,WAAW,EAAG,CAAI,EAC/C,GAAI,GAAI,GAAI,aAAa,EAAG,EAAI,EAAK,EAAE,IAAM,EAAI,EAAE,EAAI,EAAI,EAAE,IAAM,CAAG,EAEtE,GAAI,EAAG,WAAa,GAAO,WACvB,OAEJ,EAAK,EAAE,GACH,GAAG,GAAI,WAAW,EAAG,EAAG,GAAG,EAC/B,GAAW,EAAG,WAAa,GAAO,QAAQ,EAC1C,GAAW,EAAG,OAAO,EAAG,UAAY,GAAG,SAAW,EAAO,EACzD,UACJ,KACK,IAAY,CACb,GAAI,EAAE,MAAM,GAAI,YAAY,EAAG,CAC3B,GAAI,GAAO,EAAE,MAAM,EAAK,GAAG,MACvB,EAAO,EAAE,MAAM,GAAI,MAAQ,EAAM,EACjC,EAAQ,EAAE,MAAM,EAAK,GAAG,MAE5B,AAAI,GAAI,EAAO,GAAO,EAAQ,GAAS,IACnC,GAAG,WAAa,EAAE,IAClB,EAAE,MAAM,GAAI,UAAU,CAAG,EACzB,EAAE,MAAM,EAAK,GAAG,UAAU,CAAG,EAErC,KAAO,CACH,GAAI,GAAO,EAAE,MAAM,EAAK,GAAG,MACvB,EAAM,EAAE,MAAM,GAAI,MAAQ,EAC1B,EAAQ,EAAE,MAAM,EAAK,GAAG,MAE5B,AAAI,GAAI,EAAO,GAAO,EAAQ,GAAS,IACnC,GAAG,WAAa,EAAE,IAClB,EAAE,MAAM,GAAI,YAAY,CAAG,EAC3B,EAAE,MAAM,EAAK,GAAG,YAAY,CAAG,EAEvC,CACA,KACJ,KACK,IAAY,CACb,GAAI,GAAO,EAAE,MAAM,GACf,EAAS,EAAE,MAAM,EAAK,GACtB,EAAQ,EAAE,MAAM,EAAK,GACrB,EAEJ,GAAI,EAAK,YAAY,GAAK,EAAM,YAAY,GAAM,GAAS,GAAS,EAAQ,EAAM,KAAK,GAAI,CAEvF,GAAI,GAAQ,EAAO,QAAU,EAAI,EAAK,MACtC,EAAO,MAAQ,EAAO,OACtB,EAAK,MAAS,EAAQ,EAAM,MAAO,CACvC,KAAO,CACH,GAAI,GAAQ,EAAO,EACnB,AAAK,GAAS,GAAS,CAAM,KAAO,IAChC,GAAO,cAAc,EAAG,GAAa,+BAAgC,EAAI,CAAC,EAC9E,EAAE,MAAM,EAAK,GAAG,YAAY,CAAM,EAC7B,GAAQ,GAAS,CAAK,KAAO,IAC9B,GAAO,cAAc,EAAG,GAAa,8BAA+B,EAAI,CAAC,EAC7E,EAAE,MAAM,EAAK,GAAG,YAAY,CAAK,EAC5B,GAAQ,GAAS,CAAI,KAAO,IAC7B,GAAO,cAAc,EAAG,GAAa,uCAAwC,EAAI,CAAC,EACtF,EAAE,MAAM,GAAI,YAAY,EAAQ,CAAK,CACzC,CAEA,EAAG,WAAa,EAAE,IAClB,KACJ,KACK,IAAa,CACd,GAAI,GAAK,EAAK,EACd,GAAQ,UAAU,EAAG,EAAG,EAAG,EAAG,CAAC,EAC/B,GAAQ,UAAU,EAAG,EAAG,EAAG,EAAG,CAAC,EAC/B,GAAQ,UAAU,EAAG,EAAI,CAAE,EAC3B,GAAI,WAAW,EAAG,EAAG,CAAC,EACtB,GAAI,UAAU,EAAG,EAAI,EAAE,CAAC,EACxB,GAAI,WAAW,EAAG,EAAG,GAAG,EAExB,EAAI,EAAG,OAAO,EAAG,aACjB,EAAK,GAAG,EAAG,EAAM,CAAC,EAClB,GAAW,EAAE,SAAW,EAAW,CACvC,KAEK,IAAa,CACd,AAAK,EAAE,MAAM,EAAK,GAAG,QAAQ,GACzB,IAAQ,UAAU,EAAG,EAAI,EAAK,CAAC,EAC/B,EAAG,WAAa,EAAE,KAEtB,KACJ,KACK,IAAY,CACb,GAAI,GAAI,EAAE,EACN,EAAI,EAAE,EAEV,AAAI,IAAM,GAAG,GAAI,EAAE,IAAM,EAAK,GAE1B,IAAM,GACN,IAAW,EAAG,OAAO,EAAG,WAAW,SAAW,EAAW,EACzD,EAAI,EAAG,OAAO,EAAG,aAAa,IAGlC,GAAI,GAAI,EAAE,MAAM,GAAI,MAChB,EAAS,GAAI,GAAK,GAAqB,EAE3C,KAAO,EAAI,EAAG,IACV,GAAO,YAAY,EAAG,IAAQ,EAAE,MAAM,EAAK,EAAE,EAEjD,GAAI,WAAW,EAAG,EAAG,GAAG,EACxB,KACJ,KACK,IAAY,CACb,GAAI,GAAI,EAAG,EAAE,EAAE,EAAE,IACb,EAAM,GAAU,EAAG,EAAG,OAAQ,EAAE,MAAO,CAAI,EAC/C,AAAI,IAAQ,KACR,GAAY,EAAG,EAAG,EAAG,OAAQ,EAAM,CAAE,EAErC,EAAE,MAAM,GAAI,YAAY,CAAG,EAC/B,KACJ,KACK,IAAW,CACZ,GAAI,GAAI,EAAE,EAAI,EACV,EAAI,EAAO,EAAG,QAAU,EAAG,EAAE,UAAY,EACzC,EAWJ,IATI,EAAI,GACJ,GAAI,GAEJ,EAAI,GACJ,GAAI,EACJ,GAAI,gBAAgB,EAAG,CAAC,EACxB,GAAI,WAAW,EAAG,EAAK,CAAC,GAGvB,EAAI,EAAG,EAAI,GAAK,EAAI,EAAG,IACxB,GAAQ,UAAU,EAAG,EAAK,EAAG,EAAO,EAAI,CAAC,EAE7C,KAAO,EAAI,EAAG,IACV,EAAE,MAAM,EAAK,GAAG,YAAY,EAChC,KACJ,KACK,IACD,KAAM,OAAM,gBAAgB,EAGxC,CACJ,EAEM,GAAS,SAAS,EAAG,EAAI,EAAG,EAAG,CACjC,GAAI,GAAI,EAAE,EACV,AAAI,IAAM,GAAG,GAAM,WAAW,EAAG,EAAG,OAAS,EAAI,CAAC,EAClD,EAAG,WAAa,EAAE,IAAM,CAC5B,EAEM,GAAa,SAAS,EAAG,EAAI,CAC/B,GAAO,EAAG,EAAI,EAAG,OAAO,EAAG,WAAY,CAAC,CAC5C,EAGM,GAAgB,SAAS,EAAG,EAAG,EAAG,CACpC,GAAI,EAAE,WAAW,GAAK,EAAE,WAAW,EAC/B,MAAO,IAAM,EAAG,CAAC,EAAI,EAAI,EACxB,GAAI,EAAE,WAAW,GAAK,EAAE,WAAW,EACpC,MAAO,IAAS,EAAE,QAAQ,EAAG,EAAE,QAAQ,CAAC,EAAI,EAAI,EAAI,EACnD,CACD,GAAI,GAAM,EAAI,iBAAiB,EAAG,EAAG,EAAG,EAAI,IAAI,KAAK,EACrD,MAAI,KAAQ,MACR,GAAO,gBAAgB,EAAG,EAAG,CAAC,EAC3B,EAAM,EAAI,CACrB,CACJ,EAEM,GAAiB,SAAS,EAAG,EAAG,EAAG,CACrC,GAAI,GAEJ,MAAI,GAAE,WAAW,GAAK,EAAE,WAAW,EACxB,GAAM,EAAG,CAAC,EAAI,EAAI,EACpB,EAAE,WAAW,GAAK,EAAE,WAAW,EAC7B,GAAS,EAAE,QAAQ,EAAG,EAAE,QAAQ,CAAC,GAAK,EAAI,EAAI,EAErD,GAAM,EAAI,iBAAiB,EAAG,EAAG,EAAG,EAAI,IAAI,KAAK,EAC7C,IAAQ,KACD,EAAM,EAAI,EAGzB,GAAE,GAAG,YAAc,GAAO,SAC1B,EAAM,EAAI,iBAAiB,EAAG,EAAG,EAAG,EAAI,IAAI,KAAK,EACjD,EAAE,GAAG,YAAc,GAAO,SACtB,IAAQ,MACR,GAAO,gBAAgB,EAAG,EAAG,CAAC,EAC3B,EAAM,EAAI,GACrB,EAEM,GAAgB,SAAS,EAAG,EAAI,EAAI,CACtC,GAAI,EAAG,MAAM,IAAM,EAAG,MAAM,EACxB,MAAI,GAAG,MAAM,IAAM,EAAG,MAAM,GAAK,EAAG,MAAM,IAAM,GACrC,EAGC,EAAG,QAAU,EAAG,MAAS,EAAI,EAI7C,GAAI,GAGJ,OAAO,EAAG,MAAM,OACP,IACD,MAAO,OACN,IACD,MAAO,GAAG,OAAS,EAAG,MAAQ,EAAI,MACjC,QACA,QACA,QACA,IACD,MAAO,GAAG,QAAU,EAAG,MAAQ,EAAI,MAClC,QACA,IACD,MAAO,IAAc,EAAG,QAAQ,EAAG,EAAG,QAAQ,CAAC,EAAI,EAAI,MAEtD,QACA,IACD,GAAI,EAAG,QAAU,EAAG,MAAO,MAAO,GAC7B,GAAI,IAAM,KAAM,MAAO,GAE5B,EAAK,EAAI,OAAO,EAAG,EAAG,MAAM,UAAW,EAAI,IAAI,KAAK,EAChD,IAAO,MACP,GAAK,EAAI,OAAO,EAAG,EAAG,MAAM,UAAW,EAAI,IAAI,KAAK,GACxD,cAEA,MAAO,GAAG,QAAU,EAAG,MAAQ,EAAI,EAG3C,GAAI,IAAO,KACP,MAAO,GAEX,GAAI,GAAK,GAAI,IAAQ,OACrB,SAAI,YAAY,EAAG,EAAI,EAAI,EAAI,EAAI,CAAC,EAC7B,EAAG,UAAU,EAAI,EAAI,CAChC,EAEM,GAAmB,SAAS,EAAI,EAAI,CACtC,MAAO,IAAc,KAAM,EAAI,CAAE,CACrC,EAEM,GAAW,SAAS,EAAK,EAAM,CACjC,GAAI,GAAU,GACV,EAAS,GAAe,EAAK,EAAO,EAAI,EAAI,CAAC,EACjD,GAAI,IAAW,GAAO,CAClB,GAAI,GAAI,GAAS,CAAG,EACpB,GAAI,IAAM,GACN,MAAO,GAEX,AAAI,EAAI,EACJ,GAAS,GACL,EAAO,GAAG,GAAU,KAExB,GAAS,GACL,GAAQ,GAAG,GAAU,IAEjC,CAEA,MAAO,CACH,QAAS,EACT,OAAQ,CACZ,CACJ,EAQM,GAAiB,SAAS,EAAK,EAAM,CACvC,GAAI,EAAI,UAAU,EAAG,CACjB,GAAI,GAAI,EAAI,MACR,EAAI,KAAK,MAAM,CAAC,EAEpB,GAAI,IAAM,EAAG,CACT,GAAI,IAAS,EACT,MAAO,GACN,AAAI,EAAO,GACZ,IAAK,EACb,CAEA,MAAO,IAAoB,CAAC,CAChC,KAAO,IAAI,EAAI,YAAY,EACvB,MAAO,GAAI,MACR,GAAI,GAAQ,CAAG,EAAG,CACrB,GAAI,GAAI,GAAI,IAAQ,OACpB,GAAI,GAAQ,aAAa,EAAI,OAAO,EAAG,CAAC,IAAO,EAAI,MAAM,EAAI,EACzD,MAAO,IAAe,EAAG,CAAI,CACrC,EAEA,MAAO,EACX,EAEM,GAAY,SAAS,EAAG,CAC1B,MAAO,GAAE,YAAY,EAAI,EAAE,MAAQ,GAAe,EAAG,CAAC,CAC1D,EAEM,GAAW,SAAS,EAAG,CACzB,GAAI,EAAE,MAAM,IAAM,GACd,MAAO,GAAE,MAEb,GAAI,GAAQ,CAAC,EAAG,CACZ,GAAI,GAAI,GAAI,IAAQ,OACpB,GAAI,GAAQ,aAAa,EAAE,OAAO,EAAG,CAAC,IAAO,EAAE,MAAM,EAAI,EACrD,MAAO,GAAE,KACjB,CAEA,MAAO,EACX,EAOM,GAAQ,SAAS,EAAG,EAAG,CACzB,MAAO,GAAE,MAAQ,EAAE,KACvB,EAKM,GAAQ,SAAS,EAAG,EAAG,CACzB,MAAO,GAAE,OAAS,EAAE,KACxB,EAMM,GAAW,SAAS,EAAI,EAAI,CAC9B,GAAI,GAAI,GAAiB,CAAE,EACvB,EAAI,GAAiB,CAAE,EAE3B,MAAI,KAAM,EACC,EACF,EAAI,EACF,GAEA,CACf,EAKM,GAAc,SAAS,EAAG,EAAI,EAAI,CACpC,GAAI,GACJ,OAAO,EAAG,MAAM,OACP,IAAY,CACb,GAAI,GAAI,EAAG,MAEX,GADA,EAAK,EAAI,OAAO,EAAG,EAAE,UAAW,EAAI,IAAI,MAAM,EAC1C,IAAO,KAAM,MACjB,EAAG,UAAU,GAAO,UAAU,CAAC,CAAC,EAChC,MACJ,KACK,QACA,IACD,EAAG,UAAU,EAAG,MAAM,CAAC,EACvB,eACK,CACL,EAAK,EAAI,gBAAgB,EAAG,EAAI,EAAI,IAAI,MAAM,EAC1C,EAAG,QAAQ,GACX,GAAO,eAAe,EAAG,EAAI,GAAa,gBAAiB,EAAI,CAAC,EACpE,KACJ,EAGJ,EAAI,YAAY,EAAG,EAAI,EAAI,EAAI,EAAI,CAAC,CACxC,EAGM,GAAY,KAAK,MAAQ,SAAS,EAAG,EAAG,CAC1C,GAAI,GAAO,IAAM,GAAM,MACnB,EAAM,EAAI,MACV,EAAO,IAAM,GAAM,MACnB,EAAM,EAAI,MAKd,MAAS,GAAM,EAAU,GAAM,EAAM,EAAM,GAAQ,KAAQ,GAAK,CACpE,EAEM,GAAW,SAAS,EAAG,EAAG,EAAG,CAC/B,MAAI,KAAM,GACN,GAAO,cAAc,EAAG,GAAa,2BAA2B,CAAC,EAC9D,KAAK,MAAM,EAAI,CAAC,EAAE,CAC7B,EAGM,GAAW,SAAS,EAAG,EAAG,EAAG,CAC/B,MAAI,KAAM,GACN,GAAO,cAAc,EAAG,GAAa,2BAA2B,CAAC,EAC7D,EAAI,KAAK,MAAM,EAAI,CAAC,EAAI,EAAG,CACvC,EAEM,GAAQ,GAER,GAAc,SAAS,EAAG,EAAG,CAC/B,MAAI,GAAI,EACA,GAAK,CAAC,GAAc,EACZ,IAAM,CAAC,EAGf,GAAK,GAAc,EACX,GAAK,CAEzB,EAOM,GAAY,SAAS,EAAG,EAAO,EAAO,EAAM,CAC9C,GAAI,GAAI,EAAE,MACV,GAAI,IAAM,KAAM,CACZ,GAAI,GAAK,EAAE,SACP,EAAM,EAAG,OACb,OAAS,GAAI,EAAG,EAAI,EAAK,IAAK,CAC1B,GAAI,GAAI,EAAG,GAAG,QAAU,EAAM,EAAO,EAAG,GAAG,KAAO,EAAM,EAAG,GAAG,KAC9D,GAAI,EAAE,OAAO,KAAO,EAChB,MAAO,KACf,CACJ,CACA,MAAO,EACX,EAMM,GAAc,SAAS,EAAG,EAAG,EAAO,EAAM,EAAI,CAChD,GAAI,GAAM,EAAE,SAAS,OACjB,EAAK,EAAE,SACP,EAAM,GAAI,IAAQ,SAAS,EAAG,CAAG,EACrC,EAAI,EAAI,EACR,EAAE,MAAM,GAAI,YAAY,CAAG,EAC3B,OAAS,GAAI,EAAG,EAAI,EAAK,IACrB,AAAI,EAAG,GAAG,QACN,EAAI,OAAO,GAAK,GAAM,eAAe,EAAG,EAAO,EAAG,GAAG,GAAG,EAExD,EAAI,OAAO,GAAK,EAAM,EAAG,GAAG,KAEpC,EAAE,MAAQ,CACd,EAEM,GAAU,SAAS,EAAG,CACxB,MAAO,GAAE,WAAW,CACxB,EAEM,GAAU,SAAS,EAAG,CACxB,MAAO,GAAE,WAAW,CACxB,EAEM,GAAW,SAAS,EAAG,EAAG,CAC5B,GAAI,GAAI,EAAE,MAAM,GAEhB,MAAI,GAAE,WAAW,EAAU,GAEvB,GAAQ,CAAC,EACT,IAAQ,cAAc,EAAG,CAAC,EACnB,IAGJ,EACX,EAEM,GAAa,SAAS,EAAG,CAC3B,MAAO,GAAE,WAAW,GAAK,EAAE,MAAM,IAAM,CAC3C,EAGM,GAAY,SAAS,EAAG,EAAK,EAAG,EAAM,CACxC,GAAI,GAAK,EACT,EAAG,CACC,GAAI,GAAK,EAAE,MAAM,EAAI,GACjB,EAAI,EAAG,MAAM,EACb,EAAI,EAAG,OAAO,EAClB,EAAK,IAAI,EAAG,CAAE,EACd,GAAM,CACV,OAAS,EAAE,EAAI,EACnB,EAMM,GAAc,SAAS,EAAG,EAAO,CACnC,GAAW,GAAS,CAAC,EACrB,EAAG,CACC,GAAI,GAAM,EAAE,IACR,EAAI,EAER,GAAI,CAAE,GAAE,MAAM,EAAI,GAAG,WAAW,GAAK,GAAQ,EAAE,MAAM,EAAI,EAAE,IAAM,CAAC,GAAS,EAAG,EAAM,CAAC,EACjF,EAAI,cAAc,EAAG,EAAE,MAAM,EAAI,GAAI,EAAE,MAAM,EAAI,GAAI,EAAE,MAAM,EAAI,GAAI,EAAI,IAAI,SAAS,UAC/E,GAAW,EAAE,MAAM,EAAI,EAAE,EAChC,GAAS,EAAG,EAAM,CAAC,UACZ,GAAW,EAAE,MAAM,EAAI,EAAE,EAChC,GAAQ,UAAU,EAAG,EAAM,EAAG,EAAM,CAAC,MAClC,CAEH,GAAI,GAAK,EAAE,MAAM,EAAI,GAAG,MAAM,EAE9B,IAAK,EAAI,EAAG,EAAI,GAAS,GAAS,EAAG,EAAM,EAAI,CAAC,EAAG,IAE/C,GADQ,EAAE,MAAM,EAAM,EAAI,GAAG,MAAM,EAGvC,GAAI,GAAO,GAAI,YAAW,CAAE,EAC5B,GAAU,EAAG,EAAK,EAAG,CAAI,EACzB,GAAI,GAAK,GAAW,EAAG,CAAI,EAC3B,GAAQ,YAAY,EAAG,EAAM,EAAG,CAAE,CACtC,CAGA,IAFA,GAAS,EAAI,EAEN,EAAE,IAAM,EAAK,GAAE,IAClB,MAAO,GAAE,MAAM,EAAE,EAAE,IAC3B,OAAS,EAAQ,EACrB,EAEM,GAAa,IAEb,GAAgB,SAAS,EAAG,EAAG,EAAK,EAAI,CAC1C,OAAS,GAAO,EAAG,EAAO,GAAY,IAAQ,CAC1C,GAAI,GAEJ,GAAI,CAAC,EAAE,UAAU,EACb,EAAK,EAAI,gBAAgB,EAAG,EAAG,EAAI,IAAI,QAAQ,EAC3C,EAAG,QAAQ,GACX,GAAO,eAAe,EAAG,EAAG,GAAa,QAAS,EAAI,CAAC,MAExD,CACH,GAAI,GAAO,GAAO,SAAS,EAAG,EAAE,MAAO,CAAG,EAC1C,GAAK,EAAK,QAAQ,GAKd,GADA,EAAK,EAAI,OAAO,EAAG,EAAE,MAAM,UAAW,EAAI,IAAI,QAAQ,EAClD,IAAO,KAAM,CACb,EAAE,MAAM,GAAI,YAAY,EACxB,MACJ,MARiB,CACjB,GAAQ,SAAS,EAAG,EAAI,CAAI,EAC5B,MACJ,CAQJ,CACA,GAAI,EAAG,aAAa,EAAG,CACnB,EAAI,YAAY,EAAG,EAAI,EAAG,EAAK,EAAE,MAAM,GAAK,CAAC,EAC7C,MACJ,CACA,EAAI,CACR,CAEA,GAAO,cAAc,EAAG,GAAa,0CAA2C,EAAI,CAAC,CACzF,EAEM,GAAW,SAAS,EAAG,EAAG,EAAK,EAAK,CACtC,OAAS,GAAO,EAAG,EAAO,GAAY,IAAQ,CAC1C,GAAI,GACJ,GAAI,EAAE,UAAU,EAAG,CACf,GAAI,GAAI,EAAE,MAEV,GAAI,CAAC,AADM,GAAO,SAAS,EAAG,EAAG,CAAG,EAC1B,QAAQ,GAAM,GAAK,EAAI,OAAO,EAAG,EAAE,UAAW,EAAI,IAAI,WAAW,KAAO,KAAM,CACpF,GAAO,aAAa,EAAG,EAAG,EAAK,CAAG,EAClC,GAAO,kBAAkB,CAAC,EAC1B,MACJ,CAEJ,KACI,AAAK,GAAK,EAAI,gBAAgB,EAAG,EAAG,EAAI,IAAI,WAAW,GAAG,QAAQ,GAC9D,GAAO,eAAe,EAAG,EAAG,GAAa,QAAS,EAAI,CAAC,EAG/D,GAAI,EAAG,aAAa,EAAG,CACnB,EAAI,YAAY,EAAG,EAAI,EAAG,EAAK,EAAK,CAAC,EACrC,MACJ,CACA,EAAI,CACR,CAEA,GAAO,cAAc,EAAG,GAAa,6CAA8C,EAAI,CAAC,CAC5F,EAGA,GAAO,QAAQ,QAAmB,GAClC,GAAO,QAAQ,QAAmB,GAClC,GAAO,QAAQ,cAAmB,GAClC,GAAO,QAAQ,YAAmB,GAClC,GAAO,QAAQ,SAAmB,GAClC,GAAO,QAAQ,cAAmB,GAClC,GAAO,QAAQ,aAAmB,GAClC,GAAO,QAAQ,cAAmB,GAClC,GAAO,QAAQ,UAAmB,GAClC,GAAO,QAAQ,eAAmB,GAClC,GAAO,QAAQ,cAAmB,GAClC,GAAO,QAAQ,SAAmB,GAClC,GAAO,QAAQ,YAAmB,GAClC,GAAO,QAAQ,iBAAmB,GAClC,GAAO,QAAQ,YAAmB,GAClC,GAAO,QAAQ,eAAmB,GAClC,GAAO,QAAQ,SAAmB,GAClC,GAAO,QAAQ,UAAmB,GAClC,GAAO,QAAQ,SAAmB,KCpoClC,mBAEA,GAAM,CACF,eAAgB,CACZ,cACA,kBAEJ,gBACA,KACE,CAAE,eAAe,KACjB,GAAU,KACV,GAAU,KACV,GAAU,KACV,CACF,cACA,aACA,KACE,GAAU,KACV,GAAU,KACV,GAAU,KAEV,GAAkB,CACpB,WACA,MACA,UACA,WACA,SACA,SACA,QACA,WACA,WACA,SACA,OACJ,EAAE,IAAI,GAAK,EAAa,CAAC,CAAC,EAEpB,GAAY,SAAS,EAAG,CAC1B,MAAO,IAAgB,EAAI,EAC/B,EAOM,EAAM,CACR,SAAa,EACb,YAAa,EACb,MAAa,EACb,QAAa,EACb,OAAa,EACb,MAAa,EACb,OAAa,EACb,OAAa,EACb,OAAa,EACb,OAAa,EACb,OAAY,GACZ,OAAY,GACZ,QAAY,GACZ,QAAY,GACZ,OAAY,GACZ,QAAY,GACZ,OAAY,GACZ,OAAY,GACZ,OAAY,GACZ,QAAY,GACZ,MAAY,GACZ,MAAY,GACZ,UAAY,GACZ,QAAY,GACZ,KAAY,EAChB,EAEM,GAAY,SAAS,EAAG,CAC1B,EAAE,IAAI,OAAO,EAAI,UAAe,GAAI,IAAS,EAAG,EAAa,UAAW,EAAI,CAAC,EAC7E,EAAE,IAAI,OAAO,EAAI,aAAe,GAAI,IAAS,EAAG,EAAa,aAAc,EAAI,CAAC,EAChF,EAAE,IAAI,OAAO,EAAI,OAAe,GAAI,IAAS,EAAG,EAAa,OAAQ,EAAI,CAAC,EAC1E,EAAE,IAAI,OAAO,EAAI,SAAe,GAAI,IAAS,EAAG,EAAa,SAAU,EAAI,CAAC,EAC5E,EAAE,IAAI,OAAO,EAAI,QAAe,GAAI,IAAS,EAAG,EAAa,QAAS,EAAI,CAAC,EAC3E,EAAE,IAAI,OAAO,EAAI,OAAe,GAAI,IAAS,EAAG,EAAa,OAAQ,EAAI,CAAC,EAC1E,EAAE,IAAI,OAAO,EAAI,QAAe,GAAI,IAAS,EAAG,EAAa,QAAS,EAAI,CAAC,EAC3E,EAAE,IAAI,OAAO,EAAI,QAAe,GAAI,IAAS,EAAG,EAAa,QAAS,EAAI,CAAC,EAC3E,EAAE,IAAI,OAAO,EAAI,QAAe,GAAI,IAAS,EAAG,EAAa,QAAS,EAAI,CAAC,EAC3E,EAAE,IAAI,OAAO,EAAI,QAAe,GAAI,IAAS,EAAG,EAAa,QAAS,EAAI,CAAC,EAC3E,EAAE,IAAI,OAAO,EAAI,QAAe,GAAI,IAAS,EAAG,EAAa,QAAS,EAAI,CAAC,EAC3E,EAAE,IAAI,OAAO,EAAI,QAAe,GAAI,IAAS,EAAG,EAAa,QAAS,EAAI,CAAC,EAC3E,EAAE,IAAI,OAAO,EAAI,SAAe,GAAI,IAAS,EAAG,EAAa,SAAU,EAAI,CAAC,EAC5E,EAAE,IAAI,OAAO,EAAI,SAAe,GAAI,IAAS,EAAG,EAAa,SAAU,EAAI,CAAC,EAC5E,EAAE,IAAI,OAAO,EAAI,QAAe,GAAI,IAAS,EAAG,EAAa,QAAS,EAAI,CAAC,EAC3E,EAAE,IAAI,OAAO,EAAI,SAAe,GAAI,IAAS,EAAG,EAAa,SAAU,EAAI,CAAC,EAC5E,EAAE,IAAI,OAAO,EAAI,QAAe,GAAI,IAAS,EAAG,EAAa,QAAS,EAAI,CAAC,EAC3E,EAAE,IAAI,OAAO,EAAI,QAAe,GAAI,IAAS,EAAG,EAAa,QAAS,EAAI,CAAC,EAC3E,EAAE,IAAI,OAAO,EAAI,QAAe,GAAI,IAAS,EAAG,EAAa,QAAS,EAAI,CAAC,EAC3E,EAAE,IAAI,OAAO,EAAI,SAAe,GAAI,IAAS,EAAG,EAAa,SAAU,EAAI,CAAC,EAC5E,EAAE,IAAI,OAAO,EAAI,OAAe,GAAI,IAAS,EAAG,EAAa,OAAQ,EAAI,CAAC,EAC1E,EAAE,IAAI,OAAO,EAAI,OAAe,GAAI,IAAS,EAAG,EAAa,OAAQ,EAAI,CAAC,EAC1E,EAAE,IAAI,OAAO,EAAI,WAAe,GAAI,IAAS,EAAG,EAAa,WAAY,EAAI,CAAC,EAC9E,EAAE,IAAI,OAAO,EAAI,SAAe,GAAI,IAAS,EAAG,EAAa,SAAU,EAAI,CAAC,CAChF,EAMM,GAAS,EAAa,SAAU,EAAI,EACpC,GAAmB,SAAS,EAAG,EAAG,CACpC,GAAI,GACJ,GAAK,EAAE,UAAU,GAAM,GAAK,EAAE,MAAM,aAAe,MAC9C,EAAE,iBAAiB,GAAM,GAAK,EAAE,MAAM,aAAe,KAAO,CAC7D,GAAI,GAAO,GAAO,YAAY,EAAI,GAAW,EAAG,EAAM,CAAC,EACvD,GAAI,EAAK,WAAW,EAChB,MAAO,GAAK,OAAO,CAC3B,CACA,MAAO,IAAU,EAAE,MAAM,CAAC,CAC9B,EAEM,GAAc,SAAS,EAAG,EAAG,EAAI,EAAI,EAAI,EAAQ,CACnD,GAAI,GAAO,EAAE,IAcb,GAZA,GAAQ,UAAU,EAAG,CAAC,EACtB,GAAQ,UAAU,EAAG,CAAE,EACvB,GAAQ,UAAU,EAAG,CAAE,EAElB,GACD,GAAQ,UAAU,EAAG,CAAE,EAE3B,AAAI,EAAE,GAAG,WAAa,GAAO,SACzB,GAAI,UAAU,EAAG,EAAM,CAAM,EAE7B,GAAI,iBAAiB,EAAG,EAAM,CAAM,EAEpC,EAAQ,CACR,GAAI,GAAK,EAAE,MAAM,EAAE,IAAI,GACvB,MAAO,GAAE,MAAM,EAAE,EAAE,KACnB,EAAG,QAAQ,CAAE,CACjB,CACJ,EAEM,GAAiB,SAAS,EAAG,EAAI,EAAI,EAAK,EAAO,CACnD,GAAI,GAAK,GAAgB,EAAG,EAAI,CAAK,EAGrC,MAFI,GAAG,QAAQ,GACX,GAAK,GAAgB,EAAG,EAAI,CAAK,GACjC,EAAG,QAAQ,EAAU,GACzB,IAAY,EAAG,EAAI,EAAI,EAAI,EAAK,CAAC,EAC1B,GACX,EAEM,GAAgB,SAAS,EAAG,EAAI,EAAI,EAAK,EAAO,CAClD,GAAI,CAAC,GAAe,EAAG,EAAI,EAAI,EAAK,CAAK,EACrC,OAAQ,OACC,GAAI,UACL,MAAO,IAAO,iBAAiB,EAAG,EAAI,CAAE,MACvC,GAAI,YAAc,GAAI,WAAa,GAAI,YACvC,GAAI,WAAa,GAAI,WAAa,GAAI,QAAS,CAChD,GAAI,GAAK,GAAI,SAAS,CAAE,EACpB,EAAK,GAAI,SAAS,CAAE,EACxB,MAAI,KAAO,IAAS,IAAO,GAChB,GAAO,gBAAgB,EAAG,EAAI,CAAE,EAEhC,GAAO,gBAAgB,EAAG,EAAI,EAAI,EAAa,+BAAgC,EAAI,CAAC,CACnG,SAEI,MAAO,IAAO,gBAAgB,EAAG,EAAI,EAAI,EAAa,wBAAyB,EAAI,CAAC,EAGpG,EAEM,GAAmB,SAAS,EAAG,EAAI,EAAI,EAAO,CAChD,GAAI,GAAM,GAAI,IAAQ,OACtB,MAAK,IAAe,EAAG,EAAI,EAAI,EAAK,CAAK,EAG9B,CAAC,EAAI,UAAU,EAFf,IAGf,EAEM,GAAS,SAAS,EAAG,EAAI,EAAG,CAC9B,MAAO,KAAO,MACT,EAAG,MAAS,GAAK,EADD,KACc,GAAW,EAAI,EAAG,EAAE,IAAI,OAAO,EAAE,CACxE,EAEM,GAAa,SAAS,EAAQ,EAAO,EAAO,CAC9C,GAAM,GAAK,GAAO,YAAY,EAAQ,CAAK,EAE3C,MADA,IAAW,GAAS,EAAI,KAAK,EACzB,EAAG,QAAQ,EACX,GAAO,OAAS,GAAG,EACZ,MAEC,CAChB,EAEM,GAAkB,SAAS,EAAG,EAAG,EAAO,CAC1C,GAAI,GACJ,OAAO,EAAE,MAAM,OACN,QACA,IACD,EAAK,EAAE,MAAM,UACb,cAEA,EAAK,EAAE,IAAI,GAAG,EAAE,MAAM,GAG9B,MAAO,GAAK,GAAO,YAAY,EAAI,EAAE,IAAI,OAAO,EAAM,EAAI,GAAQ,cACtE,EAEA,GAAO,QAAQ,OAAmB,GAClC,GAAO,QAAQ,IAAmB,EAClC,GAAO,QAAQ,YAAmB,GAClC,GAAO,QAAQ,eAAmB,GAClC,GAAO,QAAQ,cAAmB,GAClC,GAAO,QAAQ,iBAAmB,GAClC,GAAO,QAAQ,WAAmB,GAClC,GAAO,QAAQ,gBAAmB,GAClC,GAAO,QAAQ,UAAmB,GAClC,GAAO,QAAQ,iBAAmB,GAClC,GAAO,QAAQ,UAAmB,KCrNlC,mBAEA,GAAM,CACF,gBACA,oBACA,uBACA,eAAgB,CACZ,eACA,YACA,cACA,gBAEJ,cAAe,CACX,YAEJ,KACE,GAAuB,KACvB,GAAuB,KACvB,GAAuB,KACvB,GAAuB,KACvB,GAAuB,KAEvB,GAAc,EAEd,GAAmB,EAAI,GAEvB,GAAN,KAAe,CAEX,aAAc,CACV,KAAK,KAAO,KACZ,KAAK,QAAU,IACf,KAAK,IAAM,IACX,KAAK,SAAW,KAChB,KAAK,KAAO,KAGZ,KAAK,OAAS,IACd,KAAK,OAAS,KACd,KAAK,UAAY,IAEjB,KAAK,IAAM,KACX,KAAK,cAAgB,KACrB,KAAK,MAAQ,KAEb,KAAK,SAAW,IAChB,KAAK,WAAa,GACtB,CAEJ,EAEM,GAAN,KAAgB,CAEZ,YAAY,EAAG,CACX,KAAK,GAAK,EAAE,aAEZ,KAAK,QAAU,GAAI,IACnB,KAAK,IAAM,IACX,KAAK,WAAa,IAClB,KAAK,MAAQ,IAGb,KAAK,IAAM,EACX,KAAK,MAAQ,KACb,KAAK,GAAK,KACV,KAAK,SAAW,KAChB,KAAK,QAAU,EACf,KAAK,KAAO,KACZ,KAAK,SAAW,EAChB,KAAK,cAAgB,EACrB,KAAK,UAAY,EACjB,KAAK,UAAY,KAAK,cACtB,KAAK,IAAM,EACX,KAAK,OAAS,GACd,KAAK,QAAU,CACnB,CAEJ,EAEM,GAAN,KAAmB,CAEf,aAAc,CACV,KAAK,WAAa,EAClB,KAAK,IAAM,GAAI,SAEf,KAAK,WAAa,KAClB,KAAK,WAAa,GAAI,IAAQ,OAAO,GAAU,IAAI,EACnD,KAAK,MAAQ,KACb,KAAK,cAAgB,KACrB,KAAK,QAAU,KACf,KAAK,OAAS,GAAI,OAAM,GAAI,IAAI,IAAI,EACpC,KAAK,GAAK,GAAI,OAAM,EAAW,CACnC,CAEJ,EAEM,GAAgB,SAAS,EAAG,CAC9B,GAAI,GAAK,GAAI,IACb,SAAE,GAAG,KAAO,EACZ,EAAG,SAAW,EAAE,GAChB,EAAG,KAAO,KACV,EAAE,GAAK,EACA,CACX,EAEM,GAAc,SAAS,EAAG,CAC5B,GAAI,GAAK,EAAE,GACX,EAAG,KAAO,IACd,EAEM,GAAa,SAAS,EAAI,EAAG,CAC/B,EAAG,MAAQ,GAAI,OAAM,EAAgB,EACrC,EAAG,IAAM,EACT,EAAG,WAAa,GAAmB,GAEnC,GAAI,GAAK,EAAG,QACZ,EAAG,KAAO,EAAG,SAAW,KACxB,EAAG,WAAa,EAChB,EAAG,QAAU,EAAG,IAChB,EAAG,KAAO,EAAG,MAAM,EAAG,KACtB,EAAG,MAAM,EAAG,OAAS,GAAI,IAAQ,OAAO,GAAU,IAAI,EACtD,EAAG,IAAM,EAAG,IAAM,GAClB,EAAG,GAAK,CACZ,EAEM,GAAY,SAAS,EAAG,CAC1B,EAAE,GAAK,EAAE,QACT,GAAY,CAAC,EACb,EAAE,MAAQ,IACd,EAKM,GAAgB,SAAS,EAAG,EAAG,CACjC,GAAI,GAAW,GAAO,SAAS,CAAC,EAChC,EAAE,WAAW,UAAU,CAAQ,EAC/B,GAAO,YAAY,EAAU,GAAqB,GAAI,IAAQ,OAAO,GAAa,CAAC,CAAC,EACpF,GAAO,YAAY,EAAU,GAAkB,GAAI,IAAQ,OAAO,GAAY,GAAO,SAAS,CAAC,CAAC,CAAC,CACrG,EAMM,GAAY,SAAS,EAAG,CAC1B,GAAI,GAAI,EAAE,IACV,GAAW,EAAG,CAAC,EACf,GAAc,EAAG,CAAC,EAClB,GAAI,UAAU,CAAC,EACf,EAAE,QAAU,GAAK,YAAY,IAAI,CACrC,EAEM,GAAgB,SAAS,EAAG,CAC9B,GAAI,GAAI,EAAE,IACN,EAAK,GAAI,IAAU,CAAC,EACxB,SAAE,MAAM,EAAE,KAAO,GAAI,IAAQ,OAAO,GAAa,CAAE,EACnD,GAAK,aAAa,CAAC,EACnB,EAAG,SAAW,EAAE,SAChB,EAAG,cAAgB,EAAE,cACrB,EAAG,KAAO,EAAE,KACZ,EAAG,UAAY,EAAG,cAClB,GAAW,EAAI,CAAC,EACT,CACX,EAEM,GAAkB,SAAS,EAAG,EAAI,CACpC,GAAU,CAAE,CAChB,EAEM,GAAe,UAAW,CAC5B,GAAI,GAAI,GAAI,IACR,EAAI,GAAI,IAAU,CAAC,EACvB,SAAE,WAAa,EAEX,GAAI,qBAAqB,EAAG,GAAW,IAAI,IAAM,IACjD,GAAI,MAGD,CACX,EAEM,GAAc,SAAS,EAAG,CAC5B,GAAU,CAAC,CACf,EAEM,GAAY,SAAS,EAAG,CAC1B,EAAI,EAAE,IAAI,WACV,GAAY,CAAC,CACjB,EAEA,GAAO,QAAQ,UAAkB,GACjC,GAAO,QAAQ,SAAkB,GACjC,GAAO,QAAQ,SAAmB,GAAG,EACrC,GAAO,QAAQ,SAAmB,GAAG,EACrC,GAAO,QAAQ,YAAmB,GAAG,EACrC,GAAO,QAAQ,WAAmB,GAAG,EACrC,GAAO,QAAQ,YAAmB,GAAG,EACrC,GAAO,QAAQ,UAAmB,GAAG,EACrC,GAAO,QAAQ,eAAmB,GAAG,EACrC,GAAO,QAAQ,SAAmB,GAAG,EACrC,GAAO,QAAQ,SAAmB,GAAG,EACrC,GAAO,QAAQ,YAAkB,GACjC,GAAO,QAAQ,UAAkB,GACjC,GAAO,QAAQ,aAAkB,GACjC,GAAO,QAAQ,cAAkB,GACjC,GAAO,QAAQ,cAAkB,GACjC,GAAO,QAAQ,YAAkB,GACjC,GAAO,QAAQ,gBAAkB,KC/MjC,mBAEA,GAAM,CACF,aACA,cACA,cACA,aACA,cACA,aACA,cACA,aACA,aACA,aACA,aACA,aACA,aACA,aACA,eAAgB,CACZ,eACA,gBACA,YACA,iBACA,YACA,YACA,sBACA,eACA,YACA,eACA,eACA,eACA,eACA,eACA,cACA,eACA,kBAEJ,mBACA,qBACA,gBACA,eACA,iBACA,KACE,CACF,YACA,YACA,YACA,cACA,KACE,GAAU,KACV,GAAU,KACV,GAAU,KACV,CACF,cACA,aACA,KACE,GAAU,KACV,CACF,0BACA,SACA,mBACA,mBACA,KACE,GAAU,KACV,CACF,WACA,eACA,eACA,KACE,GAAU,KAEV,GAAa,GACb,GAAe,GAAY,EAE3B,GAAN,KAAa,CAET,YAAY,EAAM,EAAO,CACrB,KAAK,KAAO,EACZ,KAAK,MAAQ,CACjB,CAGA,OAAQ,CACJ,MAAO,MAAK,KAAO,EACvB,CAGA,OAAQ,CACJ,MAAO,MAAK,KAAO,EACvB,CAEA,SAAS,EAAG,CACR,MAAO,MAAK,OAAS,CACzB,CAEA,UAAU,EAAG,CACT,MAAO,MAAK,MAAM,IAAM,CAC5B,CAEA,YAAa,CACT,MAAO,MAAK,UAAU,EAAW,CACrC,CAEA,WAAY,CACR,MAAO,MAAK,SAAS,EAAW,CACpC,CAEA,aAAc,CACV,MAAO,MAAK,SAAS,EAAW,CACpC,CAEA,SAAU,CACN,MAAO,MAAK,SAAS,EAAQ,CACjC,CAEA,aAAc,CACV,MAAO,MAAK,SAAS,EAAY,CACrC,CAEA,mBAAoB,CAChB,MAAO,MAAK,SAAS,EAAkB,CAC3C,CAEA,YAAa,CACT,MAAO,MAAK,UAAU,EAAW,CACrC,CAEA,eAAgB,CACZ,MAAO,MAAK,SAAS,EAAW,CACpC,CAEA,eAAgB,CACZ,MAAO,MAAK,SAAS,EAAW,CACpC,CAEA,WAAY,CACR,MAAO,MAAK,SAAS,EAAU,CACnC,CAEA,cAAe,CACX,MAAO,MAAK,UAAU,EAAa,CACvC,CAEA,aAAc,CACV,MAAQ,MAAK,KAAO,MAAU,EAClC,CAEA,cAAe,CACX,MAAO,MAAK,SAAS,EAAQ,CACjC,CAEA,cAAe,CACX,MAAO,MAAK,SAAS,EAAQ,CACjC,CAEA,SAAU,CACN,MAAO,MAAK,SAAS,EAAQ,CACjC,CAEA,kBAAmB,CACf,MAAO,MAAK,SAAS,EAAa,CACtC,CAEA,YAAa,CACT,MAAO,MAAK,SAAS,EAAW,CACpC,CAEA,aAAc,CACV,MAAO,MAAK,SAAS,EAAY,CACrC,CAEA,WAAY,CACR,MAAO,MAAK,QAAQ,GAAM,KAAK,YAAY,GAAK,KAAK,QAAU,EACnE,CAEA,YAAY,EAAG,CACX,KAAK,KAAO,GACZ,KAAK,MAAQ,CACjB,CAEA,YAAY,EAAG,CACX,GAAW,KAAK,MAAQ,EAAW,EACnC,KAAK,MAAQ,CACjB,CAEA,UAAU,EAAG,CACT,KAAK,KAAO,GACZ,KAAK,MAAQ,CACjB,CAEA,UAAU,EAAG,CACT,GAAW,KAAK,MAAQ,EAAW,EACnC,KAAK,MAAQ,CACjB,CAEA,aAAc,CACV,KAAK,KAAO,GACZ,KAAK,MAAQ,IACjB,CAEA,UAAU,EAAG,CACT,KAAK,KAAO,GACZ,KAAK,MAAQ,CACjB,CAEA,UAAU,EAAG,CACT,KAAK,KAAO,GACZ,KAAK,MAAQ,CACjB,CAEA,UAAU,EAAG,CACT,KAAK,KAAO,GACZ,KAAK,MAAQ,CACjB,CAEA,UAAU,EAAG,CACT,KAAK,KAAO,GACZ,KAAK,MAAQ,CACjB,CAEA,UAAU,EAAG,CACT,KAAK,KAAO,GACZ,KAAK,MAAQ,CACjB,CAEA,WAAW,EAAG,CACV,KAAK,KAAO,GACZ,KAAK,MAAQ,CACjB,CAEA,YAAY,EAAG,CACX,KAAK,KAAO,GACZ,KAAK,MAAQ,CACjB,CAEA,YAAY,EAAG,CACX,KAAK,KAAO,GACZ,KAAK,MAAQ,CACjB,CAEA,UAAU,EAAG,CACT,KAAK,KAAO,GACZ,KAAK,MAAQ,CACjB,CAEA,cAAe,CACX,KAAK,KAAO,GACZ,KAAK,MAAQ,IACjB,CAEA,QAAQ,EAAI,CACR,KAAK,KAAO,EAAG,KACf,KAAK,MAAQ,EAAG,KACpB,CAEA,SAAU,CACN,UAAW,KAAK,WAAW,CAAC,EACrB,KAAK,KAChB,CAEA,QAAS,CACL,MAAO,MAAK,QAAQ,EAAE,OAAO,CACjC,CAEA,OAAQ,CACJ,MAAO,MAAK,QAAQ,EAAE,OAAO,CACjC,CAEA,SAAS,EAAM,EAAI,CACf,MAAO,IAAY,KAAK,OAAO,EAAG,EAAM,EAAI,EAAI,CACpD,CACJ,EAEM,GAAY,SAAS,EAAG,EAAI,CAC9B,EAAE,MAAM,EAAE,OAAS,GAAI,IAAO,EAAG,KAAM,EAAG,KAAK,CACnD,EACM,GAAe,SAAS,EAAG,EAAI,CACjC,EAAE,MAAM,EAAE,OAAS,GAAI,IAAO,GAAa,CAAE,CACjD,EAEM,GAAY,SAAS,EAAG,EAAQ,EAAQ,CAC1C,EAAE,MAAM,GAAQ,QAAQ,EAAE,MAAM,EAAO,CAC3C,EAEM,GAAW,SAAS,EAAG,EAAQ,EAAO,CACxC,EAAE,MAAM,GAAQ,QAAQ,CAAK,CACjC,EACM,GAAc,SAAS,EAAG,EAAQ,EAAI,CACxC,EAAE,MAAM,GAAQ,UAAU,CAAE,CAChC,EAEM,GAAiB,GAAI,IAAO,GAAU,IAAI,EAChD,OAAO,OAAO,EAAc,EAC5B,GAAO,QAAQ,eAAiB,GAEhC,GAAM,IAAN,KAAe,CAEX,YAAY,EAAG,EAAG,CACd,KAAK,GAAK,EAAE,IAAI,aAEhB,KAAK,EAAI,KACT,KAAK,UAAY,EACjB,KAAK,OAAS,GAAI,OAAM,CAAC,CAC7B,CAEJ,EAEM,GAAN,KAAe,CAEX,YAAY,EAAG,EAAG,EAAG,CAMjB,IALA,KAAK,GAAK,EAAE,IAAI,aAEhB,KAAK,EAAI,EACT,KAAK,UAAY,EACjB,KAAK,QAAU,GAAI,OAAM,CAAC,EACnB,KACH,KAAK,QAAQ,GAAK,GAAI,IAAO,GAAU,IAAI,CAEnD,CAEJ,EAEM,GAAN,KAAY,CAER,YAAY,EAAG,EAAM,CACjB,KAAK,GAAK,EAAE,IAAI,aAEhB,KAAK,UAAY,KACjB,KAAK,UAAY,GAAI,IAAO,GAAU,IAAI,EAC1C,KAAK,IAAM,EACX,KAAK,KAAO,OAAO,OAAO,IAAI,CAClC,CAEJ,EAMM,GAAN,KAAa,CACT,aAAc,CACV,KAAK,QAAU,KACf,KAAK,QAAU,IACf,KAAK,MAAQ,GACjB,CACJ,EAEM,GAAO,GAAa,KAAK,EACzB,GAAO,GAAa,WAAY,EAChC,GAAO,GAAa,IAAK,EAEzB,GAAe,SAAS,EAAQ,EAAS,CAC3C,GAAI,GAAI,EAAO,OACX,EACJ,GAAI,EAAO,KAAO,GACd,AAAI,EAAI,EACJ,GAAM,GAAI,YAAW,EAAE,CAAC,EACxB,EAAI,IAAI,EAAO,SAAS,CAAC,CAAC,GAE1B,GAAM,GAAI,YAAW,CAAO,EAC5B,EAAI,IAAI,EAAO,SAAS,EAAG,EAAQ,CAAC,CAAC,WAElC,EAAO,KAAO,GACrB,AAAI,GAAK,EACL,GAAM,GAAI,YAAW,EAAE,CAAC,EACxB,EAAI,IAAI,EAAO,SAAS,CAAC,CAAC,GAE1B,GAAM,GAAI,YAAW,CAAO,EAC5B,EAAI,IAAI,EAAI,EACZ,GAAW,GAAK,OAChB,EAAI,IAAI,EAAO,SAAS,EAAI,CAAO,EAAG,GAAK,MAAM,OAElD,CACH,EAAM,GAAI,YAAW,CAAO,EAC5B,GAAI,GAAM,GAAkB,EAAQ,EAA6B,EACjE,EAAI,IAAI,EAAG,EACX,GAAI,GAAQ,GAAI,OAChB,GAAW,GAAI,OAAS,GAAK,OAAS,GAAI,OAC1C,AAAI,EAAI,GAAW,IAAQ,GACvB,GAAI,IAAI,EAAQ,CAAK,EACrB,GAAS,EAAO,QAEZ,KAAQ,IAAI,GAAI,GAChB,EAAI,GAAS,GAAI,GACrB,EAAI,IAAI,EAAO,SAAS,EAAG,CAAC,EAAG,CAAK,EACpC,GAAS,EACT,EAAI,IAAI,GAAM,CAAK,EACnB,GAAS,GAAK,QAElB,EAAI,IAAI,GAAK,CAAK,EAClB,GAAS,GAAI,OACb,EAAM,EAAI,SAAS,EAAG,CAAK,CAC/B,CACA,MAAO,EACX,EAEM,GAAiB,SAAS,EAAG,CAC/B,MAAI,IAAS,CAAC,EAAU,EAAI,GACf,GAAI,KAAQ,EAC7B,EAEM,GAAa,EAEb,GAAe,SAAS,EAAM,EAAG,CACnC,GAAI,GAAI,EAER,GADA,GAAW,GAAK,OAAQ,EACpB,EAAI,IACJ,EAAK,GAAa,GAAK,MACtB,CACD,GAAI,GAAM,GACV,EACI,GAAK,GAAc,KAAQ,IAAQ,EAAI,GACvC,IAAM,EACN,IAAQ,QACH,EAAI,GACb,EAAK,GAAa,GAAM,CAAC,GAAO,EAAK,CACzC,CACA,MAAO,EACX,EAIM,GAAY,GAMZ,GAAkB,SAAS,EAAG,CAChC,GAAI,GAAI,EACJ,EAAI,EACJ,EAAS,EACT,EAAW,EACX,EAAI,EACJ,EACA,EAAS,GACb,KAAO,GAAS,EAAE,EAAE,GAAG,IAGvB,GAFA,AAAK,IAAO,EAAE,KAAO,KACZ,EAAE,KAAO,KAA8B,IAC5C,CAAE,GAAE,KAAO,IAAiC,GAAE,EAAE,KAAO,KAAiC,EAAE,EAAE,KAAO,KACnG,MAAO,MACX,IAAK,GAAK,GAAK,IACX,GAAI,EAAE,KAAO,GAAgE,CACzE,GAAI,EAAQ,MACP,EAAS,EAClB,SAAW,GAAU,EAAE,EAAE,EACrB,AAAI,IAAW,GAAK,EAAE,KAAO,GACzB,IACC,AAAI,EAAE,GAAU,GACjB,EAAK,EAAI,GAAM,GAAe,EAAE,EAAE,EACjC,IACD,GAAQ,QACT,OAGX,GAAI,EAAW,IAAW,EACtB,MAAO,MAEX,GADA,GAAK,EACD,EAAE,KAAO,KAAiC,EAAE,KAAO,GAA8B,CACjF,GAAI,GAAO,EACP,EAIJ,GAHA,IACA,AAAK,IAAQ,EAAE,KAAO,KACb,EAAE,KAAO,KAA8B,IAC5C,CAAC,GAAS,EAAE,EAAE,EACd,MAAO,MACX,KAAO,GAAS,EAAE,EAAE,GAChB,EAAO,EAAO,GAAK,EAAE,KAAO,GAChC,AAAI,GAAM,GAAO,CAAC,GAClB,GAAK,CACT,CACA,MAAI,IAAK,GAAI,CAAC,GACP,CACH,EAAG,GAAM,EAAG,CAAC,EACb,EAAG,CACP,CACJ,EAEM,GAAiB,SAAS,EAAG,CAC/B,GAAI,CACA,EAAI,GAAY,CAAC,CACrB,OAAS,EAAP,CACE,MAAO,KACX,CAGA,GAAI,GAAI,uEAAuE,KAAK,CAAC,EACrF,GAAI,CAAC,EACD,MAAO,MACX,GAAI,GAAM,WAAW,EAAE,EAAE,EACzB,MAAO,AAAC,OAAM,CAAG,EAAiC,KAA7B,CAAE,EAAQ,EAAG,EAAE,GAAG,MAAO,CAClD,EAEM,GAAa,SAAS,EAAG,EAAM,CACjC,GAAI,GAAS,IAAS,IAAM,GAAgB,CAAC,EAAI,GAAe,CAAC,EACjE,GAAI,IAAW,KAAM,MAAO,MAC5B,KAAO,GAAS,EAAE,EAAO,EAAE,GAAG,EAAO,IACrC,MAAQ,GAAO,IAAM,EAAE,QAAU,EAAE,EAAO,KAAO,EAAK,EAAS,IACnE,EAEM,GAAS,CACX,GACA,IACA,GACA,IACA,EACJ,EACM,GAAQ,CACV,CAAE,IAAK,IACP,CAAC,KAAM,IACP,CAAE,IAAK,IACP,CAAC,KAAM,IACP,CAAE,IAAK,GACX,EACM,GAAU,SAAS,EAAG,CACxB,GAAI,GAAI,EAAE,OACN,EAAQ,EACZ,OAAS,GAAE,EAAG,EAAE,EAAG,IAAK,CACpB,GAAI,GAAI,EAAE,GACV,GAAI,GAAO,QAAQ,CAAC,IAAM,GAAI,CAC1B,EAAQ,EACR,KACJ,CACJ,CACA,GAAI,GAAO,GAAM,GACjB,MAAI,KAAS,IACF,KACD,GAAW,EAAG,CAAI,CAKhC,EAEM,GAAW,KAAK,MAAM,GAAU,EAAE,EAClC,GAAW,GAAU,GAErB,GAAY,SAAS,EAAG,CAC1B,GAAI,GAAI,EACJ,EAAI,EACJ,EAAQ,GACR,EAEJ,KAAO,GAAS,EAAE,EAAE,GAAG,IAGvB,GAFA,AAAK,IAAO,EAAE,KAAO,KACZ,EAAE,KAAO,KAA8B,IAC5C,EAAE,KAAO,IAAiC,GAAE,EAAE,KAAO,KAAiC,EAAE,EAAE,KAAO,IAEjG,IADA,GAAK,EACE,EAAI,EAAE,QAAU,GAAU,EAAE,EAAE,EAAG,IACpC,EAAK,EAAI,GAAK,GAAe,EAAE,EAAE,EAAG,EACpC,EAAQ,OAGZ,MAAO,EAAI,EAAE,QAAU,GAAS,EAAE,EAAE,EAAG,IAAK,CACxC,GAAI,GAAI,EAAE,GAAK,GACf,GAAI,GAAK,IAAY,GAAI,IAAW,EAAI,GAAW,GAC/C,MAAO,MACX,EAAK,EAAI,GAAK,EAAG,EACjB,EAAQ,EACZ,CAEJ,KAAO,EAAI,EAAE,QAAU,GAAS,EAAE,EAAE,GAAG,IACvC,MAAI,IAAU,IAAM,EAAE,QAAU,EAAE,KAAO,EAAW,KAEzC,CACH,EAAI,GAAM,CAAC,EAAI,GAAG,EAClB,EAAG,CACP,CAER,EAEM,GAAe,SAAS,EAAG,EAAG,CAChC,GAAI,GAAM,GAAU,CAAC,EACrB,MAAI,KAAQ,KACR,GAAE,UAAU,EAAI,CAAC,EACV,EAAI,EAAE,GAEb,GAAM,GAAQ,CAAC,EACX,IAAQ,KACR,GAAE,YAAY,EAAI,CAAC,EACZ,EAAI,EAAE,GAEN,EAEnB,EAEM,GAAgB,SAAS,EAAG,EAAK,CACnC,GAAI,GACJ,GAAI,EAAI,YAAY,EAChB,EAAO,GAAa,GAAgB,EAAI,KAAK,CAAC,MAC7C,CACD,GAAI,GAAM,GAAe,EAAI,KAAK,EAClC,AAAI,CAAC,IAA0B,mBAAmB,KAAK,CAAG,GACtD,IAAO,MAEX,EAAO,GAAa,CAAG,CAC3B,CACA,EAAI,UAAU,GAAW,EAAG,CAAI,CAAC,CACrC,EAEM,GAAU,SAAS,EAAG,EAAK,CAC7B,GAAI,YAAY,CAAC,EACjB,GAAY,EAAG,EAAE,IAAI,EAAG,GAAS,EAAG,CAAG,CAAC,CAC5C,EAEM,GAAoB,SAAS,EAAG,EAAK,EAAM,CAC7C,GAAI,GAAI,EACJ,EAAI,EACJ,EAAI,EACJ,EACJ,KACI,EAAI,GAAkB,EAAK,GAA8B,CAAC,EACtD,GAAK,IAFJ,CAIL,OADA,GAAQ,EAAG,EAAI,SAAS,EAAG,CAAC,CAAC,EACtB,EAAI,EAAE,QACJ,KAA+B,CAChC,GAAI,GAAI,EAAK,KACb,GAAI,IAAM,KAAM,EAAI,GAAa,SAAU,EAAI,MAC1C,CACD,EAAI,GAAgB,CAAC,EAErB,GAAI,GAAI,GAAkB,EAAG,CAAC,EAC9B,AAAI,IAAM,IACN,GAAI,EAAE,SAAS,EAAG,CAAC,EAC3B,CACA,GAAQ,EAAG,CAAC,EACZ,KACJ,KACK,IAA8B,CAC/B,GAAI,GAAO,EAAK,KAChB,AAAI,GAAS,CAAI,EACb,GAAQ,EAAG,GAAa,CAAI,CAAC,EAE7B,GAAiB,EAAG,GAAa,SAAU,EAAI,EAAG,CAAI,EAC1D,KACJ,KACK,SACA,IACD,GAAI,YAAY,CAAC,EACjB,EAAE,MAAM,EAAE,IAAI,GAAG,UAAU,EAAK,IAAI,EACpC,GAAc,EAAG,EAAE,MAAM,EAAE,IAAI,EAAE,EACjC,UACC,KACD,GAAI,YAAY,CAAC,EACjB,EAAE,MAAM,EAAE,IAAI,GAAG,YAAY,EAAK,IAAI,EACtC,GAAc,EAAG,EAAE,MAAM,EAAE,IAAI,EAAE,EACjC,UACC,KAA+B,CAChC,GAAI,GAAI,EAAK,KACb,GAAI,YAAa,IAAO,WACpB,YAAa,IAAO,OACpB,YAAa,KACb,YAAa,KACb,YAAa,IACb,GAAQ,EAAG,GAAa,KAAK,EAAE,GAAG,SAAS,EAAE,CAAC,CAAC,MAE/C,QAAO,MAAO,QACL,YACD,GAAQ,EAAG,GAAa,WAAW,CAAC,EACpC,UACC,SACD,GAAQ,EAAG,GAAa,UAAU,EAAE,GAAG,CAAC,EACxC,UACC,SACD,GAAQ,EAAG,GAAa,UAAU,KAAK,UAAU,CAAC,EAAE,GAAG,CAAC,EACxD,UACC,UACD,GAAQ,EAAG,GAAa,EAAE,gBAAgB,gBAAgB,CAAC,EAC3D,UACC,SACD,GAAI,IAAM,KAAM,CACZ,GAAQ,EAAG,GAAa,MAAM,CAAC,EAC/B,KACJ,KAEC,WAAY,CACb,GAAI,GAAK,EAAE,IAAI,IAAI,IAAI,CAAC,EACxB,AAAK,GACD,GAAK,EAAE,IAAI,aACX,EAAE,IAAI,IAAI,IAAI,EAAG,CAAE,GAEvB,GAAQ,EAAG,GAAa,KAAK,EAAG,SAAS,EAAE,CAAC,CAAC,EAC7C,KACJ,SAGI,GAAQ,EAAG,GAAa,UAAU,CAAC,EAG/C,KACJ,KACK,IAA8B,CAC/B,GAAI,GAAO,GAAI,YAAW,EAAU,EAChC,EAAI,GAAa,EAAM,EAAK,IAAI,EACpC,GAAQ,EAAG,EAAK,SAAS,GAAa,CAAC,CAAC,EACxC,KACJ,KACK,IACD,GAAQ,EAAG,GAAa,IAAK,EAAI,CAAC,EAClC,cAEA,GAAO,cAAc,EAAG,GAAa,4CAA4C,EAAG,EAAI,EAAI,EAAE,EAEtG,GAAK,EACL,EAAI,EAAI,CACZ,CACA,UAAI,gBAAgB,EAAG,CAAC,EACxB,GAAQ,EAAG,EAAI,SAAS,CAAC,CAAC,EACtB,EAAI,GAAG,GAAI,YAAY,EAAG,EAAE,CAAC,EAC1B,EAAE,MAAM,EAAE,IAAI,GAAG,OAAO,CACnC,EAEM,GAAmB,SAAS,EAAG,KAAQ,EAAM,CAC/C,MAAO,IAAkB,EAAG,EAAK,CAAI,CACzC,EAQM,GAAc,SAAS,EAAG,CAC5B,GAAI,GAAI,EACR,GAAI,EAAI,EAAG,MAAO,GAClB,KAAO,GAAM,GAAK,GACd,EAAK,EAAI,IAAQ,EACjB,GAAK,EAET,KAAO,GAAM,GAAK,GACd,EAAK,EAAI,GAAM,EACf,IAEJ,MAAS,GAAE,GAAM,EAAM,EAAI,CAC/B,EAEM,GAAW,SAAS,EAAG,EAAI,EAAI,EAAI,CACrC,OAAQ,OACC,IAAY,MAAQ,GAAK,EAAI,MAC7B,IAAY,MAAQ,GAAK,EAAI,MAC7B,IAAY,MAAO,IAAI,UAAU,EAAI,CAAE,MACvC,IAAY,MAAO,IAAI,SAAS,EAAG,EAAI,CAAE,MACzC,IAAY,MAAO,IAAI,SAAS,EAAG,EAAI,CAAE,MACzC,IAAY,MAAQ,GAAK,MACzB,IAAY,MAAQ,GAAK,MACzB,IAAY,MAAQ,GAAK,MACzB,IAAY,MAAO,IAAI,YAAY,EAAI,CAAE,MACzC,IAAY,MAAO,IAAI,YAAY,EAAI,CAAC,CAAE,MAC1C,IAAY,MAAQ,GAAI,EAAI,MAC5B,IAAY,MAAQ,GAAK,UACrB,GAAW,CAAC,EAE7B,EAGM,GAAW,SAAS,EAAG,EAAI,EAAI,EAAI,CACrC,OAAQ,OACC,IAAY,MAAO,GAAK,MACxB,IAAY,MAAO,GAAK,MACxB,IAAY,MAAO,GAAK,MACxB,IAAY,MAAO,GAAK,MACxB,IAAY,MAAO,MAAK,IAAI,EAAI,CAAE,MAClC,IAAY,MAAO,MAAK,MAAM,EAAK,CAAE,MACrC,IAAY,MAAO,CAAC,MACpB,IAAY,MAAO,IAAY,EAAG,EAAI,CAAE,UACpC,GAAW,CAAC,EAE7B,EAEM,GAAa,SAAS,EAAG,EAAI,EAAI,EAAI,EAAI,CAC3C,GAAI,GAAO,MAAO,IAAO,SAAY,EAAE,MAAM,GAAM,EAEnD,OAAQ,OACC,QAAiB,QAAgB,QACjC,QAAgB,QAChB,IAAY,CACb,GAAI,GAAI,EACR,GAAK,GAAK,GAAI,UAAU,CAAE,KAAO,IAAU,GAAK,GAAI,UAAU,CAAE,KAAO,GAAO,CAC1E,EAAI,UAAU,GAAS,EAAG,EAAI,EAAI,CAAE,CAAC,EACrC,MACJ,KACK,MACT,KACK,QAAgB,IAAW,CAC5B,GAAI,GAAI,EACR,GAAK,GAAK,GAAI,SAAS,CAAE,KAAO,IAAU,GAAK,GAAI,SAAS,CAAE,KAAO,GAAO,CACxE,EAAI,YAAY,GAAS,EAAG,EAAI,EAAI,CAAE,CAAC,EACvC,MACJ,KACK,MACT,SACS,CACL,GAAI,GAAI,EACR,GAAI,EAAG,YAAY,GAAK,EAAG,YAAY,EAAG,CACtC,EAAI,UAAU,GAAS,EAAG,EAAI,EAAG,MAAO,EAAG,KAAK,CAAC,EACjD,MACJ,SACU,GAAK,GAAI,SAAS,CAAE,KAAO,IAAU,GAAK,GAAI,SAAS,CAAE,KAAO,GAAO,CAC7E,EAAI,YAAY,GAAS,EAAG,EAAI,EAAI,CAAE,CAAC,EACvC,MACJ,KACK,MACT,EAGJ,GAAW,IAAM,IAAI,EACrB,GAAI,cAAc,EAAG,EAAI,EAAI,EAAK,EAAK,GAAa,GAAI,IAAI,MAAM,CACtE,EAGA,GAAO,QAAQ,SAAoB,GACnC,GAAO,QAAQ,SAAoB,GACnC,GAAO,QAAQ,aAAoB,GACnC,GAAO,QAAQ,WAAoB,GACnC,GAAO,QAAQ,OAAoB,GACnC,GAAO,QAAQ,OAAoB,GACnC,GAAO,QAAQ,MAAoB,GACnC,GAAO,QAAQ,WAAoB,GACnC,GAAO,QAAQ,WAAoB,GACnC,GAAO,QAAQ,aAAoB,GACnC,GAAO,QAAQ,eAAoB,GACnC,GAAO,QAAQ,YAAoB,GACnC,GAAO,QAAQ,iBAAoB,GACnC,GAAO,QAAQ,kBAAoB,GACnC,GAAO,QAAQ,aAAoB,GACnC,GAAO,QAAQ,cAAoB,GACnC,GAAO,QAAQ,aAAoB,GACnC,GAAO,QAAQ,SAAoB,GACnC,GAAO,QAAQ,UAAoB,GACnC,GAAO,QAAQ,aAAoB,GACnC,GAAO,QAAQ,UAAoB,GACnC,GAAO,QAAQ,SAAoB,GACnC,GAAO,QAAQ,YAAoB,KC/zBnC,mBAEA,GAAM,CAAE,eAAgB,CAAE,cAAe,KACnC,GAAU,KAEV,GAAN,KAAY,CACR,YAAY,EAAG,CACX,KAAK,GAAK,EAAE,IAAI,aAChB,KAAK,EAAI,CAAC,EACV,KAAK,EAAI,CAAC,EACV,KAAK,KAAO,CAAC,EACb,KAAK,MAAQ,KACb,KAAK,SAAW,CAAC,EACjB,KAAK,SAAW,CAAC,EACjB,KAAK,UAAY,EACjB,KAAK,UAAY,GACjB,KAAK,aAAe,EACpB,KAAK,QAAU,CAAC,EAChB,KAAK,YAAc,EACnB,KAAK,gBAAkB,EACvB,KAAK,OAAS,IAClB,CACJ,EAEM,GAAmB,SAAS,EAAG,EAAG,CACpC,MAAO,IAAI,IAAQ,SAAS,EAAG,CAAC,CACpC,EAGM,GAAiB,SAAS,EAAG,EAAO,CACtC,MAAO,GAAE,MAAM,EACnB,EAEM,GAAa,SAAS,EAAG,EAAO,CAGlC,OAAS,GAAE,EAAO,EAAE,EAAE,IAAK,IAAK,CAC5B,GAAI,GAAM,EAAE,MAAM,GAClB,EAAE,MAAM,GAAK,GAAI,IAAQ,OAAO,EAAI,KAAM,EAAI,KAAK,CACvD,CACJ,EAKM,GAAkB,SAAS,EAAG,EAAI,CACpC,OAAS,GAAI,EAAG,EAAI,EAAG,UAAW,IAC9B,EAAG,OAAO,GAAK,GAAI,IAAQ,OAAO,GAAU,IAAI,CACxD,EAMM,GAAoB,SAAS,EAAG,EAAc,EAAI,CACpD,OAAS,GAAI,EAAG,EAAI,EAAE,QAAQ,QAAU,EAAE,QAAQ,GAAG,SAAW,EAAI,IAChE,GAAI,EAAK,EAAE,QAAQ,GAAG,OAClB,KACI,IAAiB,GACjB,MAAO,GAAE,QAAQ,GAAG,QAAQ,OAAO,EAG/C,MAAO,KACX,EAEA,GAAO,QAAQ,SAAoB,IACnC,GAAO,QAAQ,MAAoB,GACnC,GAAO,QAAQ,eAAoB,GACnC,GAAO,QAAQ,WAAoB,GACnC,GAAO,QAAQ,kBAAoB,GACnC,GAAO,QAAQ,gBAAoB,GACnC,GAAO,QAAQ,iBAAoB,KCvEnC,mBAEA,GAAM,CAAE,eAAe,KAEjB,GAAN,KAAc,CACV,aAAc,CACV,KAAK,OAAS,KACd,KAAK,EAAI,CACb,CACJ,EAEM,GAAc,SAAS,EAAM,CAC/B,MAAO,GAAK,OAAO,SAAS,EAAG,EAAK,CAAC,CACzC,EAEM,GAAkB,SAAS,EAAM,EAAG,CACtC,EAAK,GAAK,CACd,EAEM,GAAmB,SAAS,EAAM,CACpC,EAAK,EAAI,CACb,EAEM,GAAoB,SAAS,EAAG,EAAM,EAAM,CAC9C,GAAI,GAAU,GAAI,YAAW,CAAI,EACjC,AAAI,EAAK,QACL,EAAQ,IAAI,EAAK,MAAM,EAC3B,EAAK,OAAS,CAClB,EAEM,GAAN,KAAU,CACN,YAAY,EAAG,EAAQ,EAAM,CACzB,KAAK,EAAI,EACT,GAAW,MAAO,IAAU,WAAY,uBAAuB,EAC/D,KAAK,OAAS,EACd,KAAK,KAAO,EACZ,KAAK,EAAI,EACT,KAAK,OAAS,KACd,KAAK,IAAM,CACf,CAEA,OAAS,CACL,MAAS,MAAK,KAAO,EAAK,KAAK,OAAO,KAAK,OAAS,GAAU,IAAI,CACtE,CACJ,EAEM,GAAM,GAEN,GAAY,SAAS,EAAG,CAC1B,GAAI,GAAO,EAAE,OAAO,EAAE,EAAG,EAAE,IAAI,EAC/B,GAAI,IAAS,KACT,MAAO,IACX,GAAW,YAAgB,YAAY,2CAA2C,EAClF,GAAI,GAAO,EAAK,OAChB,MAAI,KAAS,EACF,GACX,GAAE,OAAS,EACX,EAAE,IAAM,EACR,EAAE,EAAI,EAAO,EACN,EAAE,OAAO,EAAE,OACtB,EAIM,GAAY,SAAS,EAAG,EAAG,EAAU,EAAG,CAC1C,KAAO,GAAG,CACN,GAAI,EAAE,IAAM,EAAG,CACX,GAAI,GAAU,CAAC,IAAM,GACjB,MAAO,GAEP,EAAE,IACF,EAAE,KAEV,CACA,GAAI,GAAK,GAAK,EAAE,EAAK,EAAI,EAAE,EAC3B,OAAS,GAAE,EAAG,EAAE,EAAG,IACf,EAAE,KAAc,EAAE,OAAO,EAAE,OAE/B,EAAE,GAAK,EACH,EAAE,IAAM,GACR,GAAE,OAAS,MACf,GAAK,CACT,CAEA,MAAO,EACX,EAEA,GAAO,QAAQ,IAAoB,GACnC,GAAO,QAAQ,YAAoB,GACnC,GAAO,QAAQ,gBAAoB,GACnC,GAAO,QAAQ,UAAoB,GACnC,GAAO,QAAQ,UAAoB,GACnC,GAAO,QAAQ,iBAAoB,GACnC,GAAO,QAAQ,kBAAoB,GACnC,GAAO,QAAQ,QAAoB,GACnC,GAAO,QAAQ,IAAoB,KC/FnC,mBAEA,GAAM,CACF,eAAgB,CAAE,gBAAc,gBAChC,cAAe,CAAE,kBACjB,iBACA,KACE,CACF,iBACA,WACA,eACA,KACE,GAAW,KACX,GAAW,KACX,CACF,YACA,aACA,aACA,YACA,cACA,KACE,GAAW,KACX,CACF,cACA,aACA,oBACA,aACA,KACE,GAAW,KACX,CACF,OACA,eACA,mBACA,oBACA,sBACA,KAEE,EAAiB,IAEjB,GAAU,GAAa,OAAQ,EAAI,EAGnC,GAAc,EACd,GAAc,EAAiB,EAC/B,GAAc,EAAiB,EAC/B,GAAc,EAAiB,EAC/B,GAAc,EAAiB,EAC/B,GAAc,EAAiB,EAC/B,GAAc,EAAiB,EAC/B,GAAc,EAAiB,EAC/B,GAAc,EAAiB,EAC/B,GAAc,EAAiB,EAC/B,GAAc,EAAiB,GAC/B,GAAc,EAAiB,GAC/B,GAAc,EAAiB,GAC/B,GAAc,EAAiB,GAC/B,GAAc,EAAiB,GAC/B,GAAc,EAAiB,GAC/B,GAAc,EAAiB,GAC/B,GAAc,EAAiB,GAC/B,GAAc,EAAiB,GAC/B,GAAc,EAAiB,GAC/B,GAAc,EAAiB,GAC/B,GAAc,EAAiB,GAE/B,GAAc,EAAiB,GAC/B,GAAc,EAAiB,GAC/B,GAAc,EAAiB,GAC/B,GAAc,EAAiB,GAC/B,GAAc,EAAiB,GAC/B,GAAc,EAAiB,GAC/B,GAAc,EAAiB,GAC/B,GAAc,EAAiB,GAC/B,GAAc,EAAiB,GAC/B,GAAc,EAAiB,GAC/B,GAAc,EAAiB,GAC/B,GAAc,EAAiB,GAC/B,GAAc,EAAiB,GAC/B,GAAc,EAAiB,GAC/B,GAAc,EAAiB,GAE/B,GAAW,CACb,OAAe,GACf,SAAe,GACf,MAAe,GACf,QAAe,GACf,UAAe,GACf,OAAe,GACf,SAAe,GACf,OAAe,GACf,YAAe,GACf,QAAe,GACf,MAAe,GACf,MAAe,GACf,SAAe,GACf,OAAe,GACf,OAAe,GACf,MAAe,GACf,UAAe,GACf,UAAe,GACf,QAAe,GACf,QAAe,GACf,SAAe,GACf,SAAe,GACf,QAAe,GACf,UAAe,GACf,QAAe,GACf,MAAe,GACf,MAAe,GACf,MAAe,GACf,MAAe,GACf,OAAe,GACf,OAAe,GACf,WAAe,GACf,OAAe,GACf,OAAe,GACf,OAAe,GACf,QAAe,GACf,UAAe,EACnB,EAEM,GAAc,CAChB,MAAO,QAAS,KAAM,OAAQ,SAC9B,MAAO,QAAS,MAAO,WAAY,OAAQ,KAC3C,KAAM,QAAS,MAAO,MAAO,KAAM,SACnC,SAAU,OAAQ,OAAQ,QAAS,QACnC,KAAM,KAAM,MAAO,KAAM,KAAM,KAAM,KACrC,KAAM,KAAM,KAAM,QAClB,WAAY,YAAa,SAAU,UACvC,EAAE,IAAI,CAAC,EAAG,IAAI,GAAa,CAAC,CAAC,EAEvB,GAAN,KAAc,CACV,aAAc,CACV,KAAK,EAAI,IACT,KAAK,EAAI,IACT,KAAK,GAAK,IACd,CACJ,EAEM,GAAN,KAAY,CACR,aAAc,CACV,KAAK,MAAQ,IACb,KAAK,QAAU,GAAI,GACvB,CACJ,EAIM,GAAN,KAAe,CACX,aAAc,CACV,KAAK,QAAU,IACf,KAAK,WAAa,IAClB,KAAK,SAAW,IAChB,KAAK,EAAI,GAAI,IACb,KAAK,UAAY,GAAI,IACrB,KAAK,GAAK,KACV,KAAK,EAAI,KACT,KAAK,EAAI,KACT,KAAK,KAAO,KACZ,KAAK,EAAI,KACT,KAAK,IAAM,KACX,KAAK,OAAS,KACd,KAAK,KAAO,IAChB,CACJ,EAEM,GAAO,SAAS,EAAI,EAAG,CACzB,GAAI,GAAI,EAAG,KACX,GAAI,EAAE,EAAI,EAAI,EAAE,OAAO,OAAQ,CAC3B,AAAI,EAAE,OAAO,QAAU,GAAQ,GAC3B,GAAS,EAAI,GAAa,2BAA4B,EAAI,EAAG,CAAC,EAClE,GAAI,GAAU,EAAE,OAAO,OAAO,EAC9B,GAAkB,EAAG,EAAG,EAAG,CAAO,CACtC,CACA,EAAE,OAAO,EAAE,KAAO,EAAI,EAAI,IAAM,EAAI,EAAI,CAC5C,EAEM,GAAiB,SAAS,EAAI,EAAO,CACvC,GAAI,EAAQ,EACR,MAAO,IAAQ,iBAAiB,EAAG,EAAG,GAAa,OAAQ,EAAI,EAAG,CAAK,EACpE,CACH,GAAI,GAAI,GAAY,EAAQ,GAC5B,MAAI,GAAQ,GACD,GAAQ,iBAAiB,EAAG,EAAG,GAAa,OAAQ,EAAI,EAAG,CAAC,EAE5D,CACf,CACJ,EAEM,GAAgB,SAAS,EAAI,CAC/B,MAAO,GAAG,UAAY,IAAiC,EAAG,UAAY,EAC1E,EAEM,GAAO,SAAS,EAAI,CACtB,EAAG,QAAU,EAAG,EAAE,MAAM,CAC5B,EAEM,GAAgB,SAAS,EAAI,CAC/B,GAAK,EAAI,EAAG,OAAO,EACnB,GAAK,CAAE,CACX,EAOM,GAAS,GAAI,IAAQ,OAAO,GAAc,EAAI,EAC9C,GAAiB,SAAS,EAAI,EAAK,CACrC,GAAI,GAAI,EAAG,EACP,EAAK,GAAS,EAAG,CAAG,EAEpB,EAAQ,EAAG,EAAE,OAAO,IAAI,GAAiB,CAAE,CAAC,EAChD,GAAK,EAID,EAAK,EAAM,IAAI,QAAQ,MAJf,CACR,GAAI,GAAM,GAAI,IAAQ,OAAO,GAAa,CAAE,EAC5C,GAAO,aAAa,EAAG,EAAG,EAAG,EAAK,EAAM,CAC5C,CAGA,MAAO,EACX,EAMM,GAAgB,SAAS,EAAI,CAC/B,GAAI,GAAM,EAAG,QACb,GAAW,GAAc,CAAE,CAAC,EAC5B,GAAK,CAAE,EACH,GAAc,CAAE,GAAK,EAAG,UAAY,GACpC,GAAK,CAAE,EACP,EAAE,EAAG,YAAc,IACnB,GAAS,EAAI,GAAa,2BAA4B,EAAI,EAAG,CAAC,CACtE,EAEM,GAAgB,SAAS,EAAG,EAAI,EAAG,EAAQ,EAAW,CACxD,EAAG,EAAI,CACH,MAAO,EACP,QAAS,GAAI,GACjB,EACA,EAAG,EAAI,EACP,EAAG,QAAU,EACb,EAAG,UAAY,CACX,MAAO,GACP,QAAS,GAAI,GACjB,EACA,EAAG,EAAI,EACP,EAAG,GAAK,KACR,EAAG,WAAa,EAChB,EAAG,SAAW,EACd,EAAG,OAAS,EACZ,EAAG,KAAO,GAAW,EAAG,EAAO,EAC/B,GAAkB,EAAG,EAAG,KAAM,EAAa,CAC/C,EAEM,GAAc,SAAS,EAAI,EAAG,CAChC,MAAI,GAAG,UAAY,EACf,IAAK,CAAE,EACA,IAGJ,EACX,EAMM,GAAc,SAAS,EAAI,EAAK,CAClC,MAAI,GAAG,UAAY,EAAI,GAAG,WAAW,CAAC,GAAK,EAAG,UAAY,EAAI,GAAG,WAAW,CAAC,EACzE,IAAc,CAAE,EACT,IAGJ,EACX,EAEM,GAAe,SAAS,EAAI,EAAS,CACvC,GAAI,GAAO,KACP,EAAQ,EAAG,QAMf,IALA,GAAW,GAAS,EAAG,OAAO,CAAC,EAC/B,GAAc,CAAE,EACZ,IAAU,IAAgC,GAAY,EAAI,IAAI,GAC9D,GAAO,QAKP,GAFI,GAAY,EAAI,CAAI,GACpB,GAAY,EAAI,IAAI,EACpB,GAAU,EAAG,OAAO,EACpB,GAAc,CAAE,UACX,EAAG,UAAY,GACpB,GAAc,CAAE,MACf,OAKT,GAAI,GAAM,GAAI,IAAQ,OAGtB,MAFI,IAAQ,aAAa,GAAY,EAAG,IAAI,EAAG,CAAG,IAAM,GACpD,GAAS,EAAI,GAAa,mBAAoB,EAAI,EAAG,EAAM,EAC3D,EAAI,YAAY,EAChB,GAAQ,EAAI,EAAI,MACT,IAEP,IAAW,EAAI,UAAU,CAAC,EAC1B,EAAQ,EAAI,EAAI,MACT,GAEf,EAEM,GAAW,SAAS,EAAI,EAAO,CACjC,OAAQ,OACC,QAAc,QACd,QAAa,IAEd,MAAO,IAAQ,iBAAiB,EAAG,EAAG,GAAa,OAAQ,EAAI,EAAG,GAAY,EAAG,IAAI,CAAC,UAEtF,MAAO,IAAe,EAAI,CAAK,EAE3C,EAEM,GAAW,SAAS,EAAI,EAAK,EAAO,CACtC,EAAM,GAAO,aAAa,EAAG,EAAG,EAAK,EAAG,OAAQ,EAAG,UAAU,EACzD,GACA,GAAQ,iBAAiB,EAAG,EAAG,GAAa,YAAY,EAAG,EAAK,GAAS,EAAI,CAAK,CAAC,EACvF,GAAI,WAAW,EAAG,EAAG,EAAa,CACtC,EAEM,GAAmB,SAAS,EAAI,EAAK,CACvC,GAAS,EAAI,EAAK,EAAG,EAAE,KAAK,CAChC,EAOM,GAAW,SAAS,EAAI,CAC1B,GAAI,GAAQ,EACR,EAAI,EAAG,QAGX,IAFA,GAAW,IAAM,IAAgC,IAAM,EAA4B,EACnF,GAAc,CAAE,EACT,EAAG,UAAY,IAClB,GAAc,CAAE,EAChB,IAEJ,MAAO,GAAG,UAAY,EAAI,EAAS,CAAC,EAAS,CACjD,EAEM,GAAmB,SAAS,EAAI,EAAS,EAAK,CAChD,GAAI,GAAO,EAAG,WACd,GAAc,CAAE,EAEZ,GAAc,CAAE,GAChB,GAAc,CAAE,EAEpB,GAAI,GAAO,GACX,KAAO,CAAC,GACJ,OAAQ,EAAG,aACF,IAAK,CAEN,GAAI,GAAM,mBADC,EAAU,SAAW,+BACuB,KACvD,GAAS,EAAI,GAAa,CAAG,EAAG,EAAM,EACtC,KACJ,KACK,IAA8B,CAC/B,AAAI,GAAS,CAAE,IAAM,GACjB,IAAc,CAAE,EAChB,EAAO,IAEX,KACJ,KACK,QACA,IAA+B,CAChC,GAAK,EAAI,EAA6B,EACtC,GAAc,CAAE,EACX,GAAS,GAAiB,EAAG,IAAI,EACtC,KACJ,SAEI,AAAI,EAAS,GAAc,CAAE,EACxB,GAAK,CAAE,EAKxB,AAAI,GACA,GAAQ,GAAK,GAAe,EAAI,EAAG,KAAK,OAAO,SAAS,EAAI,EAAK,EAAG,KAAK,EAAK,GAAI,EAAI,CAAC,EAC/F,EAEM,GAAW,SAAS,EAAI,EAAG,EAAK,CAClC,AAAK,GACG,GAAG,UAAY,IACf,GAAc,CAAE,EACpB,GAAS,EAAI,EAAK,EAAS,EAEnC,EAEM,GAAU,SAAS,EAAI,CACzB,UAAc,CAAE,EAChB,GAAS,EAAI,GAAU,EAAG,OAAO,EAAG,GAAa,6BAA8B,EAAI,CAAC,EAC7E,GAAQ,eAAe,EAAG,OAAO,CAC5C,EAEM,GAAc,SAAS,EAAI,CAC7B,GAAI,GAAI,GAAQ,CAAE,EAClB,SAAK,IAAK,GAAK,GAAQ,CAAE,EACzB,GAAgB,EAAG,KAAM,CAAC,EACnB,CACX,EAEM,GAAe,SAAS,EAAI,CAC9B,GAAI,GAAI,EACR,GAAc,CAAE,EAChB,GAAS,EAAI,EAAG,UAAY,IAA+B,GAAa,cAAe,EAAI,CAAC,EAC5F,GAAI,GAAI,GAAQ,CAAE,EAGlB,IADA,GAAc,CAAE,EACT,GAAU,EAAG,OAAO,GACvB,IACA,EAAK,IAAK,GAAK,GAAQ,eAAe,EAAG,OAAO,EAChD,GAAS,EAAI,GAAK,QAAU,GAAa,wBAAyB,EAAI,CAAC,EACvE,GAAc,CAAE,EAEpB,UAAS,EAAI,EAAG,UAAY,IAA+B,GAAa,cAAe,EAAI,CAAC,EAC5F,GAAK,CAAE,EACP,GAAgB,EAAG,KAAM,CAAC,EACnB,CACX,EAEM,GAAU,SAAS,EAAI,CACzB,GAAI,GAAO,GAAI,YAAW,GAAQ,UAAU,EACxC,EAAI,GAAQ,aAAa,EAAM,GAAa,CAAE,CAAC,EACnD,KAAO,EAAI,EAAG,IACV,GAAK,EAAI,EAAK,GAAQ,WAAa,EAAE,CAC7C,EAEM,GAAa,SAAS,EAAI,CAC5B,GAAI,GAAI,EACJ,EACJ,IAAK,EAAI,EAAG,EAAI,GAAK,GAAS,EAAG,OAAO,EAAG,IACvC,EAAI,GAAK,EAAI,EAAG,QAAU,GAC1B,GAAc,CAAE,EAEpB,UAAS,EAAI,GAAK,IAAK,GAAa,2BAA4B,EAAI,CAAC,EACrE,GAAgB,EAAG,KAAM,CAAC,EACnB,CACX,EAEM,GAAc,SAAS,EAAI,EAAK,EAAS,CAG3C,IAFA,GAAc,CAAE,EAET,EAAG,UAAY,GAClB,OAAQ,EAAG,aACF,IACD,GAAS,EAAI,GAAa,oBAAqB,EAAI,EAAG,EAAM,EAC5D,UACC,QACA,IACD,GAAS,EAAI,GAAa,oBAAqB,EAAI,EAAG,EAAS,EAC/D,UACC,IAA+B,CAChC,GAAc,CAAE,EAChB,GAAI,GACA,EACJ,OAAO,EAAG,aACD,IAA8B,EAAI,EAA2B,EAAO,YAAa,UACjF,IAA8B,EAAI,EAA8B,EAAO,YAAa,UACpF,KAA+B,EAAI,GAA+B,EAAO,YAAa,UACtF,KAA+B,EAAI,GAA+B,EAAO,YAAa,UACtF,KAA+B,EAAI,GAA+B,EAAO,YAAa,UACtF,KAA+B,EAAI,EAA8B,EAAO,YAAa,UACrF,KAA+B,EAAI,GAA+B,EAAO,YAAa,UACtF,KAA+B,EAAI,GAAY,CAAE,EAAG,EAAO,YAAa,UACxE,KAA+B,GAAQ,CAAE,EAAG,EAAO,UAAW,UAC9D,QACA,IACD,GAAc,CAAE,EAAG,EAAI,GAA+B,EAAO,YAAa,UACzE,QACA,QACA,IACD,EAAI,EAAG,QAAS,EAAO,YAAa,UACnC,IAAK,EAAO,UAAW,UACvB,KAA+B,CAGhC,IAFA,GAAgB,EAAG,KAAM,CAAC,EAC1B,GAAK,CAAE,EACA,GAAS,EAAG,OAAO,GACtB,AAAI,GAAc,CAAE,EAAG,GAAc,CAAE,EAClC,GAAK,CAAE,EAEhB,EAAO,UAAW,KACtB,SACS,CACL,GAAS,EAAI,GAAS,EAAG,OAAO,EAAG,GAAa,0BAA2B,EAAI,CAAC,EAChF,EAAI,GAAW,CAAE,EACjB,EAAO,YAAa,KACxB,EAGJ,AAAI,IAAS,aACT,GAAK,CAAE,EAEP,KAAS,aAAe,IAAS,cACjC,IAAgB,EAAG,KAAM,CAAC,EAC1B,GAAK,EAAI,CAAC,GAGd,KACJ,SAEI,GAAc,CAAE,EAG5B,GAAc,CAAE,EAEhB,EAAQ,GAAK,GAAe,EAAI,EAAG,KAAK,OAAO,SAAS,EAAG,EAAG,KAAK,EAAE,CAAC,CAAC,CAC3E,EAEM,GAAiB,OAAO,OAAO,IAAI,EACzC,GAAY,QAAQ,CAAC,EAAG,IAAI,GAAe,GAAU,CAAC,GAAK,CAAC,EAE5D,GAAM,IAAa,SAAS,EAAG,CAC3B,GAAI,GAAO,GAAe,GAAiB,CAAC,GAC5C,MAAO,KAAS,QAAU,GAAQ,EACtC,EAEM,GAAO,SAAS,EAAI,EAAS,CAE/B,IADA,GAAiB,EAAG,IAAI,IAGpB,OADA,GAAW,MAAO,GAAG,SAAW,QAAQ,EAChC,EAAG,aACF,QACA,IAA+B,CAChC,GAAc,CAAE,EAChB,KACJ,KACK,QACA,QACA,OACA,IAA+B,CAChC,GAAK,CAAE,EACP,KACJ,KACK,IAA8B,CAE/B,GADA,GAAK,CAAE,EACH,EAAG,UAAY,GAA8B,MAAO,IAGxD,GADA,GAAK,CAAE,EACH,EAAG,UAAY,GAA8B,CAC7C,GAAI,GAAM,GAAS,CAAE,EAErB,GADA,GAAiB,EAAG,IAAI,EACpB,GAAO,EAAG,CACV,GAAiB,EAAI,KAAM,CAAG,EAC9B,GAAiB,EAAG,IAAI,EACxB,KACJ,CACJ,CAGA,KAAO,CAAC,GAAc,CAAE,GAAK,EAAG,UAAY,IACxC,GAAK,CAAE,EACX,KACJ,KACK,IAA8B,CAC/B,GAAI,GAAM,GAAS,CAAE,EACrB,MAAI,IAAO,EACP,IAAiB,EAAI,EAAS,CAAG,EAC1B,IACA,KAAQ,IACf,GAAS,EAAI,GAAa,gCAAiC,EAAI,EAAG,EAAS,EACxE,GACX,KACK,IAED,MADA,IAAK,CAAE,EACH,GAAY,EAAI,EAA4B,EAAU,GAC9C,OAEX,IAED,MADA,IAAK,CAAE,EACH,GAAY,EAAI,EAA4B,EAAU,GACjD,GAAY,EAAI,EAA4B,EAAU,GACnD,OAEX,IAED,MADA,IAAK,CAAE,EACH,GAAY,EAAI,EAA4B,EAAU,GACjD,GAAY,EAAI,EAA4B,EAAU,GACnD,OAEX,IAED,MADA,IAAK,CAAE,EACH,GAAY,EAAI,EAA4B,EAAU,GAC9C,OAEX,KAED,MADA,IAAK,CAAE,EACH,GAAY,EAAI,EAA4B,EAAU,GAC9C,QAEX,IAED,MADA,IAAK,CAAE,EACH,GAAY,EAAI,EAA4B,EAAU,GAC9C,OAEX,QACA,IACD,UAAY,EAAI,EAAG,QAAS,CAAO,EAC5B,OAEN,IAED,MADA,IAAc,CAAE,EACZ,GAAY,EAAI,EAA4B,EACxC,GAAY,EAAI,EAA4B,EACrC,GACC,GAEN,GAAS,EAAG,OAAO,EACjB,GAAa,EAAI,CAAO,EADG,OAGtC,QAAmC,QAAmC,QAAmC,QAAmC,QAC5I,QAAmC,QAAmC,QAAmC,QAAmC,IAC7I,MAAO,IAAa,EAAI,CAAO,MAE9B,IACD,MAAO,YAGP,GAAI,GAAU,EAAG,OAAO,EAAG,CACvB,EACI,IAAc,CAAE,QACX,GAAU,EAAG,OAAO,GAC7B,GAAI,GAAK,GAAe,EAAI,GAAY,EAAG,IAAI,CAAC,EAChD,EAAQ,GAAK,EACb,GAAI,GAAO,GAAe,GAAiB,CAAE,GAC7C,MAAI,KAAS,QAAU,GAAQ,GACpB,EAAO,EAEP,EACf,KAAO,CACH,GAAI,GAAI,EAAG,QACX,UAAK,CAAE,EACA,CACX,EAIhB,EAEM,GAAY,SAAS,EAAI,CAC3B,EAAG,SAAW,EAAG,WACjB,AAAI,EAAG,UAAU,QAAU,GACvB,GAAG,EAAE,MAAQ,EAAG,UAAU,MAC1B,EAAG,EAAE,QAAQ,EAAI,EAAG,UAAU,QAAQ,EACtC,EAAG,EAAE,QAAQ,EAAI,EAAG,UAAU,QAAQ,EACtC,EAAG,EAAE,QAAQ,GAAK,EAAG,UAAU,QAAQ,GACvC,EAAG,UAAU,MAAQ,IAErB,EAAG,EAAE,MAAQ,GAAK,EAAI,EAAG,EAAE,OAAO,CAC1C,EAEM,GAAiB,SAAS,EAAI,CAChC,UAAW,EAAG,UAAU,QAAU,EAAM,EACxC,EAAG,UAAU,MAAQ,GAAK,EAAI,EAAG,UAAU,OAAO,EAC3C,EAAG,UAAU,KACxB,EAEA,GAAO,QAAQ,eAAmB,EAClC,GAAO,QAAQ,QAAmB,GAClC,GAAO,QAAQ,SAAmB,GAClC,GAAO,QAAQ,SAAmB,GAClC,GAAO,QAAQ,WAAmB,GAClC,GAAO,QAAQ,eAAmB,GAClC,GAAO,QAAQ,eAAmB,GAClC,GAAO,QAAQ,UAAmB,GAClC,GAAO,QAAQ,cAAmB,GAClC,GAAO,QAAQ,iBAAmB,GAClC,GAAO,QAAQ,eAAmB,GAClC,GAAO,QAAQ,YAAmB,KCtqBlC,kBAEA,GAAM,CACF,eACA,aACA,cACA,cACA,aACA,cACA,aACA,cACA,aACA,aACA,aACA,aACA,eAAgB,CACZ,gBACA,sBACA,eACA,YACA,eACA,eACA,eAEJ,iBACA,KACE,CAAE,eAAe,KACjB,GAAW,KACX,GAAW,KACX,EAAW,KACX,GAAW,KACX,GAAW,KACX,GAAW,KAEX,EAAW,EAAS,SACpB,GAAW,GAAQ,OAGnB,GAAU,IAMV,GAAU,GAEV,EAAS,CACX,QAAc,EACd,QAAc,EACd,QAAc,EACd,QAAc,EACd,QAAc,EACd,QAAc,EACd,SAAc,EACd,SAAc,EACd,QAAc,EACd,SAAc,EACd,QAAc,GACd,QAAc,GACd,WAAc,GACd,OAAc,GACd,OAAc,GACd,OAAc,GACd,OAAc,GACd,OAAc,GACd,OAAc,GACd,QAAc,GACd,OAAc,GACd,aAAc,EAClB,EAEM,GAAQ,CACV,UAAc,EACd,SAAc,EACd,QAAc,EACd,QAAc,EACd,YAAc,CAClB,EAEM,GAAW,SAAS,EAAG,CACzB,MAAO,GAAE,IAAM,EAAE,CACrB,EAMM,GAAY,SAAS,EAAG,EAAa,CACvC,GAAI,GAAK,GAAQ,QACjB,GAAI,GAAS,CAAC,EACV,MAAO,GACX,OAAQ,EAAE,OACD,GAAG,MACJ,MAAI,GACO,GAAI,IAAO,GAAa,EAAE,EAAE,IAAI,EAEpC,OACN,GAAG,MACJ,MAAI,GACO,GAAI,IAAO,GAAa,EAAE,EAAE,IAAI,EAEpC,WACF,MAAO,GAExB,EAQM,GAAW,SAAS,EAAI,EAAM,EAAG,CACnC,GAAI,GACA,EAAI,EAAO,EAAI,EACnB,GAAI,EAAG,GAAK,EAAG,YACX,GAAW,EAAG,EAAE,KAAK,EAAG,GAAG,GACvB,EAAS,SAAW,EAAS,YAAY,CACzC,GAAI,GAAQ,EAAS,EACjB,EAAK,EAAQ,EAAS,EAC1B,GAAK,GAAS,GAAQ,GAAQ,EAAK,GAC1B,GAAQ,GAAS,GAAS,EAAI,EAAI,CACvC,AAAI,EAAQ,GAAM,GAAO,GACrB,EAAK,GAAG,GAAI,GAChB,EAAS,SAAS,EAAU,CAAI,EAChC,EAAS,SAAS,EAAU,EAAI,CAAI,EACpC,MACJ,CACJ,CAEJ,GAAa,EAAI,EAAS,WAAY,EAAM,EAAI,EAAG,CAAC,CACxD,EAEM,GAAiB,SAAS,EAAI,EAAG,CACnC,MAAO,GAAG,EAAE,KAAK,EAAE,EAAE,KACzB,EAMM,GAAU,SAAS,EAAI,EAAI,CAC7B,GAAI,GAAS,EAAG,EAAE,KAAK,GAAI,IAC3B,MAAI,KAAW,GACJ,GAEA,EAAK,EAAI,CACxB,EAMM,GAAU,SAAS,EAAI,EAAI,EAAM,CACnC,GAAI,GAAM,EAAG,EAAE,KAAK,GAChB,EAAS,EAAQ,GAAK,GAC1B,GAAW,IAAS,EAAO,EACvB,KAAK,IAAI,CAAM,EAAI,EAAS,YAC5B,GAAK,iBAAiB,EAAG,GAAI,GAAa,6BAA8B,EAAI,CAAC,EACjF,EAAS,WAAW,EAAK,CAAM,CACnC,EAKM,GAAc,SAAS,EAAI,EAAI,EAAI,CACrC,GAAI,IAAO,GAAS,MAAO,GACtB,GAAI,IAAO,GACZ,EAAK,MACJ,CACD,GAAI,GAAO,EACP,EAAO,GAAQ,EAAI,CAAI,EAC3B,KAAO,IAAS,IACZ,EAAO,EACP,EAAO,GAAQ,EAAI,CAAI,EAE3B,GAAQ,EAAI,EAAM,CAAE,CACxB,CAEA,MAAO,EACX,EAQM,GAAY,SAAU,EAAI,CAC5B,GAAI,GAAM,EAAG,IACb,EAAG,IAAM,GACT,GAAI,GAAI,GAAc,EAAI,EAAS,OAAQ,EAAG,EAAO,EACrD,SAAI,GAAY,EAAI,EAAG,CAAG,EACnB,CACX,EAEM,GAAc,SAAS,EAAI,EAAG,CAChC,MAAO,IAAe,EAAI,GAAU,CAAE,EAAG,CAAC,CAC9C,EAKM,GAAW,SAAS,EAAI,EAAO,EAAM,CACvC,GAAa,EAAI,EAAS,UAAW,EAAO,EAAO,EAAG,CAAC,CAC3D,EAMM,GAAW,SAAS,EAAI,EAAI,EAAG,EAAG,EAAG,CACvC,UAAa,EAAI,EAAI,EAAG,EAAG,CAAC,EACrB,GAAU,CAAE,CACvB,EAMM,GAAgB,SAAS,EAAI,CAC/B,SAAG,WAAa,EAAG,GACZ,EAAG,EACd,EAOM,GAAuB,SAAS,EAAI,EAAI,CAC1C,MAAI,IAAM,GAAK,EAAS,UAAU,EAAG,EAAE,KAAK,EAAK,GAAG,MAAM,EAC/C,EAAK,EAEL,CACf,EACM,GAAiB,SAAS,EAAI,EAAI,CACpC,MAAO,GAAG,EAAE,KAAK,GAAqB,EAAI,CAAE,EAChD,EASM,GAAe,SAAS,EAAI,EAAM,EAAK,CACzC,GAAI,GAAK,GAAqB,EAAI,CAAI,EAClC,EAAI,EAAG,EAAE,KAAK,GAClB,MAAI,GAAE,SAAW,EAAS,WACf,GACX,CAAI,IAAQ,EAAS,QAAU,IAAQ,EAAE,EACrC,EAAS,SAAS,EAAG,CAAG,EAIxB,EAAG,EAAE,KAAK,GAAM,EAAS,WAAW,EAAS,QAAS,EAAE,EAAG,EAAG,EAAE,CAAC,EAE9D,GACX,EAKM,GAAe,SAAS,EAAI,EAAM,CACpC,KAAO,IAAS,GAAS,EAAO,GAAQ,EAAI,CAAI,EAC5C,GAAa,EAAI,EAAM,EAAS,MAAM,CAC9C,EAOM,GAAe,SAAS,EAAI,EAAM,EAAS,EAAK,EAAS,CAC3D,KAAO,IAAS,IAAS,CACrB,GAAI,GAAO,GAAQ,EAAI,CAAI,EAC3B,AAAI,GAAa,EAAI,EAAM,CAAG,EAC1B,GAAQ,EAAI,EAAM,CAAO,EAEzB,GAAQ,EAAI,EAAM,CAAO,EAC7B,EAAO,CACX,CACJ,EAOM,GAAe,SAAS,EAAI,CAC9B,GAAa,EAAI,EAAG,IAAK,EAAG,GAAI,EAAS,OAAQ,EAAG,EAAE,EACtD,EAAG,IAAM,EACb,EAMM,GAAmB,SAAS,EAAI,EAAM,CACxC,GAAc,CAAE,EAChB,EAAG,IAAM,GAAY,EAAI,EAAG,IAAK,CAAI,CACzC,EAOM,GAAiB,SAAS,EAAI,EAAM,EAAQ,CAC9C,AAAI,IAAW,EAAG,GACd,GAAiB,EAAI,CAAI,EAEzB,IAAW,EAAS,EAAG,EAAE,EACzB,GAAa,EAAI,EAAM,EAAQ,EAAS,OAAQ,CAAM,EAE9D,EAOM,GAAkB,SAAS,EAAI,EAAM,EAAO,CAE9C,IADA,IACO,IAAS,GAAS,EAAO,GAAQ,EAAI,CAAI,EAAG,CAC/C,GAAI,GAAM,EAAG,EAAE,KAAK,GACpB,GAAW,EAAI,SAAW,EAAS,QAAW,GAAI,IAAM,GAAK,EAAI,GAAK,EAAM,EAC5E,EAAS,SAAS,EAAK,CAAK,CAChC,CACJ,EAMM,GAAY,SAAS,EAAI,EAAG,CAC9B,GAAI,GAAI,EAAG,EACX,UAAa,CAAE,EAEf,EAAE,KAAK,EAAG,IAAM,EAChB,EAAE,SAAS,EAAG,IAAM,EAAG,GAAG,SACnB,EAAG,IACd,EAMM,GAAe,SAAS,EAAI,EAAG,EAAG,EAAG,EAAG,CAC1C,UAAW,EAAS,UAAU,CAAC,IAAM,EAAS,IAAI,EAClD,GAAW,EAAS,SAAS,CAAC,IAAM,EAAS,QAAU,IAAM,CAAC,EAC9D,GAAW,EAAS,SAAS,CAAC,IAAM,EAAS,QAAU,IAAM,CAAC,EAC9D,GAAW,GAAK,EAAS,UAAY,GAAK,EAAS,UAAY,GAAK,EAAS,QAAQ,EAC9E,GAAU,EAAI,EAAS,WAAW,EAAG,EAAG,EAAG,CAAC,CAAC,CACxD,EAKM,GAAe,SAAS,EAAI,EAAG,EAAG,EAAI,CACxC,UAAW,EAAS,UAAU,CAAC,IAAM,EAAS,MAAQ,EAAS,UAAU,CAAC,IAAM,EAAS,KAAK,EAC9F,GAAW,EAAS,SAAS,CAAC,IAAM,EAAS,MAAM,EACnD,GAAW,GAAK,EAAS,UAAY,GAAM,EAAS,SAAS,EACtD,GAAU,EAAI,EAAS,WAAW,EAAG,EAAG,CAAE,CAAC,CACtD,EAEM,GAAgB,SAAS,EAAG,EAAE,EAAE,EAAK,CACvC,MAAO,IAAa,EAAI,EAAG,EAAI,EAAO,EAAS,UAAU,CAC7D,EAKM,GAAe,SAAS,EAAI,EAAG,CACjC,UAAW,GAAK,EAAS,SAAS,EAC3B,GAAU,EAAI,EAAS,UAAU,EAAS,YAAa,CAAC,CAAC,CACpE,EAOM,GAAa,SAAS,EAAI,EAAK,EAAG,CACpC,GAAI,GAAK,EAAS,UACd,MAAO,IAAa,EAAI,EAAS,SAAU,EAAK,CAAC,EAChD,CACD,GAAI,GAAI,GAAa,EAAI,EAAS,UAAW,EAAK,CAAC,EACnD,UAAa,EAAI,CAAC,EACX,CACX,CACJ,EAMM,GAAkB,SAAS,EAAI,EAAG,CACpC,GAAI,GAAW,EAAG,QAAU,EAC5B,AAAI,EAAW,EAAG,EAAE,cACZ,IAAY,IACZ,GAAK,iBAAiB,EAAG,GAAI,GAAa,kDAAmD,EAAI,CAAC,EACtG,EAAG,EAAE,aAAe,EAE5B,EAKM,GAAmB,SAAS,EAAI,EAAG,CACrC,GAAgB,EAAI,CAAC,EACrB,EAAG,SAAW,CAClB,EAMM,GAAU,SAAS,EAAI,EAAK,CAC9B,AAAI,CAAC,EAAS,IAAI,CAAG,GAAK,GAAO,EAAG,SAChC,GAAG,UACH,GAAW,IAAQ,EAAG,OAAO,EAErC,EAKM,GAAU,SAAS,EAAI,EAAG,CAC5B,AAAI,EAAE,IAAM,GAAQ,QAAQ,WACxB,GAAQ,EAAI,EAAE,EAAE,IAAI,CAC5B,EAMM,GAAW,SAAS,EAAI,EAAI,EAAI,CAClC,GAAI,GAAM,EAAG,IAAM,GAAQ,QAAQ,UAAa,EAAG,EAAE,KAAO,GACxD,EAAM,EAAG,IAAM,GAAQ,QAAQ,UAAa,EAAG,EAAE,KAAO,GAC5D,AAAI,EAAK,EACL,IAAQ,EAAI,CAAE,EACd,GAAQ,EAAI,CAAE,GAGd,IAAQ,EAAI,CAAE,EACd,GAAQ,EAAI,CAAE,EAEtB,EAUM,GAAO,SAAS,EAAI,EAAK,EAAG,CAC9B,GAAI,GAAI,EAAG,EACP,EAAM,GAAO,SAAS,EAAG,EAAG,EAAG,GAAG,EAAG,CAAG,EAC5C,GAAI,EAAI,YAAY,EAAG,CACnB,GAAI,GAAI,EAAI,MAEZ,GAAI,EAAI,EAAG,IAAM,EAAE,EAAE,GAAG,MAAM,IAAM,EAAE,MAAM,GAAK,EAAE,EAAE,GAAG,QAAU,EAAE,MAChE,MAAO,EACf,CAEA,GAAI,GAAI,EAAG,GACX,UAAO,aAAa,EAAG,EAAG,EAAG,GAAG,EAAG,EAAK,GAAI,IAAQ,OAAO,GAAa,CAAC,CAAC,EAC1E,EAAE,EAAE,GAAK,EACT,EAAG,KACI,CACX,EAKM,GAAe,SAAS,EAAI,EAAG,CACjC,GAAI,GAAI,GAAI,IAAO,GAAa,CAAC,EACjC,MAAO,IAAK,EAAI,EAAG,CAAC,CACxB,EAQM,GAAY,SAAS,EAAI,EAAG,CAC9B,GAAI,GAAI,GAAI,IAAO,GAAoB,CAAC,EACpC,EAAI,GAAI,IAAO,GAAa,CAAC,EACjC,MAAO,IAAK,EAAI,EAAG,CAAC,CACxB,EAKM,GAAe,SAAS,EAAI,EAAG,CACjC,GAAI,GAAI,GAAI,IAAO,GAAa,CAAC,EACjC,MAAO,IAAK,EAAI,EAAG,CAAC,CACxB,EAMM,GAAQ,SAAS,EAAI,EAAG,CAC1B,GAAI,GAAI,GAAI,IAAO,GAAc,CAAC,EAClC,MAAO,IAAK,EAAI,EAAG,CAAC,CACxB,EAMM,GAAO,SAAS,EAAI,CACtB,GAAI,GAAI,GAAI,IAAO,GAAU,IAAI,EAC7B,EAAI,GAAI,IAAO,GAAY,EAAG,GAAG,CAAC,EAEtC,MAAO,IAAK,EAAI,EAAG,CAAC,CACxB,EAOM,GAAkB,SAAS,EAAI,EAAG,EAAU,CAC9C,GAAI,GAAK,GAAQ,QACjB,GAAI,EAAE,IAAM,EAAG,MACX,EAAS,SAAS,GAAe,EAAI,CAAC,EAAG,EAAW,CAAC,UAEhD,EAAE,IAAM,EAAG,QAAS,CACzB,GAAI,GAAK,GAAe,EAAI,CAAC,EAC7B,EAAS,SAAS,EAAI,EAAW,CAAC,EAClC,EAAS,SAAS,EAAI,EAAG,OAAO,EAChC,GAAiB,EAAI,CAAC,CAC1B,KACK,IAAW,IAAa,EAAW,CAC5C,EAEM,GAAkB,SAAS,EAAI,EAAG,CACpC,GAAgB,EAAI,EAAG,EAAW,CACtC,EAYM,GAAiB,SAAS,EAAI,EAAG,CACnC,GAAI,GAAK,GAAQ,QACjB,AAAI,EAAE,IAAM,EAAG,MAEX,IAAW,GAAe,EAAI,CAAC,EAAE,IAAM,CAAC,EACxC,EAAE,EAAI,EAAG,UACT,EAAE,EAAE,KAAO,GAAe,EAAI,CAAC,EAAE,GAC1B,EAAE,IAAM,EAAG,SAClB,GAAS,SAAS,GAAe,EAAI,CAAC,EAAG,CAAC,EAC1C,EAAE,EAAI,EAAG,WAEjB,EAKM,GAAqB,SAAS,EAAI,EAAG,CACvC,GAAI,GAAK,GAAQ,QAEjB,OAAQ,EAAE,OACD,GAAG,OAAQ,CACZ,EAAE,EAAK,EAAG,UACV,KACJ,KACK,GAAG,OAAQ,CACZ,EAAE,EAAE,KAAO,GAAa,EAAI,EAAS,YAAa,EAAG,EAAE,EAAE,KAAM,CAAC,EAChE,EAAE,EAAI,EAAG,WACT,KACJ,KACK,GAAG,SAAU,CACd,GAAI,GACJ,GAAQ,EAAI,EAAE,EAAE,IAAI,GAAG,EACvB,AAAI,EAAE,EAAE,IAAI,KAAO,EAAG,OAClB,IAAQ,EAAI,EAAE,EAAE,IAAI,CAAC,EACrB,EAAK,EAAS,aAEd,IAAW,EAAE,EAAE,IAAI,KAAO,EAAG,MAAM,EACnC,EAAK,EAAS,aAElB,EAAE,EAAE,KAAO,GAAa,EAAI,EAAI,EAAG,EAAE,EAAE,IAAI,EAAG,EAAE,EAAE,IAAI,GAAG,EACzD,EAAE,EAAI,EAAG,WACT,KACJ,KACK,GAAG,YAAc,GAAG,MAAO,CAC5B,GAAe,EAAI,CAAC,EACpB,KACJ,SACS,MAEjB,EAEM,GAAgB,SAAS,EAAI,EAAG,EAAG,EAAM,CAC3C,UAAc,CAAE,EACT,GAAa,EAAI,EAAS,YAAa,EAAG,EAAG,CAAI,CAC5D,EAMM,GAAgB,SAAS,EAAI,EAAG,EAAK,CACvC,GAAI,GAAK,GAAQ,QAEjB,OADA,GAAmB,EAAI,CAAC,EAChB,EAAE,OACD,GAAG,KAAM,CACV,GAAS,EAAI,EAAK,CAAC,EACnB,KACJ,KACK,GAAG,WAAa,GAAG,MAAO,CAC3B,GAAa,EAAI,EAAS,YAAa,EAAK,EAAE,IAAM,EAAG,MAAO,CAAC,EAC/D,KACJ,KACK,GAAG,GAAI,CACR,GAAW,EAAI,EAAK,EAAE,EAAE,IAAI,EAC5B,KACJ,KACK,GAAG,MAAO,CACX,GAAW,EAAI,EAAK,GAAa,EAAI,EAAE,EAAE,IAAI,CAAC,EAC9C,KACJ,KACK,GAAG,MAAO,CACX,GAAW,EAAI,EAAK,GAAU,EAAI,EAAE,EAAE,IAAI,CAAC,EAC3C,KACJ,KACK,GAAG,WAAY,CAChB,GAAI,GAAK,GAAe,EAAI,CAAC,EAC7B,EAAS,SAAS,EAAI,CAAG,EACzB,KACJ,KACK,GAAG,UAAW,CACf,AAAI,IAAQ,EAAE,EAAE,MACZ,GAAa,EAAI,EAAS,QAAS,EAAK,EAAE,EAAE,KAAM,CAAC,EACvD,KACJ,SACS,CACL,GAAW,EAAE,IAAM,EAAG,IAAI,EAC1B,MACJ,EAEJ,EAAE,EAAE,KAAO,EACX,EAAE,EAAI,EAAG,SACb,EAKM,GAAmB,SAAS,EAAI,EAAG,CACrC,AAAI,EAAE,IAAM,GAAQ,QAAQ,WACxB,IAAiB,EAAI,CAAC,EACtB,GAAc,EAAI,EAAG,EAAG,QAAQ,CAAC,EAEzC,EAMM,GAAa,SAAS,EAAI,EAAM,CAClC,KAAO,IAAS,GAAS,EAAO,GAAQ,EAAI,CAAI,EAE5C,GAAI,AADI,GAAe,EAAI,CAAI,EACzB,SAAW,EAAS,WAAY,MAAO,GAEjD,MAAO,EACX,EASM,GAAU,SAAS,EAAI,EAAG,EAAK,CACjC,GAAI,GAAK,GAAQ,QAIjB,GAHA,GAAc,EAAI,EAAG,CAAG,EACpB,EAAE,IAAM,EAAG,MACX,GAAE,EAAI,GAAY,EAAI,EAAE,EAAG,EAAE,EAAE,IAAI,GACnC,GAAS,CAAC,EAAG,CACb,GAAI,GACA,EAAM,GACN,EAAM,GACV,GAAI,GAAW,EAAI,EAAE,CAAC,GAAK,GAAW,EAAI,EAAE,CAAC,EAAG,CAC5C,GAAI,GAAM,EAAE,IAAM,EAAG,KAAQ,GAAU,GAAU,CAAE,EACnD,EAAM,GAAc,EAAI,EAAK,EAAG,CAAC,EACjC,EAAM,GAAc,EAAI,EAAK,EAAG,CAAC,EACjC,GAAiB,EAAI,CAAE,CAC3B,CACA,EAAQ,GAAc,CAAE,EACxB,GAAa,EAAI,EAAE,EAAG,EAAO,EAAK,CAAG,EACrC,GAAa,EAAI,EAAE,EAAG,EAAO,EAAK,CAAG,CACzC,CACA,EAAE,EAAI,EAAE,EAAI,GACZ,EAAE,EAAE,KAAO,EACX,EAAE,EAAI,EAAG,SACb,EAMM,GAAmB,SAAS,EAAI,EAAG,CACrC,GAAmB,EAAI,CAAC,EACxB,GAAQ,EAAI,CAAC,EACb,GAAiB,EAAI,CAAC,EACtB,GAAQ,EAAI,EAAG,EAAG,QAAU,CAAC,CACjC,EAOM,GAAkB,SAAS,EAAI,EAAG,CAEpC,GADA,GAAmB,EAAI,CAAC,EACpB,EAAE,IAAM,GAAQ,QAAQ,UAAW,CACnC,GAAI,CAAC,GAAS,CAAC,EACX,MAAO,GAAE,EAAE,KACf,GAAI,EAAE,EAAE,MAAQ,EAAG,QACf,UAAQ,EAAI,EAAG,EAAE,EAAE,IAAI,EAChB,EAAE,EAAE,IAEnB,CACA,UAAiB,EAAI,CAAC,EACf,EAAE,EAAE,IACf,EAMM,GAAoB,SAAS,EAAI,EAAG,CACtC,AAAI,GAAE,IAAM,GAAQ,QAAQ,QAAU,GAAS,CAAC,IAC5C,GAAgB,EAAI,CAAC,CAC7B,EAMM,GAAe,SAAS,EAAI,EAAG,CACjC,AAAI,GAAS,CAAC,EACV,GAAgB,EAAI,CAAC,EAErB,GAAmB,EAAI,CAAC,CAChC,EAQM,GAAc,SAAS,EAAI,EAAG,CAChC,GAAI,GAAK,GAAQ,QACb,EAAK,GAET,OADA,GAAa,EAAI,CAAC,EACV,EAAE,OACD,GAAG,MAAO,EAAE,EAAE,KAAO,GAAM,EAAI,EAAI,EAAG,EAAK,GAAM,UACjD,GAAG,OAAQ,EAAE,EAAE,KAAO,GAAM,EAAI,EAAK,EAAG,EAAK,GAAM,UACnD,GAAG,KAAM,EAAE,EAAE,KAAO,GAAK,CAAE,EAAG,EAAK,GAAM,UACzC,GAAG,MAAO,EAAE,EAAE,KAAO,GAAU,EAAI,EAAE,EAAE,IAAI,EAAG,EAAK,GAAM,UACzD,GAAG,MAAO,EAAE,EAAE,KAAO,GAAa,EAAI,EAAE,EAAE,IAAI,EAAG,EAAK,GAAM,UAC5D,GAAG,GAAI,EAAK,GAAM,cACd,MAGb,MAAI,IACA,GAAE,EAAI,EAAG,GACL,EAAE,EAAE,MAAQ,EAAS,YACd,EAAS,MAAM,EAAE,EAAE,IAAI,EAI/B,GAAgB,EAAI,CAAC,CAChC,EAKM,GAAgB,SAAS,EAAI,EAAI,EAAI,CACvC,GAAI,GAAK,GAAQ,QACjB,OAAQ,EAAG,OACF,GAAG,OAAQ,CACZ,GAAQ,EAAI,CAAE,EACd,GAAQ,EAAI,EAAI,EAAG,EAAE,IAAI,EACzB,MACJ,KACK,GAAG,OAAQ,CACZ,GAAI,GAAI,GAAgB,EAAI,CAAE,EAC9B,GAAa,EAAI,EAAS,YAAa,EAAG,EAAG,EAAE,KAAM,CAAC,EACtD,KACJ,KACK,GAAG,SAAU,CACd,GAAI,GAAM,EAAG,EAAE,IAAI,KAAO,EAAG,OAAU,EAAS,YAAc,EAAS,YACnE,EAAI,GAAY,EAAI,CAAE,EAC1B,GAAa,EAAI,EAAI,EAAG,EAAE,IAAI,EAAG,EAAG,EAAE,IAAI,IAAK,CAAC,EAChD,KACJ,EAEJ,GAAQ,EAAI,CAAE,CAClB,EAMM,GAAY,SAAS,EAAI,EAAG,EAAK,CACnC,GAAgB,EAAI,CAAC,EACrB,GAAI,GAAO,EAAE,EAAE,KACf,GAAQ,EAAI,CAAC,EACb,EAAE,EAAE,KAAO,EAAG,QACd,EAAE,EAAI,GAAQ,QAAQ,UACtB,GAAiB,EAAI,CAAC,EACtB,GAAa,EAAI,EAAS,QAAS,EAAE,EAAE,KAAM,EAAM,GAAY,EAAI,CAAG,CAAC,EACvE,GAAQ,EAAI,CAAG,CACnB,EAKM,GAAkB,SAAS,EAAI,EAAG,CACpC,GAAI,GAAK,GAAe,EAAI,EAAE,EAAE,IAAI,EACpC,GAAW,EAAS,UAAU,EAAG,MAAM,GAAK,EAAG,SAAW,EAAS,YAAc,EAAG,SAAW,EAAS,OAAO,EAC/G,EAAS,SAAS,EAAI,CAAE,EAAG,CAAE,CACjC,EAQM,GAAa,SAAS,EAAI,EAAG,EAAM,CACrC,GAAI,EAAE,IAAM,GAAQ,QAAQ,WAAY,CACpC,GAAI,GAAK,GAAe,EAAI,CAAC,EAC7B,GAAI,EAAG,SAAW,EAAS,OACvB,SAAG,KACI,GAAS,EAAI,EAAS,QAAS,EAAG,EAAG,EAAG,CAAC,CAAI,CAG5D,CACA,UAAiB,EAAI,CAAC,EACtB,GAAQ,EAAI,CAAC,EACN,GAAS,EAAI,EAAS,WAAY,EAAS,OAAQ,EAAE,EAAE,KAAM,CAAI,CAC5E,EAKM,GAAgB,SAAS,EAAI,EAAG,CAClC,GAAI,GAAK,GAAQ,QACb,EAEJ,OADA,GAAmB,EAAI,CAAC,EAChB,EAAE,OACD,GAAG,KAAM,CACV,GAAgB,EAAI,CAAC,EACrB,EAAK,EAAE,EAAE,KACT,KACJ,KACK,GAAG,OAAS,GAAG,UAAY,GAAG,UAAY,GAAG,MAAO,CACrD,EAAK,GACL,KACJ,SACS,CACL,EAAK,GAAW,EAAI,EAAG,CAAC,EACxB,KACJ,EAEJ,EAAE,EAAI,GAAY,EAAI,EAAE,EAAG,CAAE,EAC7B,GAAiB,EAAI,EAAE,CAAC,EACxB,EAAE,EAAI,EACV,EAKM,GAAiB,SAAS,EAAI,EAAG,CACnC,GAAI,GAAK,GAAQ,QACb,EAEJ,OADA,GAAmB,EAAI,CAAC,EAChB,EAAE,OACD,GAAG,KAAM,CACV,EAAK,EAAE,EAAE,KACT,KACJ,KACK,GAAG,SAAW,GAAG,OAAQ,CAC1B,EAAK,GACL,KACJ,SACS,CACL,EAAK,GAAW,EAAI,EAAG,CAAC,EACxB,KACJ,EAEJ,EAAE,EAAI,GAAY,EAAI,EAAE,EAAG,CAAE,EAC7B,GAAiB,EAAI,EAAE,CAAC,EACxB,EAAE,EAAI,EACV,EAKM,GAAU,SAAS,EAAI,EAAG,CAC5B,GAAI,GAAK,GAAQ,QAEjB,OADA,GAAmB,EAAI,CAAC,EAChB,EAAE,OACD,GAAG,SAAW,GAAG,OAAQ,CAC1B,EAAE,EAAI,EAAG,MACT,KACJ,KACK,GAAG,OAAS,GAAG,UAAY,GAAG,UAAY,GAAG,MAAO,CACrD,EAAE,EAAI,EAAG,OACT,KACJ,KACK,GAAG,KAAM,CACV,GAAgB,EAAI,CAAC,EACrB,KACJ,KACK,GAAG,eACH,GAAG,UAAW,CACf,GAAiB,EAAI,CAAC,EACtB,GAAQ,EAAI,CAAC,EACb,EAAE,EAAE,KAAO,GAAa,EAAI,EAAS,OAAQ,EAAG,EAAE,EAAE,KAAM,CAAC,EAC3D,EAAE,EAAI,EAAG,WACT,KACJ,EAGJ,CAAE,GAAI,GAAO,EAAE,EAAG,EAAE,EAAI,EAAE,EAAG,EAAE,EAAI,CAAM,CACzC,GAAa,EAAI,EAAE,CAAC,EACpB,GAAa,EAAI,EAAE,CAAC,CACxB,EAMM,GAAe,SAAS,EAAI,EAAG,EAAG,CACpC,GAAI,GAAK,GAAQ,QACjB,GAAW,CAAC,GAAS,CAAC,GAAM,IAAQ,UAAU,EAAE,CAAC,GAAK,EAAE,IAAM,EAAG,OAAO,EACxE,EAAE,EAAE,IAAI,EAAI,EAAE,EAAE,KAChB,EAAE,EAAE,IAAI,IAAM,GAAY,EAAI,CAAC,EAC/B,EAAE,EAAE,IAAI,GAAM,EAAE,IAAM,EAAG,OAAU,EAAG,OAAS,EAAG,OAClD,EAAE,EAAI,EAAG,QACb,EAOM,GAAU,SAAS,EAAI,EAAI,EAAI,CACjC,OAAQ,OACC,QAAiB,QAAgB,QACjC,QAAgB,QAAgB,IACjC,MAAQ,IAAI,UAAU,CAAE,IAAM,IAAS,GAAI,UAAU,CAAE,IAAM,OAE5D,QAAgB,QAAiB,IAClC,MAAQ,GAAG,QAAU,UAChB,MAAO,GAExB,EAMM,GAAe,SAAS,EAAI,EAAI,EAAI,CACtC,GAAI,GAAK,GAAQ,QACb,EAAI,EACR,GAAI,CAAE,GAAK,GAAU,EAAI,EAAI,IAAM,CAAE,GAAK,GAAU,EAAI,EAAI,IAAM,CAAC,GAAQ,EAAI,EAAI,CAAE,EACjF,MAAO,GACX,GAAI,GAAM,GAAI,IAEd,GADA,GAAQ,WAAW,KAAM,EAAI,EAAI,EAAI,CAAG,EACpC,EAAI,YAAY,EAChB,EAAG,EAAI,EAAG,MACV,EAAG,EAAE,KAAO,EAAI,UAEf,CACD,GAAI,GAAI,EAAI,MACZ,GAAI,MAAM,CAAC,GAAK,IAAM,EAClB,MAAO,GACX,EAAG,EAAI,EAAG,MACV,EAAG,EAAE,KAAO,CAChB,CACA,MAAO,EACX,EAOM,GAAe,SAAS,EAAI,EAAI,EAAG,EAAM,CAC3C,GAAI,GAAI,GAAgB,EAAI,CAAC,EAC7B,GAAQ,EAAI,CAAC,EACb,EAAE,EAAE,KAAO,GAAa,EAAI,EAAI,EAAG,EAAG,CAAC,EACvC,EAAE,EAAI,GAAQ,QAAQ,WACtB,GAAa,EAAI,CAAI,CACzB,EAWM,GAAgB,SAAS,EAAI,EAAI,EAAI,EAAI,EAAM,CACjD,GAAI,GAAM,GAAY,EAAI,CAAE,EACxB,EAAM,GAAY,EAAI,CAAE,EAC5B,GAAS,EAAI,EAAI,CAAE,EACnB,EAAG,EAAE,KAAO,GAAa,EAAI,EAAI,EAAG,EAAK,CAAG,EAC5C,EAAG,EAAI,GAAQ,QAAQ,WACvB,GAAa,EAAI,CAAI,CACzB,EAOM,GAAW,SAAS,EAAI,EAAK,EAAI,EAAI,CACvC,GAAI,GAAK,GAAQ,QAEb,EACJ,AAAI,EAAG,IAAM,EAAG,GACZ,EAAM,EAAS,MAAM,EAAG,EAAE,IAAI,EAE9B,IAAW,EAAG,IAAM,EAAG,SAAS,EAChC,EAAM,EAAG,EAAE,MAGf,GAAI,GAAM,GAAY,EAAI,CAAE,EAE5B,OADA,GAAS,EAAI,EAAI,CAAE,EACX,OACC,GAAO,OAAQ,CAChB,EAAG,EAAE,KAAO,GAAS,EAAI,EAAS,MAAO,EAAG,EAAK,CAAG,EACpD,KACJ,KACK,GAAO,WAAa,GAAO,OAAQ,CAEpC,GAAI,GAAM,EAAM,EAAO,OAAU,EAAS,MAC1C,EAAG,EAAE,KAAO,GAAS,EAAI,EAAI,EAAG,EAAK,CAAG,EACxC,KACJ,SACS,CACL,GAAI,GAAM,EAAM,EAAO,OAAU,EAAS,MAC1C,EAAG,EAAE,KAAO,GAAS,EAAI,EAAI,EAAG,EAAK,CAAG,EACxC,KACJ,EAEJ,EAAG,EAAI,EAAG,IACd,EAKM,GAAc,SAAS,EAAI,EAAI,EAAG,EAAM,CAC1C,GAAI,GAAK,GAAI,IAAQ,QAKrB,OAJA,EAAG,EAAI,GAAQ,QAAQ,MACvB,EAAG,EAAE,KAAO,EAAG,EAAE,KAAO,EAAG,EAAE,KAAO,EACpC,EAAG,EAAI,GACP,EAAG,EAAI,GACC,OACC,IAAM,cAAgB,IAAM,SAC7B,GAAI,GAAa,EAAK,GAAW,EAAG,CAAE,EAClC,UAEH,IAAM,QACP,GAAa,EAAI,EAAK,EAAS,OAAQ,EAAG,CAAI,EAC9C,UACC,IAAM,QAAS,GAAQ,EAAI,CAAC,EAAG,MAE5C,EAMM,GAAa,SAAS,EAAI,EAAI,EAAG,CACnC,OAAQ,OACC,GAAO,QAAS,CACjB,GAAc,EAAI,CAAC,EACnB,KACJ,KACK,GAAO,OAAQ,CAChB,GAAe,EAAI,CAAC,EACpB,KACJ,KACK,GAAO,WAAY,CACpB,GAAiB,EAAI,CAAC,EACtB,KACJ,KACK,GAAO,YAAc,GAAO,YAC5B,GAAO,YAAc,GAAO,YAAc,GAAO,aACjD,GAAO,YAAc,GAAO,YAC5B,GAAO,aAAe,GAAO,YAAc,GAAO,aAClD,GAAO,YAAc,GAAO,QAAS,CACtC,AAAK,GAAU,EAAG,EAAK,GACnB,GAAY,EAAI,CAAC,EAErB,KACJ,SACS,CACL,GAAY,EAAI,CAAC,EACjB,KACJ,EAER,EAQM,GAAc,SAAS,EAAI,EAAI,EAAI,EAAI,EAAM,CAC/C,GAAI,GAAK,GAAQ,QACjB,OAAQ,OACC,GAAO,QAAS,CACjB,GAAW,EAAG,IAAM,EAAO,EAC3B,GAAmB,EAAI,CAAE,EACzB,EAAG,EAAI,GAAY,EAAI,EAAG,EAAG,EAAG,CAAC,EACjC,EAAG,GAAG,CAAE,EACR,KACJ,KACK,GAAO,OAAQ,CAChB,GAAW,EAAG,IAAM,EAAO,EAC3B,GAAmB,EAAI,CAAE,EACzB,EAAG,EAAI,GAAY,EAAI,EAAG,EAAG,EAAG,CAAC,EACjC,EAAG,GAAG,CAAE,EACR,KACJ,KACK,GAAO,WAAY,CACpB,GAAa,EAAI,CAAE,EACnB,GAAI,GAAM,GAAe,EAAI,CAAE,EAC/B,AAAI,EAAG,IAAM,EAAG,YAAc,EAAI,SAAW,EAAS,UAClD,IAAW,EAAG,EAAE,OAAS,EAAI,EAAI,CAAC,EAClC,GAAQ,EAAI,CAAE,EACd,EAAS,SAAS,EAAK,EAAG,EAAE,IAAI,EAChC,EAAG,EAAI,EAAG,WAAY,EAAG,EAAE,KAAO,EAAG,EAAE,MAGvC,IAAiB,EAAI,CAAE,EACvB,GAAc,EAAI,EAAS,UAAW,EAAI,EAAI,CAAI,GAEtD,KACJ,KACK,GAAO,YAAc,GAAO,YAAc,GAAO,YAAc,GAAO,YACtE,GAAO,aAAe,GAAO,YAAc,GAAO,YAClD,GAAO,aAAe,GAAO,YAAc,GAAO,aAClD,GAAO,YAAc,GAAO,QAAS,CACtC,AAAK,GAAa,EAAK,GAAW,EAAI,CAAE,GACpC,GAAc,EAAI,EAAK,EAAS,OAAQ,EAAI,EAAI,CAAI,EACxD,KACJ,KACK,GAAO,WAAa,GAAO,WAAa,GAAO,WAC/C,GAAO,WAAa,GAAO,WAAa,GAAO,OAAQ,CACxD,GAAS,EAAI,EAAI,EAAI,CAAE,EACvB,KACJ,EAGJ,MAAO,EACX,EAKM,GAAe,SAAS,EAAI,EAAM,CACpC,EAAG,EAAE,SAAS,EAAG,GAAK,GAAK,CAC/B,EASM,GAAe,SAAS,EAAI,EAAM,EAAQ,EAAS,CACrD,GAAI,GAAM,GAAS,GAAG,EAAS,kBAAoB,EAC/C,EAAK,IAAY,GAAe,EAAI,EACxC,GAAW,IAAY,GAAK,GAAW,EAAS,iBAAiB,EACjE,AAAI,GAAK,EAAS,SACd,GAAa,EAAI,EAAS,WAAY,EAAM,EAAG,CAAC,EAC/C,AAAI,GAAK,EAAS,UACnB,IAAa,EAAI,EAAS,WAAY,EAAM,EAAG,CAAC,EAChD,GAAa,EAAI,CAAC,GAGlB,GAAK,iBAAiB,EAAG,GAAI,GAAa,uBAAwB,EAAI,CAAC,EAC3E,EAAG,QAAU,EAAO,CACxB,EAGA,EAAO,QAAQ,OAAqB,EACpC,EAAO,QAAQ,QAAqB,GACpC,EAAO,QAAQ,MAAqB,GACpC,EAAO,QAAQ,eAAqB,GACpC,EAAO,QAAQ,gBAAqB,GACpC,EAAO,QAAQ,UAAqB,GACpC,EAAO,QAAQ,aAAqB,GACpC,EAAO,QAAQ,aAAqB,GACpC,EAAO,QAAQ,cAAqB,GACpC,EAAO,QAAQ,WAAqB,GACpC,EAAO,QAAQ,YAAqB,GACpC,EAAO,QAAQ,mBAAqB,GACpC,EAAO,QAAQ,YAAqB,GACpC,EAAO,QAAQ,gBAAqB,GACpC,EAAO,QAAQ,kBAAqB,GACpC,EAAO,QAAQ,iBAAqB,GACpC,EAAO,QAAQ,aAAqB,GACpC,EAAO,QAAQ,aAAqB,GACpC,EAAO,QAAQ,cAAqB,GACpC,EAAO,QAAQ,eAAqB,GACpC,EAAO,QAAQ,cAAqB,GACpC,EAAO,QAAQ,aAAqB,GACpC,EAAO,QAAQ,WAAqB,GACpC,EAAO,QAAQ,UAAqB,GACpC,EAAO,QAAQ,UAAqB,GACpC,EAAO,QAAQ,YAAqB,GACpC,EAAO,QAAQ,SAAqB,GACpC,EAAO,QAAQ,aAAqB,GACpC,EAAO,QAAQ,gBAAqB,GACpC,EAAO,QAAQ,eAAqB,GACpC,EAAO,QAAQ,iBAAqB,GACpC,EAAO,QAAQ,YAAqB,GACpC,EAAO,QAAQ,YAAqB,GACpC,EAAO,QAAQ,iBAAqB,GACpC,EAAO,QAAQ,SAAqB,GACpC,EAAO,QAAQ,UAAqB,GACpC,EAAO,QAAQ,aAAqB,GACpC,EAAO,QAAQ,gBAAqB,GACpC,EAAO,QAAQ,eAAqB,GACpC,EAAO,QAAQ,gBAAqB,GACpC,EAAO,QAAQ,cAAqB,GACpC,EAAO,QAAQ,aAAqB,KC1uCpC,mBAEA,GAAM,CACF,eACA,iBACA,KACE,CACF,OAAQ,CACJ,WACA,WACA,YACA,WACA,YACA,cACA,WACA,UACA,UACA,UACA,YACA,UACA,UACA,WACA,WACA,UACA,gBACA,UACA,WACA,WACA,WACA,YAEJ,MAAO,CACH,YACA,WACA,aACA,WACA,gBAEJ,WACA,kBACA,mBACA,gBACA,gBACA,iBACA,cACA,eACA,sBACA,eACA,mBACA,qBACA,oBACA,gBACA,gBACA,iBACA,kBACA,iBACA,gBACA,cACA,aACA,aACA,eACA,YACA,mBACA,kBACA,oBACA,eACA,eACA,oBACA,YACA,aACA,gBACA,mBACA,kBACA,mBACA,iBACA,iBACA,KACE,GAAW,KACX,GAAW,KACX,EAAW,KACX,CACF,kBACA,WACA,eACC,KACC,GAAW,KACX,CACF,SAAU,CACN,WACA,cACA,cACA,cACA,eACA,WACA,eACA,eACA,eACA,eACA,eACA,cAEJ,qBACA,YACA,YACA,eACA,KACE,CACF,iBACA,YACA,oBACA,KACE,GAAW,KACX,GAAW,GAAM,MACjB,EAAW,EAAK,SAEhB,GAAU,IAEV,GAAa,SAAS,EAAG,CAC3B,MAAO,KAAM,EAAQ,OAAS,IAAM,EAAQ,OAChD,EAEM,GAAQ,SAAS,EAAG,EAAG,CAEzB,MAAO,IAAc,EAAG,CAAC,CAC7B,EAEM,GAAN,KAAe,CACX,aAAc,CACV,KAAK,SAAW,KAChB,KAAK,WAAa,IAClB,KAAK,UAAY,IACjB,KAAK,QAAU,IACf,KAAK,MAAQ,IACb,KAAK,OAAS,GAClB,CACJ,EAEM,EAAU,CACZ,MAAO,EAEP,KAAM,EACN,MAAO,EACP,OAAQ,EACR,GAAI,EACJ,MAAO,EACP,MAAO,EACP,UAAW,EAEX,OAAQ,EACR,OAAQ,EACR,SAAU,GAIV,KAAM,GAEN,WAAY,GAEZ,MAAO,GACP,QAAS,EACb,EAEM,GAAU,SAAS,EAAG,CACxB,MAAO,GAAQ,QAAU,GAAK,GAAK,EAAQ,QAC/C,EAEM,GAAY,SAAS,EAAG,CAC1B,MAAO,KAAM,EAAQ,WAAa,IAAM,EAAQ,MACpD,EAEM,GAAN,KAAc,CACV,aAAc,CACV,KAAK,EAAI,IACT,KAAK,EAAI,CACL,KAAM,IACN,KAAM,IACN,KAAM,IACN,IAAK,CACD,IAAK,IACL,EAAG,IACH,GAAI,GACR,CACJ,EACA,KAAK,EAAI,IACT,KAAK,EAAI,GACb,CAEA,GAAG,EAAG,CACF,KAAK,EAAI,EAAE,EACX,KAAK,EAAI,EAAE,EACX,KAAK,EAAI,EAAE,EACX,KAAK,EAAI,EAAE,CACf,CACJ,EAEM,GAAN,KAAgB,CACZ,aAAc,CACV,KAAK,EAAI,KACT,KAAK,KAAO,KACZ,KAAK,GAAK,KACV,KAAK,GAAK,KACV,KAAK,GAAK,IACV,KAAK,WAAa,IAClB,KAAK,IAAM,IACX,KAAK,GAAK,IACV,KAAK,GAAK,IACV,KAAK,WAAa,IAClB,KAAK,SAAW,IAChB,KAAK,QAAU,IACf,KAAK,KAAO,IACZ,KAAK,QAAU,GACnB,CACJ,EAGM,GAAN,KAAc,CACV,aAAc,CACV,KAAK,IAAM,GACf,CACJ,EAIM,GAAN,KAAgB,CACZ,aAAc,CACV,KAAK,KAAO,KACZ,KAAK,GAAK,IACV,KAAK,KAAO,IACZ,KAAK,QAAU,GACnB,CACJ,EAIM,GAAN,KAAgB,CACZ,aAAc,CACV,KAAK,IAAM,CAAC,EACZ,KAAK,EAAI,IACT,KAAK,KAAO,GAChB,CACJ,EAGM,GAAN,KAAc,CACV,aAAc,CACV,KAAK,OAAS,CACV,IAAK,CAAC,EACN,EAAG,IACH,KAAM,GACV,EACA,KAAK,GAAK,GAAI,IACd,KAAK,MAAQ,GAAI,GACrB,CACJ,EAEM,GAAW,SAAS,EAAI,EAAK,CAC/B,EAAG,EAAE,MAAQ,EACb,EAAK,iBAAiB,EAAI,CAAG,CACjC,EAEM,GAAiB,SAAS,EAAI,EAAO,CACvC,EAAK,iBAAiB,EAAI,GAAQ,iBAAiB,EAAG,EAAG,GAAa,cAAe,EAAI,EAAG,EAAK,eAAe,EAAI,CAAK,CAAC,CAAC,CAC/H,EAEM,GAAa,SAAS,EAAI,EAAO,EAAM,CACzC,GAAI,GAAI,EAAG,GAAG,EACV,EAAO,EAAG,EAAE,YACZ,EAAS,IAAS,EAChB,GAAa,gBAAiB,EAAI,EAClC,GAAQ,iBAAiB,EAAG,GAAa,sBAAuB,EAAI,EAAG,CAAI,EAC7E,EAAM,GAAQ,iBAAiB,EAAG,GAAa,kCAAmC,EAAI,EACtF,EAAM,EAAO,CAAK,EACtB,EAAK,iBAAiB,EAAG,GAAI,CAAG,CACpC,EAEM,GAAa,SAAS,EAAI,EAAG,EAAG,EAAM,CACxC,AAAI,EAAI,GAAG,GAAW,EAAI,EAAG,CAAI,CACrC,EAEM,GAAW,SAAS,EAAI,EAAG,CAC7B,MAAI,GAAG,EAAE,QAAU,EACf,GAAK,UAAU,CAAE,EACV,IAGJ,EACX,EAEM,GAAQ,SAAS,EAAI,EAAG,CAC1B,AAAI,EAAG,EAAE,QAAU,GACf,GAAe,EAAI,CAAC,CAC5B,EAEM,GAAY,SAAS,EAAI,EAAG,CAC9B,GAAM,EAAI,CAAC,EACX,EAAK,UAAU,CAAE,CACrB,EAEM,GAAkB,SAAS,EAAI,EAAG,EAAK,CACzC,AAAK,GACD,EAAK,iBAAiB,EAAI,CAAG,CACrC,EAEM,GAAc,SAAS,EAAI,EAAM,EAAK,EAAO,CAC/C,AAAK,GAAS,EAAI,CAAI,GAClB,CAAI,IAAU,EAAG,WACb,GAAe,EAAI,CAAI,EAEvB,EAAK,iBAAiB,EAAI,GAAQ,iBAAiB,EAAG,EAClD,GAAa,sCAAsC,EACnD,EAAK,eAAe,EAAI,CAAI,EAAG,EAAK,eAAe,EAAI,CAAG,EAAG,CAAK,CAAC,EAEnF,EAEM,GAAgB,SAAS,EAAI,CAC/B,GAAM,EAAI,EAAE,OAAO,EACnB,GAAI,GAAK,EAAG,EAAE,QAAQ,GACtB,SAAK,UAAU,CAAE,EACV,CACX,EAEM,GAAW,SAAS,EAAG,EAAG,EAAG,CAC/B,EAAE,EAAI,EAAE,EAAI,GACZ,EAAE,EAAI,EACN,EAAE,EAAE,KAAO,CACf,EAEM,GAAa,SAAS,EAAI,EAAG,EAAG,CAClC,GAAS,EAAG,EAAQ,GAAI,GAAa,EAAG,GAAI,CAAC,CAAC,CAClD,EAEM,GAAY,SAAS,EAAI,EAAG,CAC9B,GAAW,EAAI,EAAG,GAAc,CAAE,CAAC,CACvC,EAEM,GAAmB,SAAS,EAAI,EAAS,CAC3C,GAAI,GAAK,EAAG,GACR,EAAI,EAAG,EACX,SAAE,QAAQ,EAAG,UAAY,GAAI,IAAQ,OACrC,EAAE,QAAQ,EAAG,UAAU,QAAU,EAC1B,EAAG,UACd,EAEM,GAAe,SAAS,EAAI,EAAM,CACpC,GAAI,GAAK,EAAG,GACR,EAAM,EAAG,IACT,EAAM,GAAiB,EAAI,CAAI,EACnC,GAAW,EAAI,EAAI,OAAO,EAAI,EAAI,EAAG,WAAY,GAAS,GAAa,kBAAmB,EAAI,CAAC,EAC/F,EAAI,OAAO,IAAI,EAAI,OAAO,GAAK,GAAI,IACnC,EAAI,OAAO,IAAI,EAAI,OAAO,GAAG,IAAM,EACnC,EAAI,OAAO,GACf,EAEM,GAAsB,SAAS,EAAI,EAAM,CAC3C,GAAa,EAAI,EAAK,eAAe,EAAI,GAAa,EAAM,EAAI,CAAC,CAAC,CACtE,EAEM,GAAY,SAAS,EAAI,EAAG,CAC9B,GAAI,GAAM,EAAG,GAAG,IAAI,OAAO,IAAI,EAAG,WAAa,GAAG,IAClD,UAAW,EAAM,EAAG,QAAQ,EACrB,EAAG,EAAE,QAAQ,EACxB,EAEM,GAAkB,SAAS,EAAI,EAAO,CACxC,GAAI,GAAK,EAAG,GAEZ,IADA,EAAG,QAAU,EAAG,QAAU,EACnB,EAAO,IACV,GAAU,EAAI,EAAG,QAAU,CAAK,EAAE,QAAU,EAAG,EACvD,EAEM,GAAa,SAAS,EAAI,EAAS,CAErC,IADA,EAAG,GAAG,IAAI,OAAO,GAAK,EAAG,QAAU,EAC5B,EAAG,QAAU,GAChB,GAAU,EAAI,EAAE,EAAG,OAAO,EAAE,MAAQ,EAAG,EAC/C,EAEM,GAAgB,SAAS,EAAI,EAAM,CACrC,GAAI,GAAK,EAAG,EAAE,SACd,OAAS,GAAI,EAAG,EAAI,EAAG,KAAM,IACzB,GAAI,GAAM,EAAG,GAAG,KAAM,CAAI,EACtB,MAAO,GAEf,MAAO,EACX,EAEM,GAAa,SAAS,EAAI,EAAM,EAAG,CACrC,GAAI,GAAI,EAAG,EACX,UAAW,EAAI,EAAG,KAAO,EAAG,GAAM,SAAU,GAAa,WAAY,EAAI,CAAC,EAC1E,EAAE,SAAS,EAAG,MAAQ,CAClB,QAAS,EAAE,IAAM,EAAQ,OACzB,IAAK,EAAE,EAAE,KACT,KAAM,CACV,EACO,EAAG,MACd,EAEM,GAAY,SAAS,EAAI,EAAG,CAC9B,OAAS,GAAI,EAAG,QAAU,EAAG,GAAK,EAAG,IACjC,GAAI,GAAM,EAAG,GAAU,EAAI,CAAC,EAAE,OAAO,EACjC,MAAO,GAGf,MAAO,EACX,EAMM,GAAY,SAAS,EAAI,EAAO,CAClC,GAAI,GAAK,EAAG,GACZ,KAAO,EAAG,QAAU,GAChB,EAAK,EAAG,SACZ,EAAG,MAAQ,CACf,EAMM,GAAe,SAAS,EAAI,EAAG,EAAI,EAAM,CAC3C,GAAI,IAAO,KACP,GAAS,EAAI,EAAQ,MAAO,CAAC,MAC5B,CACD,GAAI,GAAI,GAAU,EAAI,CAAC,EACvB,GAAI,GAAK,EACL,GAAS,EAAI,EAAQ,OAAQ,CAAC,EACzB,GACD,GAAU,EAAI,CAAC,MAChB,CACH,GAAI,GAAM,GAAc,EAAI,CAAC,EAC7B,GAAI,EAAM,EAAG,CAET,GADA,GAAa,EAAG,KAAM,EAAG,EAAI,CAAC,EAC1B,EAAG,IAAM,EAAQ,MACjB,OAEJ,EAAM,GAAW,EAAI,EAAG,CAAE,CAC9B,CACA,GAAS,EAAI,EAAQ,OAAQ,CAAG,CACpC,CACJ,CACJ,EAEM,GAAY,SAAS,EAAI,EAAI,CAC/B,GAAI,GAAU,GAAc,CAAE,EAC1B,EAAK,EAAG,GAEZ,GADA,GAAa,EAAI,EAAS,EAAI,CAAC,EAC3B,EAAG,IAAM,EAAQ,MAAO,CACxB,GAAI,GAAM,GAAI,IACd,GAAa,EAAI,EAAG,KAAM,EAAI,CAAC,EAC/B,GAAW,EAAG,IAAM,EAAQ,KAAK,EACjC,GAAW,EAAI,EAAK,CAAO,EAC3B,GAAa,EAAI,EAAI,CAAG,CAC5B,CACJ,EAEM,GAAgB,SAAS,EAAI,EAAO,EAAO,EAAG,CAChD,GAAI,GAAK,EAAG,GACR,EAAQ,EAAQ,EACpB,GAAI,GAAW,EAAE,CAAC,EACd,IACI,EAAQ,GAAG,GAAQ,GACvB,GAAgB,EAAI,EAAG,CAAK,EACxB,EAAQ,GAAG,GAAiB,EAAI,EAAQ,CAAC,UAEzC,EAAE,IAAM,EAAQ,OAAO,GAAiB,EAAI,CAAC,EAC7C,EAAQ,EAAG,CACX,GAAI,GAAM,EAAG,QACb,GAAiB,EAAI,CAAK,EAC1B,GAAS,EAAI,EAAK,CAAK,CAC3B,CAEJ,AAAI,EAAQ,GACR,GAAG,GAAG,SAAW,EAAQ,EACjC,EAEM,GAAa,SAAS,EAAI,CAC5B,GAAI,GAAI,EAAG,EACX,EAAE,EAAE,QACJ,GAAW,EAAG,GAAI,EAAE,QAAS,GAAgB,GAAa,YAAa,EAAI,CAAC,CAChF,EAEM,GAAa,SAAS,EAAI,CAC5B,MAAO,GAAG,EAAE,SAChB,EAEM,GAAY,SAAS,EAAI,EAAG,EAAO,CACrC,GAAI,GAAK,EAAG,GACR,EAAK,EAAG,IAAI,GACZ,EAAK,EAAG,IAAI,GAEhB,GADA,GAAW,GAAM,EAAG,KAAM,EAAM,IAAI,CAAC,EACjC,EAAG,QAAU,EAAM,QAAS,CAC5B,GAAI,GAAQ,GAAU,EAAI,EAAG,OAAO,EAAE,QAClC,EAAM,GAAQ,iBAAiB,EAAG,EAClC,GAAa,yDAAyD,EACtE,EAAG,KAAK,OAAO,EAAG,EAAG,KAAM,EAAM,OAAO,CAAC,EAC7C,GAAS,EAAI,CAAG,CACpB,CACA,GAAe,EAAI,EAAG,GAAI,EAAM,EAAE,EAElC,OAAS,GAAI,EAAG,EAAI,EAAG,EAAI,EAAG,IAC1B,EAAG,IAAI,GAAK,EAAG,IAAI,EAAI,GAC3B,EAAG,GACP,EAKM,GAAY,SAAS,EAAI,EAAG,CAC9B,GAAI,GAAK,EAAG,GAAG,GACX,EAAM,EAAG,IACT,EAAK,EAAI,GAAG,IAAI,GAEpB,OAAS,GAAI,EAAG,WAAY,EAAI,EAAI,MAAM,EAAG,IAAK,CAC9C,GAAI,GAAK,EAAI,MAAM,IAAI,GACvB,GAAI,GAAM,EAAG,KAAM,EAAG,IAAI,EACtB,MAAI,GAAG,QAAU,EAAG,SAAY,GAAG,OAAS,EAAI,MAAM,EAAI,EAAG,aACzD,GAAgB,EAAG,GAAI,EAAG,GAAI,EAAG,OAAO,EAC5C,GAAU,EAAI,EAAG,CAAE,EACZ,EAEf,CACA,MAAO,EACX,EAEM,GAAgB,SAAS,EAAI,EAAG,EAAM,EAAM,EAAI,CAClD,GAAI,GAAI,EAAE,EACV,SAAE,IAAI,GAAK,GAAI,IACf,EAAE,IAAI,GAAG,KAAO,EAChB,EAAE,IAAI,GAAG,KAAO,EAChB,EAAE,IAAI,GAAG,QAAU,EAAG,GAAG,QACzB,EAAE,IAAI,GAAG,GAAK,EACd,EAAE,EAAI,EAAI,EACH,CACX,EAMM,GAAY,SAAS,EAAI,EAAI,CAC/B,GAAI,GAAK,EAAG,IAAI,GACZ,EAAI,EAAG,GAAG,GAAG,UACjB,KAAO,EAAI,EAAG,GACV,AAAI,GAAM,EAAG,IAAI,GAAG,KAAM,EAAG,IAAI,EAC7B,GAAU,EAAI,EAAG,CAAE,EAEnB,GAEZ,EAQM,GAAe,SAAS,EAAI,EAAI,CAClC,GAAI,GAAI,EAAG,UACP,EAAK,EAAG,GAAG,IAAI,GAGnB,KAAO,EAAI,EAAG,GAAG,CACb,GAAI,GAAK,EAAG,IAAI,GAChB,AAAI,EAAG,QAAU,EAAG,SACZ,GAAG,OACH,GAAgB,EAAI,EAAG,GAAI,EAAG,OAAO,EACzC,EAAG,QAAU,EAAG,SAEf,GAAU,EAAG,GAAI,CAAC,GACnB,GACR,CACJ,EAEM,GAAa,SAAS,EAAI,EAAI,EAAQ,CACxC,EAAG,OAAS,EACZ,EAAG,QAAU,EAAG,QAChB,EAAG,WAAa,EAAG,GAAG,IAAI,MAAM,EAChC,EAAG,UAAY,EAAG,GAAG,IAAI,GAAG,EAC5B,EAAG,MAAQ,EACX,EAAG,SAAW,EAAG,GACjB,EAAG,GAAK,EACR,GAAW,EAAG,UAAY,EAAG,OAAO,CACxC,EAKM,GAAa,SAAS,EAAI,CAC5B,GAAI,GAAI,GAAgB,EAAG,EAAG,OAAO,EACjC,EAAI,GAAc,EAAI,EAAG,IAAI,MAAO,EAAG,EAAG,EAAG,GAAG,EAAE,EACtD,GAAU,EAAI,EAAG,IAAI,MAAM,IAAI,EAAE,CACrC,EAMM,GAAY,SAAS,EAAI,EAAI,CAC/B,GAAI,GAAM,EAAK,WAAW,EAAG,IAAI,EAC3B,oCACA,8CACN,EAAM,GAAQ,iBAAiB,EAAG,EAAG,GAAa,CAAG,EAAG,EAAG,KAAK,OAAO,EAAG,EAAG,IAAI,EACjF,GAAS,EAAI,CAAG,CACpB,EAKM,GAAe,SAAS,EAAI,CAC9B,GAAI,GAAI,EAAG,EACP,EAAM,GAAI,IAAM,CAAC,EACjB,EAAK,EAAG,GACR,EAAI,EAAG,EACX,SAAE,EAAE,EAAG,MAAQ,EACR,CACX,EAKM,GAAc,SAAS,EAAI,EAAG,CAChC,GAAI,GAAK,EAAG,GAAG,KACf,GAAS,EAAG,EAAQ,WAAY,GAAa,EAAI,GAAY,EAAG,EAAG,GAAI,CAAC,CAAC,EACzE,GAAiB,EAAI,CAAC,CAC1B,EAEM,GAAY,SAAS,EAAI,EAAI,EAAI,CACnC,EAAG,KAAO,EAAG,GACb,EAAG,GAAK,EACR,EAAG,GAAK,EACR,EAAG,GAAK,EACR,EAAG,WAAa,EAChB,EAAG,IAAM,GACT,EAAG,QAAU,EACb,EAAG,GAAK,EACR,EAAG,GAAK,EACR,EAAG,KAAO,EACV,EAAG,SAAW,EACd,EAAG,QAAU,EACb,EAAG,WAAa,EAAG,IAAI,OAAO,EAC9B,EAAG,GAAK,KACR,GAAI,GAAI,EAAG,EACX,EAAE,OAAS,EAAG,OACd,EAAE,aAAe,EACjB,GAAW,EAAI,EAAI,EAAK,CAC5B,EAEM,GAAa,SAAS,EAAI,CAC5B,GAAI,GAAK,EAAG,GACR,EAAK,EAAG,GACZ,GAAI,EAAG,UAAY,EAAG,MAAO,CAEzB,GAAI,GAAI,GAAU,CAAE,EACpB,GAAgB,EAAI,EAAI,EAAG,OAAO,EAClC,GAAiB,EAAI,CAAC,CAC1B,CAEA,AAAI,EAAG,QACH,GAAW,CAAE,EAEjB,EAAG,GAAK,EAAG,SACX,GAAW,EAAI,EAAG,OAAO,EACzB,GAAW,EAAG,UAAY,EAAG,OAAO,EACpC,EAAG,QAAU,EAAG,QAChB,EAAG,IAAI,MAAM,EAAI,EAAG,WACpB,AAAI,EAAG,SACH,GAAa,EAAI,CAAE,EACd,EAAG,UAAY,EAAG,IAAI,GAAG,GAC9B,GAAU,EAAI,EAAG,IAAI,GAAG,IAAI,EAAG,UAAU,CACjD,EAEM,GAAa,SAAS,EAAI,CAC5B,GAAI,GAAK,EAAG,GACZ,GAAS,EAAI,EAAG,CAAC,EACjB,GAAW,CAAE,EACb,GAAW,EAAG,KAAO,IAAI,EACzB,EAAG,GAAK,EAAG,IACf,EAMM,GAAe,SAAS,EAAI,EAAW,CACzC,OAAQ,EAAG,EAAE,WACJ,GAAE,YAAc,GAAE,cAClB,GAAE,WAAa,GAAE,OAClB,MAAO,OACN,GAAE,SAAU,MAAO,WACf,MAAO,GAExB,EAEM,GAAW,SAAS,EAAI,CAE1B,KAAO,CAAC,GAAa,EAAI,CAAC,GAAG,CACzB,GAAI,EAAG,EAAE,QAAU,EAAE,UAAW,CAC5B,GAAU,CAAE,EACZ,MACJ,CACA,GAAU,CAAE,CAChB,CACJ,EAEM,GAAW,SAAS,EAAI,EAAG,CAE7B,GAAI,GAAK,EAAG,GACR,EAAM,GAAI,IACd,GAAkB,EAAI,CAAC,EACvB,EAAK,UAAU,CAAE,EACjB,GAAU,EAAI,CAAG,EACjB,GAAa,EAAI,EAAG,CAAG,CAC3B,EAEM,GAAS,SAAS,EAAI,EAAG,CAE3B,EAAK,UAAU,CAAE,EACjB,GAAK,EAAI,CAAC,EACV,GAAa,EAAG,GAAI,CAAC,EACrB,GAAU,EAAI,EAA4B,CAC9C,EAQM,GAAN,KAAkB,CACd,aAAc,CACV,KAAK,EAAI,GAAI,IACb,KAAK,EAAI,GAAI,IACb,KAAK,GAAK,IACV,KAAK,GAAK,IACV,KAAK,QAAU,GACnB,CACJ,EAEM,GAAW,SAAS,EAAI,EAAI,CAE9B,GAAI,GAAK,EAAG,GACR,EAAM,EAAG,GAAG,QACZ,EAAM,GAAI,IACV,EAAM,GAAI,IAEd,AAAI,EAAG,EAAE,QAAU,EAAE,QACjB,IAAW,EAAI,EAAG,GAAI,GAAS,GAAa,yBAA0B,EAAI,CAAC,EAC3E,GAAU,EAAI,CAAG,GAEjB,GAAO,EAAI,CAAG,EAClB,EAAG,KACH,GAAU,EAAI,EAA4B,EAC1C,GAAI,GAAQ,GAAY,EAAI,CAAG,EAC/B,GAAK,EAAI,CAAG,EACZ,GAAa,EAAI,GAAa,EAAG,EAAE,EAAE,KAAM,EAAO,GAAY,EAAI,CAAG,CAAC,EACtE,EAAG,QAAU,CACjB,EAEM,GAAiB,SAAS,EAAI,EAAI,CACpC,AAAI,EAAG,EAAE,IAAM,EAAQ,OACvB,IAAiB,EAAI,EAAG,CAAC,EACzB,EAAG,EAAE,EAAI,EAAQ,MACb,EAAG,UAAY,IACf,IAAa,EAAI,EAAG,EAAE,EAAE,KAAM,EAAG,GAAI,EAAG,OAAO,EAC/C,EAAG,QAAU,GAErB,EAEM,GAAgB,SAAS,EAAI,EAAI,CACnC,AAAI,EAAG,UAAY,GACnB,CAAI,GAAW,EAAG,EAAE,CAAC,EACjB,IAAgB,EAAI,EAAG,CAAC,EACxB,GAAa,EAAI,EAAG,EAAE,EAAE,KAAM,EAAG,GAAI,EAAW,EAChD,EAAG,MAEC,GAAG,EAAE,IAAM,EAAQ,OACnB,GAAiB,EAAI,EAAG,CAAC,EAC7B,GAAa,EAAI,EAAG,EAAE,EAAE,KAAM,EAAG,GAAI,EAAG,OAAO,GAEvD,EAEM,GAAY,SAAS,EAAI,EAAI,CAE/B,GAAK,EAAI,EAAG,CAAC,EACb,GAAW,EAAG,GAAI,EAAG,GAAI,GAAS,GAAa,yBAA0B,EAAI,CAAC,EAC9E,EAAG,KACH,EAAG,SACP,EAEM,GAAQ,SAAS,EAAI,EAAI,CAE3B,OAAQ,EAAG,EAAE,WACJ,GAAE,QAAS,CACZ,AAAI,EAAK,eAAe,CAAE,IAAM,GAC5B,GAAU,EAAI,CAAE,EAEhB,GAAS,EAAI,CAAE,EACnB,KACJ,KACK,IAA8B,CAC/B,GAAS,EAAI,CAAE,EACf,KACJ,SACS,CACL,GAAU,EAAI,CAAE,EAChB,KACJ,EAER,EAEM,GAAc,SAAS,EAAI,EAAG,CAGhC,GAAI,GAAK,EAAG,GACR,EAAO,EAAG,WACV,EAAK,GAAa,EAAI,GAAa,EAAG,EAAG,CAAC,EAC1C,EAAK,GAAI,IACb,EAAG,GAAK,EAAG,GAAK,EAAG,QAAU,EAC7B,EAAG,EAAI,EACP,GAAS,EAAG,EAAQ,WAAY,CAAE,EAClC,GAAS,EAAG,EAAG,EAAQ,MAAO,CAAC,EAC/B,GAAiB,EAAG,GAAI,CAAC,EACzB,GAAU,EAAI,GAA6B,EAC3C,EAAG,CAEC,GADA,GAAW,EAAG,EAAE,IAAM,EAAQ,OAAS,EAAG,QAAU,CAAC,EACjD,EAAG,EAAE,QAAU,IAA+B,MAClD,GAAe,EAAI,CAAE,EACrB,GAAM,EAAI,CAAE,CAChB,OAAS,GAAS,EAAI,EAA4B,GAAK,GAAS,EAAI,EAA4B,GAChG,GAAY,EAAI,IAA+B,IAA+B,CAAI,EAClF,GAAc,EAAI,CAAE,EACpB,GAAS,EAAG,EAAE,KAAK,GAAK,GAAQ,YAAY,EAAG,EAAE,CAAC,EAClD,GAAS,EAAG,EAAE,KAAK,GAAK,GAAQ,YAAY,EAAG,EAAE,CAAC,CACtD,EAIM,GAAU,SAAS,EAAI,CAEzB,GAAI,GAAK,EAAG,GACR,EAAI,EAAG,EACP,EAAU,EAEd,GADA,EAAE,UAAY,GACV,EAAG,EAAE,QAAU,GACf,EACI,QAAQ,EAAG,EAAE,WACJ,GAAE,QAAS,CACZ,GAAa,EAAI,GAAc,CAAE,CAAC,EAClC,IACA,KACJ,KACK,GAAE,QAAS,CACZ,EAAK,UAAU,CAAE,EACjB,EAAE,UAAY,GACd,KACJ,SACS,EAAK,iBAAiB,EAAI,GAAa,2BAA4B,EAAI,CAAC,QAEjF,CAAC,EAAE,WAAa,GAAS,EAAI,EAA4B,GAErE,GAAgB,EAAI,CAAO,EAC3B,EAAE,UAAY,EAAG,QACjB,GAAiB,EAAI,EAAG,OAAO,CACnC,EAEM,GAAO,SAAS,EAAI,EAAG,EAAU,EAAM,CAEzC,GAAI,GAAS,GAAI,IACb,EAAK,GAAI,IACb,EAAO,EAAI,GAAa,CAAE,EAC1B,EAAO,EAAE,YAAc,EACvB,GAAU,EAAI,EAAQ,CAAE,EACxB,GAAU,EAAI,EAA4B,EACtC,GACA,IAAoB,EAAI,MAAM,EAC9B,GAAgB,EAAI,CAAC,GAEzB,GAAQ,CAAE,EACV,GAAU,EAAI,EAA4B,EAC1C,GAAS,CAAE,EACX,EAAO,EAAE,gBAAkB,EAAG,WAC9B,GAAY,EAAI,EAAE,OAAQ,EAAE,YAAa,CAAI,EAC7C,GAAY,EAAI,CAAC,EACjB,GAAW,CAAE,CACjB,EAEM,GAAU,SAAS,EAAI,EAAG,CAE5B,GAAI,GAAI,EAER,IADA,GAAK,EAAI,CAAC,EACH,GAAS,EAAI,EAA4B,GAC5C,GAAiB,EAAG,GAAI,CAAC,EACzB,GAAK,EAAI,CAAC,EACV,IAEJ,MAAO,EACX,EAEM,GAAW,SAAS,EAAI,EAAG,EAAM,CACnC,GAAI,GAAK,EAAG,GACR,EAAO,GAAI,IACf,OAAQ,EAAG,EAAE,WACJ,IAA8B,CAC/B,EAAK,UAAU,CAAE,EACjB,AAAI,EAAG,EAAE,QAAU,GACf,EAAK,EAAI,EAAQ,MAEjB,IAAQ,EAAI,CAAI,EAChB,GAAgB,EAAI,CAAI,GAE5B,GAAY,EAAI,GAA8B,GAA8B,CAAI,EAChF,KACJ,KACK,KAA+B,CAChC,GAAY,EAAI,CAAI,EACpB,KACJ,KACK,GAAE,UAAW,CACd,GAAW,EAAI,EAAM,EAAG,EAAE,QAAQ,EAAE,EACpC,EAAK,UAAU,CAAE,EACjB,KACJ,SAEI,EAAK,iBAAiB,EAAI,GAAa,8BAA+B,EAAI,CAAC,EAGnF,GAAW,EAAE,IAAM,EAAQ,SAAS,EACpC,GAAI,GACA,EAAO,EAAE,EAAE,KACf,AAAI,GAAW,EAAK,CAAC,EACjB,EAAU,GAEN,GAAK,IAAM,EAAQ,OACnB,GAAiB,EAAI,CAAI,EAC7B,EAAU,EAAG,QAAW,GAAK,IAEjC,GAAS,EAAG,EAAQ,MAAO,GAAa,EAAI,GAAS,EAAM,EAAQ,EAAG,CAAC,CAAC,EACxE,GAAa,EAAI,CAAI,EACrB,EAAG,QAAU,EAAO,CACxB,EAQM,GAAa,SAAS,EAAI,EAAG,CAE/B,OAAQ,EAAG,EAAE,WACJ,IAA8B,CAC/B,GAAI,GAAO,EAAG,WACd,EAAK,UAAU,CAAE,EACjB,GAAK,EAAI,CAAC,EACV,GAAY,EAAI,GAA8B,GAA8B,CAAI,EAChF,GAAmB,EAAG,GAAI,CAAC,EAC3B,MACJ,KACK,GAAE,QAAS,CACZ,GAAU,EAAI,CAAC,EACf,MACJ,SAEI,EAAK,iBAAiB,EAAI,GAAa,oBAAqB,EAAI,CAAC,EAG7E,EAEM,GAAc,SAAS,EAAI,EAAG,CAGhC,GAAI,GAAK,EAAG,GACR,EAAO,EAAG,WAEd,IADA,GAAW,EAAI,CAAC,IAEZ,OAAQ,EAAG,EAAE,WACJ,IAA8B,CAC/B,GAAS,EAAI,CAAC,EACd,KACJ,KACK,IAA8B,CAC/B,GAAI,GAAM,GAAI,IACd,GAAkB,EAAI,CAAC,EACvB,GAAO,EAAI,CAAG,EACd,GAAa,EAAI,EAAG,CAAG,EACvB,KACJ,KACK,IAA8B,CAC/B,GAAI,GAAM,GAAI,IACd,EAAK,UAAU,CAAE,EACjB,GAAU,EAAI,CAAG,EACjB,GAAU,EAAI,EAAG,CAAG,EACpB,GAAS,EAAI,EAAG,CAAI,EACpB,KACJ,KACK,QAAmC,GAAE,cAAgB,KAA+B,CACrF,GAAiB,EAAI,CAAC,EACtB,GAAS,EAAI,EAAG,CAAI,EACpB,KACJ,SACS,OAGrB,EAEM,GAAY,SAAS,EAAI,EAAG,CAG9B,OAAQ,EAAG,EAAE,WACJ,GAAE,OAAQ,CACX,GAAS,EAAG,EAAQ,MAAO,CAAC,EAC5B,EAAE,EAAE,KAAO,EAAG,EAAE,QAAQ,EACxB,KACJ,KACK,GAAE,OAAQ,CACX,GAAS,EAAG,EAAQ,MAAO,CAAC,EAC5B,EAAE,EAAE,KAAO,EAAG,EAAE,QAAQ,EACxB,KACJ,KACK,GAAE,UAAW,CACd,GAAW,EAAI,EAAG,EAAG,EAAE,QAAQ,EAAE,EACjC,KACJ,KACK,GAAE,OAAQ,CACX,GAAS,EAAG,EAAQ,KAAM,CAAC,EAC3B,KACJ,KACK,GAAE,QAAS,CACZ,GAAS,EAAG,EAAQ,MAAO,CAAC,EAC5B,KACJ,KACK,GAAE,SAAU,CACb,GAAS,EAAG,EAAQ,OAAQ,CAAC,EAC7B,KACJ,KACK,GAAE,QAAS,CACZ,GAAI,GAAK,EAAG,GACZ,GAAgB,EAAI,EAAG,EAAE,UAAW,GAAa,6CAA8C,EAAI,CAAC,EACpG,GAAS,EAAG,EAAQ,QAAS,GAAa,EAAI,GAAW,EAAG,EAAG,CAAC,CAAC,EACjE,KACJ,KACK,KAA+B,CAChC,GAAY,EAAI,CAAC,EACjB,MACJ,KACK,GAAE,YAAa,CAChB,EAAK,UAAU,CAAE,EACjB,GAAK,EAAI,EAAG,EAAG,EAAG,UAAU,EAC5B,MACJ,SACS,CACL,GAAY,EAAI,CAAC,EACjB,MACJ,EAEJ,EAAK,UAAU,CAAE,CACrB,EAEM,GAAW,SAAS,EAAI,CAC1B,OAAQ,OACC,GAAE,OAAQ,MAAO,QACjB,IAA8B,MAAO,QACrC,KAA+B,MAAO,QACtC,IAA8B,MAAO,YACjC,MAAO,IAExB,EAEM,GAAY,SAAS,EAAI,CAC3B,OAAQ,OACC,IAA8B,MAAO,QACrC,IAA8B,MAAO,QACrC,IAA8B,MAAO,QACrC,IAA8B,MAAO,QACrC,IAA8B,MAAO,QACrC,IAA8B,MAAO,QACrC,GAAE,QAAW,MAAO,QACpB,IAA8B,MAAO,QACrC,KAA+B,MAAO,QACtC,KAA+B,MAAO,QACtC,GAAE,OAAW,MAAO,QACpB,GAAE,OAAW,MAAO,QACpB,GAAE,UAAW,MAAO,QACpB,GAAE,MAAW,MAAO,QACpB,GAAE,MAAW,MAAO,QACpB,IAA8B,MAAO,QACrC,GAAE,MAAW,MAAO,QACpB,IAA8B,MAAO,QACrC,GAAE,MAAW,MAAO,QACpB,GAAE,OAAW,MAAO,QACpB,GAAE,MAAW,MAAO,YACP,MAAO,IAEjC,EAEM,GAAW,CACb,CAAC,KAAM,GAAI,MAAO,EAAE,EAAG,CAAC,KAAM,GAAI,MAAO,EAAE,EAC3C,CAAC,KAAM,GAAI,MAAO,EAAE,EAAG,CAAC,KAAM,GAAI,MAAO,EAAE,EAC3C,CAAC,KAAM,GAAI,MAAO,EAAE,EACpB,CAAC,KAAM,GAAI,MAAO,EAAE,EAAG,CAAC,KAAM,GAAI,MAAO,EAAE,EAC3C,CAAC,KAAM,EAAG,MAAO,CAAC,EAAG,CAAC,KAAM,EAAG,MAAO,CAAC,EAAG,CAAC,KAAM,EAAG,MAAO,CAAC,EAC5D,CAAC,KAAM,EAAG,MAAO,CAAC,EAAG,CAAC,KAAM,EAAG,MAAO,CAAC,EACvC,CAAC,KAAM,EAAG,MAAO,CAAC,EAClB,CAAC,KAAM,EAAG,MAAO,CAAC,EAAG,CAAC,KAAM,EAAG,MAAO,CAAC,EAAG,CAAC,KAAM,EAAG,MAAO,CAAC,EAC5D,CAAC,KAAM,EAAG,MAAO,CAAC,EAAG,CAAC,KAAM,EAAG,MAAO,CAAC,EAAG,CAAC,KAAM,EAAG,MAAO,CAAC,EAC5D,CAAC,KAAM,EAAG,MAAO,CAAC,EAAG,CAAC,KAAM,EAAG,MAAO,CAAC,CAC3C,EAEM,GAAiB,GAMjB,GAAU,SAAS,EAAI,EAAG,EAAO,CACnC,GAAW,CAAE,EACb,GAAI,GAAM,GAAS,EAAG,EAAE,KAAK,EAC7B,GAAI,IAAQ,GAAa,CACrB,GAAI,GAAO,EAAG,WACd,EAAK,UAAU,CAAE,EACjB,GAAQ,EAAI,EAAG,EAAc,EAC7B,GAAY,EAAG,GAAI,EAAK,EAAG,CAAI,CACnC,KACI,IAAU,EAAI,CAAC,EAEnB,GAAI,GAAK,GAAU,EAAG,EAAE,KAAK,EAC7B,KAAO,IAAO,IAAgB,GAAS,GAAI,KAAO,GAAO,CACrD,GAAI,GAAK,GAAI,IACT,EAAO,EAAG,WACd,EAAK,UAAU,CAAE,EACjB,GAAW,EAAG,GAAI,EAAI,CAAC,EAEvB,GAAI,GAAS,GAAQ,EAAI,EAAI,GAAS,GAAI,KAAK,EAC/C,GAAY,EAAG,GAAI,EAAI,EAAG,EAAI,CAAI,EAClC,EAAK,CACT,CACA,UAAW,CAAE,EACN,CACX,EAEM,GAAO,SAAS,EAAI,EAAG,CACzB,GAAQ,EAAI,EAAG,CAAC,CACpB,EAYM,GAAQ,SAAS,EAAI,CAEvB,GAAI,GAAK,EAAG,GACR,EAAK,GAAI,IACb,GAAW,EAAI,EAAI,CAAC,EACpB,GAAS,CAAE,EACX,GAAW,CAAE,CACjB,EAMM,GAAN,KAAiB,CACb,aAAc,CACV,KAAK,KAAO,KACZ,KAAK,EAAI,GAAI,GACjB,CACJ,EAQM,GAAiB,SAAS,EAAI,EAAI,EAAG,CACvC,GAAI,GAAK,EAAG,GACR,EAAQ,EAAG,QACX,EAAW,GACf,KAAO,EAAI,EAAK,EAAG,KACf,AAAI,EAAG,EAAE,IAAM,EAAQ,UAEf,GAAG,EAAE,EAAE,IAAI,KAAO,EAAE,GAAK,EAAG,EAAE,EAAE,IAAI,IAAM,EAAE,EAAE,MAC9C,GAAW,GACX,EAAG,EAAE,EAAE,IAAI,GAAK,EAAQ,OACxB,EAAG,EAAE,EAAE,IAAI,EAAI,GAGf,EAAE,IAAM,EAAQ,QAAU,EAAG,EAAE,EAAE,IAAI,MAAQ,EAAE,EAAE,MACjD,GAAW,GACX,EAAG,EAAE,EAAE,IAAI,IAAM,IAI7B,GAAI,EAAU,CAEV,GAAI,GAAK,EAAE,IAAM,EAAQ,OAAS,GAAU,GAC5C,GAAa,EAAI,EAAI,EAAO,EAAE,EAAE,KAAM,CAAC,EACvC,GAAiB,EAAI,CAAC,CAC1B,CACJ,EAEM,GAAa,SAAS,EAAI,EAAI,EAAO,CACvC,GAAI,GAAI,GAAI,IAEZ,GADA,GAAgB,EAAI,GAAQ,EAAG,EAAE,CAAC,EAAG,GAAa,eAAgB,EAAI,CAAC,EACnE,GAAS,EAAI,EAA4B,EAAG,CAC5C,GAAI,GAAK,GAAI,IACb,EAAG,KAAO,EACV,GAAY,EAAI,EAAG,CAAC,EAChB,EAAG,EAAE,IAAM,EAAQ,UACnB,GAAe,EAAI,EAAI,EAAG,CAAC,EAC/B,GAAW,EAAG,GAAI,EAAQ,EAAG,EAAE,QAAS,GAAgB,GAAa,YAAa,EAAI,CAAC,EACvF,GAAW,EAAI,EAAI,EAAQ,CAAC,CAChC,KAAO,CACH,GAAU,EAAI,EAA4B,EAC1C,GAAI,GAAQ,GAAQ,EAAI,CAAC,EACzB,GAAI,IAAU,EACV,GAAc,EAAI,EAAO,EAAO,CAAC,MAChC,CACD,GAAe,EAAG,GAAI,CAAC,EACvB,GAAc,EAAG,GAAI,EAAG,EAAG,CAAC,EAC5B,MACJ,CACJ,CACA,GAAS,EAAG,EAAQ,UAAW,EAAG,GAAG,QAAQ,CAAC,EAC9C,GAAc,EAAG,GAAI,EAAG,EAAG,CAAC,CAChC,EAEM,GAAO,SAAS,EAAI,CAEtB,GAAI,GAAI,GAAI,IACZ,UAAK,EAAI,CAAC,EACN,EAAE,IAAM,EAAQ,MAAM,GAAE,EAAI,EAAQ,QACxC,GAAc,EAAG,GAAI,CAAC,EACf,EAAE,CACb,EAEM,GAAW,SAAS,EAAI,EAAI,CAC9B,GAAI,GAAO,EAAG,WACV,EACJ,AAAI,GAAS,EAAI,EAAE,OAAO,EACtB,EAAQ,GAAc,CAAE,EAExB,GAAK,UAAU,CAAE,EACjB,EAAQ,GAAgB,EAAG,EAAG,OAAO,GAEzC,GAAI,GAAI,GAAc,EAAI,EAAG,IAAI,GAAI,EAAO,EAAM,CAAE,EACpD,GAAU,EAAI,CAAC,CACnB,EAGM,GAAgB,SAAS,EAAI,EAAI,EAAO,CAC1C,OAAS,GAAI,EAAG,GAAG,WAAY,EAAI,EAAG,EAAG,IACrC,GAAI,GAAM,EAAO,EAAG,IAAI,GAAG,IAAI,EAAG,CAC9B,GAAI,GAAM,GAAQ,iBAAiB,EAAG,GAAG,EACrC,GAAa,wCAAyC,EAAI,EAC1D,EAAM,OAAO,EAAG,EAAG,IAAI,GAAG,IAAI,EAClC,GAAS,EAAG,GAAI,CAAG,CACvB,CAER,EAGM,GAAe,SAAS,EAAI,CAC9B,KAAO,EAAG,EAAE,QAAU,IAAgC,EAAG,EAAE,QAAU,EAAE,YACnE,GAAU,CAAE,CACpB,EAEM,GAAY,SAAS,EAAI,EAAO,EAAM,CAExC,GAAI,GAAK,EAAG,GACR,EAAK,EAAG,IAAI,MACZ,EACJ,GAAc,EAAI,EAAI,CAAK,EAC3B,GAAU,EAAI,EAAE,UAAU,EAE1B,EAAI,GAAc,EAAI,EAAI,EAAO,EAAM,GAAc,CAAE,CAAC,EACxD,GAAa,CAAE,EACX,GAAa,EAAI,CAAC,GAElB,GAAG,IAAI,GAAG,QAAU,EAAG,GAAG,SAE9B,GAAU,EAAI,EAAG,IAAI,EAAE,CAC3B,EAEM,GAAY,SAAS,EAAI,EAAM,CAEjC,GAAI,GAAK,EAAG,GACR,EAAK,GAAI,IACb,EAAK,UAAU,CAAE,EACjB,GAAI,GAAY,GAAc,CAAE,EAC5B,EAAW,GAAK,CAAE,EACtB,GAAW,EAAI,EAAI,CAAC,EACpB,GAAU,EAAI,EAAE,KAAK,EACrB,GAAM,CAAE,EACR,GAAY,EAAI,CAAS,EACzB,GAAY,EAAI,EAAE,OAAQ,EAAE,SAAU,CAAI,EAC1C,GAAW,CAAE,EACb,GAAiB,EAAI,CAAQ,CACjC,EAEM,GAAa,SAAS,EAAI,EAAM,CAElC,GAAI,GAAK,EAAG,GACR,EAAc,GAAc,CAAE,EAC9B,EAAM,GAAI,IACV,EAAM,GAAI,IACd,GAAW,EAAI,EAAK,CAAC,EACrB,GAAW,EAAI,EAAK,CAAC,EACrB,EAAK,UAAU,CAAE,EACjB,GAAS,CAAE,EACX,GAAY,EAAI,EAAE,SAAU,EAAE,UAAW,CAAI,EAC7C,GAAI,GAAW,GAAK,CAAE,EACtB,AAAI,EAAI,OACJ,GAAgB,EAAI,EAAU,EAAI,OAAO,EAC7C,GAAW,CAAE,EACb,GAAe,EAAI,EAAU,CAAW,EACxC,GAAW,CAAE,CACjB,EAEM,GAAO,SAAS,EAAI,CACtB,GAAI,GAAI,GAAI,IACZ,UAAK,EAAI,CAAC,EACV,GAAiB,EAAG,GAAI,CAAC,EACzB,GAAW,EAAE,IAAM,EAAQ,SAAS,EAC1B,EAAE,EAAE,IAElB,EAEM,GAAU,SAAS,EAAI,EAAM,EAAM,EAAO,EAAO,CAEnD,GAAI,GAAK,GAAI,IACT,EAAK,EAAG,GACR,EACJ,GAAgB,EAAI,CAAC,EACrB,GAAU,EAAI,EAAE,KAAK,EACrB,GAAI,GAAO,EAAQ,GAAc,EAAI,GAAY,EAAM,EAAO,EAAI,GAAU,CAAE,EAC9E,GAAW,EAAI,EAAI,CAAC,EACpB,GAAgB,EAAI,CAAK,EACzB,GAAiB,EAAI,CAAK,EAC1B,GAAM,CAAE,EACR,GAAW,CAAE,EACb,GAAiB,EAAI,CAAI,EACzB,AAAI,EACA,EAAS,GAAc,EAAI,GAAY,EAAM,EAAO,EAEpD,IAAa,EAAI,GAAa,EAAM,EAAG,CAAK,EAC5C,GAAa,EAAI,CAAI,EACrB,EAAS,GAAc,EAAI,GAAa,EAAO,EAAG,EAAO,GAE7D,GAAe,EAAI,EAAQ,EAAO,CAAC,EACnC,GAAa,EAAI,CAAI,CACzB,EAEM,GAAS,SAAS,EAAI,EAAS,EAAM,CAEvC,GAAI,GAAK,EAAG,GACR,EAAO,EAAG,QACd,GAAoB,EAAI,aAAa,EACrC,GAAoB,EAAI,aAAa,EACrC,GAAoB,EAAI,YAAY,EACpC,GAAa,EAAI,CAAO,EACxB,GAAU,EAAI,EAA4B,EAC1C,GAAK,CAAE,EACP,GAAU,EAAI,EAA4B,EAC1C,GAAK,CAAE,EACP,AAAI,GAAS,EAAI,EAA4B,EACzC,GAAK,CAAE,EAEP,IAAW,EAAI,EAAG,QAAS,GAAU,EAAI,CAAC,CAAC,EAC3C,GAAiB,EAAI,CAAC,GAE1B,GAAQ,EAAI,EAAM,EAAM,EAAG,CAAC,CAChC,EAEM,GAAU,SAAS,EAAI,EAAW,CAEpC,GAAI,GAAK,EAAG,GACR,EAAI,GAAI,IACR,EAAQ,EACR,EAAO,EAAG,QAOd,IALA,GAAoB,EAAI,iBAAiB,EACzC,GAAoB,EAAI,aAAa,EACrC,GAAoB,EAAI,eAAe,EAEvC,GAAa,EAAI,CAAS,EACnB,GAAS,EAAI,EAA4B,GAC5C,GAAa,EAAI,GAAc,CAAE,CAAC,EAClC,IAEJ,GAAU,EAAI,EAAE,KAAK,EACrB,GAAI,GAAO,EAAG,WACd,GAAc,EAAI,EAAG,GAAQ,EAAI,CAAC,EAAG,CAAC,EACtC,GAAgB,EAAI,CAAC,EACrB,GAAQ,EAAI,EAAM,EAAM,EAAQ,EAAG,CAAC,CACxC,EAEM,GAAU,SAAS,EAAI,EAAM,CAE/B,GAAI,GAAK,EAAG,GACR,EAAK,GAAI,IACb,GAAW,EAAI,EAAI,CAAC,EACpB,EAAK,UAAU,CAAE,EACjB,GAAI,GAAU,GAAc,CAAE,EAC9B,OAAQ,EAAG,EAAE,WACJ,IAA8B,GAAO,EAAI,EAAS,CAAI,EAAG,UACzD,QAAmC,GAAE,MAAO,GAAQ,EAAI,CAAO,EAAG,cAC9D,EAAK,iBAAiB,EAAI,GAAa,uBAAwB,EAAI,CAAC,EAEjF,GAAY,EAAI,EAAE,OAAQ,EAAE,OAAQ,CAAI,EACxC,GAAW,CAAE,CACjB,EAEM,GAAkB,SAAS,EAAI,EAAY,CAE7C,GAAI,GAAK,GAAI,IACT,EAAK,EAAG,GACR,EAAI,GAAI,IACR,EAMJ,GAJA,EAAK,UAAU,CAAE,EACjB,GAAK,EAAI,CAAC,EACV,GAAU,EAAI,EAAE,OAAO,EAEnB,EAAG,EAAE,QAAU,EAAE,SAAW,EAAG,EAAE,QAAU,EAAE,SAAU,CAIvD,IAHA,GAAe,EAAG,GAAI,CAAC,EACvB,GAAW,EAAI,EAAI,EAAK,EACxB,GAAS,EAAI,EAAE,CAAC,EACT,GAAS,EAAI,EAA4B,GAAE,CAClD,GAAI,GAAa,EAAI,CAAC,EAClB,UAAW,CAAE,EACN,EAEP,EAAK,GAAU,CAAE,CACzB,KACI,IAAc,EAAG,GAAI,CAAC,EACtB,GAAW,EAAI,EAAI,EAAK,EACxB,EAAK,EAAE,EAGX,UAAS,CAAE,EACX,GAAW,CAAE,EACT,GAAG,EAAE,QAAU,EAAE,SAAW,EAAG,EAAE,QAAU,EAAE,YAC7C,GAAa,GAAY,EAAI,EAAY,GAAU,CAAE,CAAC,GAC1D,GAAiB,EAAI,CAAE,EAEhB,CACX,EAEM,GAAS,SAAS,EAAI,EAAM,CAE9B,GAAI,GAAK,EAAG,GACR,EAAa,GAEjB,IADA,EAAa,GAAgB,EAAI,CAAU,EACpC,EAAG,EAAE,QAAU,EAAE,WACpB,EAAa,GAAgB,EAAI,CAAU,EAC/C,AAAI,GAAS,EAAI,EAAE,OAAO,GACtB,GAAM,CAAE,EACZ,GAAY,EAAI,EAAE,OAAQ,EAAE,MAAO,CAAI,EACvC,GAAiB,EAAI,CAAU,CACnC,EAEM,GAAY,SAAS,EAAI,CAC3B,GAAI,GAAI,GAAI,IACR,EAAK,EAAG,GACZ,GAAa,EAAI,GAAc,CAAE,CAAC,EAClC,GAAgB,EAAI,CAAC,EACrB,GAAK,EAAI,EAAG,EAAG,EAAG,UAAU,EAE5B,GAAU,EAAI,EAAE,EAAE,IAAI,EAAE,QAAU,EAAG,EACzC,EAEM,GAAY,SAAS,EAAI,CAE3B,GAAI,GAAQ,EACR,EACA,EAAI,GAAI,IACZ,EACI,IAAa,EAAI,GAAc,CAAE,CAAC,EAClC,UACK,GAAS,EAAI,EAA4B,GAClD,AAAI,GAAS,EAAI,EAA4B,EACzC,EAAQ,GAAQ,EAAI,CAAC,EAErB,GAAE,EAAI,EAAQ,MACd,EAAQ,GAEZ,GAAc,EAAI,EAAO,EAAO,CAAC,EACjC,GAAgB,EAAI,CAAK,CAC7B,EAEM,GAAW,SAAS,EAAI,EAAG,CAE7B,GAAI,GAAW,EAEf,IADA,GAAU,EAAI,CAAC,EACR,EAAG,EAAE,QAAU,IAClB,GAAS,EAAI,CAAC,EAClB,MAAI,GAAG,EAAE,QAAU,IACf,GAAW,EACX,GAAS,EAAI,CAAC,GAEX,CACX,EAEM,GAAW,SAAS,EAAI,EAAM,CAEhC,GAAI,GAAI,GAAI,IACR,EAAI,GAAI,IACZ,EAAK,UAAU,CAAE,EACjB,GAAI,GAAW,GAAS,EAAI,CAAC,EAC7B,GAAK,EAAI,EAAG,EAAU,CAAI,EAC1B,GAAc,EAAG,GAAI,EAAG,CAAC,EACzB,GAAa,EAAG,GAAI,CAAI,CAC5B,EAEM,GAAU,SAAS,EAAI,CAEzB,GAAI,GAAK,EAAG,GACR,EAAI,GAAI,IACZ,GAAY,EAAI,EAAE,CAAC,EACnB,AAAI,EAAG,EAAE,QAAU,IAAgC,EAAG,EAAE,QAAU,GAC9D,GAAE,KAAO,KACT,GAAW,EAAI,EAAG,CAAC,GAGnB,IAAgB,EAAI,EAAE,EAAE,IAAM,EAAQ,MAAO,GAAa,eAAgB,EAAI,CAAC,EAC/E,GAAS,GAAe,EAAI,EAAE,CAAC,EAAG,CAAC,EAE3C,EAEM,GAAU,SAAS,EAAI,CAEzB,GAAI,GAAK,EAAG,GACR,EAAI,GAAI,IACR,EAAO,EACX,AAAI,GAAa,EAAI,CAAC,GAAK,EAAG,EAAE,QAAU,GACtC,EAAQ,EAAO,EAEf,GAAO,GAAQ,EAAI,CAAC,EACpB,AAAI,GAAW,EAAE,CAAC,EACd,IAAgB,EAAI,CAAC,EACjB,EAAE,IAAM,EAAQ,OAAS,IAAS,GAClC,IAAW,GAAe,EAAI,CAAC,EAAG,EAAW,EAC7C,GAAW,GAAe,EAAI,CAAC,EAAE,IAAM,EAAG,OAAO,GAErD,EAAQ,EAAG,QACX,EAAO,IAEP,AAAI,IAAS,EACT,EAAQ,GAAgB,EAAI,CAAC,EAE7B,IAAiB,EAAI,CAAC,EACtB,EAAQ,EAAG,QACX,GAAW,IAAS,EAAG,QAAU,CAAK,IAIlD,GAAS,EAAI,EAAO,CAAI,EACxB,GAAS,EAAI,EAA4B,CAC7C,EAEM,GAAY,SAAS,EAAI,CAC3B,GAAI,GAAO,EAAG,WAEd,OADA,GAAW,CAAE,EACN,EAAG,EAAE,WACH,IAA8B,CAC/B,EAAK,UAAU,CAAE,EACjB,KACJ,KACK,GAAE,MAAO,CACV,GAAO,EAAI,CAAI,EACf,KACJ,KACK,GAAE,SAAU,CACb,GAAU,EAAI,CAAI,EAClB,KACJ,KACK,GAAE,MAAO,CACV,EAAK,UAAU,CAAE,EACjB,GAAM,CAAE,EACR,GAAY,EAAI,EAAE,OAAQ,EAAE,MAAO,CAAI,EACvC,KACJ,KACK,GAAE,OAAQ,CACX,GAAQ,EAAI,CAAI,EAChB,KACJ,KACK,GAAE,UAAW,CACd,GAAW,EAAI,CAAI,EACnB,KACJ,KACK,GAAE,YAAa,CAChB,GAAS,EAAI,CAAI,EACjB,KACJ,KACK,GAAE,SAAU,CACb,EAAK,UAAU,CAAE,EACjB,AAAI,GAAS,EAAI,EAAE,WAAW,EAC1B,GAAU,CAAE,EAEZ,GAAU,CAAE,EAChB,KACJ,KACK,GAAE,WAAY,CACf,EAAK,UAAU,CAAE,EACjB,GAAU,EAAI,GAAc,CAAE,EAAG,CAAI,EACrC,KACJ,KACK,GAAE,UAAW,CACd,EAAK,UAAU,CAAE,EACjB,GAAQ,CAAE,EACV,KACJ,KACK,GAAE,aACF,GAAE,QAAS,CACZ,GAAS,EAAI,GAAU,EAAG,EAAE,CAAC,EAC7B,KACJ,SACS,CACL,GAAS,CAAE,EACX,KACJ,EAEJ,GAAW,EAAG,GAAG,EAAE,cAAgB,EAAG,GAAG,SAAW,EAAG,GAAG,SAAW,EAAG,GAAG,OAAO,EAClF,EAAG,GAAG,QAAU,EAAG,GAAG,QACtB,GAAW,CAAE,CACjB,EAMM,GAAW,SAAS,EAAI,EAAI,CAC9B,GAAI,GAAK,GAAI,IACT,EAAI,GAAI,IACZ,GAAU,EAAI,EAAI,CAAE,EACpB,EAAG,EAAE,UAAY,GACjB,GAAS,EAAG,EAAQ,OAAQ,CAAC,EAC7B,GAAW,EAAI,EAAG,KAAM,CAAC,EACzB,EAAK,UAAU,CAAE,EACjB,GAAS,CAAE,EACX,GAAM,EAAI,EAAE,MAAM,EAClB,GAAW,CAAE,CACjB,EAEM,GAAc,SAAS,EAAG,EAAG,EAAM,EAAK,EAAM,EAAW,CAC3D,GAAI,GAAW,GAAI,GAAK,SACpB,EAAY,GAAI,IAChB,EAAK,GAAM,iBAAiB,EAAG,CAAC,EACpC,UAAI,YAAY,CAAC,EACjB,EAAE,MAAM,EAAE,IAAI,GAAG,YAAY,CAAE,EAC/B,EAAS,EAAI,GAAO,SAAS,CAAC,EAC9B,GAAI,YAAY,CAAC,EACjB,EAAE,MAAM,EAAE,IAAI,GAAG,UAAU,EAAS,CAAC,EACrC,EAAU,EAAI,EAAG,EAAI,GAAI,IAAM,CAAC,EAChC,EAAU,EAAE,OAAS,GAAS,EAAG,CAAI,EACrC,EAAS,KAAO,EAChB,EAAS,IAAM,EACf,EAAI,OAAO,EAAI,EAAI,GAAG,EAAI,EAAI,MAAM,EAAI,EACxC,EAAK,cAAc,EAAG,EAAU,EAAG,EAAU,EAAE,OAAQ,CAAS,EAChE,GAAS,EAAU,CAAS,EAC5B,GAAW,CAAC,EAAU,MAAQ,EAAU,OAAS,GAAK,CAAC,EAAS,EAAE,EAElE,GAAW,EAAI,OAAO,IAAM,GAAK,EAAI,GAAG,IAAM,GAAK,EAAI,MAAM,IAAM,CAAC,EACpE,MAAO,GAAE,MAAM,EAAE,EAAE,KACZ,CACX,EAGA,GAAO,QAAQ,QAAc,GAC7B,GAAO,QAAQ,QAAc,EAC7B,GAAO,QAAQ,QAAc,GAC7B,GAAO,QAAQ,YAAc,GAC7B,GAAO,QAAQ,UAAc,KChpD7B,mBAEA,GAAM,CACF,iBACA,eAAgB,CACZ,gBACA,eACA,YACA,eACA,eACA,gBAEJ,cAAe,CAAE,kBACjB,gBACA,gBACA,iBACA,KACE,GAAW,KACX,GAAW,KACX,GAAW,KACX,CACF,cACA,SACA,UACA,SACA,UACA,SACA,UACA,UACA,WACA,UACA,WACA,UACA,YACA,KACE,CAAE,eAAe,KACjB,CAAE,eAAe,KACjB,CACF,aACA,QACA,KAEA,GAAY,CAAC,GAAM,IAAM,GAAI,GAAI,GAAM,EAAE,EAEvC,GAAN,KAAqB,CAEjB,YAAY,EAAG,EAAG,EAAM,CACpB,KAAK,QAAU,EACf,KAAK,WAAa,EAClB,KAAK,gBAAkB,EACvB,KAAK,YAAc,EACnB,KAAK,WAAa,EAElB,GAAW,YAAa,IAAK,uCAAuC,EACpE,GAAW,GAAa,CAAI,CAAC,EAE7B,AAAI,EAAK,KAAO,IAAgC,EAAK,KAAO,GACxD,KAAK,KAAO,EAAK,SAAS,CAAC,EAC1B,AAAI,EAAK,IAAM,GAAc,GAC9B,KAAK,KAAO,GAAa,gBAAiB,EAAI,EAE9C,KAAK,KAAO,EAEhB,KAAK,EAAI,EACT,KAAK,EAAI,EAGT,KAAK,YAAc,GAAI,aACnB,KAAK,IAAI,KAAK,QAAS,KAAK,WAAY,KAAK,gBAAiB,KAAK,YAAa,KAAK,UAAU,CACnG,EACA,KAAK,GAAK,GAAI,UAAS,KAAK,WAAW,EACvC,KAAK,GAAK,GAAI,YAAW,KAAK,WAAW,CAC7C,CAEA,KAAK,EAAM,CACP,GAAI,GAAK,GAAI,YAAW,CAAI,EAC5B,MAAG,IAAU,KAAK,EAAG,EAAI,EAAG,CAAI,IAAM,GAClC,KAAK,MAAM,WAAW,EACnB,CACX,CAEA,UAAW,CACP,MAAI,IAAU,KAAK,EAAG,KAAK,GAAI,EAAG,CAAC,IAAM,GACrC,KAAK,MAAM,WAAW,EACnB,KAAK,GAAG,EACnB,CAEA,SAAU,CACN,MAAI,IAAU,KAAK,EAAG,KAAK,GAAI,EAAG,KAAK,OAAO,IAAM,GAChD,KAAK,MAAM,WAAW,EACnB,KAAK,GAAG,SAAS,EAAG,EAAI,CACnC,CAEA,YAAa,CACT,MAAI,IAAU,KAAK,EAAG,KAAK,GAAI,EAAG,KAAK,UAAU,IAAM,GACnD,KAAK,MAAM,WAAW,EACnB,KAAK,GAAG,WAAW,EAAG,EAAI,CACrC,CAEA,aAAc,CACV,MAAI,IAAU,KAAK,EAAG,KAAK,GAAI,EAAG,KAAK,WAAW,IAAM,GACpD,KAAK,MAAM,WAAW,EACnB,KAAK,GAAG,SAAS,EAAG,EAAI,CACnC,CAEA,YAAa,CACT,MAAO,MAAK,YAAY,CAC5B,CAEA,YAAa,CACT,GAAI,GAAO,KAAK,SAAS,EAGzB,MAFI,KAAS,KACT,GAAO,KAAK,WAAW,GACvB,IAAS,EACF,KACJ,GAAW,KAAK,EAAG,KAAK,KAAK,EAAK,CAAC,CAAC,CAC/C,CAGA,MAAO,OAAM,EAAG,EAAG,CACf,MAAS,CAAG,KAAM,IAAO,CAC7B,CAEA,SAAS,EAAG,CACR,GAAI,GAAI,KAAK,QAAQ,EACjB,EAAI,GAER,OAAS,GAAI,EAAG,EAAI,EAAG,IAAK,CACxB,AAAI,GAAU,KAAK,EAAG,KAAK,GAAI,EAAG,KAAK,eAAe,IAAM,GACxD,KAAK,MAAM,WAAW,EAC1B,GAAI,GAAM,KAAK,GAAG,UAAU,EAAG,EAAI,EACnC,EAAE,KAAK,GAAK,CACR,KAAQ,EACR,OAAS,GAAO,GAAU,EAAE,MAAM,GAAS,CAAC,EAC5C,EAAS,GAAO,GAAU,EAAE,MAAM,GAAS,CAAC,EAC5C,EAAS,GAAO,GAAU,EAAE,MAAM,GAAS,CAAC,EAC5C,EAAS,GAAO,GAAU,EAAE,MAAM,GAAS,CAAC,EAC5C,GAAS,GAAO,GAAU,EAAE,MAAM,GAAS,CAAC,EAC5C,GAAS,GAAO,GAAU,EAAE,MAAM,GAAS,CAAC,EAC5C,IAAU,IAAO,GAAU,EAAE,MAAM,GAAS,CAAC,GAAK,EACtD,CACJ,CACJ,CAEA,cAAc,EAAG,CACb,GAAI,GAAI,KAAK,QAAQ,EAErB,OAAS,GAAI,EAAG,EAAI,EAAG,IAAK,CACxB,GAAI,GAAI,KAAK,SAAS,EAEtB,OAAQ,OACC,IACD,EAAE,EAAE,KAAK,GAAI,IAAQ,OAAO,GAAU,IAAI,CAAC,EAC3C,UACC,IACD,EAAE,EAAE,KAAK,GAAI,IAAQ,OAAO,GAAc,KAAK,SAAS,IAAM,CAAC,CAAC,EAChE,UACC,IACD,EAAE,EAAE,KAAK,GAAI,IAAQ,OAAO,GAAa,KAAK,WAAW,CAAC,CAAC,EAC3D,UACC,IACD,EAAE,EAAE,KAAK,GAAI,IAAQ,OAAO,GAAa,KAAK,YAAY,CAAC,CAAC,EAC5D,UACC,QACA,IACD,EAAE,EAAE,KAAK,GAAI,IAAQ,OAAO,GAAa,KAAK,WAAW,CAAC,CAAC,EAC3D,cAEA,KAAK,MAAM,0BAA0B,IAAI,EAErD,CACJ,CAEA,WAAW,EAAG,CACV,GAAI,GAAI,KAAK,QAAQ,EAErB,OAAS,GAAI,EAAG,EAAI,EAAG,IACnB,EAAE,EAAE,GAAK,GAAI,IAAM,MAAM,KAAK,CAAC,EAC/B,KAAK,aAAa,EAAE,EAAE,GAAI,EAAE,MAAM,CAE1C,CAEA,aAAa,EAAG,CACZ,GAAI,GAAI,KAAK,QAAQ,EAErB,OAAS,GAAI,EAAG,EAAI,EAAG,IACnB,EAAE,SAAS,GAAK,CACZ,KAAS,KACT,QAAS,KAAK,SAAS,EACvB,IAAS,KAAK,SAAS,CAC3B,CAER,CAEA,UAAU,EAAG,CACT,GAAI,GAAI,KAAK,QAAQ,EACrB,OAAS,GAAI,EAAG,EAAI,EAAG,IACnB,EAAE,SAAS,GAAK,KAAK,QAAQ,EAEjC,EAAI,KAAK,QAAQ,EACjB,OAAS,GAAI,EAAG,EAAI,EAAG,IACnB,EAAE,QAAQ,GAAK,CACX,QAAS,KAAK,WAAW,EACzB,QAAS,KAAK,QAAQ,EACtB,MAAS,KAAK,QAAQ,CAC1B,EAGJ,EAAI,KAAK,QAAQ,EACjB,OAAS,GAAI,EAAG,EAAI,EAAG,IACnB,EAAE,SAAS,GAAG,KAAO,KAAK,WAAW,CAE7C,CAEA,aAAa,EAAG,EAAS,CACrB,EAAE,OAAS,KAAK,WAAW,EACvB,EAAE,SAAW,MACb,GAAE,OAAS,GACf,EAAE,YAAc,KAAK,QAAQ,EAC7B,EAAE,gBAAkB,KAAK,QAAQ,EACjC,EAAE,UAAY,KAAK,SAAS,EAC5B,EAAE,UAAY,KAAK,SAAS,IAAM,EAClC,EAAE,aAAe,KAAK,SAAS,EAC/B,KAAK,SAAS,CAAC,EACf,KAAK,cAAc,CAAC,EACpB,KAAK,aAAa,CAAC,EACnB,KAAK,WAAW,CAAC,EACjB,KAAK,UAAU,CAAC,CACpB,CAEA,aAAa,EAAG,EAAK,CACjB,GAAI,GAAO,KAAK,KAAK,EAAE,MAAM,EAC7B,AAAK,GAAa,EAAM,CAAC,GACrB,KAAK,MAAM,CAAG,CACtB,CAEA,aAAc,CACV,KAAK,aAAa,GAAc,SAAS,CAAC,EAAG,OAAO,EAEhD,KAAK,SAAS,IAAM,IACpB,KAAK,MAAM,qBAAqB,EAEhC,KAAK,SAAS,IAAM,GACpB,KAAK,MAAM,oBAAoB,EAEnC,KAAK,aAAa,GAAW,WAAW,EAExC,KAAK,QAAkB,KAAK,SAAS,EACrC,KAAK,WAAkB,KAAK,SAAS,EACrC,KAAK,gBAAkB,KAAK,SAAS,EACrC,KAAK,YAAkB,KAAK,SAAS,EACrC,KAAK,WAAkB,KAAK,SAAS,EAErC,KAAK,UAAU,KAAK,QAAS,EAAG,KAAK,EACrC,KAAK,UAAU,KAAK,WAAY,EAAG,QAAQ,EAC3C,KAAK,UAAU,KAAK,gBAAiB,EAAG,aAAa,EACrD,KAAK,UAAU,KAAK,YAAa,EAAG,SAAS,EAC7C,KAAK,UAAU,KAAK,WAAY,EAAG,QAAQ,EAEvC,KAAK,YAAY,IAAM,OACvB,KAAK,MAAM,wBAAwB,EAEnC,KAAK,WAAW,IAAM,OACtB,KAAK,MAAM,0BAA0B,CAE7C,CAEA,MAAM,EAAK,CACP,GAAQ,iBAAiB,KAAK,EAAG,GAAa,0BAA0B,EAAG,KAAK,KAAM,GAAa,CAAG,CAAC,EACvG,GAAI,WAAW,KAAK,EAAG,EAAa,CACxC,CAEA,UAAU,EAAM,EAAM,EAAO,CACzB,AAAI,IAAS,GACT,KAAK,MAAM,GAAG,oBAAwB,CAC9C,CACJ,EAEM,GAAc,SAAS,EAAG,EAAG,EAAM,CACrC,GAAI,GAAI,GAAI,IAAe,EAAG,EAAG,CAAI,EACrC,EAAE,YAAY,EACd,GAAI,GAAK,GAAM,iBAAiB,EAAG,EAAE,SAAS,CAAC,EAC/C,UAAI,YAAY,CAAC,EACjB,EAAE,MAAM,EAAE,IAAI,GAAG,YAAY,CAAE,EAC/B,EAAG,EAAI,GAAI,IAAM,MAAM,CAAC,EACxB,EAAE,aAAa,EAAG,EAAG,IAAI,EACzB,GAAW,EAAG,YAAc,EAAG,EAAE,SAAS,MAAM,EAEzC,CACX,EAEA,GAAO,QAAQ,YAAc,KCnS7B,mBAEA,GAAM,CACF,gBACA,eACA,oBACA,gBACA,gBACA,eACA,gBACA,eACA,iBACA,eAAgB,CACZ,YACA,YACA,YACA,aAEJ,cAAe,CACX,cACA,cACA,cACA,iBACA,UACA,cAEJ,aACA,qBACA,iBACA,KACE,GAAW,KACX,GAAW,KACX,GAAW,KACX,CACF,aACA,cACA,mBACA,KACE,GAAW,KACX,GAAW,KACX,GAAW,KACX,GAAW,KACX,CAAE,oBAAoB,KACtB,GAAW,KACX,CAAE,kBAAkB,KACpB,GAAW,KACX,GAAW,KACX,CAAE,YAAY,KAEd,GAAa,SAAS,EAAG,EAAQ,CACnC,GAAI,EAAE,IAAM,EACR,KAAO,EAAE,IAAM,GACX,EAAE,MAAM,EAAE,OAAS,GAAI,IAAQ,OAAO,GAAU,IAAI,MAExD,MAAO,EAAE,IAAM,GACX,MAAO,GAAE,MAAM,EAAE,EAAE,IAE/B,EAEM,GAAc,SAAS,EAAG,EAAS,EAAQ,CAC7C,GAAI,GAAc,EAAE,IAGpB,KAAO,EAAE,IAAM,EAAS,GACpB,EAAE,MAAM,EAAE,OAAS,GAAI,IAAQ,OAAO,GAAU,IAAI,EAExD,OAAQ,OACC,IAAY,CACb,GAAQ,YAAY,EAAG,EAAQ,GAAgB,EAAG,mBAAmB,CAAC,EACtE,KACJ,KACK,IAAY,CACb,GAAQ,YAAY,EAAG,EAAQ,GAAgB,EAAG,yBAAyB,CAAC,EAC5E,KACJ,SAEI,GAAQ,UAAU,EAAG,EAAQ,EAAc,CAAC,EAIpD,KAAO,EAAE,IAAM,EAAS,GACpB,MAAO,GAAE,MAAM,EAAE,EAAE,IAC3B,EAEM,GAAiB,GAAgB,IAEjC,GAAoB,SAAS,EAAG,EAAS,CAC3C,GAAW,GAAW,IAAiB,GAAW,EAAc,EAChE,GAAW,EAAE,YAAc,EAAE,MAAM,OAAS,GAAO,WAAW,EAC9D,EAAE,MAAM,OAAS,EACjB,EAAE,WAAa,EAAU,GAAO,WACpC,EAEM,GAAiB,SAAS,EAAG,EAAG,CAClC,GAAI,GAAO,EAAE,MAAM,OACnB,GAAI,EAAO,GACP,GAAW,EAAG,EAAU,MACvB,CACD,GAAI,GAAS,EAAE,IAAM,EAAI,GAAO,YAC5B,EAAU,EAAI,EAClB,AAAI,EAAU,IAAe,GAAU,IACnC,EAAU,GAAQ,GAAU,GAChC,AAAI,EAAU,GACV,IAAkB,EAAG,EAAc,EACnC,GAAO,cAAc,EAAG,GAAa,iBAAkB,EAAI,CAAC,GAG5D,GAAkB,EAAG,CAAO,CACpC,CACJ,EAEM,GAAkB,SAAS,EAAG,EAAG,CACnC,AAAI,EAAE,WAAa,EAAE,KAAO,GACxB,GAAe,EAAG,CAAC,CAC3B,EAEM,GAAa,SAAS,EAAG,CAC3B,GAAI,GAAM,EAAE,IACZ,OAAS,GAAK,EAAE,GAAI,IAAO,KAAM,EAAK,EAAG,SACrC,AAAI,EAAM,EAAG,KAAK,GAAM,EAAG,KAE/B,UAAW,GAAO,EAAE,UAAU,EACvB,EAAM,CACjB,EAEM,GAAmB,SAAS,EAAG,CACjC,GAAI,GAAQ,GAAW,CAAC,EACpB,EAAW,EAAQ,KAAK,MAAM,EAAQ,CAAC,EAAI,EAAE,GAAO,YACxD,AAAI,EAAW,IACX,GAAW,IACX,EAAE,MAAM,OAAS,IACjB,GAAO,YAAY,CAAC,EAGpB,GAAU,GAAgB,GAAO,aAAgB,EAAW,EAAE,MAAM,QACpE,GAAkB,EAAG,CAAQ,CACrC,EAEM,GAAc,SAAS,EAAG,CAC5B,GAAgB,EAAG,CAAC,EACpB,EAAE,MAAM,EAAE,OAAS,GAAI,IAAQ,OAAO,GAAU,IAAI,CACxD,EASM,GAAe,SAAS,EAAG,EAAK,EAAU,CAC5C,GAAI,GAAO,EAAE,MAAM,GAEnB,OAAO,EAAK,UACH,QACA,IAAU,CACX,GAAI,GAAI,EAAK,OAAS,GAAW,EAAK,MAAM,EAAI,EAAK,MAErD,GAAgB,EAAG,EAAY,EAC/B,GAAI,GAAK,GAAO,cAAc,CAAC,EAC/B,EAAG,QAAU,EACb,EAAG,SAAW,EACd,EAAG,KAAO,EACV,EAAG,IAAM,EAAE,IAAM,GACjB,GAAW,EAAG,KAAO,EAAE,UAAU,EACjC,EAAG,WAAa,EACZ,EAAE,SAAW,IACb,GAAU,EAAG,GAAc,EAAE,EACjC,GAAI,GAAI,EAAE,CAAC,EACX,GAAI,MAAO,IAAM,UAAY,EAAI,GAAM,GAAE,KAAO,EAC5C,KAAM,OAAM,0DAA0D,EAC1E,UAAK,gBAAgB,EAAG,CAAC,EAEzB,GAAa,EAAG,EAAI,EAAE,IAAM,EAAG,CAAC,EAEzB,EACX,KACK,IAAU,CACX,GAAI,GACA,EAAI,EAAK,MAAM,EACf,EAAI,EAAE,IAAM,EAAM,EAClB,EAAQ,EAAE,aAEd,GADA,GAAgB,EAAG,CAAK,EACpB,EAAE,UACF,EAAO,GAAe,EAAG,EAAG,CAAC,MAC1B,CACH,KAAO,EAAI,EAAE,UAAW,IACpB,EAAE,MAAM,EAAE,OAAS,GAAI,IAAQ,OAAO,GAAU,IAAI,EACxD,EAAO,EAAM,CACjB,CAEA,GAAI,GAAK,GAAO,cAAc,CAAC,EAC/B,SAAG,QAAU,EACb,EAAG,SAAW,EACd,EAAG,KAAO,EACV,EAAG,OAAS,EACZ,EAAG,IAAM,EAAO,EAChB,GAAW,EAAG,EAAG,GAAG,EACpB,EAAG,OAAS,EAAE,KACd,EAAG,UAAY,EACf,EAAG,WAAa,GAAO,SACnB,EAAE,SAAW,IACb,GAAS,EAAG,CAAE,EACX,EACX,SAEI,UAAgB,EAAG,CAAC,EACpB,GAAU,EAAG,EAAK,CAAI,EACf,GAAa,EAAG,EAAK,CAAQ,EAEhD,EAEM,GAAe,SAAS,EAAG,EAAI,EAAa,EAAM,CACpD,GAAI,GAAS,EAAG,SAEhB,AAAI,EAAE,SAAY,IAAc,KACxB,GAAE,SAAW,IACb,GAAU,EAAG,GAAa,EAAE,EAChC,EAAE,MAAQ,EAAG,SAAS,WAG1B,GAAI,GAAM,EAAG,QACb,SAAE,GAAK,EAAG,SACV,EAAE,GAAG,KAAO,KACL,GAAY,EAAG,EAAa,EAAK,EAAM,CAAM,CACxD,EAEM,GAAc,SAAS,EAAG,EAAa,EAAK,EAAM,EAAQ,CAC5D,OAAQ,OACC,GACD,UACC,GAAG,CACJ,AAAI,IAAS,EACT,EAAE,MAAM,GAAK,YAAY,EAEzB,GAAQ,UAAU,EAAG,EAAK,CAAW,EAEzC,KACJ,KACK,IAAa,CACd,OAAS,GAAI,EAAG,EAAI,EAAM,IACtB,GAAQ,UAAU,EAAG,EAAM,EAAG,EAAc,CAAC,EACjD,OAAS,GAAE,EAAE,IAAK,GAAI,EAAM,EAAO,IAC/B,MAAO,GAAE,MAAM,GACnB,SAAE,IAAM,EAAM,EACP,EACX,SACS,CACL,GAAI,GACJ,GAAI,GAAU,EACV,IAAK,EAAI,EAAG,EAAI,EAAQ,IACpB,GAAQ,UAAU,EAAG,EAAM,EAAG,EAAc,CAAC,MAC9C,CACH,IAAK,EAAI,EAAG,EAAI,EAAM,IAClB,GAAQ,UAAU,EAAG,EAAM,EAAG,EAAc,CAAC,EACjD,KAAO,EAAI,EAAQ,IACf,AAAI,EAAI,GAAK,EAAE,IACX,EAAE,MAAM,EAAM,GAAK,GAAI,IAAQ,OAAO,GAAU,IAAI,EAEpD,EAAE,MAAM,EAAM,GAAG,YAAY,CAEzC,CACA,KACJ,EAEJ,GAAI,GAAS,EAAM,EACnB,OAAS,GAAE,EAAE,IAAK,GAAG,EAAQ,IACzB,MAAO,GAAE,MAAM,GACnB,SAAE,IAAM,EACD,EACX,EAOM,GAAY,SAAS,EAAG,EAAO,EAAM,CACvC,GAAI,GAAO,EAAE,KACb,GAAI,GAAQ,EAAE,UAAW,CACrB,GAAI,GAAK,EAAE,GACP,EAAM,EAAE,IACR,EAAS,EAAG,IACZ,EAAK,GAAI,IACb,EAAG,MAAQ,EACX,EAAG,YAAc,EACjB,EAAG,KAAO,EACV,GAAgB,EAAG,EAAY,EAC/B,EAAG,IAAM,EAAE,IAAM,GACjB,GAAW,EAAG,KAAO,EAAE,UAAU,EACjC,EAAE,UAAY,EACd,EAAG,YAAc,GAAO,YACxB,EAAK,EAAG,CAAE,EACV,GAAW,CAAC,EAAE,SAAS,EACvB,EAAE,UAAY,EACd,EAAG,IAAM,EACT,GAAW,EAAG,CAAG,EACjB,EAAG,YAAc,CAAC,GAAO,WAC7B,CACJ,EAEM,GAAW,SAAS,EAAG,EAAI,CAC7B,GAAI,GAAO,GACX,EAAG,YACE,EAAG,SAAS,WAAa,GAAO,UACnC,EAAG,SAAS,OAAO,EAAG,SAAS,UAAY,GAAG,QAAU,GAAS,SAAS,aACxE,GAAG,YAAc,GAAO,UACxB,EAAO,IAEX,GAAU,EAAG,EAAM,EAAE,EACrB,EAAG,WACP,EAEM,GAAiB,SAAS,EAAG,EAAG,EAAQ,CAC1C,GAAI,GAAW,EAAE,UAEb,EAAQ,EAAE,IAAM,EAChB,EAAO,EAAE,IAET,EACJ,IAAK,EAAI,EAAG,EAAI,GAAY,EAAI,EAAQ,IACpC,GAAQ,UAAU,EAAG,EAAE,MAAM,EAAQ,EAAE,EACvC,EAAE,MAAM,EAAQ,GAAG,YAAY,EAGnC,KAAO,EAAI,EAAU,IACjB,EAAE,MAAM,EAAE,OAAS,GAAI,IAAQ,OAAO,GAAU,IAAI,EAExD,MAAO,EACX,EAEM,GAAY,SAAS,EAAG,EAAK,EAAM,CACrC,GAAI,GAAK,GAAI,gBAAgB,EAAG,EAAM,GAAI,IAAI,OAAO,EACrD,AAAK,EAAG,aAAa,CAAE,GACnB,GAAO,eAAe,EAAG,EAAM,GAAa,OAAQ,EAAI,CAAC,EAE7D,GAAQ,UAAU,EAAG,EAAE,MAAM,EAAE,IAAI,EAAE,EACrC,OAAS,GAAI,EAAE,IAAI,EAAG,EAAI,EAAK,IAC3B,GAAQ,UAAU,EAAG,EAAG,EAAE,CAAC,EAC/B,GAAQ,SAAS,EAAG,EAAK,CAAE,CAC/B,EASM,GAAa,SAAS,EAAG,CAC3B,AAAI,EAAE,UAAY,GACd,GAAO,cAAc,EAAG,GAAa,oBAAqB,EAAI,CAAC,EAC1D,EAAE,SAAW,GAAkB,KAAkB,IACtD,GAAW,EAAG,EAAU,CAChC,EAQM,GAAY,SAAS,EAAG,EAAK,EAAU,CACzC,AAAI,EAAE,EAAE,SAAW,IACf,GAAW,CAAC,EACX,GAAa,EAAG,EAAK,CAAQ,GAC9B,GAAI,aAAa,CAAC,EACtB,EAAE,SACN,EAEM,GAAa,SAAS,EAAG,EAAS,CACpC,GAAI,EAAE,SACF,QAAE,SAAS,OAAS,EACd,EAAE,SACL,CACH,GAAI,GAAI,EAAE,IAEV,GADA,EAAE,OAAS,EACP,EAAE,WAAW,SACb,EAAE,WAAW,MAAM,EAAE,WAAW,OAAS,EAAE,MAAM,EAAE,IAAM,GACzD,GAAW,EAAE,WAAY,CAAO,MAC7B,CACH,GAAI,GAAQ,EAAE,MACd,KAAI,IACA,IAAY,EAAG,EAAS,EAAE,GAAG,EACzB,EAAE,GAAG,IAAM,EAAE,KACb,GAAE,GAAG,IAAM,EAAE,KACjB,EAAM,CAAC,GAEL,GAAI,OAAM,WAAW,GAAS,CACxC,CACJ,CACJ,EAEM,GAAuB,SAAS,EAAG,EAAG,EAAI,CAC5C,GAAI,GAAa,EAAE,QACf,EAAK,CACL,OAAQ,GACR,SAAU,EAAE,QAChB,EACA,EAAE,SAAW,EAEb,GAAI,CACA,EAAE,EAAG,CAAE,CACX,OAAS,EAAP,CACE,GAAI,EAAG,SAAW,GAAQ,CAGtB,GAAI,GAAgB,EAAE,IAAI,cAC1B,GAAI,EACA,GAAI,CASA,GARA,EAAG,OAAS,GAEZ,GAAK,kBAAkB,EAAG,CAAa,EACvC,GAAK,sBAAsB,EAAG,CAAC,EAC/B,GAAiB,EAAG,EAAE,IAAM,EAAG,CAAC,EAI5B,EAAE,UAAY,EAAG,CACjB,GAAI,GAAU,EAAE,QAChB,GAAQ,UAAU,EAAG,EAAE,MAAM,EAAE,IAAM,EAAE,EACvC,GAAQ,UAAU,EAAG,EAAE,IAAM,EAAG,CAAO,EACvC,GAAiB,EAAG,EAAE,IAAM,EAAG,CAAC,CACpC,CAEA,EAAG,OAAS,EAChB,OAAQ,EAAN,CACE,AAAI,EAAG,SAAW,IAEd,GAAG,OAAS,GAEpB,KAEA,GAAG,OAAS,EAEpB,CACJ,CAEA,SAAE,SAAW,EAAG,SAChB,EAAE,QAAU,EAEL,EAAG,MAEd,EAMM,GAAc,SAAS,EAAG,EAAQ,CACpC,GAAI,GAAK,EAAE,GAGX,GAAW,EAAG,MAAQ,MAAQ,EAAE,MAAQ,CAAC,EAEzC,GAAW,EAAG,WAAa,GAAO,aAAe,IAAW,EAAS,EAEjE,EAAG,WAAa,GAAO,aACvB,GAAG,YAAc,CAAC,GAAO,YACzB,EAAE,QAAU,EAAG,eAKf,EAAG,WAAa,IAAe,EAAE,GAAG,IAAM,EAAE,KAAK,GAAE,GAAG,IAAM,EAAE,KAClE,GAAI,GAAM,EAAG,IACT,EAAI,EAAI,EAAG,EAAQ,EAAG,KAAK,EAC/B,GAAK,gBAAgB,EAAG,CAAC,EACzB,GAAa,EAAG,EAAI,EAAE,IAAM,EAAG,CAAC,CACpC,EAUM,GAAS,SAAS,EAAG,EAAI,CAI3B,IAHI,IAAO,MACP,GAAY,EAAG,CAAE,EAEd,EAAE,KAAO,EAAE,SACd,AAAM,EAAE,GAAG,WAAa,GAAO,SAG3B,IAAI,cAAc,CAAC,EACnB,GAAI,aAAa,CAAC,GAHlB,GAAY,EAAG,EAAS,CAMpC,EAMM,GAAY,SAAS,EAAG,CAC1B,OAAS,GAAK,EAAE,GAAI,IAAO,KAAM,EAAK,EAAG,SACrC,GAAI,EAAG,WAAa,GAAO,YACvB,MAAO,GAGf,MAAO,KACX,EAOM,GAAU,SAAS,EAAG,EAAQ,CAChC,GAAI,GAAK,GAAU,CAAC,EACpB,GAAI,IAAO,KAAM,MAAO,GAExB,GAAI,GAAS,EAAG,MAChB,UAAM,WAAW,EAAG,CAAM,EAC1B,GAAY,EAAG,EAAQ,CAAM,EAC7B,EAAE,GAAK,EACP,EAAE,UAAY,EAAG,WAAa,GAAO,SACrC,EAAE,IAAM,EACR,GAAiB,CAAC,EAClB,EAAE,QAAU,EAAG,cACR,CACX,EAOM,GAAe,SAAS,EAAG,EAAK,EAAM,CACxC,GAAI,GAAK,GAAgB,EAAG,CAAG,EAC/B,GAAI,IAAS,EACT,GAAQ,aAAa,EAAG,CAAE,EAC1B,GAAU,EAAG,EAAE,KAAO,EAAE,GAAG,IAAK,gBAAgB,MAC7C,CAEH,OAAS,GAAE,EAAG,EAAE,EAAM,IAClB,MAAO,GAAE,MAAM,EAAE,EAAE,KACvB,GAAQ,YAAY,EAAG,EAAE,IAAI,EAAG,CAAE,CACtC,CACA,MAAO,GACX,EASM,GAAS,SAAS,EAAG,EAAG,CAC1B,GAAI,GAAW,EAAE,IAAM,EACnB,EAAK,EAAE,GACX,AAAI,EAAE,SAAW,GACR,GAAa,EAAG,EAAW,EAAG,EAAW,GAC1C,GAAI,aAAa,CAAC,EAEtB,IAAW,EAAE,SAAW,EAAS,EACjC,EAAE,OAAS,GACX,EAAG,QAAU,EAAG,MAChB,EAAG,KAAO,EAAE,MAAM,EAAG,SAErB,AAAI,EAAG,WAAa,GAAO,SACvB,GAAI,aAAa,CAAC,EAEd,GAAG,MAAQ,MACX,GAAI,EAAG,IAAI,EAAG,GAAW,EAAG,KAAK,EACjC,GAAK,gBAAgB,EAAG,CAAC,EACzB,EAAW,EAAE,IAAM,GAGvB,GAAa,EAAG,EAAI,EAAU,CAAC,GAGnC,GAAO,EAAG,IAAI,EAEtB,EAEM,GAAa,SAAS,EAAG,EAAM,EAAO,CACxC,GAAI,GAAS,EAAE,IAEf,GAAI,EAAE,SAAW,IACb,GAAI,EAAE,KAAO,EAAE,QACX,MAAO,IAAa,EAAG,wCAAyC,CAAK,UAClE,EAAE,SAAW,GACpB,MAAO,IAAa,EAAG,+BAAgC,CAAK,EAGhE,GADA,EAAE,QAAU,EAAO,EAAK,QAAU,EAAI,EAClC,EAAE,SAAW,GACb,MAAO,IAAa,EAAG,oBAAqB,CAAK,EAErD,EAAE,IAAM,EAER,GAAK,gBAAgB,EAAG,EAAE,SAAW,GAAS,EAAQ,EAAG,CAAK,EAE9D,GAAI,GAAS,GAAqB,EAAG,GAAQ,CAAK,EAClD,GAAI,IAAW,GACX,EAAS,OACR,CACD,KAAO,EAAS,IAAa,GAAQ,EAAG,CAAM,GAE1C,EAAS,GAAqB,EAAG,GAAQ,CAAM,EAGnD,AAAI,EAAS,GACT,GAAE,OAAS,EACX,GAAY,EAAG,EAAQ,EAAE,GAAG,EAC5B,EAAE,GAAG,IAAM,EAAE,KAEb,GAAW,IAAW,EAAE,MAAM,CACtC,CAEA,SAAE,IAAM,EACR,EAAE,UACF,GAAW,EAAE,UAAa,GAAO,EAAK,QAAU,EAAE,EAC3C,CACX,EAEM,GAAkB,SAAS,EAAG,CAChC,MAAO,GAAE,MAAQ,CACrB,EAEM,GAAa,SAAS,EAAG,EAAU,EAAK,EAAG,CAC7C,GAAI,GAAK,EAAE,GACX,UAAK,gBAAgB,EAAG,CAAQ,EAE5B,EAAE,IAAM,GACR,CAAI,IAAM,EAAE,IAAI,WACZ,GAAO,cAAc,EAAG,GAAa,6CAA8C,EAAI,CAAC,EAExF,GAAO,cAAc,EAAG,GAAa,4CAA6C,EAAI,CAAC,GAG/F,EAAE,OAAS,GACX,EAAG,MAAQ,EAAG,QACd,AAAI,EAAG,WAAa,GAAO,SACvB,GAAU,EAAG,IAAM,KAAM,sCAAsC,EAE/D,GAAG,IAAM,EACL,IAAM,MACN,GAAG,MAAQ,GACf,EAAG,QAAU,EAAE,IAAM,EAAW,EAChC,EAAG,KAAO,EAAE,MAAM,EAAG,SACrB,GAAW,EAAG,EAAS,GAG3B,GAAW,EAAG,WAAa,GAAO,WAAW,EACtC,CACX,EAEM,GAAY,SAAS,EAAG,EAAG,CAC7B,GAAW,EAAG,EAAG,EAAG,IAAI,CAC5B,EAEM,GAAa,SAAS,EAAG,EAAM,EAAG,EAAS,EAAI,CACjD,GAAI,GAAS,EAAE,GACX,EAAiB,EAAE,UACnB,EAAU,EAAE,IACZ,EAAc,EAAE,QACpB,EAAE,QAAU,EAEZ,GAAI,GAAS,GAAqB,EAAG,EAAM,CAAC,EAE5C,MAAI,KAAW,IACX,IAAM,WAAW,EAAG,CAAO,EAC3B,GAAY,EAAG,EAAQ,CAAO,EAC9B,EAAE,GAAK,EACP,EAAE,UAAY,EACd,EAAE,IAAM,EACR,GAAiB,CAAC,GAGtB,EAAE,QAAU,EAEL,CACX,EAKM,GAAmB,SAAS,EAAG,EAAK,EAAU,CAChD,EAAE,MACF,GAAU,EAAG,EAAK,CAAQ,EAC1B,EAAE,KACN,EAKM,GAAN,KAAc,CACV,YAAY,EAAG,EAAM,EAAM,CACvB,KAAK,EAAI,EACT,KAAK,KAAO,GAAI,IAChB,KAAK,IAAM,GAAI,IAAQ,QACvB,KAAK,KAAO,EACZ,KAAK,KAAO,CAChB,CACJ,EAEM,GAAY,SAAS,EAAG,EAAM,EAAG,CACnC,AAAI,GAAQ,GAAkB,EAAM,EAAE,EAAE,IAAM,IAC1C,IAAQ,iBAAiB,EACrB,GAAa,2CAA2C,EAAG,EAAG,CAAI,EACtE,GAAW,EAAG,EAAa,EAEnC,EAEM,GAAW,SAAS,EAAG,EAAG,CAC5B,GAAI,GACA,EAAI,EAAE,EAAE,MAAM,EAClB,AAAI,IAAM,GAAc,GACpB,IAAU,EAAG,EAAE,KAAM,GAAa,SAAU,EAAI,CAAC,EACjD,EAAK,GAAQ,YAAY,EAAG,EAAE,EAAG,EAAE,IAAI,GAEvC,IAAU,EAAG,EAAE,KAAM,GAAa,OAAQ,EAAI,CAAC,EAC/C,EAAK,GAAQ,YAAY,EAAG,EAAE,EAAG,EAAE,KAAM,EAAE,IAAK,EAAE,KAAM,CAAC,GAG7D,GAAW,EAAG,YAAc,EAAG,EAAE,SAAS,MAAM,EAChD,GAAM,gBAAgB,EAAG,CAAE,CAC/B,EAEM,GAAuB,SAAS,EAAG,EAAG,EAAM,EAAM,CACpD,GAAI,GAAI,GAAI,IAAQ,EAAG,EAAM,CAAI,EACjC,EAAE,MACF,GAAI,GAAS,GAAW,EAAG,GAAU,EAAG,EAAE,IAAK,EAAE,OAAO,EACxD,SAAE,MACK,CACX,EAEA,GAAO,QAAQ,WAAuB,GACtC,GAAO,QAAQ,UAAuB,GACtC,GAAO,QAAQ,iBAAuB,GACtC,GAAO,QAAQ,gBAAuB,GACtC,GAAO,QAAQ,eAAuB,GACtC,GAAO,QAAQ,UAAuB,GACtC,GAAO,QAAQ,YAAuB,GACtC,GAAO,QAAQ,WAAuB,GACtC,GAAO,QAAQ,aAAuB,GACtC,GAAO,QAAQ,aAAuB,GACtC,GAAO,QAAQ,qBAAuB,GACtC,GAAO,QAAQ,qBAAuB,GACtC,GAAO,QAAQ,kBAAuB,GACtC,GAAO,QAAQ,WAAuB,GACtC,GAAO,QAAQ,gBAAuB,GACtC,GAAO,QAAQ,WAAuB,GACtC,GAAO,QAAQ,UAAuB,GACtC,GAAO,QAAQ,WAAuB,KC7uBtC,mBAEA,GAAM,CACF,iBACA,gBACA,iBACA,gBACA,eAAgB,CACZ,gBACA,YACA,eAEJ,cAAe,CACX,cACA,cAEJ,mBACA,gBACA,qBACA,gBACA,KACE,CACF,aACA,eACA,KACE,CAAE,eAAe,KACjB,GAAW,KACX,GAAW,KACX,GAAW,KACX,GAAW,KACX,GAAW,KACX,GAAW,KACX,GAAW,KACX,GAAW,KACX,GAAW,KACX,GAAW,KAEX,GAAY,SAAS,EAAI,CAC3B,UAAW,EAAG,WAAa,GAAO,QAAQ,EACnC,EAAG,UAAY,CAC1B,EAEM,GAAc,SAAS,EAAI,CAC7B,MAAO,GAAG,KAAK,MAAM,EAAE,SAAS,SAAW,EAAI,EAAG,KAAK,MAAM,EAAE,SAAS,GAAU,CAAE,GAAK,EAC7F,EAQM,GAAY,SAAS,EAAG,CAC1B,GAAI,EAAE,SAAW,GAAW,CACxB,GAAI,GAAK,EAAE,GACP,EAAO,EAAG,QACd,EAAG,KAAO,EAAE,MAAM,EAAG,OACrB,EAAG,QAAU,EAAG,MAChB,EAAG,MAAQ,CACf,CACJ,EAEM,GAAc,SAAS,EAAG,EAAM,EAAM,EAAO,CAC/C,AAAI,KAAS,MAAQ,IAAS,IAC1B,GAAO,EACP,EAAO,MAEP,EAAE,GAAG,WAAa,GAAO,UACzB,GAAE,MAAQ,EAAE,GAAG,WACnB,EAAE,KAAO,EACT,EAAE,cAAgB,EAClB,EAAE,UAAY,EAAE,cAChB,EAAE,SAAW,CACjB,EAEM,GAAc,SAAS,EAAG,CAC5B,MAAO,GAAE,IACb,EAGM,GAAkB,SAAS,EAAG,CAChC,MAAO,GAAE,QACb,EAGM,GAAmB,SAAS,EAAG,CACjC,MAAO,GAAE,aACb,EAEM,GAAe,SAAS,EAAG,EAAO,EAAI,CACxC,GAAI,GACA,EACJ,GAAI,EAAQ,EAAG,MAAO,GACtB,IAAK,EAAK,EAAE,GAAI,EAAQ,GAAK,IAAO,EAAE,QAAS,EAAK,EAAG,SACnD,IACJ,MAAI,KAAU,GAAK,IAAO,EAAE,QACxB,GAAS,EACT,EAAG,KAAO,GAEV,EAAS,EACN,CACX,EAEM,GAAY,SAAS,EAAG,EAAI,CAC9B,GAAW,EAAK,EAAE,SAAS,MAAM,EACjC,GAAI,GAAI,EAAE,SAAS,GAAI,KACvB,MAAI,KAAM,KAAa,EAAa,IAAK,EAAI,EACtC,EAAE,OAAO,CACpB,EAEM,GAAa,SAAS,EAAI,EAAG,CAC/B,GAAI,GAAU,EAAG,KAAK,MAAM,EAAE,UAC9B,MAAI,IAAK,EAAG,OAAS,EAAG,QAAU,EACvB,KAEA,CACH,IAAK,EAAG,QAAU,EAAU,EAC5B,KAAM,EAAa,YAAa,EAAI,CACxC,CAER,EAEM,GAAY,SAAS,EAAG,EAAI,EAAG,CACjC,GAAI,GAAM,EAAO,KAEjB,GAAI,EAAG,WAAa,GAAO,SAAU,CACjC,GAAI,EAAI,EACJ,MAAO,IAAW,EAAI,CAAC,CAAC,EAExB,EAAO,EAAG,OACV,EAAO,GAAM,kBAAkB,EAAG,KAAK,MAAM,EAAG,EAAG,GAAU,CAAE,CAAC,CAExE,KACI,GAAO,EAAG,QAAU,EAExB,GAAI,IAAS,KAET,GAAI,AADQ,KAAO,EAAE,GAAK,EAAE,IAAM,EAAG,KAAK,SAC9B,GAAQ,GAAK,EAAI,EACzB,EAAO,EAAa,eAAgB,EAAI,MAExC,OAAO,MAEf,MAAO,CACH,IAAK,EAAQ,GAAI,GACjB,KAAM,CACV,CACJ,EAEM,GAAe,SAAS,EAAG,EAAI,EAAG,CACpC,GAAI,GAEJ,GADA,GAAU,CAAC,EACP,IAAO,KACP,AAAK,EAAE,MAAM,EAAE,IAAM,GAAG,aAAa,EAGjC,EAAO,GAAM,kBAAkB,EAAE,MAAM,EAAE,IAAM,GAAG,MAAM,EAAG,EAAG,CAAC,EAF/D,EAAO,SAGR,CACH,GAAI,GAAQ,GAAU,EAAG,EAAG,KAAM,CAAC,EACnC,AAAI,EACA,GAAO,EAAM,KACb,GAAQ,UAAU,EAAG,EAAE,MAAM,EAAM,IAAI,EACvC,GAAU,EAAG,EAAE,KAAO,EAAE,GAAG,IAAK,gBAAgB,GAEhD,EAAO,IAEf,CACA,UAAU,CAAC,EACJ,CACX,EAEM,GAAe,SAAS,EAAG,EAAI,EAAG,CACpC,GAAI,GACJ,GAAU,CAAC,EACX,GAAI,GAAQ,GAAU,EAAG,EAAG,KAAM,CAAC,EACnC,MAAI,GACA,GAAO,EAAM,KACb,GAAQ,UAAU,EAAG,EAAM,IAAK,EAAE,IAAM,CAAC,EACzC,MAAO,GAAE,MAAM,EAAE,EAAE,MAEnB,EAAO,KAEX,GAAU,CAAC,EACJ,CACX,EAEM,GAAW,SAAS,EAAI,EAAI,CAC9B,GAAI,IAAO,MAAQ,YAAc,IAAQ,SACrC,EAAG,OAAS,EAAa,QAAS,EAAI,EACtC,EAAG,YAAc,GACjB,EAAG,gBAAkB,GACrB,EAAG,KAAO,EAAa,IAAK,EAAI,MAC7B,CACH,GAAI,GAAI,EAAG,EACX,EAAG,OAAS,EAAE,OAAS,EAAE,OAAO,OAAO,EAAI,EAAa,KAAM,EAAI,EAClE,EAAG,YAAc,EAAE,YACnB,EAAG,gBAAkB,EAAE,gBACvB,EAAG,KAAO,EAAG,cAAgB,EAAI,EAAa,OAAQ,EAAI,EAAI,EAAa,MAAO,EAAI,CAC1F,CAEA,EAAG,UAAY,GAAQ,aAAa,EAAG,OAAQ,EAAU,CAC7D,EAEM,GAAoB,SAAS,EAAG,EAAG,CACrC,GAAI,IAAM,MAAQ,YAAa,IAAQ,SACnC,EAAE,MAAM,EAAE,KAAO,GAAI,IAAQ,OAAO,GAAU,IAAI,EAClD,GAAK,aAAa,CAAC,MAChB,CACH,GAAI,GAAW,EAAE,EAAE,SACf,EAAI,GAAO,SAAS,CAAC,EACzB,EAAE,MAAM,EAAE,KAAO,GAAI,IAAQ,OAAO,GAAY,CAAC,EACjD,GAAK,aAAa,CAAC,EACnB,GAAI,GAAI,GAAI,IAAQ,OAAO,GAAc,EAAI,EAC7C,OAAS,GAAI,EAAG,EAAI,EAAS,OAAQ,IACjC,GAAO,YAAY,EAAG,EAAS,GAAI,CAAC,CAC5C,CACJ,EAEM,GAAc,SAAS,EAAG,EAAI,CAChC,GAAI,GAAI,CACJ,KAAM,KACN,SAAU,IACd,EACA,MAAI,KAAO,KACA,KACF,EAAG,WAAa,GAAO,SAC5B,GAAE,KAAO,EAAa,OAAQ,EAAI,EAClC,EAAE,SAAW,EAAa,aAAc,EAAI,EACrC,GAGF,CAAE,GAAG,WAAa,GAAO,YAAc,EAAG,SAAS,WAAa,GAAO,SACrE,GAAiB,EAAG,EAAG,QAAQ,EAC9B,IAChB,EAEM,GAAa,SAAS,EAAG,EAAM,EAAI,EAAG,EAAI,CAC5C,GAAI,GAAS,EACb,KAAO,EAAK,OAAS,EAAG,EAAO,EAAK,SAAS,CAAC,EAC1C,OAAQ,EAAK,QACJ,IAA8B,CAC/B,GAAS,EAAI,CAAC,EACd,KACJ,KACK,KAA+B,CAChC,EAAG,YAAc,GAAM,EAAG,WAAa,GAAO,SAAW,GAAY,CAAE,EAAI,GAC3E,KACJ,KACK,KAA+B,CAChC,EAAG,KAAO,IAAM,KAAO,EAAI,EAAE,UAC7B,AAAI,IAAM,MAAQ,YAAa,IAAQ,SACnC,GAAG,SAAW,GACd,EAAG,QAAU,GAEb,GAAG,SAAW,EAAE,EAAE,UAClB,EAAG,QAAU,EAAE,EAAE,WAErB,KACJ,KACK,KAA+B,CAChC,EAAG,WAAa,EAAK,EAAG,WAAa,GAAO,UAAY,EACxD,KACJ,KACK,KAA+B,CAChC,GAAI,GAAI,GAAY,EAAG,CAAE,EACzB,AAAI,IAAM,KACN,GAAG,SAAW,EAAa,GAAI,EAAI,EACnC,EAAG,KAAO,MAEV,GAAG,SAAW,EAAE,SAChB,EAAG,KAAO,EAAE,MAEhB,KACJ,KACK,QACA,KACD,cACK,EAAS,EAI1B,MAAO,EACX,EAEM,GAAc,SAAS,EAAG,EAAM,EAAI,CACtC,EAAO,GAAgB,CAAI,EAC3B,GAAI,GAAQ,EAAI,EAAI,EACpB,UAAU,CAAC,EACX,AAAI,EAAK,KAAO,GACZ,GAAK,KACL,EAAO,EAAE,MAAM,EAAE,IAAM,GACvB,GAAU,EAAG,EAAK,aAAa,EAAG,mBAAmB,EACrD,EAAO,EAAK,SAAS,CAAC,EACtB,EAAE,OAEF,GAAK,EAAG,KACR,EAAO,EAAG,KACV,GAAW,EAAG,KAAK,aAAa,CAAC,GAGrC,EAAK,EAAK,YAAY,EAAI,EAAK,MAAQ,KACvC,EAAS,GAAW,EAAG,EAAM,EAAI,EAAI,CAAE,EACnC,GAAkB,EAAM,GAA6B,GAAK,GAC1D,IAAQ,UAAU,EAAG,CAAI,EACzB,GAAU,EAAG,EAAE,KAAO,EAAE,GAAG,IAAK,gBAAgB,GAGpD,GAAU,CAAC,EACP,GAAkB,EAAM,EAA4B,GAAK,GACzD,GAAkB,EAAG,CAAE,EAEpB,CACX,EAEM,GAAQ,SAAS,EAAG,EAAI,EAAG,CAC7B,GAAI,GAAI,CACJ,KAAM,KACN,SAAU,IACd,EAEA,GAAI,GAAS,IAAI,CAAC,EAAG,CACjB,GAAI,GAAS,EAAE,EAAE,GAAS,OAAO,CAAC,GAClC,GAAI,EAAO,WAAW,EAClB,SAAE,KAAO,EAAO,OAAO,EAChB,CAGf,KAAO,CACH,GAAI,GAAO,GAAW,EAAG,EAAI,CAAC,EAC9B,GAAI,GAAQ,EAAK,SAAS,KAAO,GAC7B,MAAO,EAGf,CACA,SAAE,KAAO,EAAa,IAAK,EAAI,EACxB,CACX,EAEM,GAAW,SAAS,EAAI,EAAW,CACrC,MAAI,GAAK,EACE,GACC,CAChB,EAKM,GAAa,SAAS,EAAG,EAAQ,EAAK,CACxC,GAAI,GAAS,GACT,EAAY,EACZ,EAAM,GAAS,SACnB,OAAS,GAAK,EAAG,EAAK,EAAQ,IAAM,CAChC,GAAI,GAAI,EAAE,KAAK,GACX,EAAI,EAAE,EACV,OAAQ,EAAE,YACD,GAAI,WAAY,CACjB,GAAI,GAAI,EAAE,EACV,AAAI,GAAK,GAAO,GAAO,EAAI,GACvB,GAAS,GAAS,EAAI,CAAS,GACnC,KACJ,KACK,GAAI,YAAa,CAClB,AAAI,GAAO,EAAI,GACX,GAAS,GAAS,EAAI,CAAS,GACnC,KACJ,KACK,GAAI,YACJ,GAAI,YAAa,CAClB,AAAI,GAAO,GACP,GAAS,GAAS,EAAI,CAAS,GACnC,KACJ,KACK,GAAI,OAAQ,CACb,GAAI,GAAI,EAAE,IACN,EAAO,EAAK,EAAI,EAEpB,AAAI,EAAK,GAAQ,GAAQ,GACjB,EAAO,GACP,GAAY,GAEpB,KACJ,SAEI,AAAI,GAAS,UAAU,EAAE,MAAM,GAAK,IAAQ,GACxC,GAAS,GAAS,EAAI,CAAS,GACnC,MAEZ,CAEA,MAAO,EACX,EAGM,GAAa,SAAS,EAAG,EAAQ,EAAK,CACxC,GAAI,GAAI,CACJ,KAAM,GAAM,kBAAkB,EAAG,EAAM,EAAG,CAAM,EAChD,SAAU,IACd,EAEA,GAAI,EAAE,KACF,SAAE,SAAW,EAAa,QAAS,EAAI,EAChC,EAIX,GAAI,GAAK,GAAW,EAAG,EAAQ,CAAG,EAC9B,EAAM,GAAS,SACnB,GAAI,IAAO,GAAI,CACX,GAAI,GAAI,EAAE,KAAK,GACf,OAAQ,EAAE,YACD,GAAI,QAAS,CACd,GAAI,GAAI,EAAE,EACV,GAAI,EAAI,EAAE,EACN,MAAO,IAAW,EAAG,EAAI,CAAC,EAC9B,KACJ,KACK,GAAI,gBACJ,GAAI,YAAa,CAClB,GAAI,GAAI,EAAE,EACN,EAAI,EAAE,EACN,EAAK,EAAE,SAAW,EAAI,YAAc,GAAM,kBAAkB,EAAG,EAAI,EAAG,CAAE,EAAI,GAAU,EAAG,CAAC,EAC9F,SAAE,KAAO,GAAM,EAAG,EAAI,CAAC,EAAE,KACzB,EAAE,SAAY,GAAM,GAAa,EAAI,GAAK,OAAO,EAAK,EAAa,SAAU,EAAI,EAAI,EAAa,QAAS,EAAI,EACxG,CACX,KACK,GAAI,YACL,SAAE,KAAO,GAAU,EAAG,EAAE,CAAC,EACzB,EAAE,SAAW,EAAa,UAAW,EAAI,EAClC,MAEN,GAAI,aACJ,GAAI,UAAW,CAChB,GAAI,GAAI,EAAE,SAAW,EAAI,SAAW,EAAE,GAAK,EAAE,KAAK,EAAK,GAAG,GAC1D,GAAI,EAAE,EAAE,GAAG,WAAW,EAClB,SAAE,KAAO,EAAE,EAAE,GAAG,OAAO,EACvB,EAAE,SAAW,EAAa,WAAY,EAAI,EACnC,EAEX,KACJ,KACK,GAAI,QAAS,CACd,GAAI,GAAI,EAAE,EACV,SAAE,KAAO,GAAM,EAAG,EAAI,CAAC,EAAE,KACzB,EAAE,SAAW,EAAa,SAAU,EAAI,EACjC,CACX,SACS,MAEjB,CAEA,MAAO,KACX,EAQM,GAAmB,SAAS,EAAG,EAAI,CACrC,GAAI,GAAI,CACJ,KAAM,KACN,SAAU,IACd,EAEI,EAAK,EACL,EAAI,EAAG,KAAK,MAAM,EAClB,EAAK,GAAU,CAAE,EACjB,EAAI,EAAE,KAAK,GACX,EAAM,GAAS,SAEnB,GAAI,EAAG,WAAa,GAAO,YACvB,SAAE,KAAO,EAAa,IAAK,EAAI,EAC/B,EAAE,SAAW,EAAa,OAAQ,EAAI,EAC/B,EAGX,OAAQ,EAAE,YACD,GAAI,YACJ,GAAI,YACL,MAAO,IAAW,EAAG,EAAI,EAAE,CAAC,MAC3B,GAAI,YACL,SAAE,KAAO,EAAa,eAAgB,EAAI,EAC1C,EAAE,SAAW,EAAa,eAAgB,EAAI,EACvC,MAEN,GAAI,YACJ,GAAI,gBACJ,GAAI,YACL,EAAK,GAAI,IAAI,SACb,UACC,GAAI,gBACJ,GAAI,YACL,EAAK,GAAI,IAAI,YACb,UACC,GAAI,OAAW,EAAK,GAAI,IAAI,OAAW,UACvC,GAAI,OAAW,EAAK,GAAI,IAAI,OAAW,UACvC,GAAI,OAAW,EAAK,GAAI,IAAI,OAAW,UACvC,GAAI,OAAW,EAAK,GAAI,IAAI,OAAW,UACvC,GAAI,OAAW,EAAK,GAAI,IAAI,OAAW,UACvC,GAAI,OAAW,EAAK,GAAI,IAAI,OAAW,UACvC,GAAI,QAAW,EAAK,GAAI,IAAI,QAAW,UACvC,GAAI,QAAW,EAAK,GAAI,IAAI,QAAW,UACvC,GAAI,OAAW,EAAK,GAAI,IAAI,OAAW,UACvC,GAAI,QAAW,EAAK,GAAI,IAAI,QAAW,UACvC,GAAI,OAAW,EAAK,GAAI,IAAI,OAAW,UACvC,GAAI,OAAW,EAAK,GAAI,IAAI,OAAW,UACvC,GAAI,OAAW,EAAK,GAAI,IAAI,OAAW,UACvC,GAAI,QAAW,EAAK,GAAI,IAAI,QAAW,UACvC,GAAI,OAAW,EAAK,GAAI,IAAI,OAAW,UACvC,GAAI,UAAW,EAAK,GAAI,IAAI,UAAW,UACvC,GAAI,MAAW,EAAK,GAAI,IAAI,MAAW,UACvC,GAAI,MAAW,EAAK,GAAI,IAAI,MAAW,UACvC,GAAI,MAAW,EAAK,GAAI,IAAI,MAAW,cAExC,MAAO,MAGf,SAAE,KAAO,EAAE,IAAI,OAAO,GAAI,OAAO,EACjC,EAAE,SAAW,EAAa,aAAc,EAAI,EACrC,CACX,EAEM,GAAY,SAAS,EAAG,EAAI,EAAG,CACjC,OAAS,GAAI,EAAG,OAAQ,EAAI,EAAG,IAAK,IAChC,GAAI,EAAE,MAAM,KAAO,EACf,MAAO,GAGf,MAAO,EACX,EAOM,GAAe,SAAS,EAAG,EAAI,EAAG,CACpC,GAAI,GAAI,EAAG,KAAK,MAChB,OAAS,GAAI,EAAG,EAAI,EAAE,UAAW,IAC7B,GAAI,EAAE,OAAO,KAAO,EAChB,MAAO,CACH,KAAM,GAAU,EAAE,EAAG,CAAC,EACtB,SAAU,EAAa,UAAW,EAAI,CAC1C,EAIR,MAAO,KACX,EAEM,GAAU,SAAS,EAAG,EAAG,CAC3B,GAAI,GAAK,EAAE,GACP,EAAO,KACX,GAAI,EAAG,WAAa,GAAO,SAAU,CACjC,EAAO,GAAa,EAAG,EAAI,CAAC,EAC5B,GAAI,GAAQ,GAAU,EAAG,EAAI,CAAC,EAC9B,AAAI,CAAC,GAAQ,GACT,GAAO,GAAW,EAAG,KAAK,MAAM,EAAG,GAAU,CAAE,EAAG,EAAQ,EAAG,MAAM,EAC3E,CAEA,MAAO,GAAO,GAAQ,iBAAiB,EAAG,EAAa,aAAc,EAAI,EAAG,EAAK,SAAU,EAAK,IAAI,EAAI,EAAa,GAAI,EAAI,CACjI,EAEM,GAAiB,SAAS,EAAG,EAAG,EAAI,CACtC,GAAI,GAAI,GAAI,iBAAiB,EAAG,CAAC,EACjC,GAAc,EAAG,EAAa,6BAA8B,EAAI,EAAG,EAAI,EAAG,GAAQ,EAAG,CAAC,CAAC,CAC3F,EAEM,GAAmB,SAAS,EAAG,EAAI,EAAI,CACzC,AAAI,GAAG,WAAW,GAAK,GAAI,QAAQ,CAAE,IAAG,GAAK,GAC7C,GAAe,EAAG,EAAI,EAAa,cAAe,EAAI,CAAC,CAC3D,EAKM,GAAkB,SAAS,EAAG,EAAI,EAAI,EAAK,CAC7C,AAAI,GAAI,SAAS,CAAE,IAAM,IACrB,GAAK,GACT,GAAe,EAAG,EAAI,CAAG,CAC7B,EAEM,GAAkB,SAAS,EAAG,EAAI,EAAI,CACxC,GAAI,GAAK,GAAI,iBAAiB,EAAG,CAAE,EAC/B,EAAK,GAAI,iBAAiB,EAAG,CAAE,EACnC,AAAI,GAAa,EAAI,CAAE,EACnB,GAAc,EAAG,EAAa,mCAAoC,EAAI,EAAG,CAAE,EAE3E,GAAc,EAAG,EAAa,gCAAiC,EAAI,EAAG,EAAI,CAAE,CACpF,EAGM,GAAe,SAAS,EAAG,EAAK,EAAK,EAAM,CAC7C,GAAI,GACJ,MAAI,GACA,EAAO,GAAQ,aAAa,EAAI,OAAO,EAAG,EAAU,EAEpD,EAAO,EAAa,IAAK,EAAI,EAE1B,GAAQ,iBAAiB,EAAG,EAAa,YAAa,EAAI,EAAG,EAAM,EAAM,CAAG,CACvF,EAEM,GAAgB,SAAS,EAAG,KAAQ,EAAM,CAC5C,GAAI,GAAK,EAAE,GACP,EAAM,GAAQ,kBAAkB,EAAG,EAAK,CAAI,EAChD,AAAI,EAAG,WAAa,GAAO,UACvB,GAAa,EAAG,EAAK,EAAG,KAAK,MAAM,EAAE,OAAQ,GAAY,CAAE,CAAC,EAChE,GAAc,CAAC,CACnB,EAEM,GAAgB,SAAS,EAAG,CAC9B,GAAI,EAAE,UAAY,EAAG,CACjB,GAAI,GAAU,EAAE,QAChB,GAAQ,UAAU,EAAG,EAAE,MAAM,EAAE,IAAM,EAAE,EACvC,GAAQ,UAAU,EAAG,EAAE,IAAM,EAAG,CAAO,EACvC,GAAI,iBAAiB,EAAG,EAAE,IAAM,EAAG,CAAC,CACxC,CAEA,GAAI,WAAW,EAAG,EAAU,CAChC,EAKM,GAAkB,SAAS,EAAG,EAAI,EAAI,CAExC,AAAI,AADO,GAAI,UAAU,CAAE,IACd,IACT,GAAK,GACT,GAAc,EAAG,EAAa,yCAA0C,EAAI,EAAG,GAAQ,EAAG,CAAE,CAAC,CACjG,EAEM,GAAiB,SAAS,EAAG,CAC/B,GAAI,GAAK,EAAE,GACP,EAAO,EAAE,SACT,EAAa,EAAE,EAAE,YAAc,GAAM,EAAO,GAChD,GAAI,EACA,EAAE,UAAY,EAAE,sBACX,CAAE,GAAO,IACd,OACJ,GAAI,EAAG,WAAa,GAAO,eAAgB,CACvC,EAAG,YAAc,CAAC,GAAO,eACzB,MACJ,CAGA,GAFI,GACA,GAAI,UAAU,EAAG,GAAe,EAAE,EAClC,EAAO,GAAc,CACrB,GAAI,GAAI,EAAG,KAAK,MAAM,EAClB,EAAM,EAAG,UAAY,EACrB,EAAU,EAAE,SAAS,SAAW,EAAI,EAAE,SAAS,GAAO,GAC1D,AAAI,KAAQ,GACR,EAAG,WAAa,EAAE,OAClB,IAAa,GAAE,SAAS,SAAW,EAAI,EAAE,SAAS,EAAE,MAAQ,GAAK,MACjE,GAAI,UAAU,EAAG,GAAc,CAAO,CAC9C,CACA,EAAE,MAAQ,EAAG,UACT,EAAE,SAAW,IACT,IACA,GAAE,UAAY,GAClB,EAAG,YACH,EAAG,YAAc,GAAO,eACxB,EAAG,QAAU,EAAE,IAAM,EACrB,EAAG,KAAO,EAAE,MAAM,EAAG,SACrB,GAAI,WAAW,EAAG,EAAS,EAEnC,EAEA,GAAO,QAAQ,aAAmB,GAClC,GAAO,QAAQ,iBAAmB,GAClC,GAAO,QAAQ,cAAmB,GAClC,GAAO,QAAQ,gBAAmB,GAClC,GAAO,QAAQ,gBAAmB,GAClC,GAAO,QAAQ,cAAmB,GAClC,GAAO,QAAQ,gBAAmB,GAClC,GAAO,QAAQ,eAAmB,GAClC,GAAO,QAAQ,eAAmB,GAClC,GAAO,QAAQ,YAAmB,GAClC,GAAO,QAAQ,iBAAmB,GAClC,GAAO,QAAQ,gBAAmB,GAClC,GAAO,QAAQ,YAAmB,GAClC,GAAO,QAAQ,aAAmB,GAClC,GAAO,QAAQ,aAAmB,GAClC,GAAO,QAAQ,YAAmB,GAClC,GAAO,QAAQ,aAAmB,KC1qBlC,mBAEA,GAAM,CACF,iBACA,qBACA,qBACA,eAAgB,CACZ,gBACA,eACA,YACA,eACA,eACA,gBAEJ,iBACA,KAEE,GAAe,GAAa,GAAI,IAAK,GAAI,GAAI,GAAI,EAAE,EACnD,GAAe,MACf,GAAe,MACf,GAAe,OAAO,EAAiB,EAAI,GAAK,OAAO,EAAiB,EACxE,GAAe,EAEf,GAAN,KAAgB,CACZ,aAAc,CACV,KAAK,EAAI,KACT,KAAK,MAAQ,KACb,KAAK,KAAO,KACZ,KAAK,MAAQ,IACb,KAAK,OAAS,GAClB,CACJ,EAEM,GAAY,SAAS,EAAG,EAAM,EAAG,CACnC,AAAI,EAAE,SAAW,GAAK,EAAO,GACzB,GAAE,OAAS,EAAE,OAAO,EAAE,EAAG,EAAG,EAAM,EAAE,IAAI,EAChD,EAEM,GAAW,SAAS,EAAG,EAAG,CAC5B,GAAU,GAAa,CAAC,EAAG,EAAG,CAAC,CACnC,EAEM,GAAU,SAAS,EAAG,EAAG,CAC3B,GAAI,GAAK,GAAI,aAAY,CAAC,EAE1B,AADS,GAAI,UAAS,CAAE,EACrB,SAAS,EAAG,EAAG,EAAI,EACtB,GAAI,GAAI,GAAI,YAAW,CAAE,EACzB,GAAU,EAAG,EAAG,CAAC,CACrB,EAEM,GAAc,SAAS,EAAG,EAAG,CAC/B,GAAI,GAAK,GAAI,aAAY,CAAC,EAE1B,AADS,GAAI,UAAS,CAAE,EACrB,SAAS,EAAG,EAAG,EAAI,EACtB,GAAI,GAAI,GAAI,YAAW,CAAE,EACzB,GAAU,EAAG,EAAG,CAAC,CACrB,EAEM,GAAa,SAAS,EAAG,EAAG,CAC9B,GAAI,GAAK,GAAI,aAAY,CAAC,EAE1B,AADS,GAAI,UAAS,CAAE,EACrB,WAAW,EAAG,EAAG,EAAI,EACxB,GAAI,GAAI,GAAI,YAAW,CAAE,EACzB,GAAU,EAAG,EAAG,CAAC,CACrB,EAEM,GAAa,SAAS,EAAG,EAAG,CAC9B,GAAI,IAAM,KACN,GAAS,EAAG,CAAC,MACZ,CACD,GAAI,GAAO,EAAE,OAAO,EAAI,EACpB,EAAM,EAAE,OAAO,EACnB,AAAI,EAAO,IACP,GAAS,EAAM,CAAC,EAEhB,IAAS,IAAM,CAAC,EAChB,GAAY,EAAM,CAAC,GAEvB,GAAU,EAAK,EAAO,EAAG,CAAC,CAC9B,CACJ,EAEM,GAAW,SAAS,EAAG,EAAG,CAC5B,GAAI,GAAI,EAAE,KAAK,IAAI,GAAK,EAAE,IAAI,EAC9B,GAAQ,EAAE,OAAQ,CAAC,EAEnB,OAAS,GAAI,EAAG,EAAI,EAAE,OAAQ,IAC1B,GAAQ,EAAE,GAAI,CAAC,CACvB,EAEM,GAAgB,SAAS,EAAG,EAAG,CACjC,GAAI,GAAI,EAAE,EAAE,OACZ,GAAQ,EAAG,CAAC,EACZ,OAAS,GAAI,EAAG,EAAI,EAAG,IAAK,CACxB,GAAI,GAAI,EAAE,EAAE,GAEZ,OADA,GAAS,EAAE,MAAM,EAAG,CAAC,EACb,EAAE,MAAM,OACP,IACD,UACC,IACD,GAAS,EAAE,MAAQ,EAAI,EAAG,CAAC,EAC3B,UACC,IACD,GAAW,EAAE,MAAO,CAAC,EACrB,UACC,IACD,GAAY,EAAE,MAAO,CAAC,EACtB,UACC,QACA,IACD,GAAW,EAAE,QAAQ,EAAG,CAAC,EACzB,MAEZ,CACJ,EAEM,GAAa,SAAS,EAAG,EAAG,CAC9B,GAAI,GAAI,EAAE,EAAE,OACZ,GAAQ,EAAG,CAAC,EACZ,OAAS,GAAI,EAAG,EAAI,EAAG,IACnB,GAAa,EAAE,EAAE,GAAI,EAAE,OAAQ,CAAC,CACxC,EAEM,GAAe,SAAS,EAAG,EAAG,CAChC,GAAI,GAAI,EAAE,SAAS,OACnB,GAAQ,EAAG,CAAC,EACZ,OAAS,GAAI,EAAG,EAAI,EAAG,IACnB,GAAS,EAAE,SAAS,GAAG,QAAU,EAAI,EAAG,CAAC,EACzC,GAAS,EAAE,SAAS,GAAG,IAAK,CAAC,CAErC,EAEM,GAAY,SAAS,EAAG,EAAG,CAC7B,GAAI,GAAI,EAAE,MAAQ,EAAI,EAAE,SAAS,OACjC,GAAQ,EAAG,CAAC,EACZ,OAAS,GAAI,EAAG,EAAI,EAAG,IACnB,GAAQ,EAAE,SAAS,GAAI,CAAC,EAC5B,EAAI,EAAE,MAAQ,EAAI,EAAE,QAAQ,OAC5B,GAAQ,EAAG,CAAC,EACZ,OAAS,GAAI,EAAG,EAAI,EAAG,IACnB,GAAW,EAAE,QAAQ,GAAG,QAAS,CAAC,EAClC,GAAQ,EAAE,QAAQ,GAAG,QAAS,CAAC,EAC/B,GAAQ,EAAE,QAAQ,GAAG,MAAO,CAAC,EAEjC,EAAI,EAAE,MAAQ,EAAI,EAAE,SAAS,OAC7B,GAAQ,EAAG,CAAC,EACZ,OAAS,GAAI,EAAG,EAAI,EAAG,IACnB,GAAW,EAAE,SAAS,GAAG,KAAM,CAAC,CACxC,EAEM,GAAe,SAAS,EAAG,EAAS,EAAG,CACzC,AAAI,EAAE,OAAS,EAAE,SAAW,EACxB,GAAW,KAAM,CAAC,EAElB,GAAW,EAAE,OAAQ,CAAC,EAC1B,GAAQ,EAAE,YAAa,CAAC,EACxB,GAAQ,EAAE,gBAAiB,CAAC,EAC5B,GAAS,EAAE,UAAW,CAAC,EACvB,GAAS,EAAE,UAAU,EAAE,EAAG,CAAC,EAC3B,GAAS,EAAE,aAAc,CAAC,EAC1B,GAAS,EAAG,CAAC,EACb,GAAc,EAAG,CAAC,EAClB,GAAa,EAAG,CAAC,EACjB,GAAW,EAAG,CAAC,EACf,GAAU,EAAG,CAAC,CAClB,EAEM,GAAa,SAAS,EAAG,CAC3B,GAAU,GAAe,GAAc,OAAQ,CAAC,EAChD,GAAS,GAAc,CAAC,EACxB,GAAS,GAAa,CAAC,EACvB,GAAU,GAAW,GAAU,OAAQ,CAAC,EACxC,GAAS,EAAG,CAAC,EACb,GAAS,EAAG,CAAC,EACb,GAAS,EAAG,CAAC,EACb,GAAS,EAAG,CAAC,EACb,GAAS,EAAG,CAAC,EACb,GAAY,GAAU,CAAC,EACvB,GAAW,GAAU,CAAC,CAC1B,EAKM,GAAY,SAAS,EAAG,EAAG,EAAG,EAAM,EAAO,CAC7C,GAAI,GAAI,GAAI,IACZ,SAAE,EAAI,EACN,EAAE,OAAS,EACX,EAAE,KAAO,EACT,EAAE,MAAQ,EACV,EAAE,OAAS,EACX,GAAW,CAAC,EACZ,GAAS,EAAE,SAAS,OAAQ,CAAC,EAC7B,GAAa,EAAG,KAAM,CAAC,EAChB,EAAE,MACb,EAEA,GAAO,QAAQ,UAAY,KCrM3B,kBAEA,GAAM,CACF,eACA,cACA,YACA,YACA,YACA,aACA,qBACA,oBACA,mBACA,eAAgB,CACZ,eACA,gBACA,YACA,iBACA,YACA,YACA,sBACA,eACA,YACA,aACA,eACA,eACA,eACA,cACA,eACA,kBAEJ,cAAe,CAAE,WACjB,mBACA,iBACA,KACE,CAAE,aAAc,KAChB,GAAY,KACZ,GAAY,KACZ,CAAE,cAAc,KAChB,GAAY,KACZ,EAAY,KACZ,GAAY,KACZ,CACF,cACA,YACA,oBACA,KACE,GAAY,KACZ,CAAE,kBAAkB,KACpB,GAAY,KACZ,GAAY,KACZ,CAAE,QAAQ,KACV,GAAY,EAAQ,OACpB,GAAY,EAAQ,SAEpB,GAAe,SAAS,EAAG,CAC7B,EAAE,MACF,EAAU,EAAG,EAAE,KAAO,EAAE,GAAG,IAAK,gBAAgB,CACpD,EAEM,GAAkB,SAAS,EAAG,EAAG,CACnC,EAAU,EAAG,EAAK,EAAE,IAAM,EAAE,GAAG,QAAU,kCAAkC,CAC/E,EAEM,GAAmB,SAAS,EAAG,CACjC,GAAI,CAAC,EAAG,KAAM,WAAU,kBAAkB,CAC9C,EAEM,GAA0B,SAAS,EAAG,CACxC,GAAiB,MAAO,IAAM,UAAa,GAAE,KAAO,CAAC,CACzD,EAEM,GAAU,SAAS,EAAG,CACxB,MAAO,KAAM,EAAQ,cACzB,EAEM,GAAc,SAAS,EAAG,CAC5B,MAAI,KAAM,KAAa,GACX,EAAE,IAAI,OACtB,EAEM,GAAc,SAAS,EAAG,EAAQ,CACpC,GAAI,GAAM,EAAE,IAAI,MAChB,SAAE,IAAI,MAAQ,EACP,CACX,EAEM,GAAoB,SAAS,EAAG,EAAQ,CAC1C,GAAI,GAAM,EAAE,IAAI,cAChB,SAAE,IAAI,cAAgB,EACf,CACX,EAGM,EAAa,SAAS,EAAG,EAAK,CAChC,GAAI,GAAK,EAAE,GACX,GAAI,EAAM,EAAG,CACT,GAAI,GAAI,EAAG,QAAU,EAErB,MADA,GAAU,EAAG,GAAO,EAAG,IAAO,GAAG,QAAU,GAAI,oBAAoB,EAC/D,GAAK,EAAE,IAAY,EAAQ,eACnB,EAAE,MAAM,EACxB,KAAO,OAAI,GAAM,GACb,GAAU,EAAG,IAAQ,GAAK,CAAC,GAAO,EAAE,IAAK,eAAe,EACjD,EAAE,MAAM,EAAE,IAAM,IAChB,IAAQ,GACR,EAAE,IAAI,WAEb,GAAM,GAAoB,EAC1B,EAAU,EAAG,GAAO,GAAM,SAAW,EAAG,yBAAyB,EAC7D,EAAG,KAAK,QAAQ,EACT,EAAQ,eAER,GAAO,EAAG,KAAK,MAAM,UAAY,EAAG,KAAK,MAAM,QAAQ,EAAM,GAAK,EAAQ,eAG7F,EAGM,GAAc,SAAS,EAAG,EAAK,CACjC,GAAI,GAAK,EAAE,GACX,GAAI,EAAM,EAAG,CACT,GAAI,GAAI,EAAG,QAAU,EAErB,MADA,GAAU,EAAG,GAAO,EAAG,IAAO,GAAG,QAAU,GAAI,oBAAoB,EAC/D,GAAK,EAAE,IAAY,KACX,CAChB,KAAO,IAAI,EAAM,GACb,SAAU,EAAG,IAAQ,GAAK,CAAC,GAAO,EAAE,IAAK,eAAe,EACjD,EAAE,IAAM,EAEf,KAAM,OAAM,6BAA6B,EAEjD,EAEM,GAAiB,SAAS,EAAG,EAAG,CAClC,GAAI,GACA,EAAK,EAAE,GACX,SAAU,EAAG,GAAK,EAAG,cAAc,EACnC,AAAI,EAAE,WAAa,EAAE,IAAM,EACvB,EAAM,GAGN,AAAI,AADQ,EAAE,IAAM,GAAO,YACf,GAAgB,EACxB,EAAM,GAEN,IAAI,eAAe,EAAG,CAAC,EACvB,EAAM,IAIV,GAAO,EAAG,IAAM,EAAE,IAAM,GACxB,GAAG,IAAM,EAAE,IAAM,GAEd,CACX,EAEM,GAAY,SAAS,EAAM,EAAI,EAAG,CACpC,GAAI,IAAS,EACb,IAAgB,EAAM,CAAC,EACvB,EAAU,EAAM,EAAK,MAAQ,EAAG,IAAK,iCAAiC,EACtE,EAAU,EAAM,EAAG,GAAG,IAAM,EAAG,KAAO,EAAG,gBAAgB,EACzD,EAAK,KAAO,EACZ,OAAS,GAAI,EAAG,EAAI,EAAG,IACnB,EAAG,MAAM,EAAG,KAAO,GAAI,GAAQ,OAC/B,EAAQ,SAAS,EAAI,EAAG,IAAK,EAAK,MAAM,EAAK,IAAM,EAAE,EACrD,MAAO,GAAK,MAAM,EAAK,IAAM,GAC7B,EAAG,MAEX,EASM,GAAe,SAAS,EAAG,EAAK,CAClC,MAAQ,GAAM,GAAK,GAAO,GACpB,EACC,EAAE,IAAM,EAAE,GAAG,QAAW,CACnC,EAEM,GAAa,SAAS,EAAG,CAC3B,MAAO,GAAE,IAAO,GAAE,GAAG,QAAU,EACnC,EAEM,GAAgB,SAAS,EAAG,EAAK,CACnC,EAAQ,UAAU,EAAG,EAAW,EAAG,CAAG,CAAC,EACvC,EAAU,EAAG,EAAE,KAAO,EAAE,GAAG,IAAK,gBAAgB,CACpD,EAEM,GAAa,SAAS,EAAG,EAAK,CAChC,GAAI,GAAO,EAAE,GAAG,QACZ,EACJ,AAAI,GAAO,EACP,GAAU,EAAG,GAAO,EAAE,WAAc,GAAO,GAAI,mBAAmB,EAClE,EAAS,EAAO,EAAI,GAEpB,GAAU,EAAG,CAAE,GAAM,IAAM,EAAE,IAAO,GAAO,GAAI,iBAAiB,EAChE,EAAS,EAAE,IAAM,EAAM,GAE3B,GAAI,WAAW,EAAG,CAAM,CAC5B,EAEM,GAAU,SAAS,EAAG,EAAG,CAC3B,GAAW,EAAG,CAAC,EAAI,CAAC,CACxB,EAEM,GAAU,SAAS,EAAG,EAAM,EAAI,CAClC,KAAO,EAAO,EAAI,IAAQ,IAAM,CAC5B,GAAI,GAAS,EAAE,MAAM,GACjB,EAAO,GAAI,IAAO,EAAO,KAAM,EAAO,KAAK,EAC/C,EAAQ,UAAU,EAAG,EAAM,CAAE,EAC7B,EAAQ,SAAS,EAAG,EAAI,CAAI,CAChC,CACJ,EAMM,GAAa,SAAS,EAAG,EAAK,EAAG,CACnC,GAAI,GAAI,EAAE,IAAM,EACZ,EAAO,GAAY,EAAG,CAAG,EACzB,EAAI,EAAE,MAAM,GAChB,EAAU,EAAG,GAAQ,CAAC,GAAK,EAAM,GAAmB,wBAAwB,EAC5E,EAAU,EAAI,IAAK,EAAI,EAAI,CAAC,IAAO,EAAI,EAAO,EAAI,aAAa,EAC/D,GAAI,GAAI,GAAK,EAAI,EAAI,EAAI,EAAO,EAAI,EACpC,GAAQ,EAAG,EAAM,CAAC,EAClB,GAAQ,EAAG,EAAI,EAAG,EAAE,IAAM,CAAC,EAC3B,GAAQ,EAAG,EAAM,EAAE,IAAM,CAAC,CAC9B,EAEM,GAAW,SAAS,EAAG,EAAS,EAAO,CACzC,GAAI,GAAO,EAAW,EAAG,CAAO,EAChC,EAAW,EAAG,CAAK,EAAE,QAAQ,CAAI,CACrC,EAEM,GAAa,SAAS,EAAG,EAAK,CAChC,GAAW,EAAG,EAAK,EAAE,EACrB,GAAQ,EAAG,CAAC,CAChB,EAEM,GAAa,SAAS,EAAG,EAAK,CAChC,GAAW,EAAG,EAAK,CAAC,CACxB,EAEM,GAAc,SAAS,EAAG,EAAK,CACjC,GAAS,EAAG,GAAI,CAAG,EACnB,GAAQ,EAAG,CAAC,CAChB,EAMM,GAAc,SAAS,EAAG,CAC5B,EAAE,MAAM,EAAE,KAAO,GAAI,IAAO,GAAU,IAAI,EAC1C,GAAa,CAAC,CAClB,EAEM,GAAiB,SAAS,EAAG,EAAG,CAClC,GAAiB,MAAO,IAAM,QAAQ,EACtC,EAAE,MAAM,EAAE,KAAO,GAAI,IAAO,GAAa,CAAC,EAC1C,GAAa,CAAC,CAClB,EAEM,GAAkB,SAAS,EAAG,EAAG,CACnC,GAAwB,CAAC,EACzB,EAAE,MAAM,EAAE,KAAO,GAAI,IAAO,GAAa,CAAC,EAC1C,GAAa,CAAC,CAClB,EAEM,GAAkB,SAAS,EAAG,EAAG,EAAK,CACxC,GAAwB,CAAG,EAC3B,GAAI,GACJ,MAAI,KAAQ,EACR,GAAI,GAAa,GAAI,EAAI,EACzB,EAAK,GAAW,EAAG,CAAC,GAEpB,GAAI,GAAgB,CAAC,EACrB,EAAU,EAAG,EAAE,QAAU,EAAK,mCAAmC,EACjE,EAAK,GAAS,EAAG,EAAE,SAAS,EAAG,CAAG,CAAC,GAEvC,EAAQ,aAAa,EAAG,CAAE,EAC1B,EAAU,EAAG,EAAE,KAAO,EAAE,GAAG,IAAK,gBAAgB,EACzC,EAAG,KACd,EAEM,GAAiB,SAAU,EAAG,EAAG,CACnC,GAAI,AAAmB,GAAM,KACzB,EAAE,MAAM,EAAE,KAAO,GAAI,IAAO,GAAU,IAAI,EAC1C,EAAE,UACC,CACH,GAAI,GAAK,GAAS,EAAG,GAAgB,CAAC,CAAC,EACvC,EAAQ,aAAa,EAAG,CAAE,EAC1B,EAAI,EAAG,OAAO,CAClB,CACA,SAAU,EAAG,EAAE,KAAO,EAAE,GAAG,IAAK,gBAAgB,EACzC,CACX,EAEM,GAAmB,SAAU,EAAG,EAAK,EAAM,CAC7C,SAAM,GAAgB,CAAG,EAClB,EAAQ,kBAAkB,EAAG,EAAK,CAAI,CACjD,EAEM,GAAkB,SAAU,EAAG,KAAQ,EAAM,CAC/C,SAAM,GAAgB,CAAG,EAClB,EAAQ,kBAAkB,EAAG,EAAK,CAAI,CACjD,EAGM,GAAkB,SAAU,EAAG,EAAG,CACpC,GAAI,AAAmB,GAAM,KACzB,EAAE,MAAM,EAAE,KAAO,GAAI,IAAO,GAAU,IAAI,EAC1C,EAAE,UACC,CACH,GAAiB,MAAO,IAAM,QAAQ,EACtC,GAAI,GAAK,GAAgB,EAAG,CAAC,EAC7B,EAAQ,aAAa,EAAG,CAAE,EAC1B,EAAI,EAAG,OAAO,CAClB,CACA,SAAU,EAAG,EAAE,KAAO,EAAE,GAAG,IAAK,gBAAgB,EAEzC,CACX,EAEM,GAAmB,SAAS,EAAG,EAAI,EAAG,CAGxC,GAFA,GAAiB,MAAO,IAAO,UAAU,EACzC,GAAwB,CAAC,EACrB,IAAM,EACN,EAAE,MAAM,EAAE,KAAO,GAAI,IAAO,GAAU,CAAE,MACvC,CACD,GAAgB,EAAG,CAAC,EACpB,EAAU,EAAG,GAAK,GAAM,SAAU,yBAAyB,EAC3D,GAAI,GAAK,GAAI,IAAS,EAAG,EAAI,CAAC,EAC9B,OAAS,GAAE,EAAG,EAAE,EAAG,IACf,EAAG,QAAQ,GAAG,QAAQ,EAAE,MAAM,EAAE,IAAM,EAAI,EAAE,EAChD,OAAS,GAAE,EAAG,EAAE,EAAG,IACf,MAAO,GAAE,MAAM,EAAE,EAAE,KACvB,AAAI,EAAE,GACF,EAAE,EAAE,IACR,EAAE,MAAM,EAAE,KAAK,YAAY,CAAE,CACjC,CACA,GAAa,CAAC,CAClB,EAEM,GAAoB,GAEpB,GAAoB,SAAS,EAAG,EAAI,CACtC,GAAiB,EAAG,EAAI,CAAC,CAC7B,EAEM,GAAqB,GAErB,GAAkB,SAAS,EAAG,EAAG,CACnC,EAAE,MAAM,EAAE,KAAO,GAAI,IAAO,GAAc,CAAC,CAAC,CAAC,EAC7C,GAAa,CAAC,CAClB,EAEM,GAAwB,SAAS,EAAG,EAAG,CACzC,EAAE,MAAM,EAAE,KAAO,GAAI,IAAO,GAAoB,CAAC,EACjD,GAAa,CAAC,CAClB,EAEM,GAAiB,SAAS,EAAG,CAC/B,SAAE,MAAM,EAAE,KAAO,GAAI,IAAO,GAAa,CAAC,EAC1C,GAAa,CAAC,EACP,EAAE,IAAI,aAAe,CAChC,EAEM,GAAsB,SAAS,EAAG,CACpC,GAAY,EAAG,GAAmB,EAAgB,CACtD,EASM,GAAY,SAAS,EAAG,EAAG,EAAG,CAChC,GAAI,GAAM,GAAS,EAAG,GAAgB,CAAC,CAAC,EACxC,GAAgB,EAAG,CAAC,EACpB,EAAQ,aAAa,EAAG,CAAG,EAC3B,EAAU,EAAG,EAAE,KAAO,EAAE,GAAG,IAAK,gBAAgB,EAChD,GAAI,SAAS,EAAG,EAAG,EAAE,MAAM,EAAE,IAAM,GAAI,EAAE,MAAM,EAAE,IAAM,EAAE,EAEzD,MAAO,GAAE,MAAM,EAAE,EAAE,KACnB,MAAO,GAAE,MAAM,EAAE,EAAE,IACvB,EAEM,GAAgB,SAAS,EAAG,EAAM,CACpC,GAAU,EAAG,GAAO,YAAY,EAAE,IAAI,WAAW,MAAO,EAAgB,EAAG,CAAI,CACnF,EAEM,GAAmB,SAAS,EAAG,EAAU,CAC3C,GAAgB,EAAG,CAAC,EACpB,GAAI,GACA,EAAM,EAAW,EAAG,CAAQ,EAQhC,OAPA,AAAI,EAAE,MAAM,EAAE,IAAM,GAAG,QAAQ,EAC3B,EAAK,KAEL,GAAU,EAAG,EAAE,MAAM,EAAE,IAAM,GAAG,UAAU,EAAG,gBAAgB,EAC7D,EAAK,EAAE,MAAM,EAAE,IAAM,GAAG,OAGpB,EAAI,MAAM,OACT,QACA,IAAY,CACb,EAAI,MAAM,UAAY,EACtB,KACJ,SACS,CACL,EAAE,IAAI,GAAG,EAAI,MAAM,GAAK,EACxB,KACJ,EAGJ,aAAO,GAAE,MAAM,EAAE,EAAE,KACZ,EACX,EAEM,GAAe,SAAS,EAAG,EAAK,CAClC,GAAgB,EAAG,CAAC,EACpB,GAAI,GAAI,EAAW,EAAG,CAAG,EACzB,GAAI,SAAS,EAAG,EAAG,EAAE,MAAM,EAAE,IAAM,GAAI,EAAE,MAAM,EAAE,IAAM,EAAE,EACzD,MAAO,GAAE,MAAM,EAAE,EAAE,KACnB,MAAO,GAAE,MAAM,EAAE,EAAE,IACvB,EAEM,GAAe,SAAS,EAAG,EAAK,EAAG,CACrC,GAAU,EAAG,EAAW,EAAG,CAAG,EAAG,CAAC,CACtC,EAEM,GAAW,SAAS,EAAG,EAAK,EAAG,CACjC,GAAwB,CAAC,EACzB,GAAgB,EAAG,CAAC,EACpB,GAAI,GAAI,EAAW,EAAG,CAAG,EACzB,EAAE,MAAM,EAAE,KAAO,GAAI,IAAO,GAAa,CAAC,EAC1C,GAAa,CAAC,EACd,GAAI,SAAS,EAAG,EAAG,EAAE,MAAM,EAAE,IAAM,GAAI,EAAE,MAAM,EAAE,IAAM,EAAE,EAEzD,MAAO,GAAE,MAAM,EAAE,EAAE,KACnB,MAAO,GAAE,MAAM,EAAE,EAAE,IACvB,EAEM,GAAa,SAAS,EAAG,EAAK,CAChC,GAAgB,EAAG,CAAC,EACpB,GAAI,GAAI,EAAW,EAAG,CAAG,EACzB,EAAU,EAAG,EAAE,UAAU,EAAG,gBAAgB,EAC5C,GAAI,GAAI,EAAE,MAAM,EAAE,IAAM,GACpB,EAAI,EAAE,MAAM,EAAE,IAAM,GACxB,GAAO,aAAa,EAAG,EAAE,MAAO,EAAG,CAAC,EACpC,GAAO,kBAAkB,EAAE,KAAK,EAChC,MAAO,GAAE,MAAM,EAAE,EAAE,KACnB,MAAO,GAAE,MAAM,EAAE,EAAE,IACvB,EAEM,GAAc,SAAS,EAAG,EAAK,EAAG,CACpC,GAAwB,CAAC,EACzB,GAAgB,EAAG,CAAC,EACpB,GAAI,GAAI,EAAW,EAAG,CAAG,EACzB,EAAU,EAAG,EAAE,UAAU,EAAG,gBAAgB,EAC5C,GAAO,YAAY,EAAE,MAAO,EAAG,EAAE,MAAM,EAAE,IAAM,EAAE,EACjD,MAAO,GAAE,MAAM,EAAE,EAAE,IACvB,EAEM,GAAc,SAAS,EAAG,EAAK,EAAG,CACpC,GAAgB,EAAG,CAAC,EACpB,GAAI,GAAI,EAAW,EAAG,CAAG,EACzB,EAAU,EAAG,EAAE,UAAU,EAAG,gBAAgB,EAC5C,GAAI,GAAI,GAAI,IAAO,GAAoB,CAAC,EACpC,EAAI,EAAE,MAAM,EAAE,IAAM,GACxB,GAAO,aAAa,EAAG,EAAE,MAAO,EAAG,CAAC,EACpC,MAAO,GAAE,MAAM,EAAE,EAAE,IACvB,EAMM,GAAY,SAAS,EAAG,EAAG,EAAG,CAChC,GAAI,GAAM,GAAS,EAAG,GAAgB,CAAC,CAAC,EACxC,SAAQ,aAAa,EAAG,CAAG,EAC3B,EAAU,EAAG,EAAE,KAAO,EAAE,GAAG,IAAK,gBAAgB,EAChD,GAAI,cAAc,EAAG,EAAG,EAAE,MAAM,EAAE,IAAM,GAAI,EAAE,IAAM,CAAC,EAC9C,EAAE,MAAM,EAAE,IAAM,GAAG,MAAM,CACpC,EAEM,GAAc,SAAS,EAAG,EAAK,EAAG,CACpC,GAAI,GAAI,EAAW,EAAG,CAAG,EACzB,UAAwB,CAAC,EACzB,EAAU,EAAG,EAAE,UAAU,EAAG,gBAAgB,EAC5C,EAAQ,UAAU,EAAG,GAAO,YAAY,EAAE,MAAO,CAAC,CAAC,EACnD,EAAU,EAAG,EAAE,KAAO,EAAE,GAAG,IAAK,gBAAgB,EACzC,EAAE,MAAM,EAAE,IAAM,GAAG,MAAM,CACpC,EAEM,GAAc,SAAS,EAAG,EAAK,EAAG,CACpC,GAAI,GAAI,EAAW,EAAG,CAAG,EACzB,EAAU,EAAG,EAAE,UAAU,EAAG,gBAAgB,EAC5C,GAAI,GAAI,GAAI,IAAO,GAAoB,CAAC,EACxC,SAAQ,UAAU,EAAG,GAAO,SAAS,EAAG,EAAE,MAAO,CAAC,CAAC,EACnD,EAAU,EAAG,EAAE,KAAO,EAAE,GAAG,IAAK,gBAAgB,EACzC,EAAE,MAAM,EAAE,IAAM,GAAG,MAAM,CACpC,EAEM,GAAa,SAAS,EAAG,EAAK,CAChC,GAAI,GAAI,EAAW,EAAG,CAAG,EACzB,SAAU,EAAG,EAAE,UAAU,CAAC,EAAG,gBAAgB,EAC7C,EAAQ,SAAS,EAAG,EAAE,IAAM,EAAG,GAAO,SAAS,EAAG,EAAE,MAAO,EAAE,MAAM,EAAE,IAAM,EAAE,CAAC,EACvE,EAAE,MAAM,EAAE,IAAM,GAAG,MAAM,CACpC,EAGM,GAAkB,SAAS,EAAG,EAAQ,EAAM,CAC9C,GAAI,GAAI,GAAI,GAAQ,OAAO,GAAY,GAAO,SAAS,CAAC,CAAC,EACzD,EAAE,MAAM,EAAE,KAAO,EACjB,GAAa,CAAC,CAClB,EAEM,GAAgB,SAAS,EAAG,EAAM,CACpC,MAAO,IAAI,GAAQ,MAAM,EAAG,CAAI,CACpC,EAEM,GAAkB,SAAS,EAAG,EAAM,CACtC,GAAI,GAAI,GAAc,EAAG,CAAI,EAC7B,SAAE,MAAM,EAAE,KAAO,GAAI,GAAQ,OAAO,GAAe,CAAC,EACpD,GAAa,CAAC,EACP,EAAE,IACb,EAEM,GAAc,SAAS,EAAG,EAAI,EAAG,CAEnC,OADA,GAAwB,CAAC,EAClB,EAAG,MAAM,OACP,IAAU,CACX,GAAI,GAAI,EAAG,MACX,MAAM,IAAK,GAAK,GAAK,EAAE,UAChB,CACH,KAAM,GAAa,GAAI,EAAI,EAC3B,IAAK,EAAE,QAAQ,EAAE,EACrB,EAJ0C,IAK9C,KACK,IAAU,CACX,GAAI,GAAI,EAAG,MACP,EAAI,EAAE,EACV,GAAI,CAAE,IAAK,GAAK,GAAK,EAAE,SAAS,QAAS,MAAO,MAChD,GAAI,GAAO,EAAE,SAAS,EAAE,GAAG,KAC3B,MAAO,CACH,KAAM,EAAO,EAAK,OAAO,EAAI,GAAa,aAAc,EAAI,EAC5D,IAAK,EAAE,OAAO,EAAE,EACpB,CACJ,SACS,MAAO,MAExB,EAEM,GAAiB,SAAS,EAAG,EAAW,EAAG,CAC7C,GAAI,GAAK,GAAY,EAAG,EAAW,EAAG,CAAS,EAAG,CAAC,EACnD,GAAI,EAAI,CACJ,GAAI,GAAO,EAAG,KACV,EAAM,EAAG,IACb,SAAQ,UAAU,EAAG,CAAG,EACxB,EAAU,EAAG,EAAE,KAAO,EAAE,GAAG,IAAK,gBAAgB,EACzC,CACX,CACA,MAAO,KACX,EAEM,GAAiB,SAAS,EAAG,EAAW,EAAG,CAC7C,GAAI,GAAK,EAAW,EAAG,CAAS,EAChC,GAAgB,EAAG,CAAC,EACpB,GAAI,GAAM,GAAY,EAAG,EAAI,CAAC,EAC9B,GAAI,EAAK,CACL,GAAI,GAAO,EAAI,KAEf,MADU,GAAI,IACV,QAAQ,EAAE,MAAM,EAAE,IAAI,EAAE,EAC5B,MAAO,GAAE,MAAM,EAAE,EAAE,KACZ,CACX,CACA,MAAO,KACX,EAEM,GAAe,SAAS,EAAG,CAC7B,GAAgB,EAAG,EAAG,CAAC,CAC3B,EAEM,GAAe,SAAS,EAAG,EAAG,EAAG,CACnC,GAAkB,EAAG,CAAC,EACtB,GAAc,EAAG,CAAC,CACtB,EAEM,GAAmB,SAAS,EAAG,EAAU,CAC3C,GAAI,GAAM,EAAW,EAAG,CAAQ,EAC5B,EACA,EAAM,GACV,OAAQ,EAAI,MAAM,OACT,QACA,IACD,EAAK,EAAI,MAAM,UACf,cAEA,EAAK,EAAE,IAAI,GAAG,EAAI,MAAM,GACxB,MAGR,MAAI,IAAO,MACP,GAAE,MAAM,EAAE,KAAO,GAAI,IAAO,GAAY,CAAE,EAC1C,GAAa,CAAC,EACd,EAAM,IAGH,CACX,EAEM,GAAmB,SAAS,EAAG,EAAK,CACtC,GAAI,GAAI,EAAW,EAAG,CAAG,EACzB,EAAU,EAAG,EAAE,iBAAiB,EAAG,wBAAwB,EAC3D,GAAI,GAAK,EAAE,MAAM,UACjB,SAAE,MAAM,EAAE,KAAO,GAAI,IAAO,EAAG,KAAM,EAAG,KAAK,EAC7C,GAAa,CAAC,EACP,EAAE,MAAM,EAAE,IAAM,GAAG,MAAM,CACpC,EAEM,GAAe,SAAS,EAAG,EAAK,CAClC,GAAI,GAAI,EAAW,EAAG,CAAG,EACzB,UAAI,cAAc,EAAG,EAAG,EAAE,MAAM,EAAE,IAAM,GAAI,EAAE,IAAM,CAAC,EAC9C,EAAE,MAAM,EAAE,IAAM,GAAG,MAAM,CACpC,EAEM,GAAe,SAAS,EAAG,EAAK,EAAG,CACrC,MAAO,IAAU,EAAG,EAAW,EAAG,CAAG,EAAG,CAAC,CAC7C,EAEM,GAAW,SAAS,EAAG,EAAK,EAAG,CACjC,GAAI,GAAI,EAAW,EAAG,CAAG,EACzB,UAAwB,CAAC,EACzB,EAAE,MAAM,EAAE,KAAO,GAAI,IAAO,GAAa,CAAC,EAC1C,GAAa,CAAC,EACd,GAAI,cAAc,EAAG,EAAG,EAAE,MAAM,EAAE,IAAM,GAAI,EAAE,IAAM,CAAC,EAC9C,EAAE,MAAM,EAAE,IAAM,GAAG,MAAM,CACpC,EAEM,GAAgB,SAAS,EAAG,EAAM,CACpC,MAAO,IAAU,EAAG,GAAO,YAAY,EAAE,IAAI,WAAW,MAAO,EAAgB,EAAG,CAAI,CAC1F,EAMM,GAAgB,SAAS,EAAG,EAAK,CAEnC,MAAO,CAAC,AADA,EAAW,EAAG,CAAG,EACf,UAAU,CACxB,EAEM,GAAgB,SAAS,EAAG,EAAK,CACnC,GAAI,GAAI,EAAW,EAAG,CAAG,EAEzB,GAAI,CAAC,EAAE,WAAW,EAAG,CACjB,GAAI,CAAC,GAAI,QAAQ,CAAC,EACd,MAAO,MAEX,EAAQ,cAAc,EAAG,CAAC,CAC9B,CACA,MAAO,GAAE,OAAO,CACpB,EAEM,GAAgB,GAEhB,GAAiB,SAAS,EAAG,EAAK,CACpC,GAAI,GAAI,EAAW,EAAG,CAAG,EAEzB,GAAI,CAAC,EAAE,WAAW,EAAG,CACjB,GAAI,CAAC,GAAI,QAAQ,CAAC,EACd,MAAO,MAEX,EAAQ,cAAc,EAAG,CAAC,CAC9B,CACA,MAAO,GAAE,SAAS,CACtB,EAEM,GAAiB,SAAS,EAAG,EAAK,CACpC,GAAI,GAAK,GAAc,EAAG,CAAG,EAC7B,MAAO,IAAI,UAAS,EAAG,OAAQ,EAAG,WAAY,EAAG,UAAU,CAC/D,EAEM,GAAa,SAAS,EAAG,EAAK,CAChC,GAAI,GAAI,EAAW,EAAG,CAAG,EACzB,OAAQ,EAAE,MAAM,OACP,QACA,IACD,MAAO,GAAE,MAAM,MACd,IACD,MAAO,GAAE,MAAM,QACd,IACD,MAAO,IAAO,UAAU,EAAE,KAAK,UAE/B,MAAO,GAEnB,EAEM,GAAkB,SAAS,EAAG,EAAK,CACrC,GAAI,GAAI,EAAW,EAAG,CAAG,EACzB,MAAI,GAAE,QAAQ,GAAK,EAAE,aAAa,EAAU,EAAE,MAClC,IAChB,EAEM,GAAgB,SAAS,EAAG,EAAK,CACnC,GAAI,GAAI,GAAe,EAAG,CAAG,EAC7B,MAAO,KAAM,GAAQ,EAAI,CAC7B,EAEM,GAAiB,SAAS,EAAG,EAAK,CACpC,MAAO,IAAI,UAAU,EAAW,EAAG,CAAG,CAAC,CAC3C,EAEM,GAAe,SAAS,EAAG,EAAK,CAClC,GAAI,GAAI,GAAc,EAAG,CAAG,EAC5B,MAAO,KAAM,GAAQ,EAAI,CAC7B,EAEM,GAAgB,SAAS,EAAG,EAAK,CACnC,MAAO,IAAI,SAAS,EAAW,EAAG,CAAG,CAAC,CAC1C,EAEM,GAAiB,SAAS,EAAG,EAAK,CACpC,GAAI,GAAI,EAAW,EAAG,CAAG,EACzB,OAAQ,EAAE,MAAM,OACP,IACD,MAAO,GAAE,MAAM,SACd,IACD,MAAO,GAAE,cACJ,MAAO,MAExB,EAEM,GAAe,SAAS,EAAG,EAAK,CAClC,GAAI,GAAI,EAAW,EAAG,CAAG,EACzB,MAAO,GAAE,WAAW,EAAI,EAAE,MAAQ,IACtC,EAEM,GAAgB,SAAS,EAAG,EAAK,CACnC,GAAI,GAAI,EAAW,EAAG,CAAG,EACzB,OAAQ,EAAE,MAAM,OACP,QACA,QACA,QACA,QACA,QACA,QACA,IACD,MAAO,GAAE,cAET,MAAO,MAEnB,EAMM,GAAO,GAAI,SAGX,GAAc,SAAS,EAAG,EAAG,CAC/B,GAAI,GAAI,GAAK,IAAI,CAAC,EAClB,MAAK,GAEG,IAAM,MAAU,EAAE,MAAQ,EADvB,EAEf,EAGM,GAAe,SAAS,EAAG,EAAM,EAAO,CAC1C,GAAI,GAAQ,SAAS,EAAG,CACpB,EAAU,EAAG,YAAa,IAAO,WAAa,IAAM,EAAE,IAAK,gCAAgC,EAC3F,EAAE,MAAM,EAAE,KAAO,GAAI,IAAO,EAAM,CAAK,EACvC,GAAa,CAAC,CAClB,EACA,UAAK,IAAI,EAAO,CAAC,EACV,CACX,EAEM,GAAc,SAAS,EAAG,EAAK,CACjC,GAAI,GAAK,EAAW,EAAG,CAAG,EAE1B,MAAO,IAAa,EAAE,IAAK,EAAG,KAAM,EAAG,KAAK,CAChD,EAGM,GAAc,SAAS,EAAG,EAAQ,EAAQ,EAAI,CAChD,GAAI,GAAK,EAAW,EAAG,CAAM,EACzB,EAAK,EAAW,EAAG,CAAM,EAEzB,EAAI,EAER,GAAI,GAAQ,CAAE,GAAK,GAAQ,CAAE,EACzB,OAAQ,OACC,IAAU,EAAI,GAAI,cAAc,EAAG,EAAI,CAAE,EAAG,UAC5C,IAAU,EAAI,GAAI,cAAc,EAAG,EAAI,CAAE,EAAG,UAC5C,IAAU,EAAI,GAAI,eAAe,EAAG,EAAI,CAAE,EAAG,cACzC,EAAU,EAAG,GAAO,gBAAgB,EAIrD,MAAO,EACX,EAEM,GAAqB,SAAS,EAAG,EAAG,CACtC,GAAI,GAAK,GAAI,IACT,EAAK,EAAQ,aAAa,EAAG,CAAE,EACnC,MAAI,KAAO,GACP,GAAE,MAAM,EAAE,KAAO,EACjB,GAAa,CAAC,GAEX,CACX,EAEM,GAAS,SAAS,EAAG,EAAI,CAC3B,GAAI,iBAAiB,EAAG,EAAG,QAAS,EAAG,QAAQ,CACnD,EAEM,GAAW,SAAS,EAAG,EAAK,CAC9B,GAAI,GAAI,EAAW,EAAG,CAAG,EACzB,MAAO,IAAQ,CAAC,EAAK,EAAE,MAAM,EAAI,EACrC,EAEM,GAAe,SAAS,EAAG,EAAG,CAChC,SAAU,EAAG,IAAa,GAAK,EAAI,GAAa,aAAa,EACtD,GAAI,UAAU,CAAC,CAC1B,EAEM,GAAkB,SAAS,EAAG,EAAK,CACrC,GAAI,GAAI,EAAW,EAAG,CAAG,EACzB,MAAO,GAAE,QAAQ,CAAC,GAAK,EAAE,aAAa,CAC1C,EAEM,GAAY,SAAS,EAAG,EAAG,CAC7B,MAAO,IAAS,EAAG,CAAC,IAAM,EAC9B,EAEM,GAAgB,SAAS,EAAG,EAAG,CACjC,MAAO,IAAS,EAAG,CAAC,IAAM,EAC9B,EAEM,GAAa,SAAS,EAAG,EAAG,CAC9B,MAAO,IAAS,EAAG,CAAC,IAAM,EAC9B,EAEM,GAAkB,SAAS,EAAG,EAAG,CACnC,MAAO,IAAS,EAAG,CAAC,GAAK,CAC7B,EAEM,GAAc,SAAS,EAAG,EAAK,CACjC,MAAO,GAAW,EAAG,CAAG,EAAE,UAAU,CACxC,EAEM,GAAgB,SAAS,EAAG,EAAK,CACnC,MAAO,GAAW,EAAG,CAAG,EAAE,YAAY,CAC1C,EAEM,GAAe,SAAS,EAAG,EAAK,CAClC,MAAO,IAAI,SAAS,EAAW,EAAG,CAAG,CAAC,IAAM,EAChD,EAEM,GAAe,SAAS,EAAG,EAAK,CAClC,GAAI,GAAI,EAAW,EAAG,CAAG,EACzB,MAAO,GAAE,WAAW,GAAK,GAAI,QAAQ,CAAC,CAC1C,EAEM,GAAiB,SAAS,EAAG,EAAK,CACpC,GAAI,GAAI,EAAW,EAAG,CAAG,EACzB,MAAO,GAAE,iBAAiB,CAAC,GAAK,EAAE,kBAAkB,CACxD,EAEM,GAAe,SAAS,EAAG,EAAK,CAClC,MAAO,IAAS,EAAG,CAAG,IAAM,EAChC,EAEM,GAAiB,SAAS,EAAG,EAAK,CACpC,MAAO,IAAS,EAAG,CAAG,IAAM,EAChC,EAEM,GAAsB,SAAS,EAAG,EAAK,CACzC,MAAO,IAAS,EAAG,CAAG,IAAM,EAChC,EAEM,GAAe,SAAS,EAAG,EAAQ,EAAQ,CAC7C,GAAI,GAAK,EAAW,EAAG,CAAM,EACzB,EAAK,EAAW,EAAG,CAAM,EAC7B,MAAO,IAAQ,CAAE,GAAK,GAAQ,CAAE,EAAI,GAAI,cAAc,KAAM,EAAI,CAAE,EAAI,CAC1E,EAEM,GAAY,SAAS,EAAG,EAAI,CAC9B,AAAI,IAAO,IAAa,IAAO,GAC3B,GAAgB,EAAG,CAAC,EAEpB,IAAgB,EAAG,CAAC,EACpB,EAAQ,UAAU,EAAG,EAAE,MAAM,EAAE,IAAI,EAAE,EACrC,EAAU,EAAG,EAAE,KAAO,EAAE,GAAG,IAAK,gBAAgB,GAGpD,EAAQ,WAAW,EAAG,EAAI,EAAE,MAAM,EAAE,IAAM,GAAI,EAAE,MAAM,EAAE,IAAM,GAAI,EAAE,MAAM,EAAE,IAAM,EAAE,EACpF,MAAO,GAAE,MAAM,EAAE,EAAE,IACvB,EAMM,GAAoB,GAAa,GAAG,EACpC,GAAW,SAAS,EAAG,EAAQ,EAAM,EAAW,EAAM,CACxD,AAAK,EACA,EAAY,GAAgB,CAAS,EAD1B,EAAY,GAExB,IAAS,MAAM,GAAO,GAAgB,CAAI,GAC9C,GAAI,GAAI,GAAI,IAAI,EAAG,EAAQ,CAAI,EAC3B,EAAS,GAAI,qBAAqB,EAAG,EAAG,EAAW,CAAI,EAC3D,GAAI,IAAW,GAAQ,CACnB,GAAI,GAAI,EAAE,MAAM,EAAE,IAAM,GAAG,MAC3B,GAAI,EAAE,WAAa,EAAG,CAElB,GAAI,GAAK,GAAO,YAAY,EAAE,IAAI,WAAW,MAAO,EAAgB,EAEpE,EAAE,OAAO,GAAG,QAAQ,CAAE,CAC1B,CACJ,CACA,MAAO,EACX,EAEM,GAAW,SAAS,EAAG,EAAQ,EAAM,EAAO,CAC9C,GAAgB,EAAG,CAAC,EACpB,GAAI,GAAI,EAAE,MAAM,EAAE,IAAK,GACvB,MAAI,GAAE,aAAa,EACR,GAAU,EAAG,EAAE,MAAM,EAAG,EAAQ,EAAM,CAAK,EAC/C,CACX,EAEM,GAAa,SAAS,EAAG,CAC3B,MAAO,GAAE,MACb,EAEM,GAAmB,SAAS,EAAG,EAAK,CACtC,GAAgB,EAAG,CAAC,EACpB,GAAI,GAAI,EAAW,EAAG,CAAG,EACzB,EAAU,EAAG,EAAE,iBAAiB,EAAG,wBAAwB,EAC3D,EAAE,MAAM,UAAU,QAAQ,EAAE,MAAM,EAAE,IAAM,EAAE,EAC5C,MAAO,GAAE,MAAM,EAAE,EAAE,IACvB,EAEM,GAAe,SAAS,EAAE,EAAG,EAAI,CACnC,EAAU,EAAG,IAAO,IAAgB,EAAE,GAAG,IAAM,EAAE,KAAQ,EAAO,EAC5D,mDAAmD,CAC3D,EAEM,GAAY,SAAS,EAAG,EAAO,EAAU,EAAK,EAAG,CACnD,EAAU,EAAG,IAAM,MAAQ,CAAE,GAAE,GAAG,WAAa,GAAO,UAAW,uCAAuC,EACxG,GAAgB,EAAG,EAAQ,CAAC,EAC5B,EAAU,EAAG,EAAE,SAAW,GAAQ,sCAAsC,EACxE,GAAa,EAAG,EAAO,CAAQ,EAC/B,GAAI,GAAO,EAAE,IAAO,GAAQ,GAC5B,AAAI,IAAM,MAAQ,EAAE,MAAQ,EACxB,GAAE,GAAG,IAAM,EACX,EAAE,GAAG,MAAQ,EACb,GAAI,UAAU,EAAG,EAAM,CAAQ,GAE/B,GAAI,iBAAiB,EAAG,EAAM,CAAQ,EAGtC,IAAa,IAAe,EAAE,GAAG,IAAM,EAAE,KACzC,GAAE,GAAG,IAAM,EAAE,IACrB,EAEM,GAAW,SAAS,EAAG,EAAG,EAAG,CAC/B,GAAU,EAAG,EAAG,EAAG,EAAG,IAAI,CAC9B,EAEM,GAAa,SAAS,EAAG,EAAO,EAAU,EAAS,EAAK,EAAG,CAC7D,EAAU,EAAG,IAAM,MAAQ,CAAE,GAAE,GAAG,WAAa,GAAO,UAAW,uCAAuC,EACxG,GAAgB,EAAG,EAAQ,CAAC,EAC5B,EAAU,EAAG,EAAE,SAAW,GAAQ,sCAAsC,EACxE,GAAa,EAAG,EAAO,CAAQ,EAC/B,GAAI,GACA,EACJ,AAAI,IAAY,EACZ,EAAO,EAEP,EAAO,GAAY,EAAG,CAAO,EAEjC,GAAI,GAAU,EAAE,IAAO,GAAQ,GAC/B,GAAI,IAAM,MAAQ,EAAE,IAAM,EAAG,CACzB,GAAI,GAAI,CACJ,QAAS,EACT,SAAU,CACd,EACA,EAAS,GAAI,WAAW,EAAG,GAAQ,EAAG,EAAS,CAAI,CACvD,KAAO,CACH,GAAI,GAAK,EAAE,GACX,EAAG,IAAM,EACT,EAAG,MAAQ,EAEX,EAAG,MAAQ,EACX,EAAG,cAAgB,EAAE,QACrB,EAAE,QAAU,EACZ,EAAG,YAAc,CAAC,GAAO,SAAW,EAAE,UACtC,EAAG,YAAc,GAAO,YACxB,GAAI,UAAU,EAAG,EAAS,CAAQ,EAClC,EAAG,YAAc,CAAC,GAAO,YACzB,EAAE,QAAU,EAAG,cACf,EAAS,EACb,CAEA,MAAI,KAAa,IAAe,EAAE,GAAG,IAAM,EAAE,KACzC,GAAE,GAAG,IAAM,EAAE,KAEV,CACX,EAEM,GAAY,SAAS,EAAG,EAAG,EAAG,EAAG,CACnC,MAAO,IAAW,EAAG,EAAG,EAAG,EAAG,EAAG,IAAI,CACzC,EAMM,GAAY,SAAS,EAAG,CAC1B,GAAgB,EAAG,CAAC,EACpB,GAAO,cAAc,CAAC,CAC1B,EAEM,GAAW,SAAS,EAAG,EAAK,CAC9B,GAAI,GAAI,EAAW,EAAG,CAAG,EAIzB,MAHA,GAAU,EAAG,EAAE,UAAU,EAAG,gBAAgB,EAC5C,EAAE,MAAM,EAAE,KAAO,GAAI,IACV,GAAO,UAAU,EAAG,EAAE,MAAO,EAAE,IAAM,CAAC,EAE7C,IAAa,CAAC,EACP,GAEP,OAAO,GAAE,MAAM,EAAE,KACjB,MAAO,GAAE,MAAM,EAAE,EAAE,KACZ,EAEf,EAEM,GAAa,SAAS,EAAG,EAAG,CAC9B,GAAgB,EAAG,CAAC,EACpB,AAAI,GAAK,EACL,GAAI,YAAY,EAAG,CAAC,EACf,IAAM,GACX,GAAQ,aAAa,EAAG,GAAW,EAAG,GAAa,GAAI,EAAI,CAAC,CAAC,EAC7D,EAAU,EAAG,EAAE,KAAO,EAAE,GAAG,IAAK,gBAAgB,EAExD,EAEM,GAAU,SAAS,EAAG,EAAK,CAC7B,GAAI,GAAI,EAAW,EAAG,CAAG,EACrB,EAAK,GAAI,IACb,GAAI,YAAY,EAAG,EAAI,CAAC,EACxB,EAAE,MAAM,EAAE,KAAO,EACjB,GAAa,CAAC,CAClB,EAEM,GAAc,SAAS,EAAG,EAAM,EAAG,CACrC,GAAI,GAAK,EAAW,EAAG,CAAI,EAC3B,EAAU,EAAG,EAAG,aAAa,EAAG,uBAAuB,EACvD,GAAI,GAAI,EAAG,MACX,UAAwB,CAAC,EACzB,EAAU,EAAG,GAAK,GAAK,GAAK,EAAE,EAAE,SAAS,OAAQ,uBAAuB,EACjE,CACH,EAAG,EACH,EAAG,EAAI,CACX,CACJ,EAEM,GAAgB,SAAS,EAAG,EAAM,EAAG,CACvC,GAAI,GAAK,EAAW,EAAG,CAAI,EAC3B,OAAQ,EAAG,MAAM,OACR,IAAU,CACX,GAAI,GAAM,GAAY,EAAG,EAAM,CAAC,EAChC,MAAO,GAAI,EAAE,OAAO,EAAI,EAC5B,KACK,IAAU,CACX,GAAI,GAAI,EAAG,MACX,SAAU,EAAI,GAAE,KAAO,GAAK,EAAI,GAAK,GAAK,EAAE,UAAW,uBAAuB,EACvE,EAAE,QAAQ,EAAI,EACzB,SAEI,SAAU,EAAG,GAAO,kBAAkB,EAC/B,KAGnB,EAEM,GAAkB,SAAS,EAAG,EAAO,EAAI,EAAO,EAAI,CACtD,GAAI,GAAO,GAAY,EAAG,EAAO,CAAE,EAC/B,EAAO,GAAY,EAAG,EAAO,CAAE,EAC/B,EAAM,EAAK,EAAE,OAAO,EAAK,GAC7B,EAAK,EAAE,OAAO,EAAK,GAAK,CAC5B,EAGM,GAAS,UAAY,CAAC,EAEtB,GAAgB,UAAY,CAC9B,eAAQ,KAAK,gCAAgC,EACtC,CACX,EAEM,GAAgB,UAAY,CAC9B,eAAQ,KAAK,gCAAgC,EACtC,CACX,EAEM,GAAoB,UAAY,CAClC,eAAQ,KAAK,oCAAoC,EAC1C,CACX,EAEA,EAAO,QAAQ,aAAwB,GACvC,EAAO,QAAQ,gBAAwB,GACvC,EAAO,QAAQ,aAAwB,GACvC,EAAO,QAAQ,UAAwB,GACvC,EAAO,QAAQ,YAAwB,GACvC,EAAO,QAAQ,kBAAwB,GACvC,EAAO,QAAQ,SAAwB,GACvC,EAAO,QAAQ,UAAwB,GACvC,EAAO,QAAQ,eAAwB,GACvC,EAAO,QAAQ,YAAwB,GACvC,EAAO,QAAQ,WAAwB,GACvC,EAAO,QAAQ,SAAwB,GACvC,EAAO,QAAQ,gBAAwB,GACvC,EAAO,QAAQ,SAAwB,GACvC,EAAO,QAAQ,UAAwB,GACvC,EAAO,QAAQ,OAAwB,GACvC,EAAO,QAAQ,cAAwB,GACvC,EAAO,QAAQ,kBAAwB,GACvC,EAAO,QAAQ,aAAwB,GACvC,EAAO,QAAQ,cAAwB,GACvC,EAAO,QAAQ,SAAwB,GACvC,EAAO,QAAQ,iBAAwB,GACvC,EAAO,QAAQ,aAAwB,GACvC,EAAO,QAAQ,WAAwB,GACvC,EAAO,QAAQ,eAAwB,GACvC,EAAO,QAAQ,iBAAwB,GACvC,EAAO,QAAQ,WAAwB,GACvC,EAAO,QAAQ,cAAwB,GACvC,EAAO,QAAQ,gBAAwB,GACvC,EAAO,QAAQ,eAAwB,GACvC,EAAO,QAAQ,cAAwB,GACvC,EAAO,QAAQ,oBAAwB,GACvC,EAAO,QAAQ,UAAwB,GACvC,EAAO,QAAQ,WAAwB,GACvC,EAAO,QAAQ,gBAAwB,GACvC,EAAO,QAAQ,aAAwB,GACvC,EAAO,QAAQ,YAAwB,GACvC,EAAO,QAAQ,aAAwB,GACvC,EAAO,QAAQ,YAAwB,GACvC,EAAO,QAAQ,aAAwB,GACvC,EAAO,QAAQ,eAAwB,GACvC,EAAO,QAAQ,QAAwB,GACvC,EAAO,QAAQ,SAAwB,GACvC,EAAO,QAAQ,aAAwB,GACvC,EAAO,QAAQ,gBAAwB,GACvC,EAAO,QAAQ,SAAwB,GACvC,EAAO,QAAQ,UAAwB,GACvC,EAAO,QAAQ,WAAwB,GACvC,EAAO,QAAQ,QAAwB,GACvC,EAAO,QAAQ,gBAAwB,GACvC,EAAO,QAAQ,iBAAwB,GACvC,EAAO,QAAQ,kBAAwB,GACvC,EAAO,QAAQ,gBAAwB,GACvC,EAAO,QAAQ,oBAAwB,GACvC,EAAO,QAAQ,gBAAwB,GACvC,EAAO,QAAQ,kBAAwB,GACvC,EAAO,QAAQ,mBAAwB,GACvC,EAAO,QAAQ,sBAAwB,GACvC,EAAO,QAAQ,gBAAwB,GACvC,EAAO,QAAQ,gBAAwB,GACvC,EAAO,QAAQ,YAAwB,GACvC,EAAO,QAAQ,eAAwB,GACvC,EAAO,QAAQ,eAAwB,GACvC,EAAO,QAAQ,eAAwB,GACvC,EAAO,QAAQ,cAAwB,GACvC,EAAO,QAAQ,iBAAwB,GACvC,EAAO,QAAQ,aAAwB,GACvC,EAAO,QAAQ,WAAwB,GACvC,EAAO,QAAQ,YAAwB,GACvC,EAAO,QAAQ,YAAwB,GACvC,EAAO,QAAQ,WAAwB,GACvC,EAAO,QAAQ,WAAwB,GACvC,EAAO,QAAQ,YAAwB,GACvC,EAAO,QAAQ,YAAwB,GACvC,EAAO,QAAQ,aAAwB,GACvC,EAAO,QAAQ,WAAwB,GACvC,EAAO,QAAQ,YAAwB,GACvC,EAAO,QAAQ,WAAwB,GACvC,EAAO,QAAQ,cAAwB,GACvC,EAAO,QAAQ,aAAwB,GACvC,EAAO,QAAQ,cAAwB,GACvC,EAAO,QAAQ,SAAwB,GACvC,EAAO,QAAQ,iBAAwB,GACvC,EAAO,QAAQ,aAAwB,GACvC,EAAO,QAAQ,WAAwB,GACvC,EAAO,QAAQ,eAAwB,GACvC,EAAO,QAAQ,iBAAwB,GACvC,EAAO,QAAQ,WAAwB,GACvC,EAAO,QAAQ,mBAAwB,GACvC,EAAO,QAAQ,cAAwB,GACvC,EAAO,QAAQ,gBAAwB,GACvC,EAAO,QAAQ,eAAwB,GACvC,EAAO,QAAQ,cAAwB,GACvC,EAAO,QAAQ,eAAwB,GACvC,EAAO,QAAQ,eAAwB,GACvC,EAAO,QAAQ,cAAwB,GACvC,EAAO,QAAQ,aAAwB,GACvC,EAAO,QAAQ,cAAwB,GACvC,EAAO,QAAQ,cAAwB,GACvC,EAAO,QAAQ,YAAwB,GACvC,EAAO,QAAQ,aAAwB,GACvC,EAAO,QAAQ,aAAwB,GACvC,EAAO,QAAQ,eAAwB,GACvC,EAAO,QAAQ,SAAwB,GACvC,EAAO,QAAQ,aAAwB,GACvC,EAAO,QAAQ,cAAwB,GACvC,EAAO,QAAQ,gBAAwB,GACvC,EAAO,QAAQ,YAAwB,GACvC,EAAO,QAAQ,UAAwB,KC7sCvC,kBAEA,GAAM,GAAS,KACT,EAAS,KACT,GAAS,KACT,GAAS,KACT,GAAS,KAEf,EAAO,QAAQ,YAA0B,EAAK,YAC9C,EAAO,QAAQ,cAA0B,EAAK,cAC9C,EAAO,QAAQ,WAA0B,EAAK,cAAc,WAC5D,EAAO,QAAQ,YAA0B,EAAK,cAAc,YAC5D,EAAO,QAAQ,WAA0B,EAAK,cAAc,WAC5D,EAAO,QAAQ,WAA0B,EAAK,cAAc,WAC5D,EAAO,QAAQ,cAA0B,EAAK,cAAc,cAC5D,EAAO,QAAQ,aAA0B,EAAK,aAC9C,EAAO,QAAQ,cAA0B,EAAK,cAC9C,EAAO,QAAQ,aAA0B,EAAK,aAC9C,EAAO,QAAQ,YAA0B,EAAK,YAC9C,EAAO,QAAQ,iBAA0B,EAAK,iBAC9C,EAAO,QAAQ,aAA0B,EAAK,aAC9C,EAAO,QAAQ,cAA0B,EAAK,cAC9C,EAAO,QAAQ,aAA0B,EAAK,aAC9C,EAAO,QAAQ,YAA0B,EAAK,YAC9C,EAAO,QAAQ,aAA0B,EAAK,aAC9C,EAAO,QAAQ,YAA0B,EAAK,YAC9C,EAAO,QAAQ,YAA0B,EAAK,eAAe,YAC7D,EAAO,QAAQ,OAA0B,EAAK,cAAc,OAC5D,EAAO,QAAQ,UAA0B,EAAK,UAC9C,EAAO,QAAQ,WAA0B,EAAK,WAC9C,EAAO,QAAQ,WAA0B,EAAK,WAC9C,EAAO,QAAQ,UAA0B,EAAK,UAC9C,EAAO,QAAQ,WAA0B,EAAK,WAC9C,EAAO,QAAQ,UAA0B,EAAK,UAC9C,EAAO,QAAQ,SAA0B,EAAK,SAC9C,EAAO,QAAQ,WAA0B,EAAK,WAC9C,EAAO,QAAQ,SAA0B,EAAK,SAC9C,EAAO,QAAQ,SAA0B,EAAK,SAC9C,EAAO,QAAQ,UAA0B,EAAK,UAC9C,EAAO,QAAQ,UAA0B,EAAK,UAC9C,EAAO,QAAQ,UAA0B,EAAK,UAC9C,EAAO,QAAQ,UAA0B,EAAK,UAC9C,EAAO,QAAQ,UAA0B,EAAK,UAC9C,EAAO,QAAQ,UAA0B,EAAK,UAC9C,EAAO,QAAQ,UAA0B,EAAK,UAC9C,EAAO,QAAQ,kBAA0B,EAAK,kBAC9C,EAAO,QAAQ,YAA0B,EAAK,YAC9C,EAAO,QAAQ,iBAA0B,EAAK,iBAC9C,EAAO,QAAQ,cAA0B,EAAK,cAC9C,EAAO,QAAQ,oBAA0B,EAAK,oBAC9C,EAAO,QAAQ,cAA0B,EAAK,cAC9C,EAAO,QAAQ,UAA0B,EAAK,eAAe,UAC7D,EAAO,QAAQ,SAA0B,EAAK,eAAe,SAC7D,EAAO,QAAQ,aAA0B,EAAK,eAAe,aAC7D,EAAO,QAAQ,mBAA0B,EAAK,eAAe,mBAC7D,EAAO,QAAQ,YAA0B,EAAK,eAAe,YAC7D,EAAO,QAAQ,YAA0B,EAAK,eAAe,YAC7D,EAAO,QAAQ,WAA0B,EAAK,eAAe,WAC7D,EAAO,QAAQ,cAA0B,EAAK,eAAe,cAC7D,EAAO,QAAQ,cAA0B,EAAK,eAAe,cAC7D,EAAO,QAAQ,YAA0B,EAAK,eAAe,YAC7D,EAAO,QAAQ,YAA0B,EAAK,YAC9C,EAAO,QAAQ,kBAA0B,EAAK,kBAC9C,EAAO,QAAQ,kBAA0B,EAAK,kBAC9C,EAAO,QAAQ,gBAA0B,EAAK,gBAC9C,EAAO,QAAQ,oBAA0B,EAAK,oBAC9C,EAAO,QAAQ,UAA0B,EAAK,cAAc,UAC5D,EAAO,QAAQ,UAA0B,EAAK,UAC9C,EAAO,QAAQ,iBAA0B,EAAK,iBAC9C,EAAO,QAAQ,aAA0B,EAAK,aAC9C,EAAO,QAAQ,UAA0B,EAAK,UAC9C,EAAO,QAAQ,YAA0B,EAAK,YAC9C,EAAO,QAAQ,kBAA0B,EAAK,kBAC9C,EAAO,QAAQ,SAA0B,EAAK,SAC9C,EAAO,QAAQ,UAA0B,EAAK,UAC9C,EAAO,QAAQ,eAA0B,EAAK,eAC9C,EAAO,QAAQ,UAA0B,GAAO,UAChD,EAAO,QAAQ,YAA0B,EAAK,YAC9C,EAAO,QAAQ,WAA0B,EAAK,WAC9C,EAAO,QAAQ,SAA0B,EAAK,SAC9C,EAAO,QAAQ,gBAA0B,EAAK,gBAC9C,EAAO,QAAQ,SAA0B,EAAK,SAC9C,EAAO,QAAQ,UAA0B,EAAK,UAC9C,EAAO,QAAQ,OAA0B,EAAK,OAC9C,EAAO,QAAQ,cAA0B,EAAK,cAC9C,EAAO,QAAQ,kBAA0B,EAAK,kBAC9C,EAAO,QAAQ,aAA0B,EAAK,aAC9C,EAAO,QAAQ,cAA0B,EAAK,cAC9C,EAAO,QAAQ,YAA0B,GAAO,YAChD,EAAO,QAAQ,iBAA0B,GAAO,iBAChD,EAAO,QAAQ,gBAA0B,GAAO,gBAChD,EAAO,QAAQ,SAA0B,EAAK,SAC9C,EAAO,QAAQ,YAA0B,GAAO,YAChD,EAAO,QAAQ,aAA0B,GAAO,aAChD,EAAO,QAAQ,iBAA0B,EAAK,iBAC9C,EAAO,QAAQ,aAA0B,GAAO,aAChD,EAAO,QAAQ,aAA0B,EAAK,aAC9C,EAAO,QAAQ,WAA0B,EAAK,WAC9C,EAAO,QAAQ,eAA0B,EAAK,eAC9C,EAAO,QAAQ,iBAA0B,EAAK,iBAC9C,EAAO,QAAQ,WAA0B,EAAK,WAC9C,EAAO,QAAQ,cAA0B,EAAK,cAC9C,EAAO,QAAQ,gBAA0B,EAAK,gBAC9C,EAAO,QAAQ,eAA0B,EAAK,eAC9C,EAAO,QAAQ,cAA0B,EAAK,cAC9C,EAAO,QAAQ,oBAA0B,EAAK,oBAC9C,EAAO,QAAQ,UAA0B,EAAK,UAC9C,EAAO,QAAQ,WAA0B,EAAK,WAC9C,EAAO,QAAQ,gBAA0B,EAAK,gBAC9C,EAAO,QAAQ,aAA0B,EAAK,aAC9C,EAAO,QAAQ,YAA0B,EAAK,YAC9C,EAAO,QAAQ,aAA0B,EAAK,aAC9C,EAAO,QAAQ,YAA0B,EAAK,YAC9C,EAAO,QAAQ,aAA0B,EAAK,aAC9C,EAAO,QAAQ,eAA0B,EAAK,eAC9C,EAAO,QAAQ,gBAA0B,GAAI,gBAC7C,EAAO,QAAQ,QAA0B,EAAK,QAC9C,EAAO,QAAQ,SAA0B,EAAK,SAC9C,EAAO,QAAQ,aAA0B,GAAO,aAChD,EAAO,QAAQ,aAA0B,EAAK,aAC9C,EAAO,QAAQ,cAA0B,GAAO,cAChD,EAAO,QAAQ,gBAA0B,EAAK,gBAC9C,EAAO,QAAQ,SAA0B,EAAK,SAC9C,EAAO,QAAQ,UAA0B,EAAK,UAC9C,EAAO,QAAQ,WAA0B,EAAK,WAC9C,EAAO,QAAQ,QAA0B,EAAK,QAC9C,EAAO,QAAQ,gBAA0B,EAAK,gBAC9C,EAAO,QAAQ,iBAA0B,EAAK,iBAC9C,EAAO,QAAQ,kBAA0B,EAAK,kBAC9C,EAAO,QAAQ,gBAA0B,EAAK,gBAC9C,EAAO,QAAQ,oBAA0B,EAAK,oBAC9C,EAAO,QAAQ,gBAA0B,EAAK,gBAC9C,EAAO,QAAQ,kBAA0B,EAAK,kBAC9C,EAAO,QAAQ,mBAA0B,EAAK,mBAC9C,EAAO,QAAQ,sBAA0B,EAAK,sBAC9C,EAAO,QAAQ,gBAA0B,EAAK,gBAC9C,EAAO,QAAQ,gBAA0B,EAAK,gBAC9C,EAAO,QAAQ,YAA0B,EAAK,YAC9C,EAAO,QAAQ,eAA0B,EAAK,eAC9C,EAAO,QAAQ,eAA0B,EAAK,eAC9C,EAAO,QAAQ,eAA0B,EAAK,eAC9C,EAAO,QAAQ,cAA0B,EAAK,cAC9C,EAAO,QAAQ,iBAA0B,EAAK,iBAC9C,EAAO,QAAQ,aAA0B,EAAK,aAC9C,EAAO,QAAQ,WAA0B,EAAK,WAC9C,EAAO,QAAQ,YAA0B,EAAK,YAC9C,EAAO,QAAQ,YAA0B,EAAK,YAC9C,EAAO,QAAQ,WAA0B,EAAK,WAC9C,EAAO,QAAQ,WAA0B,EAAK,WAC9C,EAAO,QAAQ,YAA0B,EAAK,YAC9C,EAAO,QAAQ,YAA0B,EAAK,YAC9C,EAAO,QAAQ,aAA0B,EAAK,aAC9C,EAAO,QAAQ,WAA0B,EAAK,WAC9C,EAAO,QAAQ,YAA0B,EAAK,YAC9C,EAAO,QAAQ,WAA0B,GAAI,WAC7C,EAAO,QAAQ,WAA0B,EAAK,WAC9C,EAAO,QAAQ,aAA0B,GAAI,aAC7C,EAAO,QAAQ,aAA0B,EAAK,aAC9C,EAAO,QAAQ,cAA0B,EAAK,cAC9C,EAAO,QAAQ,YAA0B,GAAO,YAChD,EAAO,QAAQ,SAA0B,EAAK,SAC9C,EAAO,QAAQ,aAA0B,GAAO,aAChD,EAAO,QAAQ,iBAA0B,EAAK,iBAC9C,EAAO,QAAQ,aAA0B,EAAK,aAC9C,EAAO,QAAQ,WAA0B,EAAK,WAC9C,EAAO,QAAQ,eAA0B,EAAK,eAC9C,EAAO,QAAQ,iBAA0B,EAAK,iBAC9C,EAAO,QAAQ,WAA0B,EAAK,WAC9C,EAAO,QAAQ,mBAA0B,EAAK,mBAC9C,EAAO,QAAQ,cAA0B,EAAK,cAC9C,EAAO,QAAQ,eAA0B,EAAK,eAC9C,EAAO,QAAQ,cAA0B,EAAK,cAC9C,EAAO,QAAQ,eAA0B,EAAK,eAC9C,EAAO,QAAQ,eAA0B,EAAK,eAC9C,EAAO,QAAQ,cAA0B,EAAK,cAC9C,EAAO,QAAQ,aAA0B,EAAK,aAC9C,EAAO,QAAQ,cAA0B,EAAK,cAC9C,EAAO,QAAQ,cAA0B,EAAK,cAC9C,EAAO,QAAQ,YAA0B,EAAK,YAC9C,EAAO,QAAQ,aAA0B,EAAK,aAC9C,EAAO,QAAQ,aAA0B,EAAK,aAC9C,EAAO,QAAQ,eAA0B,EAAK,eAC9C,EAAO,QAAQ,SAA0B,EAAK,SAC9C,EAAO,QAAQ,aAA0B,EAAK,aAC9C,EAAO,QAAQ,cAA0B,EAAK,cAC9C,EAAO,QAAQ,gBAA0B,EAAK,gBAC9C,EAAO,QAAQ,YAA0B,EAAK,YAC9C,EAAO,QAAQ,UAA0B,EAAK,UAC9C,EAAO,QAAQ,UAA0B,GAAI,UAC7C,EAAO,QAAQ,WAA0B,GAAI,WAC7C,EAAO,QAAQ,gBAA0B,EAAK,kBC9L9C,kBAEA,GAAM,CACF,oBACA,KACE,CACF,cACA,eACA,qBACA,iBACA,gBACA,sBACA,YACA,aACA,eACA,eACA,cACA,mBACA,aACA,gBACA,eACA,YACA,kBACA,cACA,YACA,mBACA,aACA,gBACA,eACA,oBACA,gBACA,cACA,cACA,iBACA,aACA,gBACA,gBACA,eACA,WACA,YACA,gBACA,gBACA,YACA,aACA,WACA,mBACA,oBACA,qBACA,mBACA,mBACA,mBACA,mBACA,eACA,kBACA,iBACA,oBACA,gBACA,cACA,eACA,cACA,eACA,cACA,gBACA,iBACA,oBACA,cACA,iBACA,iBACA,kBACA,kBACA,iBACA,gBACA,iBACA,iBACA,gBACA,kBACA,YACA,gBACA,gBACA,KACE,CACF,mBACA,gBACA,eACA,iBACA,KAGE,GAAc,GAAW,EAGzB,GAAmB,EAAa,SAAS,EAGzC,GAAoB,EAAa,UAAU,EAE3C,GAAiB,EAAa,OAAO,EAErC,GAAiB,EAAE,GAAK,EAExB,GAAS,EAAa,QAAQ,EAC9B,GAAa,EAAa,YAAY,EAEtC,GAAQ,GAAI,YAAW,CAAC,EAExB,GAAN,KAAkB,CACd,aAAc,CACV,KAAK,EAAI,KACT,KAAK,EAAI,GACT,KAAK,EAAI,CACb,CACJ,EAEM,GAAU,GACV,GAAU,GAMV,GAAY,SAAS,EAAG,EAAQ,EAAO,CACzC,GAAI,IAAU,GAAK,CAAC,GAAY,EAAG,EAAE,EACjC,MAAO,GAIX,IAFA,GAAY,CAAC,EAEN,GAAS,EAAG,EAAE,GAAG,CACpB,GAAI,GAAS,EAAG,EAAE,IAAM,GAAa,CACjC,GAAI,GAAa,EAAG,EAAQ,EAAE,EAC1B,UAAQ,EAAG,CAAC,EACL,EACJ,GAAI,GAAU,EAAG,EAAQ,EAAQ,CAAC,EACrC,UAAW,EAAG,EAAE,EAChB,GAAgB,EAAG,GAAG,EACtB,GAAW,EAAG,EAAE,EAChB,GAAW,EAAG,CAAC,EACR,CAEf,CACA,GAAQ,EAAG,CAAC,CAChB,CAEA,MAAO,EACX,EAKM,GAAqB,SAAS,EAAG,EAAI,CACvC,GAAI,GAAM,GAAW,CAAC,EAGtB,GAFA,GAAY,EAAG,EAAa,GAAG,EAAG,CAAE,EACpC,GAAa,EAAG,GAAmB,EAAgB,EAC/C,GAAU,EAAG,EAAM,EAAG,CAAC,EAAG,CAC1B,GAAI,GAAO,GAAa,EAAG,EAAE,EAC7B,MAAI,GAAK,KAAO,IACZ,EAAK,KAAO,IACZ,EAAK,KAAO,IAEZ,IAAe,EAAG,EAAK,SAAS,CAAC,CAAC,EAClC,GAAW,EAAG,EAAE,GAEpB,GAAS,EAAG,GAAI,EAAM,CAAC,EACvB,GAAQ,EAAG,CAAC,EACL,CACX,KACI,WAAW,EAAG,CAAG,EACV,CAEf,EAEM,GAAe,SAAS,EAAG,EAAI,CACjC,AAAI,GAAmB,EAAG,CAAE,EACxB,IAAgB,EAAG,EAAa,eAAe,EAAG,GAAa,EAAG,EAAE,CAAC,EACrE,GAAW,EAAG,EAAE,GAEf,AAAI,EAAG,SAAS,SAAW,EAC5B,GAAgB,EAAG,EAAa,SAAS,EAAG,EAAG,SAAU,EAAG,IAAI,EAC/D,AAAI,EAAG,MAAQ,EAAG,KAAK,KAAO,IAC/B,GAAgB,EAAG,YAAY,EAC9B,AAAI,EAAG,MAAQ,EAAG,KAAK,KAAO,GAC/B,GAAgB,EAAG,EAAa,kBAAkB,EAAG,EAAG,UAAW,EAAG,WAAW,EAEjF,GAAgB,EAAG,GAAG,CAC9B,EAEM,GAAY,SAAS,EAAG,CAC1B,GAAI,GAAK,GAAI,IACT,EAAK,EACL,EAAK,EAET,KAAO,GAAa,EAAG,EAAI,CAAE,GAAK,EAAK,EAAI,GAAM,EAEjD,KAAO,EAAK,GAAI,CACZ,GAAI,GAAI,KAAK,MAAO,GAAK,GAAI,CAAC,EAC9B,AAAI,GAAa,EAAG,EAAG,CAAE,EAAG,EAAK,EAAI,EAChC,EAAK,CACd,CACA,MAAO,GAAK,CAChB,EAEM,GAAiB,SAAS,EAAG,EAAI,EAAK,EAAO,CAC/C,GAAI,GAAK,GAAI,IACT,EAAM,GAAW,CAAC,EAClB,EAAO,GAAU,CAAE,EACnB,EAAK,EAAO,EAAQ,GAAU,GAAU,GAAU,GAKtD,IAJI,GACA,GAAgB,EAAG,EAAa;AAAA,CAAM,EAAG,CAAG,EAChD,GAAgB,EAAG,GAAI,IAAI,EAC3B,GAAgB,EAAG,kBAAkB,EAC9B,GAAa,EAAI,IAAS,CAAE,GAC/B,AAAI,MAAS,EACT,IAAgB,EAAG;AAAA,KAAS,EAC5B,EAAQ,EAAO,GAAU,GAEzB,IAAY,EAAI,EAAa,OAAQ,EAAI,EAAG,CAAE,EAC9C,GAAgB,EAAG,EAAa;AAAA,KAAS,EAAG,EAAG,SAAS,EACpD,EAAG,YAAc,GACjB,GAAgB,EAAG,GAAG,EAAG,cAAc,EAC3C,GAAgB,EAAG,MAAM,EACzB,GAAa,EAAG,CAAE,EACd,EAAG,YACH,GAAgB,EAAG;AAAA,mBAAuB,EAC9C,GAAW,EAAG,GAAW,CAAC,EAAI,CAAG,GAGzC,GAAW,EAAG,GAAW,CAAC,EAAI,CAAG,CACrC,EAEM,GAAQ,SAAS,EAAG,CACtB,GAAI,GAAM,gDAAkD,GAAe,EAAG,EAAE,EAAI,IACpF,KAAM,IAAI,OAAM,CAAG,CACvB,EAEM,GAAgB,SAAS,EAAG,EAAK,EAAU,CAC7C,GAAI,GAAK,GAAI,IAEb,MAAK,IAAa,EAAG,EAAG,CAAE,EAG1B,IAAY,EAAG,EAAa,GAAG,EAAG,CAAE,EAEhC,GAAa,EAAG,SAAU,EAAa,QAAQ,CAAC,GAChD,KACI,IAAQ,GACD,GAAW,EAAG,EAAa,+BAA+B,EAAG,EAAG,KAAM,CAAQ,EAGzF,GAAG,OAAS,MACZ,GAAG,KAAO,GAAmB,EAAG,CAAE,EAAI,GAAa,EAAG,EAAE,EAAI,EAAa,GAAG,GAEzE,GAAW,EAAG,EAAa,+BAA+B,EAAG,EAAK,EAAG,KAAM,CAAQ,IAb/E,GAAW,EAAG,EAAa,uBAAuB,EAAG,EAAK,CAAQ,CAcjF,EAEM,GAAY,SAAS,EAAG,EAAK,EAAO,CACtC,GAAI,GACJ,AAAI,GAAkB,EAAG,EAAK,EAAM,IAAM,GACtC,EAAU,GAAa,EAAG,EAAE,EAC3B,AAAI,GAAS,EAAG,CAAG,IAAM,GAC1B,EAAU,EAAa,iBAAkB,EAAI,EAE7C,EAAU,GAAc,EAAG,CAAG,EAElC,GAAI,GAAM,GAAgB,EAAG,EAAa,qBAAqB,EAAG,EAAO,CAAO,EAChF,MAAO,IAAc,EAAG,EAAK,CAAG,CACpC,EAEM,GAAa,SAAS,EAAG,EAAO,CAClC,GAAI,GAAK,GAAI,IACb,GAAI,GAAa,EAAG,EAAO,CAAE,GACzB,IAAY,EAAG,EAAa,KAAM,EAAI,EAAG,CAAE,EACvC,EAAG,YAAc,GAAG,CACpB,GAAgB,EAAG,EAAa,SAAS,EAAG,EAAG,UAAW,EAAG,WAAW,EACxE,MACJ,CAEJ,GAAe,EAAG,EAAa,EAAE,CAAC,CACtC,EAEM,GAAa,SAAS,EAAG,KAAQ,EAAM,CACzC,UAAW,EAAG,CAAC,EACf,GAAiB,EAAG,EAAK,CAAI,EAC7B,GAAW,EAAG,CAAC,EACR,GAAU,CAAC,CACtB,EAGM,GAAkB,SAAS,EAAG,EAAM,EAAO,EAAG,CAChD,GAAI,EACA,UAAgB,EAAG,CAAC,EACb,EACJ,CACH,GAAY,CAAC,EACb,GAAI,GAAS,EACb,MAAI,GACA,GAAU,EAAE,QACZ,EAAQ,CAAC,EAAE,OAEX,GAAU,UACV,EAAQ,GAEZ,AAAI,EACA,GAAgB,EAAG,EAAa,QAAQ,EAAG,EAAO,EAAa,CAAO,CAAC,EAEvE,GAAe,EAAG,EAAa,CAAO,CAAC,EAC3C,GAAgB,EAAG,CAAK,EACjB,CACX,CACJ,EAGM,GAAkB,SAAS,EAAG,EAAG,CACnC,GAAI,GAAM,EACV,GAAI,IAAM,KACN,UAAgB,EAAG,CAAC,EACpB,GAAgB,EAAG,MAAM,EACzB,GAAgB,EAAG,CAAC,EACb,EACJ,GAAI,EAAE,OACT,EAAO,OACP,EAAO,EAAE,eACF,EAAE,OACT,EAAO,SACP,EAAO,EAAE,WAGT,OAAO,IAAgB,EAAG,EAAG,KAAM,CAAC,EAExC,UAAY,CAAC,EACb,GAAgB,EAAG,CAAI,EACvB,GAAgB,EAAG,CAAI,EAChB,CACX,EAEM,GAAoB,SAAS,EAAG,EAAG,CACrC,MAAO,IAAa,EAAG,GAAmB,CAAC,CAC/C,EAEM,GAAoB,SAAS,EAAG,EAAO,CACzC,MAAI,IAAkB,EAAG,CAAK,IAAM,GACzB,EACX,IAAQ,EAAG,CAAC,EACZ,GAAgB,EAAG,EAAG,CAAC,EACvB,GAAe,EAAG,CAAK,EACvB,GAAa,EAAG,GAAI,EAAM,EAC1B,GAAc,EAAG,EAAE,EACnB,GAAa,EAAG,GAAmB,CAAK,EACjC,EAEX,EAEM,GAAoB,SAAS,EAAG,EAAO,CACzC,GAAkB,EAAG,CAAK,EAC1B,GAAiB,EAAG,EAAE,CAC1B,EAEM,GAAiB,SAAS,EAAG,EAAI,EAAO,CAC1C,GAAI,GAAI,GAAe,EAAG,CAAE,EAC5B,MAAI,KAAM,MACF,GAAiB,EAAG,CAAE,EACtB,IAAkB,EAAG,CAAK,EACrB,GAAa,EAAG,GAAI,EAAE,GACvB,GAAI,MACR,GAAQ,EAAG,CAAC,EACL,GAGR,IACX,EAEM,GAAkB,SAAS,EAAG,EAAI,EAAO,CAC3C,GAAI,GAAI,GAAe,EAAG,EAAI,CAAK,EACnC,MAAI,KAAM,MAAM,GAAU,EAAG,EAAI,CAAK,EAC/B,CACX,EAEM,GAAmB,SAAS,EAAG,EAAK,EAAK,EAAK,CAChD,GAAI,GAAO,IAAQ,KAAO,GAAe,EAAG,EAAK,CAAG,EAAI,GAAiB,EAAG,CAAG,EAC/E,OAAS,GAAI,EAAG,EAAI,GAAI,IACpB,GAAI,GAAa,EAAI,GAAI,CAAI,EACzB,MAAO,GACf,MAAO,IAAc,EAAG,EAAK,GAAgB,EAAG,EAAa,qBAAqB,EAAG,CAAI,CAAC,CAC9F,EAEM,GAAY,SAAS,EAAG,EAAK,EAAK,CACpC,GAAU,EAAG,EAAK,GAAa,EAAG,CAAG,CAAC,CAC1C,EAEM,GAAgB,UAAW,CAC7B,GAAI,GAAI,GAAa,EACrB,MAAI,IAAG,GAAY,EAAG,EAAK,EACpB,CACX,EAGM,GAAgB,SAAS,EAAG,EAAG,CACjC,MAAO,IAAa,EAAG,GAAS,EAAG,CAAC,CAAC,CACzC,EAEM,GAAgB,SAAS,EAAG,EAAM,EAAK,EAAU,CACnD,AAAK,GAAM,GAAc,EAAG,EAAK,CAAQ,CAC7C,EAEM,GAAgB,SAAS,EAAG,EAAK,CACnC,AAAI,GAAS,EAAG,CAAG,IAAM,IACrB,GAAc,EAAG,EAAK,EAAa,iBAAkB,EAAI,CAAC,CAClE,EAEM,GAAiB,SAAS,EAAG,EAAK,EAAG,CACvC,AAAI,GAAS,EAAG,CAAG,IAAM,GACrB,GAAU,EAAG,EAAK,CAAC,CAC3B,EAEM,GAAoB,SAAS,EAAG,EAAK,CACvC,GAAI,GAAI,GAAc,EAAG,CAAG,EAC5B,MAAI,IAAM,MAAyB,GAAU,EAAG,EAAK,EAAW,EACzD,CACX,EAEM,GAAmB,GAEnB,GAAkB,SAAS,EAAG,EAAK,EAAK,CAC1C,MAAI,IAAS,EAAG,CAAG,GAAK,EACb,IAAQ,KAAO,KAAO,GAAgB,CAAG,EACtC,GAAkB,EAAG,CAAG,CAC1C,EAEM,GAAiB,GAEjB,GAAW,SAAS,EAAG,EAAK,CAC9B,AAAI,GAAa,EAAG,CAAG,EACnB,GAAc,EAAG,EAAK,EAAa,uCAAwC,EAAI,CAAC,EAEhF,GAAU,EAAG,EAAK,EAAW,CACrC,EAEM,GAAmB,SAAS,EAAG,EAAK,CACtC,GAAI,GAAI,GAAc,EAAG,CAAG,EAC5B,MAAI,KAAM,IACN,GAAU,EAAG,EAAK,EAAW,EAC1B,CACX,EAEM,GAAiB,SAAS,EAAG,EAAK,EAAK,CACzC,MAAO,IAAS,EAAG,GAAkB,EAAK,CAAG,CACjD,EAEM,GAAoB,SAAS,EAAG,EAAK,CACvC,GAAI,GAAI,GAAe,EAAG,CAAG,EAC7B,MAAI,KAAM,IACN,GAAS,EAAG,CAAG,EACZ,CACX,EAEM,GAAkB,SAAS,EAAG,EAAK,EAAK,CAC1C,MAAO,IAAS,EAAG,GAAmB,EAAK,CAAG,CAClD,EAEM,GAAoB,SAAS,EAAG,EAAI,CACtC,GAAI,GAAS,EAAE,EAAI,EACnB,GAAI,EAAE,EAAE,OAAS,EAAQ,CACrB,GAAI,GAAU,KAAK,IAAI,EAAE,EAAE,OAAS,EAAG,CAAM,EACzC,EAAU,GAAI,YAAW,CAAO,EACpC,EAAQ,IAAI,EAAE,CAAC,EACf,EAAE,EAAI,CACV,CACA,MAAO,GAAE,EAAE,SAAS,EAAE,EAAG,CAAM,CACnC,EAEM,GAAgB,SAAS,EAAG,EAAG,CACjC,EAAE,EAAI,EACN,EAAE,EAAI,EACV,EAEM,GAAoB,SAAS,EAAG,EAAG,EAAI,CACzC,UAAc,EAAG,CAAC,EACX,GAAkB,EAAG,CAAE,CAClC,EAEM,GAAkB,SAAS,EAAG,CAChC,MAAO,IAAkB,EAAG,EAAe,CAC/C,EAEM,GAAkB,SAAS,EAAG,EAAG,EAAG,CACtC,AAAI,EAAI,GACJ,GAAI,GAAgB,CAAC,EAErB,AADQ,GAAkB,EAAG,CAAC,EAC5B,IAAI,EAAE,SAAS,EAAG,CAAC,CAAC,EACtB,GAAa,EAAG,CAAC,EAEzB,EAEM,GAAiB,SAAS,EAAG,EAAG,CAClC,EAAI,GAAgB,CAAC,EACrB,GAAgB,EAAG,EAAG,EAAE,MAAM,CAClC,EAEM,GAAkB,SAAS,EAAG,CAChC,GAAgB,EAAE,EAAG,EAAE,EAAG,EAAE,CAAC,EAE7B,EAAE,EAAI,EACN,EAAE,EAAI,EACV,EAEM,GAAe,SAAS,EAAG,EAAG,CAChC,GAAkB,EAAG,CAAC,EACtB,EAAE,EAAE,EAAE,KAAO,CACjB,EAEM,GAAe,SAAS,EAAG,EAAG,CAChC,EAAE,GAAK,CACX,EAEM,GAAsB,SAAS,EAAG,EAAI,CACxC,GAAa,EAAG,CAAE,EAClB,GAAgB,CAAC,CACrB,EAEM,GAAgB,SAAS,EAAG,CAC9B,GAAI,GAAI,EAAE,EACN,EAAI,GAAa,EAAG,EAAE,EAC1B,GAAgB,EAAG,EAAG,EAAE,MAAM,EAC9B,GAAQ,EAAG,CAAC,CAChB,EAEM,GAAW,SAAS,EAAG,EAAG,EAAG,EAAG,CAClC,MAAO,IAAS,EAAG,CAAC,GAAK,EAAI,EAAI,EAAE,EAAG,CAAC,CAC3C,EAEM,GAAO,SAAS,EAAG,EAAI,CACzB,GAAI,GAAI,EAAG,OACX,SAAG,OAAS,KACL,CACX,EAEM,GAAmB,SAAS,EAAG,EAAM,EAAM,EAAM,EAAM,CACzD,MAAO,IAAS,EAAG,GAAM,CAAC,OAAQ,CAAI,EAAG,EAAM,CAAI,CACvD,EAEM,GAAkB,SAAS,EAAG,EAAG,EAAI,EAAG,CAC1C,MAAO,IAAiB,EAAG,EAAG,EAAI,EAAG,IAAI,CAC7C,EAEM,GAAkB,SAAS,EAAG,EAAG,CACnC,MAAO,IAAgB,EAAG,EAAG,EAAE,OAAQ,CAAC,CAC5C,EAEM,GAAgB,SAAS,EAAG,EAAG,CACjC,MAAQ,IAAgB,EAAG,CAAC,GAAK,GAAU,EAAG,EAAG,GAAa,CAAC,CACnE,EAEM,GAAoB,SAAS,EAAG,EAAK,EAAO,CAC9C,GAAK,GAAiB,EAAG,CAAG,EAEvB,CACD,GAAe,EAAG,CAAK,EACvB,GAAI,GAAK,GAAW,EAAG,EAAE,EACzB,MAAI,KAAO,GACP,GAAQ,EAAG,CAAC,EAEZ,GAAW,EAAG,EAAE,EACb,CACX,KATI,OAAO,GAUf,EAEM,GAAgB,SAAS,EAAG,EAAK,EAAO,CAE1C,MADA,GAAM,GAAa,EAAG,CAAG,EACrB,GAAkB,EAAG,EAAK,CAAK,IAAM,GAC9B,GAEX,IAAc,EAAG,CAAG,EACpB,GAAS,EAAG,EAAG,CAAC,EAET,GACX,EAEM,GAAW,SAAS,EAAG,EAAK,CAC9B,GAAQ,EAAG,CAAG,EACd,GAAI,GAAI,GAAe,EAAG,EAAE,EAC5B,MAAI,KAAM,IACN,GAAW,EAAG,EAAa,kCAAmC,EAAI,CAAC,EACvE,GAAQ,EAAG,CAAC,EACL,CACX,EAEM,GAAM,EAAa,IAAI,EACvB,GAAM,EAAa,IAAI,EACvB,GAAiB,SAAS,EAAG,EAAK,CACpC,GAAI,GAAc,EAAG,EAAK,EAAU,EAChC,AAAK,GAAa,EAAG,EAAE,GACnB,GAAW,EAAG,EAAa,mCAAmC,CAAC,MAGnE,QADQ,GAAS,EAAG,CAAG,OAEd,IAAa,CACd,AAAI,GAAc,EAAG,CAAG,EACpB,GAAgB,EAAG,GAAK,GAAc,EAAG,CAAG,CAAC,EAE7C,GAAgB,EAAG,GAAK,GAAa,EAAG,CAAG,CAAC,EAChD,KACJ,KACK,IACD,GAAc,EAAG,CAAG,EACpB,UACC,IACD,GAAgB,EAAI,GAAc,EAAG,CAAG,EAAI,OAAS,OAAQ,EAC7D,UACC,IACD,GAAgB,EAAG,KAAK,EACxB,cACK,CACL,GAAI,GAAK,GAAkB,EAAG,EAAK,EAAM,EACrC,EAAO,IAAO,GAAc,GAAa,EAAG,EAAE,EAAI,GAAc,EAAG,CAAG,EAC1E,GAAgB,EAAG,EAAa,QAAQ,EAAG,EAAM,GAAc,EAAG,CAAG,CAAC,EAClE,IAAO,IACP,GAAW,EAAG,EAAE,EACpB,KACJ,EAIR,MAAO,IAAc,EAAG,EAAE,CAC9B,EAQM,GAAgB,SAAS,EAAG,EAAS,EAAO,EAAK,CACnD,GAAiB,EAAG,GAAmB,EAAgB,EACvD,GAAa,EAAG,GAAI,CAAO,EACtB,GAAc,EAAG,EAAE,GACpB,IAAQ,EAAG,CAAC,EACZ,GAAkB,EAAG,CAAK,EAC1B,GAAe,EAAG,CAAO,EACzB,GAAS,EAAG,EAAG,CAAC,EAChB,GAAc,EAAG,EAAE,EACnB,GAAa,EAAG,GAAI,CAAO,GAE/B,GAAW,EAAG,EAAE,EACZ,GACA,IAAc,EAAG,EAAE,EACnB,GAAc,EAAG,CAAO,EAEhC,EAEM,GAAgB,SAAS,EAAK,EAAQ,EAAY,CACpD,GAAI,GAAI,IAAe,EACnB,EAAK,EAAO,OACZ,EAAI,EAAI,OAAS,EAAI,EAEzB,EAAM,KAAO,EAAI,EAAG,IAAK,CACrB,OAAS,GAAI,EAAG,EAAI,EAAI,IACpB,GAAI,EAAI,EAAE,KAAO,EAAO,GACpB,WACR,MAAO,EACX,CACA,MAAO,EACX,EAEM,GAAY,SAAS,EAAG,EAAG,EAAG,EAAG,CACnC,GAAI,GACA,EAAI,GAAI,IAEZ,IADA,GAAc,EAAG,CAAC,EACV,GAAO,GAAc,EAAG,CAAC,IAAM,GACnC,GAAgB,EAAG,EAAG,CAAI,EAC1B,GAAe,EAAG,CAAC,EACnB,EAAI,EAAE,SAAS,EAAO,EAAE,MAAM,EAElC,UAAe,EAAG,CAAC,EACnB,GAAgB,CAAC,EACV,GAAa,EAAG,EAAE,CAC7B,EAMM,GAAmB,SAAS,EAAG,EAAK,EAAO,CAC7C,MAAI,IAAa,EAAG,EAAK,CAAK,IAAM,GACzB,GAEP,IAAQ,EAAG,CAAC,EACZ,EAAM,GAAa,EAAG,CAAG,EACzB,GAAa,CAAC,EACd,GAAc,EAAG,EAAE,EACnB,GAAa,EAAG,EAAK,CAAK,EACnB,GAEf,EAOM,GAAgB,SAAS,EAAG,EAAG,EAAK,CACtC,GAAgB,EAAG,EAAK,EAAa,oBAAqB,EAAI,CAAC,EAC/D,OAAS,KAAO,GAAG,CACf,OAAS,GAAI,EAAG,EAAI,EAAK,IACrB,GAAc,EAAG,CAAC,CAAG,EACzB,GAAiB,EAAG,EAAE,GAAM,CAAG,EAC/B,GAAa,EAAG,CAAE,GAAM,GAAI,EAAa,CAAG,CAAC,CACjD,CACA,GAAQ,EAAG,CAAG,CAClB,EASM,GAAkB,SAAS,EAAG,EAAO,EAAK,CAC5C,AAAK,GAAe,EAAG,CAAK,GACxB,CAAI,EACA,GAAW,EAAG,EAAa,qBAAqB,EAAG,CAAG,EAEtD,GAAW,EAAG,EAAa,iBAAkB,EAAI,CAAC,EAE9D,EAEM,GAAmB,SAAS,EAAG,CACjC,GAAgB,CAAC,CACrB,EAEM,GAAc,SAAS,EAAG,EAAG,CAC/B,GAAgB,CAAC,EACjB,GAAc,EAAG,EAAG,CAAC,CACzB,EAGM,GAAa,GACb,GAAa,GAEb,GAAW,SAAS,EAAG,EAAG,CAC5B,GAAI,GACJ,MAAI,IAAU,EAAG,EAAE,EACf,IAAQ,EAAG,CAAC,EACL,IAEX,GAAI,GAAa,EAAG,CAAC,EACrB,GAAY,EAAG,EAAG,CAAC,EACnB,EAAM,GAAc,EAAG,EAAE,EACzB,GAAQ,EAAG,CAAC,EACZ,AAAI,IAAQ,EACR,IAAY,EAAG,EAAG,CAAG,EACrB,GAAY,EAAG,EAAG,CAAC,GAGnB,EAAM,GAAW,EAAG,CAAC,EAAI,EAC7B,GAAY,EAAG,EAAG,CAAG,EACd,EACX,EAGM,GAAa,SAAS,EAAG,EAAG,EAAK,CACnC,AAAI,GAAO,GACP,GAAI,GAAa,EAAG,CAAC,EACrB,GAAY,EAAG,EAAG,CAAC,EACnB,GAAY,EAAG,EAAG,CAAG,EACrB,GAAgB,EAAG,CAAG,EACtB,GAAY,EAAG,EAAG,CAAC,EAE3B,EAGM,GAAU,SAAS,EAAG,EAAM,EAAY,EAAO,CACjD,GAAI,GAAO,EAAM,QACb,EAAW,GAAa,EAAG,CAAU,EAAE,SAAS,CAAC,EACrD,UAAgB,EAAG,EAAa,kBAAkB,EAAG,EAAa,CAAI,EAAG,EAAU,EAAa,CAAI,CAAC,EACrG,GAAW,EAAG,CAAU,EACjB,EACX,EAEI,GAEE,GAAW,CAAC,IAAM,IAAM,GAAI,EAC5B,GAAU,SAAS,EAAI,CACzB,EAAG,EAAI,EACP,GAAI,GACA,EAAI,EACR,EAAG,CAEC,GADA,EAAI,GAAK,CAAE,EACP,IAAM,MAAQ,IAAM,GAAS,GAAI,MAAO,GAC5C,IACA,EAAG,KAAK,EAAG,KAAO,CACtB,OAAS,EAAI,GAAS,QACtB,SAAG,EAAI,EACA,GAAK,CAAE,CAClB,EASM,GAAc,SAAS,EAAI,CAC7B,GAAI,GAAI,GAAQ,CAAE,EAClB,GAAI,IAAM,GAA4B,CAClC,EACI,GAAI,GAAK,CAAE,QACN,GAAK,IAAM,IAEpB,MAAO,CACH,QAAS,GACT,EAAG,GAAK,CAAE,CACd,CACJ,KACI,OAAO,CACH,QAAS,GACT,EAAG,CACP,CAER,EAEI,GAEgC,CAChC,MAAM,CAAM,CACR,aAAc,CACV,KAAK,EAAI,IACT,KAAK,EAAI,KACT,KAAK,KAAO,GAAI,YAAW,IAAI,EAC/B,KAAK,IAAM,EACX,KAAK,IAAM,MACf,CACJ,CAEA,GAAM,GAAO,SAAS,EAAG,EAAI,CACzB,GAAI,GAAK,EAET,GAAI,EAAG,IAAM,MAAQ,EAAG,EAAI,EAAG,CAC3B,GAAI,GAAQ,EAAG,EACf,SAAG,EAAI,EACP,EAAG,EAAI,EAAG,EAAE,SAAS,EAAG,GAAG,EACpB,EAAG,KAAK,SAAS,EAAG,CAAK,CACpC,CAEA,GAAI,GAAI,EAAG,EACX,SAAG,EAAI,KACA,CACX,EAEA,GAAO,SAAS,EAAI,CAChB,MAAO,GAAG,IAAM,EAAG,EAAE,OAAS,EAAG,EAAE,EAAG,OAAS,IACnD,EAEA,GAAiB,SAAS,EAAG,EAAU,EAAM,CACzC,GAAI,GAAK,GAAI,GACT,EAAa,GAAW,CAAC,EAAI,EACjC,GAAI,IAAa,KACb,KAAM,IAAI,OAAM,iCAAiC,EAC9C,CACH,GAAgB,EAAG,EAAa,KAAK,EAAG,CAAQ,EAChD,GAAI,GAAO,GAAa,CAAQ,EAC5B,EAAM,GAAI,gBAUd,GATA,EAAI,KAAK,MAAO,EAAM,EAAK,EAKvB,MAAO,SAAW,aAClB,GAAI,aAAe,eAEvB,EAAI,KAAK,EACL,EAAI,QAAU,KAAO,EAAI,QAAU,IACnC,AAAI,MAAO,GAAI,UAAa,SACxB,EAAG,EAAI,EAAa,EAAI,QAAQ,EAEhC,EAAG,EAAI,GAAI,YAAW,EAAI,QAAQ,MAGtC,UAAG,IAAM,EAAI,OACN,GAAQ,EAAG,OAAQ,EAAY,CAAE,QAAS,GAAG,EAAI,WAAW,EAAI,YAAa,CAAC,CAE7F,CACA,GAAI,GAAM,GAAY,CAAE,EAExB,AAAI,EAAI,IAAM,GAAc,IAAM,GAEvB,EAAI,SACX,GAAG,KAAK,EAAG,KAAO,IAElB,EAAI,IAAM,MACV,GAAG,KAAK,EAAG,KAAO,EAAI,GAC1B,GAAI,GAAS,GAAS,EAAG,EAAM,EAAI,GAAa,EAAG,EAAE,EAAG,CAAI,EACxD,EAAa,EAAG,IACpB,MAAI,GACA,IAAW,EAAG,CAAU,EACjB,GAAQ,EAAG,OAAQ,EAAY,CAAU,GAEpD,IAAW,EAAG,CAAU,EACjB,EACX,CACJ,CAiFA,GAAM,IAAgB,SAAS,EAAG,EAAU,CACxC,MAAO,IAAe,EAAG,EAAU,IAAI,CAC3C,EAEM,GAAc,SAAS,EAAG,EAAU,CACtC,MAAQ,IAAc,EAAG,CAAQ,GAAK,GAAU,EAAG,EAAG,GAAa,CAAC,CACxE,EAEM,GAAuB,UAAW,CACpC,OAAS,GAAE,EAAG,EAAE,UAAU,OAAQ,IAAK,CACnC,GAAI,GAAI,UAAU,GAGd,EAAG,CAGC,GAAI,GAAI,uBAAuB,KAAK,CAAC,EACrC,QAAQ,MAAM,EAAE,EAAE,EAClB,EAAI,EAAE,EACV,OAAS,IAAM,GAIvB,CACJ,EAEM,GAAqB,SAAS,EAAG,EAAK,EAAI,CAC5C,GAAI,GAAI,GAAY,CAAC,EACrB,AAAI,GAAM,IACN,GAAW,EAAG,EAAa,kDAAkD,CAAC,EAClF,AAAI,GAAK,GAAY,IAAI,EACrB,GAAW,EAAG,EAAa,2BAA2B,CAAC,EAClD,IAAM,GACX,GAAW,EAAG,EAAa,uDAAuD,EAAG,EAAK,CAAC,CACnG,EAGM,GAAoB,SAAS,EAAG,CAClC,GAAmB,EAAG,GAAiB,EAAa,CACxD,EAEA,EAAO,QAAQ,YAAuB,GACtC,EAAO,QAAQ,eAAuB,GACtC,EAAO,QAAQ,iBAAuB,GACtC,EAAO,QAAQ,UAAuB,GACtC,EAAO,QAAQ,kBAAuB,GACtC,EAAO,QAAQ,WAAuB,GACtC,EAAO,QAAQ,YAAuB,GACtC,EAAO,QAAQ,aAAuB,GACtC,EAAO,QAAQ,gBAAuB,GACtC,EAAO,QAAQ,aAAuB,GACtC,EAAO,QAAQ,eAAuB,GACtC,EAAO,QAAQ,cAAuB,GACtC,EAAO,QAAQ,cAAuB,GACtC,EAAO,QAAQ,cAAuB,GACtC,EAAO,QAAQ,cAAuB,GACtC,EAAO,QAAQ,kBAAuB,GACtC,EAAO,QAAQ,cAAuB,GACtC,EAAO,QAAQ,cAAuB,GACtC,EAAO,QAAQ,kBAAuB,GACtC,EAAO,QAAQ,kBAAuB,GACtC,EAAO,QAAQ,iBAAuB,GACtC,EAAO,QAAQ,iBAAuB,GACtC,EAAO,QAAQ,gBAAuB,GACtC,EAAO,QAAQ,iBAAuB,GACtC,EAAO,QAAQ,eAAuB,GACtC,EAAO,QAAQ,gBAAuB,GACtC,EAAO,QAAQ,kBAAuB,GACtC,EAAO,QAAQ,mBAAuB,GACtC,EAAO,QAAQ,YAAuB,GACtC,EAAO,QAAQ,cAAuB,GACtC,EAAO,QAAQ,WAAuB,GACtC,EAAO,QAAQ,gBAAuB,GACtC,EAAO,QAAQ,gBAAuB,GACtC,EAAO,QAAQ,kBAAuB,GACtC,EAAO,QAAQ,kBAAuB,GACtC,EAAO,QAAQ,iBAAuB,GACtC,EAAO,QAAQ,UAAuB,GACtC,EAAO,QAAQ,SAAuB,GACtC,EAAO,QAAQ,gBAAuB,GACtC,EAAO,QAAQ,iBAAuB,GACtC,EAAO,QAAQ,cAAuB,GACtC,EAAO,QAAQ,eAAuB,GACtC,EAAO,QAAQ,gBAAuB,GACtC,EAAO,QAAQ,YAAuB,GACtC,EAAO,QAAQ,iBAAuB,GACtC,EAAO,QAAQ,kBAAuB,GACtC,EAAO,QAAQ,cAAuB,GACtC,EAAO,QAAQ,SAAuB,GACtC,EAAO,QAAQ,gBAAuB,GACtC,EAAO,QAAQ,gBAAuB,GACtC,EAAO,QAAQ,eAAuB,GACtC,EAAO,QAAQ,eAAuB,GACtC,EAAO,QAAQ,gBAAuB,GACtC,EAAO,QAAQ,kBAAuB,GACtC,EAAO,QAAQ,gBAAuB,GACtC,EAAO,QAAQ,oBAAuB,GACtC,EAAO,QAAQ,SAAuB,GACtC,EAAO,QAAQ,cAAuB,GACtC,EAAO,QAAQ,cAAuB,GACtC,EAAO,QAAQ,kBAAuB,GACtC,EAAO,QAAQ,eAAuB,GACtC,EAAO,QAAQ,eAAuB,GACtC,EAAO,QAAQ,eAAuB,GACtC,EAAO,QAAQ,cAAuB,GACtC,EAAO,QAAQ,WAAuB,GACtC,EAAO,QAAQ,WAAuB,GACtC,EAAO,QAAQ,qBAAuB,KC/jCtC,mBAEA,GAAM,CACF,eACA,UACA,iBACA,YACA,aACA,eACA,eACA,cACA,eACA,aACA,YACA,aACA,cACA,aACA,iBACA,YACA,oBACA,cACA,cACA,aACA,cACA,gBACA,YACA,YACA,cACA,WACA,mBACA,qBACA,uBACA,mBACA,mBACA,eACA,kBACA,iBACA,gBACA,cACA,cACA,cACA,cACA,eACA,cACA,gBACA,oBACA,cACA,kBACA,sBACA,iBACA,iBACA,gBACA,YACA,iBACA,KACE,CACF,iBACA,iBACA,qBACA,oBACA,mBACA,kBACA,cACA,qBACA,oBACA,iBACA,kBACA,mBACA,kBACA,iBACA,kBACA,eACA,KACE,CACF,eACA,iBACA,KAEA,GACA,GAEA,GAAI,MAAO,cAAgB,WAAY,CACnC,GAAI,GAAO,GACP,EAAU,GAAI,aAAY,OAAO,EACrC,GAAkB,SAAS,EAAG,CAC1B,GAAQ,EAAQ,OAAO,EAAG,CAAC,OAAQ,EAAI,CAAC,CAC5C,EACA,GAAI,GAAQ,GAAI,YAAW,CAAC,EAC5B,GAAgB,UAAW,CACvB,GAAQ,EAAQ,OAAO,CAAK,EAC5B,QAAQ,IAAI,CAAI,EAChB,EAAO,EACX,CACJ,KAAO,CACH,GAAI,GAAO,CAAC,EACZ,GAAkB,SAAS,EAAG,CAC1B,GAAI,CAEA,EAAI,GAAY,CAAC,CACrB,OAAQ,EAAN,CAEE,GAAI,GAAO,GAAI,YAAW,EAAE,MAAM,EAClC,EAAK,IAAI,CAAC,EACV,EAAI,CACR,CACA,EAAK,KAAK,CAAC,CACf,EACA,GAAgB,UAAW,CACvB,QAAQ,IAAI,MAAM,QAAQ,IAAK,CAAI,EACnC,EAAO,CAAC,CACZ,CACJ,CASJ,GAAM,IAAa,SAAS,EAAG,CAC3B,GAAI,GAAI,GAAW,CAAC,EACpB,GAAc,EAAG,GAAa,WAAY,EAAI,CAAC,EAC/C,OAAS,GAAI,EAAG,GAAK,EAAG,IAAK,CACzB,GAAc,EAAG,EAAE,EACnB,GAAc,EAAG,CAAC,EAClB,GAAS,EAAG,EAAG,CAAC,EAChB,GAAI,GAAI,GAAc,EAAG,EAAE,EAC3B,GAAI,IAAM,KACN,MAAO,IAAW,EAAG,GAAa,4CAA4C,CAAC,EACnF,AAAI,EAAI,GAAG,GAAgB,GAAa,GAAI,CAAC,EAC7C,GAAgB,CAAC,EACjB,GAAQ,EAAG,CAAC,CAChB,CACA,UAAc,EACP,CACX,EAEM,GAAgB,SAAS,EAAG,CAC9B,UAAc,EAAG,CAAC,EAClB,GAAe,EAAG,CAAC,EAEZ,CACX,EAEM,GAAoB,SAAS,EAAG,CAElC,MADA,IAAc,EAAG,CAAC,EACd,AAAC,GAAiB,EAAG,CAAC,EAI1B,IAAkB,EAAG,EAAG,GAAa,cAAe,EAAI,CAAC,EAClD,GAJH,IAAY,CAAC,EACN,EAIf,EAEM,GAAoB,SAAS,EAAG,CAClC,GAAI,GAAI,GAAS,EAAG,CAAC,EAGrB,MAFA,IAAe,EAAG,EAAG,EAAU,EAC/B,GAAc,EAAG,IAAM,IAAY,IAAM,GAAY,EAAG,uBAAuB,EAC3E,GAAkB,EAAG,EAAG,GAAa,cAAe,EAAI,CAAC,IAAM,GACxD,GAAW,EAAG,GAAa,qCAAqC,CAAC,EAC5E,IAAW,EAAG,CAAC,EACf,GAAiB,EAAG,CAAC,EACd,EACX,EAEM,GAAgB,SAAS,EAAG,CAC9B,UAAc,EAAG,CAAC,EAClB,GAAc,EAAG,CAAC,EAClB,GAAgB,EAAG,GAAa,EAAG,EAAG,CAAC,CAAC,EACjC,CACX,EAEM,GAAc,SAAS,EAAG,CAC5B,GAAI,GAAI,GAAS,EAAG,CAAC,EACrB,UAAc,EAAG,IAAM,IAAc,IAAM,GAAa,EAAG,0BAA0B,EACrF,GAAgB,EAAG,GAAW,EAAG,CAAC,CAAC,EAC5B,CACX,EAEM,GAAc,SAAS,EAAG,CAC5B,UAAe,EAAG,EAAG,EAAU,EAC/B,GAAc,EAAG,CAAC,EAClB,GAAW,EAAG,CAAC,EACf,GAAW,EAAG,CAAC,EACR,CACX,EAEM,GAAc,SAAS,EAAG,CAC5B,UAAe,EAAG,EAAG,EAAU,EAC/B,GAAc,EAAG,CAAC,EAClB,GAAc,EAAG,CAAC,EAClB,GAAW,EAAG,CAAC,EACf,GAAW,EAAG,CAAC,EACR,CACX,EAEM,GAAO,CACT,OAAQ,UAAW,UACnB,QAAS,OAAQ,WAAY,aAC7B,WACJ,EAAE,IAAI,AAAC,GAAM,GAAa,CAAC,CAAC,EACtB,GAAsB,SAAS,EAAG,CACpC,GAAiB,EAAG,EAAG,UAAW,EAAI,EACtC,GAAgB,EAAG,EAAG,CAAC,EACvB,GAAW,EAAG,GAAa,wBAAwB,CAAC,CACxD,EAEM,GAAY,SAAS,EAAG,CAC1B,GAAI,GAAI,GAAS,EAAG,CAAC,EACrB,UAAc,EAAG,IAAM,GAAW,EAAG,gBAAgB,EACrD,GAAe,EAAG,GAAa,EAAG,CAAC,CAAC,EAC7B,CACX,EAEM,GAAY,SAAS,EAAG,EAAQ,EAAQ,EAAM,CAChD,UAAc,EAAG,CAAC,EAClB,AAAI,GAAkB,EAAG,EAAG,CAAM,IAAM,GACpC,IAAkB,EAAG,CAAI,EACzB,GAAc,EAAG,CAAC,EAClB,AAAI,EAAQ,GAAgB,EAAG,CAAC,EAC3B,GAAY,CAAC,GAElB,IAAc,EAAG,CAAC,EAClB,GAAS,EAAG,EAAG,CAAC,GAEb,CACX,EAEM,GAAY,SAAS,EAAG,CAG1B,MAFA,IAAe,EAAG,EAAG,EAAU,EAC/B,GAAW,EAAG,CAAC,EACX,GAAS,EAAG,CAAC,EACN,EAEP,IAAY,CAAC,EACN,EAEf,EAEM,GAAa,SAAS,EAAG,CAC3B,MAAO,IAAU,EAAG,GAAa,UAAW,EAAI,EAAG,EAAG,EAAS,CACnE,EAKM,GAAY,SAAS,EAAG,CAC1B,GAAI,GAAI,GAAkB,EAAG,CAAC,EAAI,EAClC,UAAgB,EAAG,CAAC,EACb,GAAS,EAAG,EAAG,CAAC,IAAM,GAAW,EAAI,CAChD,EAMM,GAAc,SAAS,EAAG,CAI5B,UAAc,EAAG,CAAC,EAClB,GAAkB,EAAG,EAAS,EAC9B,GAAc,EAAG,CAAC,EAClB,GAAgB,EAAG,CAAC,EACb,CACX,EAEM,GAAY,SAAS,EAAG,EAAM,CAChC,GAAI,CACA,EAAI,GAAY,CAAC,CACrB,OAAS,EAAP,CACE,MAAO,KACX,CACA,GAAI,GAAI,wDAAwD,KAAK,CAAC,EACtE,GAAI,CAAC,EAAG,MAAO,MACf,GAAI,GAAI,SAAS,EAAE,GAAG,EAAE,GAAI,CAAI,EAChC,MAAI,OAAM,CAAC,EAAU,KACd,EAAE,CACb,EAEM,GAAgB,SAAS,EAAG,CAC9B,GAAI,GAAS,EAAG,CAAC,GAAK,EAAG,CAErB,GADA,GAAc,EAAG,CAAC,EACd,GAAS,EAAG,CAAC,IAAM,GACnB,UAAW,EAAG,CAAC,EACR,EACJ,CACH,GAAI,GAAI,GAAa,EAAG,CAAC,EACzB,GAAI,IAAM,MAAQ,GAAmB,EAAG,CAAC,IAAM,EAAE,OAAO,EACpD,MAAO,EACf,CACJ,KAAO,CACH,GAAI,GAAO,GAAkB,EAAG,CAAC,EACjC,GAAe,EAAG,EAAG,EAAW,EAChC,GAAI,GAAI,GAAa,EAAG,CAAC,EACzB,GAAc,EAAG,GAAK,GAAQ,GAAQ,GAAI,EAAG,mBAAmB,EAChE,GAAI,GAAI,GAAU,EAAG,CAAI,EACzB,GAAI,IAAM,KACN,UAAgB,EAAG,CAAC,EACb,CAEf,CAEA,UAAY,CAAC,EACN,CACX,EAEM,GAAa,SAAS,EAAG,CAC3B,GAAI,GAAQ,GAAgB,EAAG,EAAG,CAAC,EACnC,UAAW,EAAG,CAAC,EACX,GAAS,EAAG,CAAC,IAAM,IAAe,EAAQ,GAC1C,IAAW,EAAG,CAAK,EACnB,GAAc,EAAG,CAAC,EAClB,GAAW,EAAG,CAAC,GAEZ,GAAU,CAAC,CACtB,EAEM,GAAc,SAAS,EAAG,CAC5B,MAAI,IAAc,EAAG,CAAC,EACX,GAAW,CAAC,EAEnB,IAAc,EAAG,CAAC,EAClB,GAAW,EAAG,CAAC,EACf,GAAgB,EAAG,mBAAmB,EACtC,GAAW,EAAG,CAAC,EACR,GAAW,CAAC,EAE3B,EAEM,GAAc,SAAS,EAAG,CAC5B,GAAI,GAAI,GAAW,CAAC,EACpB,GAAI,GAAS,EAAG,CAAC,IAAM,IAAe,GAAa,EAAG,CAAC,EAAE,KAAO,GAC5D,UAAgB,EAAG,EAAI,CAAC,EACjB,EACJ,CACH,GAAI,GAAI,GAAkB,EAAG,CAAC,EAC9B,MAAI,GAAI,EAAG,EAAI,EAAI,EACV,EAAI,GAAG,GAAI,GACpB,GAAc,EAAG,GAAK,EAAG,EAAG,oBAAoB,EACzC,EAAI,CACf,CACJ,EASM,GAAc,SAAS,EAAG,EAAQ,EAAO,CAC3C,MAAI,KAAW,IAAU,IAAW,GAChC,IAAgB,EAAG,CAAC,EACpB,GAAc,EAAG,EAAE,EACZ,GAEA,GAAW,CAAC,EAAI,CAC/B,EAEM,GAAa,SAAS,EAAG,CAC3B,GAAc,EAAG,CAAC,EAClB,GAAgB,EAAG,CAAC,EACpB,GAAW,EAAG,CAAC,EACf,GAAI,GAAS,GAAW,EAAG,GAAW,CAAC,EAAI,EAAG,GAAa,EAAG,EAAG,EAAW,EAC5E,MAAO,IAAY,EAAG,EAAQ,CAAC,CACnC,EAOM,GAAc,SAAS,EAAG,CAC5B,GAAI,GAAI,GAAW,CAAC,EACpB,GAAe,EAAG,EAAG,EAAa,EAClC,GAAgB,EAAG,CAAC,EACpB,GAAc,EAAG,CAAC,EAClB,GAAW,EAAG,EAAG,CAAC,EAClB,GAAI,GAAS,GAAW,EAAG,EAAI,EAAG,GAAa,EAAG,EAAG,EAAW,EAChE,MAAO,IAAY,EAAG,EAAQ,CAAC,CACnC,EAEM,GAAW,SAAS,EAAG,EAAQ,EAAQ,CACzC,MAAI,KAAW,GACP,KAAW,GACX,IAAc,EAAG,CAAM,EAClB,GAAe,EAAG,GAAI,CAAC,GACxB,GAAQ,EAAG,CAAC,GAEb,GAEP,IAAY,CAAC,EACb,GAAW,EAAG,EAAE,EACT,EAEf,EAOM,GAAe,EAQf,GAAiB,SAAS,EAAG,EAAI,CAInC,MAHA,IAAgB,EAAG,EAAG,2BAA2B,EACjD,GAAc,EAAG,CAAC,EAClB,GAAS,EAAG,EAAG,CAAC,EACZ,GAAU,EAAG,EAAE,EACf,IAAQ,EAAG,CAAC,EACL,MACC,IAAa,EAAG,EAAE,GAC1B,GAAW,EAAG,GAAa,sCAAsC,CAAC,EACtE,GAAY,EAAG,EAAY,EACpB,GAAa,EAAG,EAAY,EACvC,EAEM,GAAY,SAAS,EAAG,CAC1B,GAAI,GAAI,GAAa,EAAG,CAAC,EACrB,EAAO,GAAe,EAAG,EAAG,IAAI,EAChC,EAAM,AAAC,GAAW,EAAG,CAAC,EAAQ,EAAJ,EAC1B,EACJ,GAAI,IAAM,KAAM,CACZ,GAAI,GAAY,GAAe,EAAG,EAAG,CAAC,EACtC,EAAS,GAAiB,EAAG,EAAG,EAAE,OAAQ,EAAW,CAAI,CAC7D,KAAO,CACH,GAAI,GAAY,GAAe,EAAG,EAAG,SAAS,EAC9C,GAAe,EAAG,EAAG,EAAa,EAClC,GAAW,EAAG,EAAY,EAC1B,EAAS,GAAS,EAAG,GAAgB,KAAM,EAAW,CAAI,CAC9D,CACA,MAAO,IAAS,EAAG,EAAQ,CAAG,CAClC,EAEM,GAAgB,SAAS,EAAG,CAC9B,GAAI,GAAQ,GAAe,EAAG,EAAG,IAAI,EACjC,EAAO,GAAe,EAAG,EAAG,IAAI,EAChC,EAAM,AAAC,GAAW,EAAG,CAAC,EAAQ,EAAJ,EAC1B,EAAS,GAAe,EAAG,EAAO,CAAI,EAC1C,MAAO,IAAS,EAAG,EAAQ,CAAG,CAClC,EAEM,GAAa,SAAS,EAAG,EAAI,EAAI,CACnC,MAAO,IAAW,CAAC,EAAI,CAC3B,EAEM,GAAc,SAAS,EAAG,CAC5B,GAAI,GAAQ,GAAe,EAAG,EAAG,IAAI,EAErC,MADA,IAAW,EAAG,CAAC,EACX,GAAc,EAAG,CAAK,IAAM,GACrB,GAAU,CAAC,EACtB,IAAU,EAAG,EAAG,GAAa,EAAG,EAAU,EACnC,GAAW,EAAG,EAAG,CAAC,EAC7B,EAEM,GAAa,CACf,OAAkB,GAClB,eAAkB,GAClB,OAAkB,GAClB,MAAkB,GAClB,aAAkB,GAClB,OAAkB,GAClB,KAAkB,GAClB,SAAkB,GAClB,KAAkB,GAClB,MAAkB,GAClB,MAAkB,GAClB,MAAkB,GAClB,SAAkB,GAClB,OAAkB,GAClB,OAAkB,GAClB,OAAkB,GAClB,OAAkB,GAClB,aAAkB,GAClB,SAAkB,GAClB,SAAkB,GAClB,KAAkB,GAClB,OAAkB,EACtB,EAEM,GAAe,SAAS,EAAG,CAE7B,UAAoB,CAAC,EACrB,GAAc,EAAG,GAAY,CAAC,EAE9B,GAAc,EAAG,EAAE,EACnB,GAAa,EAAG,GAAI,GAAa,IAAI,CAAC,EAEtC,GAAgB,EAAG,EAAW,EAC9B,GAAa,EAAG,GAAI,GAAa,UAAU,CAAC,EACrC,CACX,EAEA,GAAO,QAAQ,aAAe,KCrf9B,mBAEA,GAAM,CACF,UACA,iBACA,eACA,aACA,aACA,kBACA,cACA,aACA,gBACA,cACA,cACA,mBACA,iBACA,WACA,mBACA,oBACA,mBACA,kBACA,iBACA,cACA,cACA,gBACA,YACA,oBACA,aACA,cACA,KACE,CACF,iBACA,kBACA,eACA,eACA,KAEE,GAAQ,SAAS,EAAG,CACtB,GAAI,GAAK,GAAa,EAAG,CAAC,EAC1B,UAAc,EAAG,EAAI,EAAG,iBAAiB,EAClC,CACX,EAEM,GAAY,SAAS,EAAG,EAAI,EAAM,CACpC,GAAI,CAAC,GAAe,EAAI,CAAI,EACxB,UAAgB,EAAG,8BAA8B,EAC1C,GAGX,GAAI,GAAW,CAAE,IAAM,IAAU,GAAW,CAAE,IAAM,EAChD,UAAgB,EAAG,8BAA8B,EAC1C,GAGX,GAAU,EAAG,EAAI,CAAI,EACrB,GAAI,GAAS,GAAW,EAAI,EAAG,CAAI,EACnC,GAAI,IAAW,IAAU,IAAW,GAAW,CAC3C,GAAI,GAAO,GAAW,CAAE,EACxB,MAAK,IAAe,EAAG,EAAO,CAAC,EAM/B,IAAU,EAAK,EAAG,CAAI,EACf,GANH,IAAQ,EAAI,CAAI,EAChB,GAAgB,EAAG,4BAA4B,EACxC,GAKf,KACI,WAAU,EAAI,EAAG,CAAC,EACX,EAEf,EAEM,GAAgB,SAAS,EAAG,CAC9B,GAAI,GAAK,GAAM,CAAC,EACZ,EAAI,GAAU,EAAG,EAAI,GAAW,CAAC,EAAI,CAAC,EAC1C,MAAI,GAAI,EACJ,IAAgB,EAAG,CAAC,EACpB,GAAW,EAAG,EAAE,EACT,GAEP,IAAgB,EAAG,CAAC,EACpB,GAAW,EAAG,CAAE,GAAI,EAAE,EACf,EAAI,EAEnB,EAEM,GAAe,SAAS,EAAG,CAC7B,GAAI,GAAK,GAAa,EAAG,GAAiB,CAAC,CAAC,EACxC,EAAI,GAAU,EAAG,EAAI,GAAW,CAAC,CAAC,EACtC,MAAI,GAAI,EACA,IAAS,EAAG,EAAE,IAAM,IACpB,IAAW,EAAG,CAAC,EACf,GAAW,EAAG,EAAE,EAChB,GAAW,EAAG,CAAC,GAGZ,GAAU,CAAC,GAGf,CACX,EAEM,GAAgB,SAAS,EAAG,CAC9B,GAAe,EAAG,EAAG,EAAa,EAClC,GAAI,GAAK,GAAc,CAAC,EACxB,UAAc,EAAG,CAAC,EAClB,GAAU,EAAG,EAAI,CAAC,EACX,CACX,EAEM,GAAc,SAAS,EAAG,CAC5B,UAAc,CAAC,EACf,GAAiB,EAAG,GAAc,CAAC,EAC5B,CACX,EAEM,GAAa,SAAS,EAAG,CAC3B,MAAO,IAAU,EAAG,GAAW,CAAC,CAAC,CACrC,EAEM,GAAgB,SAAS,EAAG,CAC9B,GAAI,GAAK,GAAM,CAAC,EAChB,GAAI,IAAM,EAAI,GAAgB,EAAG,SAAS,MAEtC,QAAQ,GAAW,CAAE,OACZ,IACD,GAAgB,EAAG,WAAW,EAC9B,UACC,IAAQ,CACT,GAAI,GAAK,GAAI,IACb,AAAI,GAAa,EAAI,EAAG,CAAE,EAAI,EAC1B,GAAgB,EAAG,QAAQ,EAC1B,AAAI,GAAW,CAAE,IAAM,EACxB,GAAgB,EAAG,MAAM,EAEzB,GAAgB,EAAG,WAAW,EAClC,KACJ,SAEI,GAAgB,EAAG,MAAM,EACzB,MAIZ,MAAO,EACX,EAEM,GAAiB,SAAS,EAAG,CAC/B,UAAgB,EAAG,GAAgB,CAAC,CAAC,EAC9B,CACX,EAEM,GAAiB,SAAS,EAAG,CAC/B,UAAgB,EAAG,GAAe,CAAC,CAAC,EAC7B,CACX,EAEM,GAAW,CACb,OAAe,GACf,YAAe,GACf,OAAe,GACf,QAAe,GACf,OAAe,GACf,KAAe,GACf,MAAe,EACnB,EAEM,GAAoB,SAAS,EAAG,CAClC,UAAY,EAAG,EAAQ,EAChB,CACX,EAEA,GAAO,QAAQ,kBAAoB,KC5KnC,mBAEA,GAAM,CAAE,mBAAmB,KACrB,CACF,YACA,YACA,iBACA,YACA,cACA,YACA,kBACA,eACA,mBACA,YACA,oBACA,cACA,cACA,aACA,mBACA,gBACA,WACA,mBACA,eACA,kBACA,iBACA,cACA,gBACA,YACA,cACA,iBACA,aACA,KACE,CACF,eACA,mBACA,iBACA,iBACA,iBACA,qBACA,kBACA,cACA,YACA,eACA,YACA,mBACA,mBACA,mBACA,kBACA,KACE,GAAS,KACT,CAAE,iBAAiB,KAMnB,GAAS,EACT,GAAS,EACT,GAAS,EACT,GAAU,GAAQ,GAElB,GAAa,SAAS,EAAG,EAAK,EAAG,CACnC,UAAe,EAAG,CAAG,EACd,GAAW,EAAG,CAAC,CAAC,IAAM,EACjC,EAMM,GAAW,SAAS,EAAG,EAAK,EAAM,CACpC,GAAI,GAAS,EAAG,CAAG,IAAM,GAAY,CACjC,GAAI,GAAI,EACR,AAAI,GAAiB,EAAG,CAAG,GACtB,EAAE,GAAO,KAAU,GAAW,EAAG,GAAa,UAAW,EAAI,EAAG,EAAE,CAAC,IACnE,EAAE,GAAO,KAAU,GAAW,EAAG,GAAa,aAAc,EAAI,EAAG,EAAE,CAAC,IACtE,EAAE,GAAO,KAAU,GAAW,EAAG,GAAa,QAAS,EAAI,EAAG,EAAE,CAAC,GAClE,GAAQ,EAAG,CAAC,EAGZ,GAAe,EAAG,EAAK,EAAU,CACzC,CACJ,EAEM,GAAW,SAAS,EAAG,EAAG,EAAG,CAC/B,UAAS,EAAG,EAAG,EAAI,EAAK,EACjB,GAAS,EAAG,CAAC,CACxB,EAEM,GAAW,SAAS,EAAG,EAAG,EAAG,CAC/B,GAAS,EAAG,EAAG,CAAC,EACX,GAAa,EAAG,EAAE,GACnB,GAAW,EAAG,GAAa,sDAAsD,EAC7E,GAAc,EAAG,EAAE,EAAG,CAAC,EAE/B,GAAc,CAAC,CACnB,EAEM,GAAU,SAAS,EAAG,CACxB,GAAI,GAAI,GAAS,EAAG,EAAG,EAAM,EAAI,EAC7B,EACJ,OAAQ,GAAW,CAAC,OACX,GACD,EAAM,EACN,UACC,GAAG,CACJ,EAAM,GAAkB,EAAG,CAAC,EAC5B,GAAc,EAAG,GAAK,GAAO,GAAO,EAAG,EAAG,wBAAwB,EAClE,OAAS,GAAI,EAAG,EAAI,EAAK,IACrB,GAAS,EAAG,EAAG,EAAI,CAAC,EACpB,GAAS,EAAG,EAAG,CAAC,EAEpB,KACJ,SAEI,MAAO,IAAW,EAAG,uCAAuC,EAIpE,UAAS,EAAG,EAAG,CAAG,EACX,CACX,EAEM,GAAU,SAAS,EAAG,CACxB,GAAI,GAAO,GAAS,EAAG,EAAG,EAAM,EAC5B,EAAM,GAAgB,EAAG,EAAG,CAAI,EAIpC,IAHI,IAAQ,GACR,GAAc,EAAG,GAAK,GAAO,GAAO,EAAO,EAAG,EAAG,wBAAwB,EAC7E,GAAS,EAAG,EAAG,CAAG,EACX,EAAM,EAAM,IACf,GAAS,EAAG,EAAG,EAAM,CAAC,EACtB,GAAS,EAAG,EAAG,CAAG,EAEtB,UAAY,CAAC,EACb,GAAS,EAAG,EAAG,CAAG,EACX,CACX,EAQM,GAAQ,SAAS,EAAG,CACtB,GAAI,GAAI,GAAkB,EAAG,CAAC,EAC1B,EAAI,GAAkB,EAAG,CAAC,EAC1B,EAAI,GAAkB,EAAG,CAAC,EAC1B,EAAK,AAAC,GAAgB,EAAG,CAAC,EAAQ,EAAJ,EAGlC,GAFA,GAAS,EAAG,EAAG,EAAK,EACpB,GAAS,EAAG,EAAI,EAAK,EACjB,GAAK,EAAG,CACR,GAAc,EAAG,EAAI,GAAK,EAAI,GAAiB,EAAG,EAAG,2BAA2B,EAChF,GAAI,GAAI,EAAI,EAAI,EAGhB,GAFA,GAAc,EAAG,GAAK,GAAiB,EAAI,EAAG,EAAG,yBAAyB,EAEtE,EAAI,GAAK,GAAK,GAAM,IAAO,GAAK,GAAY,EAAG,EAAG,EAAI,EAAQ,IAAM,EACpE,OAAS,GAAI,EAAG,EAAI,EAAG,IACnB,GAAS,EAAG,EAAG,EAAI,CAAC,EACpB,GAAS,EAAG,EAAI,EAAI,CAAC,MAGzB,QAAS,GAAI,EAAI,EAAG,GAAK,EAAG,IACxB,GAAS,EAAG,EAAG,EAAI,CAAC,EACpB,GAAS,EAAG,EAAI,EAAI,CAAC,CAGjC,CAEA,UAAc,EAAG,CAAE,EACZ,CACX,EAEM,GAAU,SAAS,EAAG,CACxB,GAAI,GAAO,GAAS,EAAG,EAAG,EAAK,EAC3B,EAAM,GAAgB,EAAG,EAAG,EAAE,EAC9B,EAAO,EAAI,OACX,EAAI,GAAgB,EAAG,EAAG,CAAC,EAC/B,EAAO,GAAgB,EAAG,EAAG,CAAI,EAEjC,GAAI,GAAI,GAAI,IAGZ,IAFA,GAAc,EAAG,CAAC,EAEX,EAAI,EAAM,IACb,GAAS,EAAG,EAAG,CAAC,EAChB,GAAgB,EAAG,EAAK,CAAI,EAGhC,MAAI,KAAM,GACN,GAAS,EAAG,EAAG,CAAC,EAEpB,GAAgB,CAAC,EAEV,CACX,EAEM,GAAO,SAAS,EAAG,CACrB,GAAI,GAAI,GAAW,CAAC,EACpB,GAAgB,EAAG,EAAG,CAAC,EACvB,GAAW,EAAG,CAAC,EACf,OAAS,GAAI,EAAG,GAAK,EAAG,IACpB,GAAS,EAAG,EAAG,CAAC,EACpB,UAAgB,EAAG,CAAC,EACpB,GAAa,EAAG,EAAG,GAAa,GAAG,CAAC,EAC7B,CACX,EAEM,GAAS,SAAS,EAAG,CACvB,GAAI,GAAI,GAAgB,EAAG,EAAG,CAAC,EAC3B,EAAI,GAAS,EAAG,GAAmB,EAAG,GAAS,EAAG,CAAC,CAAC,EACxD,GAAI,EAAI,EAAG,MAAO,GAClB,GAAI,GAAI,EAAI,EACZ,GAAI,GAAK,OAAO,kBAAoB,CAAC,GAAe,EAAG,EAAE,CAAC,EACtD,MAAO,IAAW,EAAG,GAAa,4BAA4B,CAAC,EACnE,KAAO,EAAI,EAAG,IACV,GAAS,EAAG,EAAG,CAAC,EACpB,UAAS,EAAG,EAAG,CAAC,EACT,CACX,EAEM,GAAmB,UAAW,CAChC,MAAO,MAAK,MAAM,KAAK,OAAO,EAAE,UAAW,CAC/C,EAEM,GAAW,IAEX,GAAO,SAAS,EAAG,EAAG,EAAG,CAC3B,GAAS,EAAG,EAAG,CAAC,EAChB,GAAS,EAAG,EAAG,CAAC,CACpB,EAEM,GAAY,SAAS,EAAG,EAAG,EAAG,CAChC,GAAI,GAAU,EAAG,CAAC,EACd,MAAO,IAAY,EAAG,EAAG,EAAG,EAAQ,EACnC,CACD,GAAc,EAAG,CAAC,EAClB,GAAc,EAAG,EAAE,CAAC,EACpB,GAAc,EAAG,EAAE,CAAC,EACpB,GAAS,EAAG,EAAG,CAAC,EAChB,GAAI,GAAM,GAAc,EAAG,EAAE,EAC7B,UAAQ,EAAG,CAAC,EACL,CACX,CACJ,EAEM,GAAY,SAAS,EAAG,EAAI,EAAI,CAClC,GAAI,GAAI,EACJ,EAAI,EAAK,EAEb,OAAS,CAEL,KAAO,GAAS,EAAG,EAAG,EAAE,CAAC,EAAG,GAAU,EAAG,GAAI,EAAE,GAC3C,AAAI,GAAK,EAAK,GACV,GAAW,EAAG,GAAa,oCAAoC,CAAC,EACpE,GAAQ,EAAG,CAAC,EAIhB,KAAO,GAAS,EAAG,EAAG,EAAE,CAAC,EAAG,GAAU,EAAG,GAAI,EAAE,GAC3C,AAAI,EAAI,GACJ,GAAW,EAAG,GAAa,oCAAoC,CAAC,EACpE,GAAQ,EAAG,CAAC,EAGhB,GAAI,EAAI,EAEJ,UAAQ,EAAG,CAAC,EAEZ,GAAK,EAAG,EAAK,EAAG,CAAC,EACV,EAGX,GAAK,EAAG,EAAG,CAAC,CAChB,CACJ,EAEM,GAAc,SAAS,EAAI,EAAI,EAAK,CACtC,GAAI,GAAK,KAAK,MAAO,GAAK,GAAM,CAAC,EAC7B,EAAI,EAAO,GAAK,GAAM,GAAK,GAC/B,UAAO,WAAW,EAAK,GAAM,GAAK,GAAK,EAAK,CAAE,EACvC,CACX,EAEM,GAAU,SAAS,EAAG,EAAI,EAAI,EAAK,CACrC,KAAO,EAAK,GAAI,CAQZ,GANA,GAAS,EAAG,EAAG,CAAE,EACjB,GAAS,EAAG,EAAG,CAAE,EACjB,AAAI,GAAU,EAAG,GAAI,EAAE,EACnB,GAAK,EAAG,EAAI,CAAE,EAEd,GAAQ,EAAG,CAAC,EACZ,EAAK,GAAM,EACX,OACJ,GAAI,GAiBJ,GAhBA,AAAI,EAAK,EAAK,IAAY,IAAQ,EAC9B,EAAI,KAAK,MAAO,GAAK,GAAI,CAAC,EAE1B,EAAI,GAAY,EAAI,EAAI,CAAG,EAC/B,GAAS,EAAG,EAAG,CAAC,EAChB,GAAS,EAAG,EAAG,CAAE,EACjB,AAAI,GAAU,EAAG,GAAI,EAAE,EACnB,GAAK,EAAG,EAAG,CAAE,EAEb,IAAQ,EAAG,CAAC,EACZ,GAAS,EAAG,EAAG,CAAE,EACjB,AAAI,GAAU,EAAG,GAAI,EAAE,EACnB,GAAK,EAAG,EAAG,CAAE,EAEb,GAAQ,EAAG,CAAC,GAEhB,EAAK,GAAM,EACX,OACJ,GAAS,EAAG,EAAG,CAAC,EAChB,GAAc,EAAG,EAAE,EACnB,GAAS,EAAG,EAAG,EAAK,CAAC,EACrB,GAAK,EAAG,EAAG,EAAK,CAAC,EACjB,EAAI,GAAU,EAAG,EAAI,CAAE,EACvB,GAAI,GAEJ,AAAI,EAAI,EAAK,EAAK,EACd,IAAQ,EAAG,EAAI,EAAI,EAAG,CAAG,EACzB,EAAI,EAAI,EACR,EAAK,EAAI,GAET,IAAQ,EAAG,EAAI,EAAG,EAAI,CAAG,EACzB,EAAI,EAAK,EACT,EAAK,EAAI,GAER,GAAK,GAAM,IAAM,GAClB,GAAM,GAAiB,EAC/B,CACJ,EAEM,GAAO,SAAS,EAAG,CACrB,GAAI,GAAI,GAAS,EAAG,EAAG,EAAM,EAC7B,MAAI,GAAI,GACJ,IAAc,EAAG,EAAI,GAAgB,EAAG,eAAe,EAClD,GAAgB,EAAG,CAAC,GACrB,GAAe,EAAG,EAAG,EAAa,EACtC,GAAW,EAAG,CAAC,EACf,GAAQ,EAAG,EAAG,EAAG,CAAC,GAEf,CACX,EAEM,GAAY,CACd,OAAU,GACV,OAAU,GACV,KAAU,GACV,KAAU,GACV,OAAU,GACV,KAAU,GACV,OAAU,EACd,EAEM,GAAgB,SAAS,EAAG,CAC9B,UAAY,EAAG,EAAS,EACjB,CACX,EAEA,GAAO,QAAQ,cAAgB,KCzW/B,mBAEA,GAAM,CACF,YACA,cACA,aACA,mBACA,gBACA,iBACA,mBACA,WACA,mBACA,mBACA,mBACA,mBACA,eACA,kBACA,kBACA,gBACA,cACA,iBACA,mBACA,KACE,CACF,eACA,gBACA,kBAEA,iBACA,iBACA,qBACA,oBACA,kBACA,cACA,mBACA,mBACA,eACA,mBACA,mBACA,kBACA,oBACA,KACE,CACF,gBACA,eACA,gBACA,KAwBE,GAAsB,EAAa,uCAAuC,EAG1E,GAAW,SAAS,EAAG,EAAK,EAAO,CACrC,GAAgB,EAAG,CAAK,EACxB,GAAa,EAAG,GAAI,EAAa,EAAK,EAAI,CAAC,CAC/C,EAEM,GAAe,SAAS,EAAG,EAAM,EAAK,CACxC,GAAS,EAAG,MAAS,EAAM,EAAK,cAAc,EAAK,EAAK,WAAW,CAAC,EACpE,GAAS,EAAG,MAAS,EAAM,EAAK,cAAc,EAAK,EAAK,WAAW,CAAC,EACpE,GAAS,EAAG,OAAS,EAAM,EAAK,YAAY,EAAO,EAAK,SAAS,CAAC,EAClE,GAAS,EAAG,MAAS,EAAM,EAAK,WAAW,EAAQ,EAAK,QAAQ,CAAC,EACjE,GAAS,EAAG,QAAU,GAAM,EAAK,YAAY,EAAM,EAAK,SAAS,GAAK,CAAC,EACvE,GAAS,EAAG,OAAS,EAAM,EAAK,eAAe,EAAI,EAAK,YAAY,CAAC,EACrE,GAAS,EAAG,OAAU,GAAM,EAAK,UAAU,EAAQ,EAAK,OAAO,GAAK,CAAC,EACrE,GAAS,EAAG,OAAQ,KAAK,MAAO,GAAQ,GAAI,MAAK,EAAK,YAAY,EAAG,EAAG,CAAsC,GAAM,KAAQ,CAAC,CAEjI,EAEM,GAAkB,OAAO,iBAAmB,EAE5C,GAAW,SAAS,EAAG,EAAK,EAAG,EAAO,CACxC,GAAI,GAAI,GAAa,EAAG,GAAI,EAAa,EAAK,EAAI,CAAC,EAC/C,EAAM,GAAe,EAAG,EAAE,EAC9B,GAAI,IAAQ,GAAO,CACf,GAAI,IAAM,GACN,MAAO,IAAW,EAAG,EAAa,8BAA8B,EAAG,CAAG,EACrE,GAAI,EAAI,EACT,MAAO,IAAW,EAAG,EAAa,kCAAkC,EAAG,CAAG,EAC9E,EAAM,CACV,KACK,CACD,GAAI,CAAE,EAAC,IAAkB,GAAO,GAAO,IACnC,MAAO,IAAW,EAAG,EAAa,4BAA4B,EAAG,CAAG,EACxE,GAAO,CACX,CACA,UAAQ,EAAG,CAAC,EACL,CACX,EAGM,GAAS,CACX,KAAM,CAAC,SAAU,SAAU,UAAW,YAAa,WAAY,SAAU,UAAW,EAAE,IAAI,AAAC,GAAM,EAAa,CAAC,CAAC,EAChH,UAAW,CAAC,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,KAAK,EAAE,IAAI,AAAC,GAAM,EAAa,CAAC,CAAC,EACvF,OAAQ,CAAC,UAAW,WAAY,QAAS,QAAS,MAAO,OAAQ,OAAQ,SAAU,YAAa,UAAW,WAAY,UAAU,EAAE,IAAI,AAAC,GAAM,EAAa,CAAC,CAAC,EAC7J,YAAa,CAAC,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,KAAK,EAAE,IAAI,AAAC,GAAM,EAAa,CAAC,CAAC,EAC5H,GAAI,EAAa,IAAI,EACrB,GAAI,EAAa,IAAI,EACrB,GAAI,EAAa,IAAI,EACrB,GAAI,EAAa,IAAI,EACrB,QAAS,CACL,EAAG,EAAa,sBAAsB,EACtC,EAAG,EAAa,UAAU,EAC1B,EAAG,EAAa,UAAU,EAC1B,EAAG,EAAa,OAAO,EACvB,EAAG,EAAa,aAAa,EAC7B,EAAG,EAAa,UAAU,EAC1B,EAAG,EAAa,IAAI,EACpB,EAAG,EAAa,IAAI,CACxB,CACJ,EAEM,GAAc,SAAS,EAAM,EAAe,CAG9C,GAAI,GAAU,EAAK,OAAO,EAC1B,AAAI,IAAkB,UAClB,CAAI,IAAY,EACZ,EAAU,EAEV,KAER,GAAI,GAAQ,GAAO,GAAI,MAAK,EAAK,YAAY,EAAG,EAAG,CAAC,GAAK,MACzD,MAAO,MAAK,MAAO,GAAO,EAAI,GAAW,CAAC,CAC9C,EAEM,GAAa,SAAS,EAAG,EAAG,EAAK,CACnC,AAAI,EAAI,IACJ,GAAa,EAAG,CAAG,EACvB,GAAe,EAAG,EAAa,OAAO,CAAC,CAAC,CAAC,CAC7C,EAEM,GAAW,SAAS,EAAG,EAAG,EAAG,EAAM,CACrC,GAAI,GAAI,EACR,KAAO,EAAI,EAAE,QACT,GAAI,EAAE,KAAO,GACT,GAAa,EAAG,EAAE,IAAI,MACnB,CACH,IACA,GAAI,GAAM,GAAY,EAAG,EAAG,CAAC,EAE7B,OAAO,EAAE,QAEA,IACD,GAAa,EAAG,EAAE,EAClB,UAGC,IACD,GAAe,EAAG,GAAO,KAAK,EAAK,OAAO,EAAE,EAC5C,UAGC,IACD,GAAe,EAAG,GAAO,OAAO,EAAK,SAAS,EAAE,EAChD,UAGC,IACD,GAAW,EAAG,KAAK,MAAM,EAAK,YAAY,EAAI,GAAG,EAAG,EAAU,EAC9D,UAGC,IACD,GAAS,EAAG,EAAG,GAAO,QAAQ,EAAG,CAAI,EACrC,UAGC,IACD,GAAS,EAAG,EAAG,GAAO,QAAQ,EAAG,CAAI,EACrC,UAGC,IACD,GAAW,EAAG,EAAK,SAAS,EAAG,EAAU,EACzC,UAGC,IACD,GAAW,EAAI,GAAK,SAAS,EAAI,IAAM,GAAK,EAAG,EAAU,EACzD,UAGC,IACD,GAAW,EAAG,EAAK,WAAW,EAAG,EAAU,EAC3C,UAGC,IACD,GAAe,EAAG,EAAK,SAAS,EAAI,GAAK,GAAO,GAAK,GAAO,EAAE,EAC9D,UAGC,IACD,GAAS,EAAG,EAAG,GAAO,QAAQ,EAAG,CAAI,EACrC,UAGC,IACD,GAAW,EAAG,EAAK,WAAW,EAAG,EAAU,EAC3C,UAGC,IACD,GAAS,EAAG,EAAG,GAAO,QAAQ,EAAG,CAAI,EACrC,UAGC,IACD,GAAW,EAAG,GAAY,EAAM,QAAQ,EAAG,EAAU,EACrD,UAGC,IACD,GAAW,EAAG,GAAY,EAAM,QAAQ,EAAG,EAAU,EACrD,UAGC,IACD,GAAS,EAAG,EAAG,GAAO,QAAQ,EAAG,CAAI,EACrC,UAGC,IACD,GAAe,EAAG,EAAa,OAAO,EAAK,YAAY,CAAC,CAAC,CAAC,EAC1D,UAGC,IAAY,CACb,GAAI,GAAW,EAAK,SAAS,EAAE,MAAM,eAAe,EACpD,AAAI,GACA,GAAe,EAAG,EAAa,EAAS,EAAE,CAAC,EAC/C,KACJ,KAGK,IACD,GAAe,EAAG,GAAO,UAAU,EAAK,OAAO,EAAE,EACjD,UAGC,QACA,KACD,GAAe,EAAG,GAAO,YAAY,EAAK,SAAS,EAAE,EACrD,UAGC,IACD,GAAS,EAAG,EAAG,GAAO,QAAQ,EAAG,CAAI,EACrC,UAGC,KACD,GAAW,EAAG,EAAK,QAAQ,EAAG,EAAU,EACxC,UAGC,KACD,GAAW,EAAG,EAAK,QAAQ,EAAG,EAAc,EAC5C,UAGC,KAAa,CACd,GAAI,GAAO,KAAK,MAAO,GAAO,GAAI,MAAK,EAAK,YAAY,EAAG,EAAG,CAAC,GAAK,KAAQ,EAC5E,AAAI,EAAO,KACH,GAAO,IACP,GAAa,EAAG,EAAU,EAC9B,GAAa,EAAG,EAAU,GAE9B,GAAe,EAAG,EAAa,OAAO,CAAI,CAAC,CAAC,EAC5C,KACJ,KAGK,KACD,GAAW,EAAG,EAAK,SAAS,EAAG,EAAc,EAC7C,UAGC,KACD,GAAW,EAAI,GAAK,SAAS,EAAI,IAAM,GAAK,EAAG,EAAc,EAC7D,UAGC,KACD,GAAW,EAAG,EAAK,SAAS,EAAI,EAAG,EAAU,EAC7C,UAGC,KACD,GAAa,EAAG,EAAE,EAClB,UAGC,KACD,GAAe,EAAG,EAAK,SAAS,EAAI,GAAK,GAAO,GAAK,GAAO,EAAE,EAC9D,UAGC,KACD,GAAS,EAAG,EAAG,GAAO,QAAQ,EAAG,CAAI,EACrC,UAGC,KACD,GAAe,EAAG,EAAa,OAAO,KAAK,MAAM,EAAO,GAAI,CAAC,CAAC,CAAC,EAC/D,UAGC,KACD,GAAa,EAAG,CAAC,EACjB,UAGC,KAAa,CACd,GAAI,GAAM,EAAK,OAAO,EACtB,GAAe,EAAG,EAAa,OAAO,IAAQ,EAAI,EAAI,CAAG,CAAC,CAAC,EAC3D,KACJ,KAGK,KACD,GAAe,EAAG,EAAa,OAAO,EAAK,OAAO,CAAC,CAAC,CAAC,EACrD,UAGC,KACD,GAAS,EAAG,EAAG,GAAO,QAAQ,EAAG,CAAI,EACrC,UAGC,KACD,GAAW,EAAG,EAAK,YAAY,EAAI,IAAK,EAAU,EAClD,UAGC,KAAa,CACd,GAAI,GAAM,EAAK,kBAAkB,EACjC,AAAI,EAAM,EACN,GAAa,EAAG,EAAU,EAE1B,GAAM,CAAC,EACP,GAAa,EAAG,EAAU,GAE9B,GAAW,EAAG,KAAK,MAAM,EAAI,EAAE,EAAG,EAAU,EAC5C,GAAW,EAAG,EAAM,GAAI,EAAU,EAClC,KACJ,EAEJ,GAAK,CACT,CAER,EAGM,GAAc,SAAS,EAAG,EAAM,EAAG,CACrC,GAAI,GAAS,GACT,EAAI,EACJ,EAAQ,EACZ,KAAO,EAAI,EAAO,QAAU,GAAU,EAAK,OAAS,EAAI,GAAK,EACzD,GAAI,EAAO,KAAO,IAAI,WAAW,CAAC,EAC9B,YACK,GAAa,EAAK,SAAS,EAAG,EAAE,CAAK,EAAG,EAAO,SAAS,EAAG,EAAE,CAAK,CAAC,EACxE,MAAO,GAGf,GAAc,EAAG,EACb,GAAgB,EAAG,EAAa,qCAAqC,EAAG,CAAI,CAAC,CACrF,EAMM,GAAU,SAAS,EAAG,CACxB,GAAI,GAAI,GAAgB,EAAG,EAAG,IAAI,EAC9B,EAAM,GAAgB,EAAG,CAAC,EAAI,GAAI,MAAS,GAAI,MAAK,GAAY,EAAG,CAAC,EAAI,GAAI,EAC5E,EAAM,GACN,EAAI,EAKR,GAJI,EAAE,KAAO,IAAI,WAAW,CAAC,GACzB,GAAM,GACN,KAEA,EAAE,KAAO,IAAI,WAAW,CAAC,GAAK,EAAE,EAAE,KAAO,IAAI,WAAW,CAAC,EACzD,GAAgB,EAAG,EAAG,CAAC,EACvB,GAAa,EAAG,EAAK,CAAG,MACrB,CACH,GAAI,GAAK,GAAI,YAAW,CAAC,EACzB,EAAG,GAAK,IAAI,WAAW,CAAC,EACxB,GAAI,GAAI,GAAI,IACZ,GAAc,EAAG,CAAC,EAClB,GAAS,EAAG,EAAG,EAAG,CAAG,EACrB,GAAgB,CAAC,CACrB,CACA,MAAO,EACX,EAEM,GAAU,SAAS,EAAG,CACxB,GAAI,GACJ,MAAI,IAAgB,EAAG,CAAC,EACpB,EAAI,GAAI,MAER,IAAe,EAAG,EAAG,EAAU,EAC/B,GAAW,EAAG,CAAC,EACf,EAAI,GAAI,MACJ,GAAS,EAAG,OAAQ,GAAI,CAAC,EACzB,GAAS,EAAG,QAAS,GAAI,CAAC,EAC1B,GAAS,EAAG,MAAO,GAAI,CAAC,EACxB,GAAS,EAAG,OAAQ,GAAI,CAAC,EACzB,GAAS,EAAG,MAAO,EAAG,CAAC,EACvB,GAAS,EAAG,MAAO,EAAG,CAAC,CAC3B,EACA,GAAa,EAAG,CAAC,GAGrB,GAAgB,EAAG,KAAK,MAAM,EAAI,GAAI,CAAC,EAChC,CACX,EAEM,GAAc,SAAS,EAAG,EAAK,CAGjC,MAFQ,IAAkB,EAAG,CAAG,CAGpC,EAEM,GAAc,SAAS,EAAG,CAC5B,GAAI,GAAK,GAAY,EAAG,CAAC,EACrB,EAAK,GAAY,EAAG,CAAC,EACzB,UAAe,EAAG,EAAK,CAAE,EAClB,CACX,EAEM,GAAS,CACX,KAAQ,GACR,SAAY,GACZ,KAAQ,EACZ,EAGI,GAAO,MAAQ,SAAS,EAAG,CACvB,UAAe,EAAG,YAAY,IAAI,EAAE,GAAI,EACjC,CACX,EAsGJ,GAAM,IAAa,SAAS,EAAG,CAC3B,UAAY,EAAG,EAAM,EACd,CACX,EAEA,GAAO,QAAQ,WAAa,KC1jB5B,cAEA,AAAC,WAAW,CAGR,GAAI,GAAK,CACL,WAAY,OACZ,SAAU,OACV,SAAU,OACV,cAAe,OACf,OAAQ,UACR,YAAa,eACb,KAAM,MACN,SAAU,OACV,KAAM,YACN,OAAQ,WACR,YAAa,2FACb,IAAK,sBACL,WAAY,wBACZ,aAAc,aACd,KAAM,OACV,EAEA,WAAiB,EAAK,CAElB,MAAO,GAAe,EAAc,CAAG,EAAG,SAAS,CACvD,CAEA,WAAkB,EAAK,EAAM,CACzB,MAAO,GAAQ,MAAM,KAAM,CAAC,CAAG,EAAE,OAAO,GAAQ,CAAC,CAAC,CAAC,CACvD,CAEA,WAAwB,EAAY,EAAM,CACtC,GAAI,GAAS,EAAG,EAAc,EAAW,OAAQ,EAAK,EAAS,GAAI,EAAG,EAAG,EAAI,EAAK,EAAe,EAAY,EAAa,EAC1H,IAAK,EAAI,EAAG,EAAI,EAAa,IACzB,GAAI,MAAO,GAAW,IAAO,SACzB,GAAU,EAAW,WAEhB,MAAO,GAAW,IAAO,SAAU,CAExC,GADA,EAAK,EAAW,GACZ,EAAG,KAEH,IADA,EAAM,EAAK,GACN,EAAI,EAAG,EAAI,EAAG,KAAK,OAAQ,IAAK,CACjC,GAAI,GAAO,KACP,KAAM,IAAI,OAAM,EAAQ,gEAAiE,EAAG,KAAK,GAAI,EAAG,KAAK,EAAE,EAAE,CAAC,EAEtH,EAAM,EAAI,EAAG,KAAK,GACtB,KAEC,AAAI,GAAG,SACR,EAAM,EAAK,EAAG,UAGd,EAAM,EAAK,KAOf,GAJI,EAAG,SAAS,KAAK,EAAG,IAAI,GAAK,EAAG,cAAc,KAAK,EAAG,IAAI,GAAK,YAAe,WAC9E,GAAM,EAAI,GAGV,EAAG,YAAY,KAAK,EAAG,IAAI,GAAM,MAAO,IAAQ,UAAY,MAAM,CAAG,EACrE,KAAM,IAAI,WAAU,EAAQ,0CAA2C,CAAG,CAAC,EAO/E,OAJI,EAAG,OAAO,KAAK,EAAG,IAAI,GACtB,GAAc,GAAO,GAGjB,EAAG,UACF,IACD,EAAM,SAAS,EAAK,EAAE,EAAE,SAAS,CAAC,EAClC,UACC,IACD,EAAM,OAAO,aAAa,SAAS,EAAK,EAAE,CAAC,EAC3C,UACC,QACA,IACD,EAAM,SAAS,EAAK,EAAE,EACtB,UACC,IACD,EAAM,KAAK,UAAU,EAAK,KAAM,EAAG,MAAQ,SAAS,EAAG,KAAK,EAAI,CAAC,EACjE,UACC,IACD,EAAM,EAAG,UAAY,WAAW,CAAG,EAAE,cAAc,EAAG,SAAS,EAAI,WAAW,CAAG,EAAE,cAAc,EACjG,UACC,IACD,EAAM,EAAG,UAAY,WAAW,CAAG,EAAE,QAAQ,EAAG,SAAS,EAAI,WAAW,CAAG,EAC3E,UACC,IACD,EAAM,EAAG,UAAY,OAAO,OAAO,EAAI,YAAY,EAAG,SAAS,CAAC,CAAC,EAAI,WAAW,CAAG,EACnF,UACC,IACD,EAAO,UAAS,EAAK,EAAE,IAAM,GAAG,SAAS,CAAC,EAC1C,UACC,IACD,EAAM,OAAO,CAAG,EAChB,EAAO,EAAG,UAAY,EAAI,UAAU,EAAG,EAAG,SAAS,EAAI,EACvD,UACC,IACD,EAAM,OAAO,CAAC,CAAC,CAAG,EAClB,EAAO,EAAG,UAAY,EAAI,UAAU,EAAG,EAAG,SAAS,EAAI,EACvD,UACC,IACD,EAAM,OAAO,UAAU,SAAS,KAAK,CAAG,EAAE,MAAM,EAAG,EAAE,EAAE,YAAY,EACnE,EAAO,EAAG,UAAY,EAAI,UAAU,EAAG,EAAG,SAAS,EAAI,EACvD,UACC,IACD,EAAM,SAAS,EAAK,EAAE,IAAM,EAC5B,UACC,IACD,EAAM,EAAI,QAAQ,EAClB,EAAO,EAAG,UAAY,EAAI,UAAU,EAAG,EAAG,SAAS,EAAI,EACvD,UACC,IACD,EAAO,UAAS,EAAK,EAAE,IAAM,GAAG,SAAS,EAAE,EAC3C,UACC,IACD,EAAO,UAAS,EAAK,EAAE,IAAM,GAAG,SAAS,EAAE,EAAE,YAAY,EACzD,MAER,AAAI,EAAG,KAAK,KAAK,EAAG,IAAI,EACpB,GAAU,EAGV,CAAI,EAAG,OAAO,KAAK,EAAG,IAAI,GAAM,EAAC,GAAe,EAAG,MAC/C,GAAO,EAAc,IAAM,IAC3B,EAAM,EAAI,SAAS,EAAE,QAAQ,EAAG,KAAM,EAAE,GAGxC,EAAO,GAEX,EAAgB,EAAG,SAAW,EAAG,WAAa,IAAM,IAAM,EAAG,SAAS,OAAO,CAAC,EAAI,IAClF,EAAa,EAAG,MAAS,GAAO,GAAK,OACrC,EAAM,EAAG,OAAS,EAAa,EAAI,EAAc,OAAO,CAAU,EAAU,GAC5E,GAAU,EAAG,MAAQ,EAAO,EAAM,EAAO,IAAkB,IAAM,EAAO,EAAM,EAAM,EAAM,EAAO,EAEzG,CAEJ,MAAO,EACX,CAEA,GAAI,GAAgB,OAAO,OAAO,IAAI,EAEtC,WAAuB,EAAK,CACxB,GAAI,EAAc,GACd,MAAO,GAAc,GAIzB,OADI,GAAO,EAAK,EAAO,EAAa,CAAC,EAAG,EAAY,EAC7C,GAAM,CACT,GAAK,GAAQ,EAAG,KAAK,KAAK,CAAI,KAAO,KACjC,EAAW,KAAK,EAAM,EAAE,UAElB,GAAQ,EAAG,OAAO,KAAK,CAAI,KAAO,KACxC,EAAW,KAAK,GAAG,UAEb,GAAQ,EAAG,YAAY,KAAK,CAAI,KAAO,KAAM,CACnD,GAAI,EAAM,GAAI,CACV,GAAa,EACb,GAAI,GAAa,CAAC,EAAG,EAAoB,EAAM,GAAI,EAAc,CAAC,EAClE,GAAK,GAAc,EAAG,IAAI,KAAK,CAAiB,KAAO,KAEnD,IADA,EAAW,KAAK,EAAY,EAAE,EACtB,GAAoB,EAAkB,UAAU,EAAY,GAAG,MAAM,KAAO,IAChF,GAAK,GAAc,EAAG,WAAW,KAAK,CAAiB,KAAO,KAC1D,EAAW,KAAK,EAAY,EAAE,UAExB,GAAc,EAAG,aAAa,KAAK,CAAiB,KAAO,KACjE,EAAW,KAAK,EAAY,EAAE,MAG9B,MAAM,IAAI,aAAY,8CAA8C,MAK5E,MAAM,IAAI,aAAY,8CAA8C,EAExE,EAAM,GAAK,CACf,KAEI,IAAa,EAEjB,GAAI,IAAc,EACd,KAAM,IAAI,OAAM,2EAA2E,EAG/F,EAAW,KACP,CACI,YAAa,EAAM,GACnB,SAAa,EAAM,GACnB,KAAa,EAAM,GACnB,KAAa,EAAM,GACnB,SAAa,EAAM,GACnB,MAAa,EAAM,GACnB,MAAa,EAAM,GACnB,UAAa,EAAM,GACnB,KAAa,EAAM,EACvB,CACJ,CACJ,KAEI,MAAM,IAAI,aAAY,kCAAkC,EAE5D,EAAO,EAAK,UAAU,EAAM,GAAG,MAAM,CACzC,CACA,MAAO,GAAc,GAAO,CAChC,CAMA,AAAI,MAAO,KAAY,aACnB,IAAQ,QAAa,EACrB,GAAQ,SAAc,GAEtB,MAAO,SAAW,aAClB,QAAO,QAAa,EACpB,OAAO,SAAc,EAEjB,MAAO,SAAW,YAAc,OAAO,KACvC,OAAO,UAAW,CACd,MAAO,CACH,QAAW,EACX,SAAY,CAChB,CACJ,CAAC,EAIb,GAAE,ICtOF,mBAEA,GAAM,CAAE,YAAY,KAEd,CACF,mBACA,sBACA,kBACA,kBACA,qBACA,SACA,0BACA,KACE,CACF,gBACA,iBACA,YACA,eACA,eACA,cACA,YACA,mBACA,YACA,gBACA,cACA,iBACA,gBACA,WACA,oBACA,mBACA,yBACA,mBACA,mBACA,eACA,kBACA,kBACA,iBACA,cACA,gBACA,oBACA,cACA,iBACA,iBACA,gBACA,gBACA,kBACA,YACA,qBACA,KACE,CACF,eACA,gBACA,mBACA,gBACA,kBACA,iBACA,iBACA,iBACA,iBACA,qBACA,qBACA,oBACA,mBACA,oBACA,kBACA,cACA,eACA,mBACA,kBACA,qBACA,mBACA,uBACA,kBACA,kBACA,KACE,GAAS,KACT,CACF,gBACA,qBACA,eACA,gBACA,KAEE,GAAU,IACV,GAAU,GAAO,WAAW,CAAC,EAO7B,GAAkB,GAGlB,GAAU,WAGV,GAAS,SAAS,EAAG,CACvB,GAAI,GAAM,GAAkB,EAAG,CAAC,EAChC,MAAO,GAAM,GAAK,EAAM,EAAE,MAC9B,EAGM,GAAW,SAAS,EAAK,EAAK,CAChC,MAAI,IAAO,EAAU,EACZ,EAAI,EAAM,EAAY,EACnB,EAAM,EAAM,CAC5B,EAEM,GAAU,SAAS,EAAG,CACxB,GAAI,GAAI,GAAiB,EAAG,CAAC,EACzB,EAAI,EAAE,OACN,EAAQ,GAAS,GAAkB,EAAG,CAAC,EAAG,CAAC,EAC3C,EAAM,GAAS,GAAgB,EAAG,EAAG,EAAE,EAAG,CAAC,EAC/C,MAAI,GAAQ,GAAG,GAAQ,GACnB,EAAM,GAAG,GAAM,GACnB,AAAI,GAAS,EACT,GAAe,EAAG,EAAE,SAAS,EAAQ,EAAI,EAAQ,EAAM,GAAM,EAAQ,EAAE,CAAC,EACvE,GAAgB,EAAG,EAAE,EACnB,CACX,EAEM,GAAU,SAAS,EAAG,CACxB,UAAgB,EAAG,GAAiB,EAAG,CAAC,EAAE,MAAM,EACzC,CACX,EAEM,GAAW,SAAS,EAAG,CACzB,GAAI,GAAI,GAAW,CAAC,EAChB,EAAI,GAAI,IACR,EAAI,GAAkB,EAAG,EAAG,CAAC,EACjC,OAAS,GAAI,EAAG,GAAK,EAAG,IAAK,CACzB,GAAI,GAAI,GAAkB,EAAG,CAAC,EAC9B,GAAc,EAAG,GAAK,GAAK,GAAK,IAAK,oBAAoB,EACzD,EAAE,EAAE,GAAK,CACb,CACA,UAAoB,EAAG,CAAC,EACjB,CACX,EAEM,GAAS,SAAS,EAAG,EAAG,EAAM,EAAG,CACnC,UAAgB,EAAG,EAAG,CAAI,EACnB,CACX,EAEM,GAAW,SAAS,EAAG,CACzB,GAAI,GAAI,GAAI,IACR,EAAQ,GAAc,EAAG,CAAC,EAI9B,MAHA,IAAe,EAAG,EAAG,EAAa,EAClC,GAAW,EAAG,CAAC,EACf,GAAc,EAAG,CAAC,EACd,GAAS,EAAG,GAAQ,EAAG,CAAK,IAAM,EAC3B,GAAW,EAAG,EAAa,+BAA+B,CAAC,EACtE,IAAgB,CAAC,EACV,EACX,EAEM,GAAa,GAAkB,OAAS,EAExC,GAAS,EAET,GAAa,SAAS,EAAG,CAE3B,GAAI,OAAO,GAAG,EAAG,GAAQ,EACrB,MAAO,GAAa,KAAK,EACxB,GAAI,OAAO,GAAG,EAAG,IAAS,EAC3B,MAAO,GAAa,MAAM,EACzB,GAAI,OAAO,MAAM,CAAC,EACnB,MAAO,GAAa,KAAK,EACxB,GAAI,IAAM,EAAG,CAEd,GAAI,GAAO,GAAQ,GAAiB,QAAS,CAAC,EAC9C,MAAI,QAAO,GAAG,EAAG,EAAE,GACf,GAAO,IAAM,GACV,EAAa,CAAI,CAC5B,KAAO,CACH,GAAI,GAAO,GACP,EAAK,GAAM,CAAC,EACZ,EAAI,EAAG,GACP,EAAI,EAAG,GACX,MAAI,GAAI,GACJ,IAAQ,IACR,EAAI,CAAC,GAET,GAAQ,KACR,GAAS,GAAK,IAAG,KAAS,SAAS,EAAE,EACrC,GAAK,GACL,GAAQ,GAAQ,OAAQ,CAAC,EAClB,EAAa,CAAI,CAC5B,CACJ,EAEM,GAAkB,SAAS,EAAG,EAAK,EAAG,CACxC,GAAI,GAAO,GAAW,CAAC,EACvB,GAAI,EAAI,MAAgB,GACpB,OAAS,GAAI,EAAG,EAAI,EAAK,OAAQ,IAAK,CAClC,GAAI,GAAI,EAAK,GACb,AAAI,GAAK,IACL,GAAK,GAAK,EAAI,IACtB,KACG,AAAI,GAAI,MAAgB,IAC3B,GAAW,EAAG,EAAa,kDAAkD,CAAC,EAClF,MAAO,EACX,EAaM,GAAQ,EAAa,OAAO,EAO5B,GAAU,GAAM,IAAM,GAAK,GAAK,KAAS,IAAM,GAAK,GAAK,GACzD,GAAU,GAAK,IAAM,GAAK,GAAK,GAC/B,GAAU,GAAM,GAAQ,GAAK,GAAK,IAAS,IAAM,IACjD,GAAU,GAAK,IAAM,GAAK,GAAK,IAC/B,GAAU,GAAK,IAAM,GAAK,GAAK,IAC/B,GAAU,GAAK,IAAM,GAAK,GAAK,GAC/B,GAAU,GAAM,IAAM,GAAK,GAAK,KAAS,IAAM,GAAK,GAAK,IAAQ,IAAM,GAAK,GAAK,GACjF,GAAU,GAAK,GAAQ,CAAC,GAAK,CAAC,GAAQ,CAAC,EACvC,GAAU,GAAK,IAAM,IAAO,GAAK,GAAK,GAAK,GAC3C,GAAW,GAAM,IAAM,GAAK,GAAK,IAAQ,IAAM,GAAK,GAAK,IAAQ,IAAM,GAAK,GAAK,IAEjF,GAAY,SAAS,EAAG,EAAG,EAAK,CAClC,GAAa,EAAG,EAA0B,EAC1C,GAAI,GAAI,EACR,KAAO,KAAO,CACV,GAAI,EAAE,KAAO,IACT,EAAE,KAAO,IACT,EAAE,KAAO,GACT,GAAa,EAAG,EAA2B,EAC3C,GAAa,EAAG,EAAE,EAAE,UACb,GAAQ,EAAE,EAAE,EAAG,CACtB,GAAI,GAAO,GAAG,EAAE,GAChB,AAAI,GAAQ,EAAE,EAAE,EAAE,GACd,GAAO,IAAI,OAAO,EAAE,EAAK,MAAM,EAAI,GACvC,GAAe,EAAG,EAAa,KAAO,CAAI,CAAC,CAC/C,KACI,IAAa,EAAG,EAAE,EAAE,EACxB,GACJ,CACA,GAAa,EAAG,EAA0B,CAC9C,EAKM,GAAU,SAAS,EAAM,CAC3B,GAAI,GAAkB,EAAM,EAA4B,EAAI,EAAG,CAC3D,GAAI,GAAQ,GAAsB,EAC9B,EAAS,GAAkB,EAAM,CAAK,EAC1C,AAAI,GAAQ,GAAK,GAAU,GAC/B,CACJ,EAEM,GAAa,SAAS,EAAG,EAAG,EAAK,CACnC,OAAO,GAAS,EAAG,CAAG,OACb,IAAa,CACd,GAAI,GAAI,GAAa,EAAG,CAAG,EAC3B,GAAU,EAAG,EAAG,EAAE,MAAM,EACxB,KACJ,KACK,IAAa,CACd,GAAI,GACJ,GAAK,GAAc,EAAG,CAAG,EAIlB,CACH,GAAI,GAAI,GAAc,EAAG,CAAG,EACxB,EAAU,IAAM,GACd,MAAQ,GAAqB,IAC7B,GACN,EAAO,EAAa,GAAQ,EAAQ,CAAC,CAAC,CAC1C,KAV4B,CACxB,GAAI,GAAI,GAAa,EAAG,CAAG,EAC3B,EAAO,GAAgB,EAAG,EAAa,IAAI,KAAqB,EAAG,CAAC,EACpE,GAAQ,CAAI,CAChB,CAOA,GAAe,EAAG,CAAI,EACtB,KACJ,KACK,QAAe,IAAc,CAC9B,GAAe,EAAG,CAAG,EACrB,GAAc,CAAC,EACf,KACJ,SAEI,GAAc,EAAG,EAAK,EAAa,2BAA2B,CAAC,EAG3E,EAEM,GAAa,SAAS,EAAG,EAAS,EAAG,EAAM,CAC7C,GAAI,GAAI,EACR,KAAO,EAAQ,KAAO,GAAK,GAAkB,GAAO,EAAQ,EAAE,GAAK,GAAG,IACtE,AAAI,EAAI,GAAK,GAAM,QACf,GAAW,EAAG,EAAa,iCAAiC,CAAC,EAC7D,GAAQ,EAAQ,EAAE,GAAG,IACrB,GAAQ,EAAQ,EAAE,GAAG,IACrB,EAAQ,KAAO,IACf,KACI,GAAQ,EAAQ,EAAE,GAAG,IACrB,GAAQ,EAAQ,EAAE,GAAG,KAEzB,GAAQ,EAAQ,EAAE,GAClB,GAAW,EAAG,EAAa,8CAA8C,CAAC,EAC9E,EAAK,GAAK,GACV,OAAS,GAAI,EAAG,EAAI,EAAI,EAAI,EAAG,IAC3B,EAAK,EAAE,GAAK,EAAQ,EAAE,GAC1B,MAAO,EACX,EAKM,GAAY,SAAS,EAAM,EAAQ,CACrC,GAAI,GAAI,EAAK,OACT,EAAK,EAAO,OACZ,EAAO,EAAK,EAAI,GACpB,OAAS,GAAI,EAAG,EAAI,EAAI,IACpB,EAAK,EAAI,EAAI,GAAK,EAAO,GAC7B,EAAK,EAAI,EAAK,GAAK,CAEvB,EAEM,GAAa,SAAS,EAAG,CAC3B,GAAI,GAAM,GAAW,CAAC,EAClB,EAAM,EACN,EAAU,GAAiB,EAAG,CAAG,EACjC,EAAI,EACJ,EAAI,GAAI,IAEZ,IADA,GAAc,EAAG,CAAC,EACX,EAAI,EAAQ,QACf,GAAI,EAAQ,KAAO,GACf,GAAa,EAAG,EAAQ,IAAI,UACrB,EAAQ,EAAE,KAAO,GACxB,GAAa,EAAG,EAAQ,IAAI,MACzB,CACH,GAAI,GAAO,CAAC,EAIZ,OAHI,EAAE,EAAM,GACR,GAAc,EAAG,EAAK,EAAa,UAAU,CAAC,EAClD,EAAI,GAAW,EAAG,EAAS,EAAG,CAAI,EAC1B,OAAO,aAAa,EAAQ,IAAI,OAC/B,IAAK,CAEN,GAAa,EAAG,GAAkB,EAAG,CAAG,CAAC,EACzC,KACJ,KACK,QAAU,QACV,QAAU,QAAU,QAAU,IAAK,CACpC,GAAI,GAAI,GAAkB,EAAG,CAAG,EAChC,GAAU,EAAM,EAAa,GAAoB,EAAI,CAAC,EACtD,GAAe,EAAG,EAAa,GAAQ,OAAO,aAAa,GAAG,CAAI,EAAG,CAAC,CAAC,CAAC,EACxE,KACJ,KACK,QAAU,IAAK,CAChB,GAAU,EAAM,EAAa,GAAoB,EAAI,CAAC,EACtD,GAAe,EAAG,GAAgB,EAAG,EAAM,GAAiB,EAAG,CAAG,CAAC,CAAC,EACpE,KACJ,KACK,QAAU,QAAU,QACpB,QAAU,IAAK,CAChB,GAAI,GAAI,GAAiB,EAAG,CAAG,EAC/B,GAAU,EAAM,EAAa,GAAoB,EAAI,CAAC,EACtD,GAAe,EAAG,EAAa,GAAQ,OAAO,aAAa,GAAG,CAAI,EAAG,CAAC,CAAC,CAAC,EACxE,KACJ,KACK,IAAK,CACN,GAAW,EAAG,EAAG,CAAG,EACpB,KACJ,KACK,IAAK,CACN,GAAI,GAAI,GAAe,EAAG,CAAG,EAC7B,AAAI,EAAK,QAAU,GAAK,EAAK,KAAO,EAChC,GAAc,CAAC,EAEf,IAAc,EAAG,EAAE,SAAW,GAAO,CAAC,EAAG,EAAK,uBAAuB,EACrE,AAAI,GAAkB,EAAM,EAA0B,EAAI,GAAK,EAAE,QAAU,IAEvE,GAAc,CAAC,EAGf,IAAe,EAAG,EAAa,GAAQ,OAAO,aAAa,GAAG,CAAI,EAAG,GAAY,CAAC,CAAC,CAAC,CAAC,EACrF,GAAQ,EAAG,CAAC,IAGpB,KACJ,SAEI,MAAO,IAAW,EAAG,EAAa,mCAAmC,EAAG,EAAQ,EAAE,EAAE,EAGhG,CAEJ,UAAgB,CAAC,EACV,CACX,EAGM,GAAmB,EAGnB,GAAa,GAEb,GAAQ,EAGR,GAAK,EAGL,GAAO,IAAK,IAAM,EAElB,GAAW,EAKX,GAAN,KAAa,CACT,YAAY,EAAG,CACX,KAAK,EAAI,EACT,KAAK,SAAW,GAChB,KAAK,SAAW,CACpB,CACJ,EAKM,GAAa,EACb,GAAa,EACb,GAAa,EACb,GAAa,EACb,GAAa,EACb,GAAa,EACb,GAAa,EACb,GAAa,EACb,GAAa,EAEb,GAAQ,GAER,GAAS,SAAS,EAAK,EAAI,CAC7B,GAAI,EAAI,KAAO,EAAI,EAAE,QAAU,CAAC,GAAM,EAAI,EAAE,EAAI,IAAI,EAChD,MAAO,GACN,CACD,GAAI,GAAI,EACR,EACI,GAAI,EAAI,GAAM,GAAI,EAAE,EAAI,OAAS,UAC5B,EAAI,IAAM,EAAI,EAAE,QAAU,GAAM,EAAI,EAAE,EAAI,IAAI,GAAK,GAAM,IAAU,GAAG,IAC/E,MAAO,EACX,CACJ,EAMM,GAAc,SAAS,EAAG,EAAK,EAAI,CACrC,GAAI,GAAK,GAAO,EAAK,CAAE,EACvB,MAAI,GAAK,IAAc,GAAM,IACzB,GAAW,EAAE,EAAG,EAAa,yCAAyC,EAAG,EAAI,EAAU,EACpF,CACX,EAKM,GAAY,SAAS,EAAG,EAAK,CAC/B,GAAI,GAAI,CACJ,IAAK,EAAI,EAAE,EAAI,OACf,KAAM,CACV,EACA,OAAQ,EAAE,SACD,IAAa,SAAE,KAAO,EAAG,EAAE,IAAM,GAAe,MAChD,IAAa,SAAE,KAAO,EAAG,EAAE,IAAM,GAAe,MAChD,KAAa,SAAE,KAAO,EAAG,EAAE,IAAM,GAAe,MAChD,IAAa,SAAE,KAAO,EAAG,EAAE,IAAM,GAAe,MAChD,KAAa,SAAE,KAAO,EAAG,EAAE,IAAM,GAAe,MAChD,IAAa,SAAE,KAAO,EAAG,EAAE,IAAM,GAAe,MAChD,KAAa,SAAE,KAAO,EAAG,EAAE,IAAM,GAAe,MAChD,IAAa,SAAE,KAAO,EAAG,EAAE,IAAM,GAAe,MAChD,IAAa,SAAE,KAAO,EAAG,EAAE,IAAM,GAAe,MAChD,KAAa,SAAE,KAAO,EAAG,EAAE,IAAM,GAAe,MAChD,KAAa,SAAE,KAAO,EAAG,EAAE,IAAM,GAAe,MAChD,KAAa,SAAE,KAAO,EAAG,EAAE,IAAM,GAAe,MAChD,KAAa,SAAE,KAAO,GAAY,EAAG,EAAK,CAAC,EAAG,EAAE,IAAM,GAAgB,MACtE,IAAa,SAAE,KAAO,GAAY,EAAG,EAAK,CAAC,EAAG,EAAE,IAAM,GAAgB,MACtE,KAAa,SAAE,KAAO,GAAY,EAAG,EAAK,CAAC,EAAG,EAAE,IAAM,GAAgB,MACtE,IACD,SAAE,KAAO,GAAO,EAAK,EAAE,EACnB,EAAE,OAAS,IACX,GAAW,EAAE,EAAG,EAAa,oCAAoC,CAAC,EACtE,EAAE,IAAM,GACD,MAEN,KAAyB,SAAE,IAAM,GAAmB,MACpD,KAAa,SAAE,KAAO,EAAG,EAAE,IAAM,GAAmB,MACpD,IAAyB,SAAE,IAAM,GAAmB,MACpD,IAAa,UACb,IAAa,EAAE,SAAW,GAAM,UAChC,IAAa,EAAE,SAAW,GAAO,UACjC,IAAa,EAAE,SAAW,GAAM,UAChC,IAAa,EAAE,SAAW,GAAY,EAAG,EAAK,EAAQ,EAAG,cACrD,GAAW,EAAE,EAAG,EAAa,4BAA4B,EAAG,EAAE,GAAG,EAE9E,SAAE,IAAM,GACD,CACX,EAWM,GAAa,SAAS,EAAG,EAAW,EAAK,CAC3C,GAAI,GAAI,CACJ,IAAK,IACL,KAAM,IACN,SAAU,GACd,EAEI,EAAM,GAAU,EAAG,CAAG,EAC1B,EAAE,KAAO,EAAI,KACb,EAAE,IAAM,EAAI,IACZ,GAAI,GAAQ,EAAE,KACd,GAAI,EAAE,MAAQ,GACV,GAAI,EAAI,KAAO,EAAI,EAAE,QAAU,EAAI,EAAE,EAAI,OAAS,EAC9C,GAAc,EAAE,EAAG,EAAG,EAAa,oCAAoC,CAAC,MACvE,CACD,GAAI,GAAI,GAAU,EAAG,CAAG,EACxB,EAAQ,EAAE,KACV,EAAI,EAAE,IACF,KAAM,IAAS,IAAU,IACzB,GAAc,EAAE,EAAG,EAAG,EAAa,oCAAoC,CAAC,CAChF,CAEJ,MAAI,IAAS,GAAK,EAAE,MAAQ,GACxB,EAAE,SAAW,EAET,GAAQ,EAAE,UACV,GAAQ,EAAE,UACT,GAAS,EAAO,KAAQ,GACzB,GAAc,EAAE,EAAG,EAAG,EAAa,0CAA0C,CAAC,EAClF,EAAE,SAAY,EAAS,GAAa,EAAQ,GAAQ,EAAQ,GAEzD,CACX,EAQM,GAAU,SAAS,EAAG,EAAG,EAAU,EAAM,EAAK,CAChD,GAAI,GAAO,GAAkB,EAAG,CAAI,EACpC,EAAK,EAAW,EAAI,EAAO,GAAK,EAAI,GACpC,OAAS,GAAI,EAAG,EAAI,EAAM,IACtB,IAAM,GACN,EAAK,EAAW,EAAI,EAAO,EAAI,GAAK,EAAI,GAE5C,GAAI,GAAO,EAAO,GACd,OAAS,GAAI,GAAO,EAAI,EAAM,IAC1B,EAAK,EAAW,EAAI,EAAO,EAAI,GAAK,GAE5C,GAAa,EAAG,CAAI,CACxB,EAEM,GAAW,SAAS,EAAG,CACzB,GAAI,GAAI,GAAI,IACR,EAAI,GAAI,IAAO,CAAC,EAChB,EAAM,CACN,EAAG,GAAiB,EAAG,CAAC,EACxB,IAAK,CACT,EACI,EAAM,EACN,EAAY,EAGhB,IAFA,GAAY,CAAC,EACb,GAAc,EAAG,CAAC,EACX,EAAI,IAAM,EAAI,EAAE,QAAQ,CAC3B,GAAI,GAAU,GAAW,EAAG,EAAW,CAAG,EACtC,EAAM,EAAQ,IACd,EAAO,EAAQ,KACf,EAAW,EAAQ,SAEvB,IADA,GAAa,EAAW,EACjB,KAAa,GAChB,GAAa,EAAG,EAAgB,EAEpC,OADA,IACQ,OACC,IAAM,CACP,GAAI,GAAI,GAAkB,EAAG,CAAG,EAChC,GAAI,EAAO,GAAO,CACd,GAAI,GAAM,GAAM,EAAO,EAAK,EAC5B,GAAc,EAAG,CAAC,GAAO,GAAK,EAAI,EAAK,EAAK,kBAAkB,CAClE,CACA,GAAQ,EAAG,EAAG,EAAE,SAAU,EAAM,EAAI,CAAC,EACrC,KACJ,KACK,IAAO,CACR,GAAI,GAAI,GAAkB,EAAG,CAAG,EAChC,AAAI,EAAO,IACP,GAAc,EAAI,IAAI,EAAM,GAAM,EAAO,GAAM,EAAK,mBAAmB,EAC3E,GAAQ,EAAG,IAAI,EAAG,EAAE,SAAU,EAAM,EAAK,EACzC,KACJ,KACK,IAAQ,CACT,GAAI,GAAO,GAAkB,EAAG,CAAI,EAChC,EAAI,GAAiB,EAAG,CAAG,EAC3B,EAAK,GAAI,UAAS,EAAK,OAAQ,EAAK,WAAY,EAAK,UAAU,EACnE,AAAI,IAAS,EAAG,EAAG,WAAW,EAAG,EAAG,EAAE,QAAQ,EACzC,EAAG,WAAW,EAAG,EAAG,EAAE,QAAQ,EACnC,GAAa,EAAG,CAAI,EACpB,KACJ,KACK,IAAO,CACR,GAAI,GAAI,GAAiB,EAAG,CAAG,EAC3B,EAAM,EAAE,OAGZ,IAFA,GAAc,EAAG,GAAO,EAAM,EAAK,+BAA+B,EAClE,GAAgB,EAAG,EAAG,CAAG,EAClB,IAAQ,GACX,GAAa,EAAG,EAAgB,EACpC,KACJ,KACK,IAAS,CACV,GAAI,GAAI,GAAiB,EAAG,CAAG,EAC3B,EAAM,EAAE,OACZ,GAAc,EACV,GAAQ,GAA0B,EAAO,GAAM,EAAO,GACtD,EAAK,0CAA0C,EACnD,GAAQ,EAAG,EAAK,EAAE,SAAU,EAAM,CAAC,EACnC,GAAgB,EAAG,EAAG,CAAG,EACzB,GAAa,EACb,KACJ,KACK,IAAO,CACR,GAAI,GAAI,GAAiB,EAAG,CAAG,EAC3B,EAAM,EAAE,OACZ,GAAc,EAAG,GAAkB,EAAG,CAAC,EAAI,EAAG,EAAK,wBAAwB,EAC3E,GAAgB,EAAG,EAAG,CAAG,EACzB,GAAa,EAAG,CAAC,EACjB,GAAa,EAAM,EACnB,KACJ,KACK,IAAU,GAAa,EAAG,EAAgB,MAC1C,QAAiB,IAClB,IACA,MAEZ,CACA,UAAgB,CAAC,EACV,CACX,EAEM,GAAc,SAAS,EAAG,CAC5B,GAAI,GAAI,GAAiB,EAAG,CAAC,EACzB,EAAI,EAAE,OACN,EAAI,GAAI,YAAW,CAAC,EACxB,OAAS,GAAE,EAAG,EAAE,EAAG,IACf,EAAE,GAAK,EAAE,EAAE,EAAE,GACjB,UAAe,EAAG,CAAC,EACZ,CACX,EAEM,GAAY,SAAS,EAAG,CAC1B,GAAI,GAAI,GAAiB,EAAG,CAAC,EACzB,EAAI,EAAE,OACN,EAAI,GAAI,YAAW,CAAC,EACxB,OAAS,GAAE,EAAG,EAAE,EAAG,IAAK,CACpB,GAAI,GAAI,EAAE,GACV,AAAI,GAAQ,CAAC,GACT,GAAI,EAAI,IACZ,EAAE,GAAK,CACX,CACA,UAAe,EAAG,CAAC,EACZ,CACX,EAEM,GAAY,SAAS,EAAG,CAC1B,GAAI,GAAI,GAAiB,EAAG,CAAC,EACzB,EAAI,EAAE,OACN,EAAI,GAAI,YAAW,CAAC,EACxB,OAAS,GAAE,EAAG,EAAE,EAAG,IAAK,CACpB,GAAI,GAAI,EAAE,GACV,AAAI,GAAQ,CAAC,GACT,GAAI,EAAI,KACZ,EAAE,GAAK,CACX,CACA,UAAe,EAAG,CAAC,EACZ,CACX,EAEM,GAAU,SAAS,EAAG,CACxB,GAAI,GAAI,GAAiB,EAAG,CAAC,EACzB,EAAI,EAAE,OACN,EAAI,GAAkB,EAAG,CAAC,EAC1B,EAAM,GAAe,EAAG,EAAG,EAAE,EAC7B,EAAO,EAAI,OACf,GAAI,GAAK,EAAG,GAAgB,EAAG,EAAE,MAC5B,IAAI,EAAI,EAAO,GAAK,EAAI,EAAO,GAAU,EAC1C,MAAO,IAAW,EAAG,EAAa,4BAA4B,CAAC,EAC9D,CACD,GAAI,GAAW,EAAI,EAAK,GAAI,GAAK,EAC7B,EAAI,GAAI,IACR,EAAI,GAAkB,EAAG,EAAG,CAAQ,EACpC,EAAK,EACT,KAAO,KAAM,GACT,EAAE,IAAI,EAAG,CAAE,EACX,GAAM,EACF,EAAO,GACP,GAAE,IAAI,EAAK,CAAE,EACb,GAAM,GAGd,EAAE,IAAI,EAAG,CAAE,EACX,GAAoB,EAAG,CAAQ,CACnC,EACA,MAAO,EACX,EAEM,GAAW,SAAS,EAAG,CACzB,GAAI,GAAI,GAAiB,EAAG,CAAC,EACzB,EAAI,EAAE,OACN,EAAO,GAAS,GAAgB,EAAG,EAAG,CAAC,EAAG,CAAC,EAC3C,EAAO,GAAS,GAAgB,EAAG,EAAG,CAAI,EAAG,CAAC,EAIlD,GAFI,EAAO,GAAG,GAAO,GACjB,EAAO,GAAG,GAAO,GACjB,EAAO,EAAM,MAAO,GACxB,GAAI,EAAO,GAAQ,OAAO,iBACtB,MAAO,IAAW,EAAG,uBAAuB,EAEhD,GAAI,GAAK,EAAO,EAAQ,EACxB,GAAgB,EAAG,EAAG,uBAAuB,EAC7C,OAAS,GAAI,EAAG,EAAI,EAAG,IACnB,GAAgB,EAAG,EAAE,EAAO,EAAI,EAAE,EACtC,MAAO,EACX,EAEM,GAAe,SAAS,EAAG,CAC7B,GAAI,GAAI,GAAI,IAAO,CAAC,EAChB,EAAM,CACN,EAAG,GAAiB,EAAG,CAAC,EACxB,IAAK,CACT,EACI,EAAY,EAChB,KAAO,EAAI,IAAM,EAAI,EAAE,QAAQ,CAC3B,GAAI,GAAU,GAAW,EAAG,EAAW,CAAG,EACtC,EAAM,EAAQ,IACd,EAAO,EAAQ,KAKnB,OAHA,GADe,EAAQ,SAEvB,GAAc,EAAG,GAAa,GAAU,EAAM,EAAG,yBAAyB,EAC1E,GAAa,EACL,OACC,QACA,IACD,GAAc,EAAG,EAAG,wBAAwB,UAEtC,MAElB,CACA,UAAgB,EAAG,CAAS,EACrB,CACX,EAUM,GAAY,SAAS,EAAG,EAAK,EAAU,EAAM,EAAU,CACzD,GAAI,GAAM,EACN,EAAQ,GAAQ,GAAQ,EAAO,GACnC,OAAS,GAAI,EAAQ,EAAG,GAAK,EAAG,IAC5B,IAAQ,GACR,GAAO,EAAI,EAAW,EAAI,EAAO,EAAI,GAEzC,GAAI,EAAO,IACP,GAAI,EAAU,CACV,GAAI,GAAO,GAAM,EAAO,GAAK,EAC7B,EAAQ,GAAM,GAAQ,CAC1B,UACO,EAAO,GAAO,CACrB,GAAI,GAAO,CAAC,GAAY,GAAO,EAAI,EAAI,GACvC,OAAS,GAAI,EAAO,EAAI,EAAM,IAC1B,AAAI,EAAI,EAAW,EAAI,EAAO,EAAI,KAAO,GACrC,GAAW,EAAG,EAAa,+CAA+C,EAAG,CAAI,CAE7F,CACA,MAAO,EACX,EAEM,GAAY,SAAS,EAAG,EAAG,EAAU,EAAM,CAC7C,GAAO,WAAW,EAAE,QAAU,CAAI,EAElC,GAAI,GAAK,GAAI,UAAS,GAAI,aAAY,CAAI,CAAC,EAC3C,OAAS,GAAI,EAAG,EAAI,EAAM,IACtB,EAAG,SAAS,EAAG,EAAE,GAAI,CAAQ,EAEjC,MAAI,IAAQ,EAAU,EAAG,WAAW,EAAG,CAAQ,EACnC,EAAG,WAAW,EAAG,CAAQ,CACzC,EAEM,GAAa,SAAS,EAAG,CAC3B,GAAI,GAAI,GAAI,IAAO,CAAC,EAChB,EAAM,CACN,EAAG,GAAiB,EAAG,CAAC,EACxB,IAAK,CACT,EACI,EAAO,GAAiB,EAAG,CAAC,EAC5B,EAAK,EAAK,OACV,EAAM,GAAS,GAAgB,EAAG,EAAG,CAAC,EAAG,CAAE,EAAI,EAC/C,EAAI,EAER,IADA,GAAc,EAAG,GAAO,GAAM,GAAO,EAAG,EAAG,gCAAgC,EACpE,EAAI,IAAM,EAAI,EAAE,QAAQ,CAC3B,GAAI,GAAU,GAAW,EAAG,EAAK,CAAG,EAChC,EAAM,EAAQ,IACd,EAAO,EAAQ,KACf,EAAW,EAAQ,SAOvB,OANkC,EAAM,EAAW,EAAO,GACtD,GAAc,EAAG,EAAG,EAAa,uBAAuB,CAAC,EAC7D,GAAO,EAEP,GAAgB,EAAG,EAAG,kBAAkB,EACxC,IACQ,OACC,QACA,IAAO,CACR,GAAI,GAAM,GAAU,EAAG,EAAK,SAAS,CAAG,EAAG,EAAE,SAAU,EAAM,IAAQ,EAAI,EACzE,GAAgB,EAAG,CAAG,EACtB,KACJ,KACK,IAAQ,CACT,GAAI,GAAM,GAAU,EAAG,EAAK,SAAS,CAAG,EAAG,EAAE,SAAU,CAAI,EAC3D,GAAe,EAAG,CAAG,EACrB,KACJ,KACK,IAAO,CACR,GAAe,EAAG,EAAK,SAAS,EAAK,EAAM,CAAI,CAAC,EAChD,KACJ,KACK,IAAS,CACV,GAAI,GAAM,GAAU,EAAG,EAAK,SAAS,CAAG,EAAG,EAAE,SAAU,EAAM,CAAC,EAC9D,GAAc,EAAG,EAAM,EAAM,GAAQ,EAAI,EAAG,uBAAuB,EACnE,GAAe,EAAG,EAAK,SAAS,EAAM,EAAM,EAAM,EAAO,CAAG,CAAC,EAC7D,GAAO,EACP,KACJ,KACK,IAAO,CACR,GAAI,GAAI,GAAkB,EAAM,EAAG,CAAG,EACtC,AAAI,IAAM,IAAI,GAAI,EAAK,OAAS,GAChC,GAAe,EAAG,EAAK,SAAS,EAAK,CAAC,CAAC,EACvC,EAAM,EAAI,EACV,KACJ,KACK,QAAiB,QAAe,IACjC,IACA,MAER,GAAO,CACX,CACA,UAAgB,EAAG,EAAM,CAAC,EACnB,EAAI,CACf,EAEM,GAAiB,GACjB,GAAiB,GACjB,GAAiB,IACjB,GAAiB,EAAa,YAAY,EAE1C,GAAN,KAAiB,CACb,YAAY,EAAG,CACX,KAAK,IAAM,KACX,KAAK,SAAW,KAChB,KAAK,QAAU,KACf,KAAK,EAAI,KACT,KAAK,MAAQ,KACb,KAAK,EAAI,EACT,KAAK,WAAa,IAClB,KAAK,MAAQ,IACb,KAAK,QAAU,CAAC,CACpB,CACJ,EAEM,GAAgB,SAAS,EAAI,EAAG,CAElC,MADA,GAAI,EAAI,GACJ,EAAI,GAAK,GAAK,EAAG,OAAS,EAAG,QAAQ,GAAG,MAAQ,GACzC,GAAW,EAAG,EAAG,EAAa,4BAA4B,EAAG,EAAI,CAAC,EACtE,CACX,EAEM,GAAmB,SAAS,EAAI,CAClC,GAAI,GAAQ,EAAG,MACf,IAAK,IAAS,GAAS,EAAG,IACtB,GAAI,EAAG,QAAQ,GAAO,MAAQ,GAAgB,MAAO,GACzD,MAAO,IAAW,EAAG,EAAG,EAAa,yBAAyB,CAAC,CACnE,EAEM,GAAW,SAAS,EAAI,EAAG,CAC7B,OAAO,EAAG,EAAE,UACH,IACD,MAAI,KAAM,EAAG,OACT,GAAW,EAAG,EAAG,EAAa,oCAAoC,CAAC,EAChE,EAAI,MAEV,IAA4B,CAC7B,AAAI,EAAG,EAAE,KAAO,IAA4B,IAC5C,EACI,AAAI,KAAM,EAAG,OACT,GAAW,EAAG,EAAG,EAAa,iCAAiC,CAAC,EAChE,EAAG,EAAE,OAAS,IAAS,EAAI,EAAG,OAC9B,UACC,EAAG,EAAE,KAAO,IACrB,MAAO,GAAI,CACf,SAEI,MAAO,GAGnB,EAEM,GAAc,SAAS,EAAG,EAAI,CAChC,OAAQ,OACC,IAA6B,MAAQ,IAAQ,CAAC,MAC9C,IAA6B,MAAO,CAAC,GAAQ,CAAC,MAC9C,IAA6B,MAAQ,IAAQ,CAAC,MAC9C,IAA6B,MAAO,CAAC,GAAQ,CAAC,MAC9C,KAA6B,MAAQ,IAAQ,CAAC,MAC9C,IAA6B,MAAO,CAAC,GAAQ,CAAC,MAC9C,KAA6B,MAAQ,IAAQ,CAAC,MAC9C,IAA6B,MAAO,CAAC,GAAQ,CAAC,MAC9C,KAA6B,MAAQ,IAAQ,CAAC,MAC9C,IAA6B,MAAO,CAAC,GAAQ,CAAC,MAC9C,KAA6B,MAAQ,IAAQ,CAAC,MAC9C,IAA6B,MAAO,CAAC,GAAQ,CAAC,MAC9C,KAA6B,MAAQ,IAAQ,CAAC,MAC9C,IAA6B,MAAO,CAAC,GAAQ,CAAC,MAC9C,KAA6B,MAAQ,IAAQ,CAAC,MAC9C,IAA6B,MAAO,CAAC,GAAQ,CAAC,MAC9C,KAA6B,MAAQ,IAAQ,CAAC,MAC9C,IAA6B,MAAO,CAAC,GAAQ,CAAC,MAC9C,KAA6B,MAAQ,IAAS,CAAC,MAC/C,IAA6B,MAAO,CAAC,GAAS,CAAC,MAC/C,KAA6B,MAAQ,KAAM,MAC3C,IAA6B,MAAQ,KAAM,UACvC,MAAQ,KAAO,EAEhC,EAEM,GAAoB,SAAS,EAAI,EAAG,EAAG,EAAI,CAC7C,GAAI,GAAM,GAKV,IAJI,EAAG,EAAE,EAAI,KAAO,IAChB,GAAM,GACN,KAEG,EAAE,EAAI,GACT,GAAI,EAAG,EAAE,KAAO,IAEZ,GADA,IACI,GAAY,EAAG,EAAG,EAAE,EAAE,EACtB,MAAO,WACJ,EAAG,EAAE,EAAI,KAAO,IAA8B,EAAI,EAAI,GAE7D,GADA,GAAK,EACD,EAAG,EAAE,EAAI,IAAM,GAAK,GAAK,EAAG,EAAE,GAC9B,MAAO,WACJ,EAAG,EAAE,KAAO,EAAG,MAAO,GAErC,MAAO,CAAC,CACZ,EAEM,GAAc,SAAS,EAAI,EAAG,EAAG,EAAI,CACvC,GAAI,GAAK,EAAG,QACR,MAAO,GACN,CACD,GAAI,GAAI,EAAG,IAAI,GACf,OAAQ,EAAG,EAAE,QACJ,IAA4B,MAAO,OACnC,IAAO,MAAO,IAAY,EAAG,EAAG,EAAE,EAAI,EAAE,MACxC,IAA4B,MAAO,IAAkB,EAAI,EAAG,EAAG,EAAK,CAAC,UACjE,MAAO,GAAG,EAAE,KAAO,EAEpC,CACJ,EAEM,GAAe,SAAS,EAAI,EAAG,EAAG,CAGpC,GAFI,GAAK,EAAG,MAAQ,GAChB,GAAW,EAAG,EAAG,EAAa,+CAA+C,CAAC,EAC9E,EAAG,IAAI,KAAO,EAAG,EAAE,GACnB,MAAO,MACN,CACD,GAAI,GAAI,EAAG,EAAE,GACT,EAAI,EAAG,EAAE,EAAI,GACb,EAAO,EACX,KAAO,EAAE,EAAI,EAAG,SACZ,GAAI,EAAG,IAAI,KAAO,GACd,GAAI,EAAE,IAAS,EAAG,MAAO,GAAI,MAE5B,AAAI,GAAG,IAAI,KAAO,GAAG,GAElC,CACA,MAAO,KACX,EAEM,GAAa,SAAS,EAAI,EAAG,EAAG,EAAI,CACtC,GAAI,GAAI,EACR,KAAO,GAAY,EAAI,EAAI,EAAG,EAAG,CAAE,GAC/B,IAEJ,KAAO,GAAK,GAAG,CACX,GAAI,GAAM,GAAM,EAAI,EAAI,EAAG,EAAK,CAAC,EACjC,GAAI,EAAK,MAAO,GAChB,GACJ,CACA,MAAO,KACX,EAEM,GAAa,SAAS,EAAI,EAAG,EAAG,EAAI,CACtC,OAAS,CACL,GAAI,GAAM,GAAM,EAAI,EAAG,EAAK,CAAC,EAC7B,GAAI,IAAQ,KACR,MAAO,GACN,GAAI,GAAY,EAAI,EAAG,EAAG,CAAE,EAC7B,QACC,OAAO,KAChB,CACJ,EAEM,GAAgB,SAAS,EAAI,EAAG,EAAG,EAAM,CAC3C,GAAI,GAAQ,EAAG,MACf,AAAI,GAAS,IAAiB,GAAW,EAAG,EAAG,EAAa,mBAAmB,CAAC,EAChF,EAAG,QAAQ,GAAS,EAAG,QAAQ,GAAS,EAAG,QAAQ,GAAS,CAAC,EAC7D,EAAG,QAAQ,GAAO,KAAO,EACzB,EAAG,QAAQ,GAAO,IAAM,EACxB,EAAG,MAAQ,EAAQ,EACnB,GAAI,GACJ,MAAK,GAAM,GAAM,EAAI,EAAG,CAAC,KAAO,MAC5B,EAAG,QACA,CACX,EAEM,GAAc,SAAS,EAAI,EAAG,EAAG,CACnC,GAAI,GAAI,GAAiB,CAAE,EAC3B,EAAG,QAAQ,GAAG,IAAM,EAAI,EAAG,QAAQ,GAAG,KACtC,GAAI,GACJ,MAAK,GAAM,GAAM,EAAI,EAAG,CAAC,KAAO,MAC5B,GAAG,QAAQ,GAAG,IAAM,IACjB,CACX,EAGM,GAAY,SAAS,EAAG,EAAI,EAAG,EAAI,EAAK,CAC1C,MAAO,IAAa,EAAE,SAAS,EAAI,EAAG,CAAG,EAAG,EAAE,SAAS,EAAI,EAAG,CAAG,CAAC,CACtE,EAEM,GAAgB,SAAS,EAAI,EAAG,EAAG,CACrC,EAAI,GAAc,EAAI,CAAC,EACvB,GAAI,GAAM,EAAG,QAAQ,GAAG,IACxB,MAAK,GAAG,QAAQ,GAAM,GAAO,GAAU,EAAG,IAAK,EAAG,QAAQ,GAAG,KAAM,EAAG,IAAK,EAAG,CAAG,EACtE,EAAE,EACD,IAChB,EAEM,GAAQ,SAAS,EAAI,EAAG,EAAG,CAC7B,GAAI,GAAc,GACd,EAAW,GAKf,IAHI,EAAG,eAAiB,GACpB,GAAW,EAAG,EAAG,EAAa,qBAAqB,CAAC,EAEjD,GAAY,GAEf,GADA,EAAW,GACP,IAAM,EAAG,MACT,OAAQ,EAAc,OAAS,EAAG,EAAE,QAC3B,IAA4B,CAC7B,AAAI,EAAG,EAAE,EAAI,KAAO,GAChB,EAAI,GAAc,EAAI,EAAG,EAAI,EAAG,EAAY,EAE5C,EAAI,GAAc,EAAI,EAAG,EAAI,EAAG,EAAc,EAClD,KACJ,KACK,IAA4B,CAC7B,EAAI,GAAY,EAAI,EAAG,EAAI,CAAC,EAC5B,KACJ,KACK,IAA4B,CAC7B,GAAI,EAAI,IAAM,EAAG,MAAO,CACpB,EAAc,GACd,KACJ,CACA,EAAK,EAAG,IAAI,OAAS,IAAO,EAAI,EAAI,KACpC,KACJ,KACK,IAAO,CACR,OAAQ,EAAG,EAAE,EAAI,QACR,IAA4B,CAC7B,EAAI,GAAa,EAAI,EAAG,EAAI,CAAC,EACzB,IAAM,MACN,IAAK,EACL,EAAW,IAEf,KACJ,KACK,KAA6B,CAC9B,GAAK,EACD,EAAG,EAAE,KAAO,IACZ,GAAW,EAAG,EAAG,EAAa,oCAAoC,CAAC,EACvE,GAAI,GAAK,GAAS,EAAI,CAAC,EACnB,EAAW,IAAM,EAAG,SAAW,EAAI,EAAG,IAAI,EAAE,GAChD,GAAI,CAAC,GAAkB,EAAI,EAAU,EAAG,EAAK,CAAC,GAAK,GAAkB,EAAK,IAAI,EAAG,QAAS,EAAE,EAAG,IAAI,GAAI,EAAG,EAAK,CAAC,EAAG,CAC/G,EAAI,EAAI,EAAW,GAAM,KAC7B,CACA,EAAI,KACJ,KACJ,KACK,QAAS,QAAS,QAAS,QAAS,QACpC,QAAS,QAAS,QAAS,QAAS,IAAI,CACzC,EAAI,GAAc,EAAI,EAAG,EAAG,EAAE,EAAI,EAAE,EAChC,IAAM,MACN,IAAK,EAAG,EAAW,IAEvB,KACJ,SACS,EAAc,GAE3B,KACJ,SACS,CACL,EAAc,GACd,GAAI,GAAK,GAAS,EAAI,CAAC,EAEvB,GAAK,GAAY,EAAI,EAAG,EAAG,CAAE,EASzB,OAAQ,EAAG,EAAE,QACJ,IAA4B,CAC7B,GAAI,GACJ,AAAK,GAAM,GAAM,EAAI,EAAI,EAAG,EAAK,CAAC,KAAO,KACrC,EAAI,EAEJ,GAAI,EAAK,EAAG,EAAW,IAE3B,KACJ,KACK,IACD,QAEC,IACD,EAAI,GAAW,EAAI,EAAG,EAAG,CAAE,EAC3B,UACC,IACD,EAAI,GAAW,EAAI,EAAG,EAAG,CAAE,EAC3B,cAEA,IAAK,EAAI,EAAI,EAAW,WA5B5B,EAAG,EAAE,KAAQ,IACb,EAAG,EAAE,KAAQ,IACb,EAAG,EAAE,KAAQ,GACf,CACE,EAAI,EAAK,EAAG,EAAW,GAAM,KACjC,KACI,GAAI,KAyBZ,KACJ,EAIZ,SAAG,aACI,CACX,EAEM,GAAkB,SAAS,EAAI,EAAG,EAAG,EAAG,CAC1C,GAAI,GAAK,EAAG,MACR,AAAI,IAAM,EACN,GAAgB,EAAG,EAAG,EAAG,IAAI,SAAS,EAAG,CAAC,EAAG,EAAI,CAAC,EAElD,GAAW,EAAG,EAAG,EAAa,4BAA4B,EAAG,EAAI,CAAC,MACnE,CACH,GAAI,GAAI,EAAG,QAAQ,GAAG,IACtB,AAAI,IAAM,IAAgB,GAAW,EAAG,EAAG,EAAa,oBAAoB,CAAC,EAC7E,AAAI,IAAM,GACN,GAAgB,EAAG,EAAG,EAAG,QAAQ,GAAG,KAAO,EAAG,SAAW,CAAC,EAE1D,GAAgB,EAAG,EAAG,EAAG,IAAI,SAAS,EAAG,QAAQ,GAAG,IAAI,EAAG,CAAC,CACpE,CACJ,EAEM,GAAgB,SAAS,EAAI,EAAG,EAAG,CACrC,GAAI,GAAU,EAAG,QAAU,GAAK,EAAG,IAAI,SAAS,CAAC,EAAI,EAAI,EAAG,MAC5D,GAAgB,EAAG,EAAG,EAAS,mBAAmB,EAClD,OAAS,GAAI,EAAG,EAAI,EAAS,IACzB,GAAgB,EAAI,EAAG,EAAG,CAAC,EAC/B,MAAO,EACX,EAEM,GAAa,SAAS,EAAG,EAAG,CAC9B,OAAS,GAAE,EAAG,EAAE,EAAG,IACf,GAAI,GAAkB,GAAU,EAAE,EAAE,IAAM,GACtC,MAAO,GAEf,MAAO,EACX,EAEM,GAAY,SAAS,EAAI,EAAG,EAAG,EAAI,EAAG,EAAI,CAC5C,EAAG,EAAI,EACP,EAAG,WAAa,GAChB,EAAG,IAAM,EACT,EAAG,SAAW,EACd,EAAG,QAAU,EACb,EAAG,EAAI,EACP,EAAG,MAAQ,CACf,EAEM,GAAc,SAAS,EAAI,CAC7B,EAAG,MAAQ,EACX,GAAO,WAAW,EAAG,aAAe,EAAS,CACjD,EAEM,GAAgB,SAAS,EAAK,EAAQ,EAAY,CACpD,GAAI,GAAI,IAAe,EACnB,EAAK,EAAO,OAEhB,GAAI,IAAO,EACP,MAAO,GAEX,KAAQ,GAAI,EAAI,QAAQ,EAAO,GAAI,CAAC,KAAO,GAAI,IAC3C,GAAI,GAAa,EAAI,SAAS,EAAG,EAAE,CAAE,EAAG,CAAM,EAC1C,MAAO,GAGf,MAAO,EACX,EAEM,GAAe,SAAS,EAAG,EAAM,CACnC,GAAI,GAAI,GAAiB,EAAG,CAAC,EACzB,EAAI,GAAiB,EAAG,CAAC,EACzB,EAAK,EAAE,OACP,EAAK,EAAE,OACP,EAAO,GAAS,GAAgB,EAAG,EAAG,CAAC,EAAG,CAAE,EAChD,GAAI,EAAO,EAAG,EAAO,UACZ,EAAO,EAAK,EACjB,UAAY,CAAC,EACN,EAGX,GAAI,GAAS,IAAc,EAAG,CAAC,GAAK,GAAW,EAAG,CAAE,GAAI,CAEpD,GAAI,GAAI,GAAc,EAAE,SAAS,EAAO,CAAC,EAAG,EAAG,CAAC,EAChD,GAAI,EAAI,GACJ,UAAgB,EAAG,EAAO,CAAC,EAC3B,GAAgB,EAAG,EAAO,EAAI,EAAK,CAAC,EAC7B,CAEf,KAAO,CACH,GAAI,GAAK,GAAI,IAAW,CAAC,EACrB,EAAK,EAAO,EACZ,EAAS,EAAE,KAAO,GACtB,AAAI,GACA,GAAI,EAAE,SAAS,CAAC,EAAG,KAEvB,GAAU,EAAI,EAAG,EAAG,EAAI,EAAG,CAAE,EAC7B,EAAG,CACC,GAAI,GAEJ,GADA,GAAY,CAAE,EACT,GAAM,GAAM,EAAI,EAAI,CAAC,KAAO,KAC7B,MAAI,GACA,IAAgB,EAAG,EAAK,CAAC,EACzB,GAAgB,EAAG,CAAG,EACf,GAAc,EAAI,KAAM,CAAC,EAAI,GAE7B,GAAc,EAAI,EAAI,CAAG,CAE5C,OAAS,IAAO,EAAG,SAAW,CAAC,EACnC,CACA,UAAY,CAAC,EACN,CACX,EAEM,GAAW,SAAS,EAAG,CACzB,MAAO,IAAa,EAAG,CAAC,CAC5B,EAEM,GAAY,SAAS,EAAG,CAC1B,MAAO,IAAa,EAAG,CAAC,CAC5B,EAGM,GAAN,KAAkB,CACd,aAAc,CACV,KAAK,IAAM,IACX,KAAK,EAAI,IACT,KAAK,UAAY,IACjB,KAAK,GAAK,GAAI,GAClB,CACJ,EAEM,GAAa,SAAS,EAAG,CAC3B,GAAI,GAAK,GAAe,EAAG,GAAiB,CAAC,CAAC,EAC9C,EAAG,GAAG,EAAI,EACV,OAAS,GAAM,EAAG,IAAK,GAAO,EAAG,GAAG,QAAS,IAAO,CAChD,GAAY,EAAG,EAAE,EACjB,GAAI,GACJ,GAAK,GAAI,GAAM,EAAG,GAAI,EAAK,EAAG,CAAC,KAAO,MAAQ,IAAM,EAAG,UACnD,SAAG,IAAM,EAAG,UAAY,EACjB,GAAc,EAAG,GAAI,EAAK,CAAC,CAE1C,CACA,MAAO,EACX,EAEM,GAAa,SAAS,EAAG,CAC3B,GAAI,GAAI,GAAiB,EAAG,CAAC,EACzB,EAAI,GAAiB,EAAG,CAAC,EACzB,EAAK,EAAE,OACP,EAAK,EAAE,OACX,GAAW,EAAG,CAAC,EACf,GAAI,GAAK,GAAI,IACb,UAAsB,EAAG,CAAE,EAC3B,GAAU,EAAG,GAAI,EAAG,EAAG,EAAI,EAAG,CAAE,EAChC,EAAG,IAAM,EACT,EAAG,EAAI,EACP,EAAG,UAAY,KACf,GAAiB,EAAG,GAAY,CAAC,EAC1B,CACX,EAEM,GAAQ,SAAS,EAAI,EAAG,EAAG,EAAG,CAChC,GAAI,GAAI,EAAG,EACP,EAAO,GAAa,EAAG,CAAC,EACxB,EAAI,EAAK,OACb,OAAS,GAAI,EAAG,EAAI,EAAG,IACnB,AAAI,EAAK,KAAO,GACZ,GAAa,EAAG,EAAK,EAAE,EAEvB,KACA,AAAK,GAAQ,EAAK,EAAE,EAIb,AAAI,EAAK,KAAO,GACnB,GAAgB,EAAG,EAAG,IAAI,SAAS,EAAG,CAAC,EAAG,EAAI,CAAC,EAE/C,IAAgB,EAAI,EAAK,GAAK,GAA4B,EAAG,CAAC,EAC9D,GAAe,EAAG,EAAE,EACpB,GAAW,EAAG,EAAE,EAChB,GAAc,CAAC,GATX,GAAK,KAAO,IACZ,GAAW,EAAG,EAAa,2CAA2C,EAAG,EAAK,EAClF,GAAa,EAAG,EAAK,EAAE,GAWvC,EAEM,GAAY,SAAS,EAAI,EAAG,EAAG,EAAG,EAAI,CACxC,GAAI,GAAI,EAAG,EACX,OAAQ,OACC,IAAe,CAChB,GAAc,EAAG,CAAC,EAClB,GAAI,GAAI,GAAc,EAAI,EAAG,CAAC,EAC9B,GAAS,EAAG,EAAG,CAAC,EAChB,KACJ,KACK,IAAY,CACb,GAAgB,EAAI,EAAG,EAAG,CAAC,EAC3B,GAAa,EAAG,CAAC,EACjB,KACJ,SACS,CACL,GAAM,EAAI,EAAG,EAAG,CAAC,EACjB,MACJ,EAEJ,AAAK,GAAc,EAAG,EAAE,EAGZ,GAAa,EAAG,EAAE,GAC1B,GAAW,EAAG,EAAa,kCAAkC,EAAG,GAAc,EAAG,EAAE,CAAC,EAHpF,IAAQ,EAAG,CAAC,EACZ,GAAgB,EAAG,EAAG,IAAI,SAAS,EAAG,CAAC,EAAG,EAAI,CAAC,GAGnD,GAAc,CAAC,CACnB,EAEM,GAAW,SAAS,EAAG,CACzB,GAAI,GAAM,GAAiB,EAAG,CAAC,EAC3B,EAAO,EAAI,OACX,EAAI,GAAiB,EAAG,CAAC,EACzB,EAAK,EAAE,OACP,EAAY,KACZ,EAAK,GAAS,EAAG,CAAC,EAClB,EAAQ,GAAgB,EAAG,EAAG,EAAO,CAAC,EACtC,EAAS,EAAE,KAAO,GAClB,EAAI,EACJ,EAAK,GAAI,IAAW,CAAC,EACrB,EAAI,GAAI,IASZ,IARA,GAAc,EAAG,IAAO,IAAe,IAAO,IAAe,IAAO,IAAiB,IAAO,GAAY,EACpG,gCAAgC,EACpC,GAAc,EAAG,CAAC,EACd,GACA,GAAI,EAAE,SAAS,CAAC,EAAG,KAEvB,GAAU,EAAI,EAAG,EAAK,EAAM,EAAG,CAAE,EACjC,EAAM,EAAG,EAAI,EACN,EAAI,GAAO,CACd,GAAI,GAEJ,GADA,GAAY,CAAE,EACT,GAAI,GAAM,EAAI,EAAK,CAAC,KAAO,MAAQ,IAAM,EAC1C,IACA,GAAU,EAAI,EAAG,EAAK,EAAG,CAAE,EAC3B,EAAM,EAAY,UACX,EAAM,EAAG,QAChB,GAAa,EAAG,EAAG,IAAI,IAAM,MAC5B,OACL,GAAI,EAAQ,KAChB,CACA,UAAgB,EAAG,EAAG,IAAI,SAAS,EAAK,EAAG,OAAO,EAAG,EAAG,QAAU,CAAG,EACrE,GAAgB,CAAC,EACjB,GAAgB,EAAG,CAAC,EACb,CACX,EAEM,GAAS,CACX,KAAY,GACZ,KAAY,GACZ,KAAY,GACZ,KAAY,GACZ,OAAY,GACZ,OAAY,GACZ,KAAY,GACZ,IAAY,GACZ,MAAY,GACZ,MAAY,GACZ,KAAY,GACZ,SAAY,GACZ,IAAY,GACZ,QAAY,GACZ,IAAY,GACZ,OAAY,GACZ,MAAY,EAChB,EAEM,GAAkB,SAAS,EAAG,CAChC,GAAgB,EAAG,EAAG,CAAC,EACvB,GAAgB,EAAG,EAAE,EACrB,GAAc,EAAG,EAAE,EACnB,GAAiB,EAAG,EAAE,EACtB,GAAQ,EAAG,CAAC,EACZ,GAAc,EAAG,EAAE,EACnB,GAAa,EAAG,GAAI,EAAa,UAAW,EAAI,CAAC,EACjD,GAAQ,EAAG,CAAC,CAChB,EAEM,GAAiB,SAAS,EAAG,CAC/B,UAAY,EAAG,EAAM,EACrB,GAAgB,CAAC,EACV,CACX,EAEA,GAAO,QAAQ,eAAiB,KC17ChC,mBAEA,GAAM,CACF,cACA,qBACA,mBACA,mBACA,eACA,kBACA,iBACA,gBACA,kBACA,KACE,CACF,eACA,iBACA,iBACA,iBACA,qBACA,mBACA,oBACA,cACA,eACA,mBACA,oBACA,KACE,CACF,gBACA,iBACA,KAEE,GAAa,QAEb,GAAS,SAAS,EAAG,CAEvB,MAAO,AADC,GAAI,OACC,GACjB,EAGM,GAAa,SAAS,EAAK,EAAK,CAClC,MAAI,IAAO,EAAU,EACZ,EAAI,EAAM,EAAY,EACnB,EAAM,EAAM,CAC5B,EAKM,GAAS,CAAC,IAAM,IAAM,KAAO,KAAM,EACnC,GAAc,SAAS,EAAG,EAAK,CACjC,GAAI,GAAI,EAAE,GACN,EAAM,EACV,GAAI,EAAI,IACJ,EAAM,MACL,CACD,GAAI,GAAQ,EACZ,KAAO,EAAI,IAAM,CACb,GAAI,GAAK,EAAE,EAAO,GAAE,GACpB,GAAK,GAAK,OAAU,IAChB,MAAO,MACX,EAAO,GAAO,EAAM,EAAK,GACzB,IAAM,CACV,CAEA,GADA,GAAS,GAAI,MAAU,EAAQ,EAC3B,EAAQ,GAAK,EAAM,IAAc,GAAO,GAAO,GAC/C,MAAO,MACX,GAAO,CACX,CAEA,MAAO,CACH,KAAM,EACN,IAAK,EAAM,CACf,CACJ,EAOM,GAAS,SAAS,EAAG,CACvB,GAAI,GAAI,EACJ,EAAI,GAAiB,EAAG,CAAC,EACzB,EAAM,EAAE,OACR,EAAO,GAAW,GAAgB,EAAG,EAAG,CAAC,EAAG,CAAG,EAC/C,EAAO,GAAW,GAAgB,EAAG,EAAG,EAAE,EAAG,CAAG,EAKpD,IAHA,GAAc,EAAG,GAAK,GAAQ,EAAE,GAAQ,EAAK,EAAG,gCAAgC,EAChF,GAAc,EAAG,EAAE,EAAO,EAAK,EAAG,8BAA8B,EAEzD,GAAQ,GAAM,CACjB,GAAI,GAAM,GAAY,EAAG,CAAI,EAC7B,GAAI,IAAQ,KACR,UAAY,CAAC,EACb,GAAgB,EAAG,EAAO,CAAC,EACpB,EAEX,EAAO,EAAI,IACX,GACJ,CACA,UAAgB,EAAG,CAAC,EACb,CACX,EAEM,GAAM,GAAa,IAAI,EACvB,GAAc,SAAS,EAAG,EAAK,CACjC,GAAI,GAAO,GAAkB,EAAG,CAAG,EACnC,GAAc,EAAG,GAAK,GAAQ,GAAQ,GAAY,EAAK,oBAAoB,EAC3E,GAAgB,EAAG,GAAK,CAAI,CAChC,EAKM,GAAU,SAAS,EAAG,CACxB,GAAI,GAAI,GAAW,CAAC,EACpB,GAAI,IAAM,EACN,GAAY,EAAG,CAAC,MACf,CACD,GAAI,GAAI,GAAI,IACZ,GAAc,EAAG,CAAC,EAClB,OAAS,GAAI,EAAG,GAAK,EAAG,IACpB,GAAY,EAAG,CAAC,EAChB,GAAc,CAAC,EAEnB,GAAgB,CAAC,CACrB,CACA,MAAO,EACX,EAMM,GAAa,SAAS,EAAG,CAC3B,GAAI,GAAI,GAAiB,EAAG,CAAC,EACzB,EAAI,GAAkB,EAAG,CAAC,EAC1B,EAAO,GAAK,EAAI,EAAI,EAAE,OAAS,EAKnC,GAJA,EAAO,GAAW,GAAgB,EAAG,EAAG,CAAI,EAAG,EAAE,MAAM,EAEvD,GAAc,EAAG,GAAK,GAAQ,EAAE,GAAQ,EAAE,OAAQ,EAAG,uBAAuB,EAExE,IAAM,EAEN,KAAO,EAAO,GAAK,GAAO,EAAE,EAAK,GAAG,YAEhC,GAAO,EAAE,EAAK,GACd,GAAW,EAAG,yCAAyC,EAEvD,EAAI,EACJ,KAAO,EAAI,GAAK,EAAO,GAAG,CACtB,EACI,WACK,EAAO,GAAK,GAAO,EAAE,EAAK,GACnC,GACJ,KAGA,KADA,IACO,EAAI,GAAK,EAAO,EAAE,QAAQ,CAC7B,EACI,WACK,GAAO,EAAE,EAAK,GACvB,GACJ,CAIR,MAAI,KAAM,EACN,GAAgB,EAAG,EAAO,CAAC,EAE3B,GAAY,CAAC,EAEV,CACX,EAMM,GAAY,SAAS,EAAG,CAC1B,GAAI,GAAI,GAAiB,EAAG,CAAC,EACzB,EAAO,GAAW,GAAgB,EAAG,EAAG,CAAC,EAAG,EAAE,MAAM,EACpD,EAAO,GAAW,GAAgB,EAAG,EAAG,CAAI,EAAG,EAAE,MAAM,EAK3D,GAHA,GAAc,EAAG,GAAQ,EAAG,EAAG,cAAc,EAC7C,GAAc,EAAG,GAAQ,EAAE,OAAQ,EAAG,cAAc,EAEhD,EAAO,EAAM,MAAO,GACxB,GAAI,EAAO,GAAQ,OAAO,iBACtB,MAAO,IAAW,EAAG,uBAAuB,EAChD,GAAI,GAAK,EAAO,EAAQ,EAGxB,IAFA,GAAgB,EAAG,EAAG,uBAAuB,EAC7C,EAAI,EACC,GAAQ,EAAG,EAAO,GAAO,CAC1B,GAAI,GAAM,GAAY,EAAG,CAAI,EAC7B,GAAI,IAAQ,KACR,MAAO,IAAW,EAAG,oBAAoB,EAC7C,GAAgB,EAAG,EAAI,IAAI,EAC3B,EAAO,EAAI,IACX,GACJ,CACA,MAAO,EACX,EAEM,GAAW,SAAS,EAAG,CACzB,GAAI,GAAI,GAAiB,EAAG,CAAC,EACzB,EAAM,EAAE,OACR,EAAI,GAAc,EAAG,CAAC,EAAI,EAE9B,GAAI,EAAI,EACJ,EAAI,UACC,EAAI,EAET,IADA,IACO,GAAO,EAAE,EAAE,GAAG,IAGzB,GAAI,GAAK,EACL,MAAO,GACN,CACD,GAAI,GAAM,GAAY,EAAG,CAAC,EAC1B,MAAI,KAAQ,MAAQ,GAAO,EAAE,EAAI,IAAI,EAC1B,GAAW,EAAG,GAAa,oBAAoB,CAAC,EAC3D,IAAgB,EAAG,EAAI,CAAC,EACxB,GAAgB,EAAG,EAAI,IAAI,EACpB,EACX,CACJ,EAEM,GAAa,SAAS,EAAG,CAC3B,UAAiB,EAAG,CAAC,EACrB,GAAkB,EAAG,EAAQ,EAC7B,GAAc,EAAG,CAAC,EAClB,GAAgB,EAAG,CAAC,EACb,CACX,EAEM,GAAQ,CACV,KAAa,GACb,UAAa,GACb,MAAa,GACb,IAAa,GACb,OAAa,EACjB,EAGM,GAAW,GAAa,GAAI,EAAG,GAAI,IAAK,IAAK,GAAI,IAAK,GAAI,GAAI,IAAK,GAAI,IAAK,GAAI,EAAE,EAElF,GAAe,SAAS,EAAG,CAC7B,UAAY,EAAG,EAAK,EACpB,GAAe,EAAG,EAAQ,EAC1B,GAAa,EAAG,GAAI,GAAa,cAAe,EAAI,CAAC,EAC9C,CACX,EAEA,GAAO,QAAQ,aAAe,KC9P9B,mBAEA,GAAM,CACF,YACA,eACA,eACA,cACA,iBACA,mBACA,mBACA,mBACA,mBACA,eACA,kBACA,iBACA,gBACA,cACA,iBACA,kBACA,aACA,KACE,CACF,iBACA,iBACA,iBACA,qBACA,oBACA,cACA,eACA,mBACA,KACE,CACF,kBACA,kBACA,wBACA,KACE,CAAE,iBAAiB,KAErB,GAEE,GAAS,UAAW,CACtB,UAAc,WAAa,GAAa,MAAS,WAC1C,EACX,EACM,GAAU,SAAS,EAAG,CACxB,GAAa,EAAE,EACX,KAAe,GACf,IAAa,EACrB,EAEM,GAAc,SAAS,EAAG,CAC5B,GAAI,GAAK,EAEL,EAAK,KAAe,OAAQ,KAAK,OAAO,EAAG,GAAO,EAAI,WAC1D,OAAQ,GAAW,CAAC,OACX,GACD,UAAe,EAAG,CAAC,EACZ,MACN,GAAG,CACJ,EAAM,EACN,EAAK,GAAkB,EAAG,CAAC,EAC3B,KACJ,KACK,GAAG,CACJ,EAAM,GAAkB,EAAG,CAAC,EAC5B,EAAK,GAAkB,EAAG,CAAC,EAC3B,KACJ,SACS,MAAO,IAAW,EAAG,2BAA2B,EAI7D,UAAc,EAAG,GAAO,EAAI,EAAG,mBAAmB,EAClD,GAAc,EAAG,GAAO,GAAK,GAAM,GAAiB,EAAK,EACrD,oBAAoB,EAExB,GAAM,EAAK,EAAO,EAClB,GAAgB,EAAG,KAAK,MAAM,CAAC,EAAI,CAAG,EAC/B,CACX,EAEM,GAAkB,SAAS,EAAG,CAChC,UAAQ,GAAiB,EAAG,CAAC,CAAC,EAC9B,GAAO,EACA,CACX,EAEM,GAAW,SAAS,EAAG,CACzB,GAAI,GAAc,EAAG,CAAC,EAAG,CACrB,GAAI,GAAI,GAAc,EAAG,CAAC,EAC1B,AAAI,EAAI,GAAG,GAAK,CAAC,EAAG,GACpB,GAAgB,EAAG,CAAC,CACxB,KAEI,IAAe,EAAG,KAAK,IAAI,GAAiB,EAAG,CAAC,CAAC,CAAC,EACtD,MAAO,EACX,EAEM,GAAW,SAAS,EAAG,CACzB,UAAe,EAAG,KAAK,IAAI,GAAiB,EAAG,CAAC,CAAC,CAAC,EAC3C,CACX,EAEM,GAAW,SAAS,EAAG,CACzB,UAAe,EAAG,KAAK,IAAI,GAAiB,EAAG,CAAC,CAAC,CAAC,EAC3C,CACX,EAEM,GAAW,SAAS,EAAG,CACzB,UAAe,EAAG,KAAK,IAAI,GAAiB,EAAG,CAAC,CAAC,CAAC,EAC3C,CACX,EAEM,GAAY,SAAS,EAAG,CAC1B,UAAe,EAAG,KAAK,KAAK,GAAiB,EAAG,CAAC,CAAC,CAAC,EAC5C,CACX,EAEM,GAAY,SAAS,EAAG,CAC1B,UAAe,EAAG,KAAK,KAAK,GAAiB,EAAG,CAAC,CAAC,CAAC,EAC5C,CACX,EAEM,GAAY,SAAS,EAAG,CAC1B,GAAI,GAAI,GAAiB,EAAG,CAAC,EACzB,EAAI,GAAe,EAAG,EAAG,CAAC,EAC9B,UAAe,EAAG,KAAK,MAAM,EAAG,CAAC,CAAC,EAC3B,CACX,EAEM,GAAa,SAAS,EAAG,CAC3B,GAAI,GAAI,GAAe,EAAG,CAAC,EAC3B,MAAI,KAAM,GACN,GAAgB,EAAG,CAAC,EAEpB,IAAc,EAAG,CAAC,EAClB,GAAY,CAAC,GAEV,CACX,EAEM,GAAa,SAAS,EAAG,EAAG,CAC9B,GAAI,GAAI,GAAoB,CAAC,EAC7B,AAAI,IAAM,GACN,GAAgB,EAAG,CAAC,EAEpB,GAAe,EAAG,CAAC,CAC3B,EAEM,GAAa,SAAS,EAAG,CAC3B,MAAI,IAAc,EAAG,CAAC,EAClB,GAAW,EAAG,CAAC,EAEf,GAAW,EAAG,KAAK,MAAM,GAAiB,EAAG,CAAC,CAAC,CAAC,EAE7C,CACX,EAEM,GAAY,SAAS,EAAG,CAC1B,MAAI,IAAc,EAAG,CAAC,EAClB,GAAW,EAAG,CAAC,EAEf,GAAW,EAAG,KAAK,KAAK,GAAiB,EAAG,CAAC,CAAC,CAAC,EAE5C,CACX,EAEM,GAAY,SAAS,EAAG,CAC1B,UAAe,EAAG,KAAK,KAAK,GAAiB,EAAG,CAAC,CAAC,CAAC,EAC5C,CACX,EAEM,GAAW,SAAS,EAAG,CACzB,GAAI,GAAI,GAAkB,EAAG,CAAC,EAC1B,EAAI,GAAkB,EAAG,CAAC,EAC9B,UAAgB,EAAI,GAAK,EAAI,EAAE,GAAK,EAAE,EAAI,EAAE,GAAK,EAAE,CAAE,EAC9C,CACX,EAEM,GAAW,SAAS,EAAG,CACzB,GAAI,GAAI,GAAiB,EAAG,CAAC,EACzB,EACJ,GAAI,GAAgB,EAAG,CAAC,EACpB,EAAM,KAAK,IAAI,CAAC,MACf,CACD,GAAI,GAAO,GAAiB,EAAG,CAAC,EAChC,AAAI,IAAS,EACT,EAAM,KAAK,KAAK,CAAC,EAChB,AAAI,IAAS,GACd,EAAM,KAAK,MAAM,CAAC,EAElB,EAAM,KAAK,IAAI,CAAC,EAAE,KAAK,IAAI,CAAI,CACvC,CACA,UAAe,EAAG,CAAG,EACd,CACX,EAEM,GAAW,SAAS,EAAG,CACzB,UAAe,EAAG,KAAK,IAAI,GAAiB,EAAG,CAAC,CAAC,CAAC,EAC3C,CACX,EAEM,GAAW,SAAS,EAAG,CACzB,UAAe,EAAG,GAAiB,EAAG,CAAC,EAAK,KAAM,KAAK,GAAG,EACnD,CACX,EAEM,GAAW,SAAS,EAAG,CACzB,UAAe,EAAG,GAAiB,EAAG,CAAC,EAAK,MAAK,GAAK,IAAI,EACnD,CACX,EAEM,GAAW,SAAS,EAAG,CACzB,GAAI,GAAI,GAAW,CAAC,EAChB,EAAO,EACX,GAAc,EAAG,GAAK,EAAG,EAAG,gBAAgB,EAC5C,OAAS,GAAI,EAAG,GAAK,EAAG,IACpB,AAAI,GAAY,EAAG,EAAG,EAAM,EAAQ,GAChC,GAAO,GAEf,UAAc,EAAG,CAAI,EACd,CACX,EAEM,GAAW,SAAS,EAAG,CACzB,GAAI,GAAI,GAAW,CAAC,EAChB,EAAO,EACX,GAAc,EAAG,GAAK,EAAG,EAAG,gBAAgB,EAC5C,OAAS,GAAI,EAAG,GAAK,EAAG,IACpB,AAAI,GAAY,EAAG,EAAM,EAAG,EAAQ,GAChC,GAAO,GAEf,UAAc,EAAG,CAAI,EACd,CACX,EAEM,GAAY,SAAS,EAAG,CAC1B,MAAI,IAAS,EAAG,CAAC,IAAM,GACnB,AAAI,GAAc,EAAG,CAAC,EAClB,GAAgB,EAAG,SAAS,EAE5B,GAAgB,EAAG,OAAO,EAE9B,IAAc,EAAG,CAAC,EAClB,GAAY,CAAC,GAEV,CACX,EAEM,GAAY,SAAS,EAAG,CAC1B,GAAI,GAAc,EAAG,CAAC,GAAK,GAAc,EAAG,CAAC,EAAG,CAC5C,GAAI,GAAI,GAAc,EAAG,CAAC,EAE1B,AAAI,IAAM,EACN,GAAc,EAAG,EAAG,MAAM,EAE1B,GAAgB,EAAI,GAAc,EAAG,CAAC,EAAI,EAAG,CAAC,CACtD,KAAO,CACH,GAAI,GAAI,GAAiB,EAAG,CAAC,EACzB,EAAI,GAAiB,EAAG,CAAC,EAC7B,GAAe,EAAG,EAAE,CAAC,CACzB,CACA,MAAO,EACX,EAEM,GAAY,SAAS,EAAG,CAC1B,GAAI,GAAc,EAAG,CAAC,EAClB,GAAW,EAAG,CAAC,EACf,GAAe,EAAG,CAAC,MAChB,CACH,GAAI,GAAI,GAAiB,EAAG,CAAC,EACzB,EAAK,EAAI,EAAI,KAAK,KAAK,CAAC,EAAI,KAAK,MAAM,CAAC,EAC5C,GAAW,EAAG,CAAE,EAChB,GAAe,EAAG,IAAM,EAAK,EAAI,EAAI,CAAE,CAC3C,CACA,MAAO,EACX,EAEM,GAAU,CACZ,IAAc,GACd,KAAc,GACd,KAAc,GACd,KAAc,GACd,KAAc,GACd,IAAc,GACd,IAAc,GACd,IAAc,GACd,MAAc,GACd,KAAc,GACd,IAAc,GACd,IAAc,GACd,IAAc,GACd,KAAc,GACd,IAAc,GACd,OAAc,GACd,WAAc,GACd,IAAc,GACd,KAAc,GACd,IAAc,GACd,UAAc,GACd,KAAc,GACd,IAAc,EAClB,EAEM,GAAe,SAAS,EAAG,CAC7B,UAAY,EAAG,EAAO,EACtB,GAAe,EAAG,KAAK,EAAE,EACzB,GAAa,EAAG,GAAI,GAAa,KAAM,EAAI,CAAC,EAC5C,GAAe,EAAG,GAAQ,EAC1B,GAAa,EAAG,GAAI,GAAa,OAAQ,EAAI,CAAC,EAC9C,GAAgB,EAAG,EAAc,EACjC,GAAa,EAAG,GAAI,GAAa,aAAc,EAAI,CAAC,EACpD,GAAgB,EAAG,EAAc,EACjC,GAAa,EAAG,GAAI,GAAa,aAAc,EAAI,CAAC,EAC7C,CACX,EAEA,GAAO,QAAQ,aAAe,KC7T9B,mBAEA,GAAM,CACF,gBACA,iBACA,gBACA,eACA,qBACA,iBACA,YACA,cACA,iBACA,aACA,YACA,kBACA,eACA,oBACA,mBACA,eACA,gBACA,oBACA,gBACA,kBACA,oBACA,cACA,mBACA,kBACA,mBACA,gBACA,gBACA,aACA,WACA,mBACA,mBACA,mBACA,yBACA,mBACA,eACA,kBACA,iBACA,eACA,eACA,cACA,gBACA,eACA,gBACA,oBACA,cACA,kBACA,oBACA,kBACA,eACA,gBACA,gBACA,kBACA,YACA,iBACA,mBACA,cACA,KACE,CACF,iBACA,iBACA,iBACA,qBACA,oBACA,kBACA,cACA,mBACA,eACA,mBACA,kBACA,kBACA,yBACA,KACE,GAAS,KACT,CACF,qBACA,iBACA,KAOE,GAAa,SAAS,EAAG,EAAI,EAAG,CAClC,AAAI,IAAM,GAAM,CAAC,GAAe,EAAI,CAAC,GACjC,GAAW,EAAG,GAAa,iBAAkB,EAAI,CAAC,CAC1D,EAEM,GAAiB,SAAS,EAAG,CAC/B,UAAc,EAAG,EAAiB,EAC3B,CACX,EAEM,GAAkB,SAAS,EAAG,CAChC,UAAc,EAAG,CAAC,EACb,GAAiB,EAAG,CAAC,GACtB,GAAY,CAAC,EAEV,CACX,EAEM,GAAkB,SAAS,EAAG,CAChC,GAAM,GAAI,GAAS,EAAG,CAAC,EACvB,UAAc,EAAG,GAAK,IAAY,GAAK,GAAY,EAAG,uBAAuB,EAC7E,GAAW,EAAG,CAAC,EACf,GAAiB,EAAG,CAAC,EACd,CACX,EAEM,GAAkB,SAAS,EAAG,CAChC,MAAI,IAAS,EAAG,CAAC,IAAM,GACnB,GAAY,CAAC,EAEb,GAAiB,EAAG,CAAC,EAClB,CACX,EAGM,GAAkB,SAAS,EAAG,CAChC,UAAe,EAAG,EAAG,EAAa,EAClC,GAAc,EAAG,CAAC,EAClB,GAAW,EAAG,CAAC,EACf,GAAiB,EAAG,CAAC,EACd,CACX,EAQM,GAAY,SAAS,EAAG,CAC1B,MAAI,IAAa,EAAG,CAAC,EACV,CACH,IAAK,EACL,OAAQ,GAAa,EAAG,CAAC,CAC7B,EAEO,CACH,IAAK,EACL,OAAQ,CACZ,CAER,EAOM,GAAW,SAAS,EAAG,EAAG,EAAG,CAC/B,GAAe,EAAG,CAAC,EACnB,GAAa,EAAG,GAAI,CAAC,CACzB,EAEM,GAAW,SAAS,EAAG,EAAG,EAAG,CAC/B,GAAgB,EAAG,CAAC,EACpB,GAAa,EAAG,GAAI,CAAC,CACzB,EAEM,GAAW,SAAS,EAAG,EAAG,EAAG,CAC/B,GAAgB,EAAG,CAAC,EACpB,GAAa,EAAG,GAAI,CAAC,CACzB,EAUM,GAAmB,SAAS,EAAG,EAAI,EAAO,CAC5C,AAAI,GAAK,EACL,GAAW,EAAG,GAAI,CAAC,EAEnB,GAAU,EAAI,EAAG,CAAC,EACtB,GAAa,EAAG,GAAI,CAAK,CAC7B,EAQM,GAAa,SAAS,EAAG,CAC3B,GAAI,GAAK,GAAI,IACT,EAAS,GAAU,CAAC,EACpB,EAAM,EAAO,IACb,EAAK,EAAO,OACZ,EAAU,GAAe,EAAG,EAAM,EAAG,QAAQ,EAEjD,GADA,GAAW,EAAG,EAAI,CAAC,EACf,GAAe,EAAG,EAAM,CAAC,EACzB,EAAU,GAAgB,EAAG,GAAa,KAAK,EAAG,CAAO,EACzD,GAAc,EAAG,EAAM,CAAC,EACxB,GAAU,EAAG,EAAI,CAAC,UAEd,CAAC,GAAa,EAAI,GAAkB,EAAG,EAAM,CAAC,EAAG,CAAE,EACnD,UAAY,CAAC,EACN,EAIf,MAAK,IAAY,EAAI,EAAS,CAAE,GAC5B,GAAc,EAAG,EAAM,EAAG,gBAAgB,EAC9C,GAAa,CAAC,EACV,GAAkB,EAAS,EAA0B,EAAI,IACzD,IAAS,EAAG,GAAa,SAAU,EAAI,EAAG,EAAG,MAAM,EACnD,GAAS,EAAG,GAAa,YAAa,EAAI,EAAG,EAAG,SAAS,EACzD,GAAS,EAAG,GAAa,cAAe,EAAI,EAAG,EAAG,WAAW,EAC7D,GAAS,EAAG,GAAa,kBAAmB,EAAI,EAAG,EAAG,eAAe,EACrE,GAAS,EAAG,GAAa,OAAQ,EAAI,EAAG,EAAG,IAAI,GAE/C,GAAkB,EAAS,GAA2B,EAAI,IAC1D,GAAS,EAAG,GAAa,cAAe,EAAI,EAAG,EAAG,WAAW,EAC7D,GAAkB,EAAS,GAA2B,EAAI,IAC1D,IAAS,EAAG,GAAa,OAAQ,EAAI,EAAG,EAAG,IAAI,EAC/C,GAAS,EAAG,GAAa,UAAW,EAAI,EAAG,EAAG,OAAO,EACrD,GAAS,EAAG,GAAa,WAAY,EAAI,EAAG,EAAG,QAAQ,GAEvD,GAAkB,EAAS,GAA2B,EAAI,IAC1D,IAAS,EAAG,GAAa,OAAQ,EAAI,EAAG,EAAG,IAAI,EAC/C,GAAS,EAAG,GAAa,WAAY,EAAI,EAAG,EAAG,QAAQ,GAEvD,GAAkB,EAAS,GAA2B,EAAI,IAC1D,GAAS,EAAG,GAAa,aAAc,EAAI,EAAG,EAAG,UAAU,EAC3D,GAAkB,EAAS,EAA0B,EAAI,IACzD,GAAiB,EAAG,EAAI,GAAa,cAAe,EAAI,CAAC,EACzD,GAAkB,EAAS,GAA2B,EAAI,IAC1D,GAAiB,EAAG,EAAI,GAAa,OAAQ,EAAI,CAAC,EAC/C,CACX,EAEM,GAAc,SAAS,EAAG,CAC5B,GAAI,GAAS,GAAU,CAAC,EACpB,EAAK,EAAO,OACZ,EAAM,EAAO,IACb,EAAK,GAAI,IACT,EAAO,GAAkB,EAAG,EAAM,CAAC,EACvC,GAAI,GAAe,EAAG,EAAM,CAAC,EACzB,UAAc,EAAG,EAAM,CAAC,EACxB,GAAe,EAAG,GAAa,EAAG,KAAM,CAAI,CAAC,EACtC,EACJ,CACH,GAAI,GAAQ,GAAkB,EAAG,EAAM,CAAC,EACxC,GAAI,CAAC,GAAa,EAAI,EAAO,CAAE,EAC3B,MAAO,IAAc,EAAG,EAAI,EAAG,oBAAoB,EACvD,GAAW,EAAG,EAAI,CAAC,EACnB,GAAI,GAAO,GAAa,EAAI,EAAI,CAAI,EACpC,MAAI,GACA,IAAU,EAAI,EAAG,CAAC,EAClB,GAAe,EAAG,CAAI,EACtB,GAAW,EAAG,GAAI,CAAC,EACZ,GAGP,IAAY,CAAC,EACN,EAEf,CACJ,EAEM,GAAc,SAAS,EAAG,CAC5B,GAAI,GAAS,GAAU,CAAC,EACpB,EAAK,EAAO,OACZ,EAAM,EAAO,IACb,EAAK,GAAI,IACT,EAAQ,GAAkB,EAAG,EAAM,CAAC,EACpC,EAAO,GAAkB,EAAG,EAAM,CAAC,EACvC,GAAI,CAAC,GAAa,EAAI,EAAO,CAAE,EAC3B,MAAO,IAAc,EAAG,EAAM,EAAG,oBAAoB,EACzD,GAAc,EAAG,EAAM,CAAC,EACxB,GAAW,EAAG,EAAM,CAAC,EACrB,GAAW,EAAG,EAAI,CAAC,EACnB,GAAU,EAAG,EAAI,CAAC,EAClB,GAAI,GAAO,GAAa,EAAI,EAAI,CAAI,EACpC,MAAI,KAAS,MACT,GAAQ,EAAI,CAAC,EACjB,GAAe,EAAG,CAAI,EACf,CACX,EAKM,GAAa,SAAS,EAAG,EAAK,CAChC,GAAI,GAAI,GAAkB,EAAG,CAAC,EAC9B,GAAe,EAAG,EAAG,EAAa,EAClC,GAAI,GAAO,EAAM,GAAe,EAAG,EAAG,CAAC,EAAI,GAAe,EAAG,EAAG,CAAC,EACjE,MAAI,KAAS,KAAa,EAC1B,IAAe,EAAG,CAAI,EACtB,GAAW,EAAG,CAAE,GAAI,EAAE,EACf,EAAM,EACjB,EAGM,GAAgB,SAAS,EAAG,CAC9B,MAAO,IAAW,EAAG,CAAC,CAC1B,EAEM,GAAgB,SAAS,EAAG,CAC9B,UAAc,EAAG,CAAC,EACX,GAAW,EAAG,CAAC,CAC1B,EAMM,GAAa,SAAS,EAAG,EAAM,EAAQ,CACzC,GAAI,GAAM,GAAkB,EAAG,CAAM,EACrC,UAAe,EAAG,EAAM,EAAa,EACrC,GAAc,EAAI,GAAe,EAAG,EAAM,CAAG,IAAM,KAAO,EAAQ,uBAAuB,EAClF,CACX,EAEM,GAAe,SAAS,EAAG,CAC7B,GAAI,GAAI,GAAW,EAAG,EAAG,CAAC,EAC1B,UAAsB,EAAG,GAAc,EAAG,EAAG,CAAC,CAAC,EACxC,CACX,EAEM,GAAiB,SAAS,EAAG,CAC/B,GAAI,GAAK,GAAW,EAAG,EAAG,CAAC,EACvB,EAAK,GAAW,EAAG,EAAG,CAAC,EAC3B,UAAc,EAAG,CAAC,GAAgB,EAAG,CAAC,EAAG,EAAG,uBAAuB,EACnE,GAAc,EAAG,CAAC,GAAgB,EAAG,CAAC,EAAG,EAAG,uBAAuB,EACnE,GAAgB,EAAG,EAAG,EAAI,EAAG,CAAE,EACxB,CACX,EAMM,GAAU,GAAa,YAAa,EAAI,EAExC,GAAY,CAAC,OAAQ,SAAU,OAAQ,QAAS,WAAW,EAAE,IAAI,GAAK,GAAa,CAAC,CAAC,EAMrF,GAAQ,SAAS,EAAG,EAAI,CAC1B,GAAY,EAAG,GAAmB,EAAO,EAEzC,GAAI,GAAQ,AADI,GAAe,EAAG,EAAE,EACd,IAAI,CAAC,EAC3B,AAAI,GACA,GAAM,CAAC,EACP,GAAe,EAAG,GAAU,EAAG,MAAM,EACrC,AAAI,EAAG,aAAe,EAClB,GAAgB,EAAG,EAAG,WAAW,EAChC,GAAY,CAAC,EAClB,GAAO,WAAW,GAAY,EAAG,GAAa,IAAI,EAAG,CAAE,CAAC,EACxD,GAAS,EAAG,EAAG,CAAC,EAExB,EAKM,GAAW,SAAS,EAAO,EAAO,CACpC,GAAI,GAAO,EACX,MAAI,IAAkB,EAAO,EAA0B,EAAI,IAAI,IAAQ,IACnE,GAAkB,EAAO,GAA2B,EAAI,IAAI,IAAQ,IACpE,GAAkB,EAAO,GAA2B,EAAI,IAAI,IAAQ,IACpE,EAAQ,GAAG,IAAQ,IAChB,CACX,EAKM,GAAa,SAAS,EAAM,EAAO,CACrC,GAAI,GAAI,EACR,MAAI,GAAO,IAAc,GAAM,KAAO,IAClC,EAAO,IAAa,GAAM,KAAO,KACjC,EAAO,IAAc,GAAM,KAAO,KAC/B,EAAM,SAAS,EAAG,CAAC,CAC9B,EAEM,GAAa,SAAS,EAAG,CAC3B,GAAI,GAAM,EAAO,EACb,EAAS,GAAU,CAAC,EACpB,EAAK,EAAO,OACZ,EAAM,EAAO,IACjB,GAAI,GAAgB,EAAG,EAAI,CAAC,EACxB,GAAW,EAAG,EAAI,CAAC,EACnB,EAAO,KAAM,EAAO,EAAG,EAAQ,MAE9B,CACD,GAAM,GAAQ,GAAiB,EAAG,EAAM,CAAC,EACzC,GAAe,EAAG,EAAI,EAAG,EAAa,EACtC,EAAQ,GAAgB,EAAG,EAAM,EAAG,CAAC,EACrC,EAAO,GAAO,EAAO,GAAS,EAAO,CAAK,CAC9C,CAEA,GAAI,GACJ,AAAI,GAAY,EAAG,GAAmB,EAAO,IAAM,GAC/C,GAAY,GAAI,SAChB,GAAsB,EAAG,CAAS,EAClC,GAAY,EAAG,GAAmB,EAAO,GAEzC,EAAY,GAAe,EAAG,EAAE,EAEpC,GAAI,GAAQ,GAAY,EAAG,EAAM,CAAC,EAClC,SAAU,IAAI,EAAI,CAAK,EACvB,GAAY,EAAI,EAAM,EAAM,CAAK,EAC1B,CACX,EAEM,GAAa,SAAS,EAAG,CAE3B,GAAI,GAAK,AADI,GAAU,CAAC,EACR,OACZ,EAAO,GAAI,YAAW,CAAC,EACvB,EAAO,GAAgB,CAAE,EACzB,EAAO,GAAY,CAAE,EACzB,MAAI,KAAS,KACT,GAAY,CAAC,EACZ,AAAI,IAAS,GACd,GAAgB,EAAG,eAAe,EAElC,IAAY,EAAG,GAAmB,EAAO,EAGzC,AADY,AADI,GAAe,EAAG,EAAE,EACd,IAAI,CAAE,EACtB,CAAC,GAEX,GAAe,EAAG,GAAW,EAAM,CAAI,CAAC,EACxC,GAAgB,EAAG,GAAiB,CAAE,CAAC,EAChC,CACX,EAEM,GAAe,SAAS,EAAG,CAC7B,GAAI,GAAS,GAAU,CAAC,EACpB,EAAK,EAAO,OACZ,EAAM,EAAO,IACb,EAAM,GAAa,EAAG,EAAM,CAAC,EACjC,GAAI,IAAQ,MAAQ,CAAC,GAAgB,EAAG,EAAM,CAAC,EAC3C,GAAc,EAAG,EAAM,CAAC,MACvB,CACD,GAAI,GAAQ,GAAgB,EAAG,EAAM,EAAG,IAAM,EAAK,EAAI,CAAC,EACxD,GAAe,EAAG,EAAI,EAAK,CAAK,CACpC,CACA,MAAO,EACX,EAEM,GAAQ,CACV,QAAgB,GAChB,QAAgB,GAChB,SAAgB,GAChB,aAAgB,GAChB,YAAgB,GAChB,WAAgB,GAChB,aAAgB,GAChB,QAAgB,GAChB,SAAgB,GAChB,aAAgB,GAChB,WAAgB,GAChB,aAAgB,GAChB,UAAgB,GAChB,UAAgB,GAChB,YAAgB,EACpB,EAEI,GASG,AAAI,MAAO,SAAW,aAIzB,IAAW,UAAW,CAClB,GAAI,GAAQ,OAAO,aAAc,EAAE,EACnC,MAAQ,KAAU,KAAQ,EAAQ,EACtC,GAEJ,AAAI,IACA,IAAM,MAAQ,SAAS,EAAG,CACtB,OAAS,CACL,GAAI,GAAQ,GAAS,EAErB,GAAI,IAAU,OACV,MAAO,GAEX,GAAI,EAAM,SAAW,EACjB,SAEJ,GAAI,GAAS,GAAa,CAAK,EAC/B,AAAI,IAAgB,EAAG,EAAQ,EAAO,OAAQ,GAAa,mBAAoB,EAAI,CAAC,GAC7E,GAAU,EAAG,EAAG,EAAG,CAAC,IACvB,GAAqB,GAAe,EAAG,EAAE,EAAG;AAAA,CAAI,EAEpD,GAAW,EAAG,CAAC,CACnB,CACJ,GAGJ,GAAM,IAAgB,SAAS,EAAG,CAC9B,UAAY,EAAG,EAAK,EACb,CACX,EAEA,GAAO,QAAQ,cAAgB,KClgB/B,mBAEA,GAAM,CACF,cACA,gBACA,sBACA,oBACA,iBACA,iBACA,KACE,CACF,UACA,qBACA,YACA,cACA,aACA,mBACA,gBACA,cACA,kBACA,aACA,gBACA,gBACA,WACA,mBACA,oBACA,qBACA,mBACA,uBACA,yBACA,mBACA,mBACA,eACA,kBACA,iBACA,eACA,eACA,eACA,eACA,cACA,gBACA,oBACA,cACA,iBACA,gBACA,kBACA,qBACA,KACE,CACF,oBACA,qBACA,eACA,iBACA,iBACA,oBACA,cACA,oBACA,aACA,YACA,iBACA,eACA,kBACA,mBACA,kBACA,KACE,GAAS,KACT,CACF,qBACA,eACA,eACA,iBACA,KACE,GAAW,KAEX,GAAc,UAAW,CAIpB,MAAI,OAAO,SAAW,YAElB,OACA,MAAO,oBAAsB,aAAe,eAAgB,mBAE5D,KAGC,GAAG,MAAM,MAAM,CAE/B,EAAG,EAEG,GAAS,EAAa,YAAY,EAClC,GAAe,WACf,GAAiB,aAEjB,GAAa,IAQb,GAAc,GACd,GAAc,GAGd,GAAU,EAAa,UAAU,EAGjC,GAAY,EAAa,GAAG,EAC5B,GAAW,OAEX,GAAU,EAAa,GAAM,EAS/B,GAEA,GAAY,SAAS,EAAG,EAAM,EAAQ,CAClC,EAAO,GAAa,CAAI,EACxB,GAAI,GAAM,GAAI,gBAId,GAHA,EAAI,KAAK,MAAO,EAAM,EAAK,EAC3B,EAAI,KAAK,EAEL,EAAI,OAAS,KAAO,EAAI,QAAU,IAClC,UAAe,EAAG,EAAa,GAAG,EAAI,WAAW,EAAI,YAAY,CAAC,EAC3D,KAGX,GAAI,GAAO,EAAI,SAEf,AAAK,sBAAsB,KAAK,CAAI,GAChC,IAAQ,kBAAoB,GAChC,GAAI,GACJ,GAAI,CACA,EAAO,SAAS,UAAW,CAAI,CACnC,OAAS,EAAP,CACE,UAAe,EAAG,EAAa,GAAG,EAAE,SAAS,EAAE,SAAS,CAAC,EAClD,IACX,CACA,GAAI,GAAM,EAAK,EAAO,EACtB,MAAI,OAAO,IAAQ,YAAe,MAAO,IAAQ,UAAY,IAAQ,KAC1D,EACA,IAAQ,OACR,GAEP,IAAe,EAAG,EAAa,qCAAqC,MAAO,KAAM,CAAC,EAC3E,KAEf,EAqBJ,GAAM,IAAW,SAAS,EAAG,EAAK,EAAK,CACnC,GAAI,GAAI,EAAI,GAAY,CAAG,GAE3B,MAAI,IAAK,MAAO,IAAM,WACX,EAEP,IAAgB,EAAG,EAAa,sBAAsB,EAAG,CAAG,EACrD,KAEf,EAKM,GAAQ,SAAS,EAAG,CACtB,GAAa,EAAG,GAAmB,EAAa,WAAW,CAAC,EAC5D,GAAI,GAAI,GAAc,EAAG,EAAE,EAC3B,UAAQ,EAAG,CAAC,EACL,CACX,EAEI,GAcA,GAAW,SAAS,EAAM,CACtB,EAAO,GAAa,CAAI,EACxB,GAAI,GAAM,GAAI,gBAEd,SAAI,KAAK,MAAO,EAAM,EAAK,EAC3B,EAAI,KAAK,EAEF,EAAI,QAAU,KAAO,EAAI,QAAU,GAC9C,EAKJ,GAAM,IAAU,EACV,GAAU,EAaV,GAAc,SAAS,EAAG,EAAM,EAAK,CACvC,GAAI,GAAM,GAAW,EAAG,CAAI,EAC5B,GAAI,IAAQ,KAAM,CAEd,GADA,EAAM,GAAU,EAAG,EAAM,EAAI,KAAO,IAAI,WAAW,CAAC,CAAC,EACjD,IAAQ,KAAM,MAAO,IACzB,GAAW,EAAG,EAAM,CAAG,CAC3B,CACA,GAAI,EAAI,KAAO,IAAI,WAAW,CAAC,EAC3B,UAAgB,EAAG,CAAC,EACb,EAEN,CACD,GAAI,GAAI,GAAS,EAAG,EAAK,CAAG,EAC5B,MAAI,KAAM,KACC,GACX,IAAkB,EAAG,CAAC,EACf,EACX,CACJ,EAEM,GAAa,SAAS,EAAG,CAC3B,GAAI,GAAO,GAAiB,EAAG,CAAC,EAC5B,EAAO,GAAiB,EAAG,CAAC,EAC5B,EAAO,GAAY,EAAG,EAAM,CAAI,EACpC,MAAI,KAAS,EACF,EAEP,IAAY,CAAC,EACb,GAAW,EAAG,EAAE,EAChB,GAAgB,EAAI,IAAS,GAAU,GAAW,MAAM,EACjD,EAEf,EAEM,GAAO,UAAW,CAKhB,MAAO,GAEf,EAAG,EAKG,GAAU,SAAS,EAAG,EAAW,EAAS,EAAK,CACjD,GAAI,GAAO,GAAG,IAAU,GAAO,gBAC/B,GAAe,EAAG,EAAa,CAAI,CAAC,EACpC,GAAI,GAAO,GAAI,GACf,AAAI,IAAS,QACT,GAAO,GAAI,IACf,AAAI,IAAS,QAAa,GAAM,CAAC,EAC7B,GAAe,EAAG,CAAG,EAGrB,GAAO,GACH,EACA,EAAa,CAAI,EACjB,EAAa,GAAe,GAAc,EAAI,EAC9C,EAAa,GAAe,GAAY,EAAO,EAAI,GAAc,EAAI,CACzE,EACA,GAAU,EAAG,EAAM,GAAS,CAAG,EAC/B,GAAW,EAAG,EAAE,GAEpB,GAAa,EAAG,GAAI,CAAS,EAC7B,GAAQ,EAAG,CAAC,CAChB,EAKM,GAAa,SAAS,EAAG,EAAM,CACjC,GAAY,EAAG,GAAmB,EAAM,EACxC,GAAa,EAAG,GAAI,CAAI,EACxB,GAAI,GAAO,GAAe,EAAG,EAAE,EAC/B,UAAQ,EAAG,CAAC,EACL,CACX,EAMM,GAAa,SAAS,EAAG,EAAM,EAAM,CACvC,GAAY,EAAG,GAAmB,EAAM,EACxC,GAAsB,EAAG,CAAI,EAC7B,GAAc,EAAG,EAAE,EACnB,GAAa,EAAG,GAAI,CAAI,EACxB,GAAY,EAAG,GAAI,GAAS,EAAG,EAAE,EAAI,CAAC,EACtC,GAAQ,EAAG,CAAC,CAChB,EAEM,GAAmB,SAAS,EAAG,EAAM,CACvC,KAAO,EAAK,KAAO,GAAa,WAAW,CAAC,GAAG,EAAO,EAAK,SAAS,CAAC,EACrE,GAAI,EAAK,SAAW,EAAG,MAAO,MAC9B,GAAI,GAAI,GAAkB,EAAM,GAAa,WAAW,CAAC,CAAC,EAC1D,MAAI,GAAI,GAAG,GAAI,EAAK,QACpB,GAAgB,EAAG,EAAM,CAAC,EACnB,EAAK,SAAS,CAAC,CAC1B,EAEM,GAAa,SAAS,EAAG,EAAM,EAAM,EAAK,EAAQ,CACpD,GAAI,GAAM,GAAI,IAId,IAHA,GAAc,EAAG,CAAG,EAChB,EAAI,KAAO,GACX,GAAO,GAAU,EAAG,EAAM,EAAK,CAAM,GACjC,GAAO,GAAiB,EAAG,CAAI,KAAO,MAAM,CAChD,GAAI,GAAW,GAAU,EAAG,GAAa,EAAG,EAAE,EAAG,EAAa,GAAe,EAAI,EAAG,CAAI,EAExF,GADA,GAAW,EAAG,EAAE,EACZ,GAAS,CAAQ,EACjB,MAAO,GACX,GAAgB,EAAG,EAAa;AAAA,cAAkB,EAAG,CAAQ,EAC7D,GAAW,EAAG,EAAE,EAChB,GAAc,CAAG,CACrB,CACA,UAAgB,CAAG,EACZ,IACX,EAEM,GAAgB,SAAS,EAAG,CAQ9B,MAAI,AAPI,IACJ,EACA,GAAiB,EAAG,CAAC,EACrB,GAAiB,EAAG,CAAC,EACrB,GAAe,EAAG,EAAG,GAAG,EACxB,GAAe,EAAG,EAAG,EAAU,CACnC,IACU,KAAa,EAEnB,IAAY,CAAC,EACb,GAAW,EAAG,EAAE,EACT,EAEf,EAEM,GAAW,SAAS,EAAG,EAAM,EAAO,EAAQ,CAC9C,GAAa,EAAG,GAAiB,CAAC,EAAG,CAAK,EAC1C,GAAI,GAAO,GAAa,EAAG,EAAE,EAC7B,MAAI,KAAS,MACT,GAAW,EAAG,EAAa,+BAA+B,EAAG,CAAK,EAC/D,GAAW,EAAG,EAAM,EAAM,EAAa,GAAG,EAAG,CAAM,CAC9D,EAEM,GAAY,SAAS,EAAG,EAAM,EAAU,CAC1C,MAAI,GACA,IAAe,EAAG,CAAQ,EACnB,GAEA,GAAW,EAAG,EAAa;AAAA,IAAiD,EAC/E,GAAa,EAAG,CAAC,EAAG,EAAU,GAAa,EAAG,EAAE,CAAC,CAC7D,EAEM,GAAe,SAAS,EAAG,CAC7B,GAAI,GAAO,GAAiB,EAAG,CAAC,EAC5B,EAAW,GAAS,EAAG,EAAM,EAAa,OAAQ,EAAI,EAAG,EAAa,GAAa,EAAI,CAAC,EAC5F,MAAI,KAAa,KAAa,EACvB,GAAU,EAAG,GAAc,EAAG,CAAQ,IAAM,GAAQ,CAAQ,CACvE,EAUM,GAAW,SAAS,EAAG,EAAU,EAAS,CAC5C,GAAI,GACJ,EAAU,GAAU,EAAG,EAAS,EAAa,GAAG,EAAG,EAAS,EAC5D,GAAI,GAAO,GAAkB,EAAS,GAAW,WAAW,CAAC,CAAC,EAC9D,GAAI,GAAQ,EAAG,CACX,EAAW,GAAgB,EAAG,EAAS,CAAI,EAC3C,EAAW,GAAgB,EAAG,EAAa,MAAM,EAAG,GAAS,CAAQ,EACrE,GAAI,GAAO,GAAY,EAAG,EAAU,CAAQ,EAC5C,GAAI,IAAS,GAAS,MAAO,GAC7B,EAAU,EAAO,CACrB,CACA,SAAW,GAAgB,EAAG,EAAa,MAAM,EAAG,GAAS,CAAO,EAC7D,GAAY,EAAG,EAAU,CAAQ,CAC5C,EAEM,GAAa,SAAS,EAAG,CAC3B,GAAI,GAAO,GAAiB,EAAG,CAAC,EAC5B,EAAW,GAAS,EAAG,EAAM,EAAa,SAAU,EAAI,EAAG,EAAa,GAAa,EAAI,CAAC,EAC9F,MAAI,KAAa,KAAa,EACvB,GAAU,EAAI,GAAS,EAAG,EAAU,CAAI,IAAM,EAAI,CAAQ,CACrE,EAEM,GAAiB,SAAS,EAAG,CAC/B,GAAI,GAAO,GAAiB,EAAG,CAAC,EAC5B,EAAI,GAAkB,EAAM,IAAI,WAAW,CAAC,CAAC,EAC7C,EACJ,GAAI,EAAI,EAAG,MAAO,GAClB,GAAgB,EAAG,EAAM,CAAC,EAC1B,GAAI,GAAW,GAAS,EAAG,GAAa,EAAG,EAAE,EAAG,EAAa,SAAU,EAAI,EAAG,EAAa,GAAa,EAAI,CAAC,EAC7G,MAAI,KAAa,KAAa,EACzB,GAAO,GAAS,EAAG,EAAU,CAAI,KAAO,EACrC,GAAQ,GACD,GAAU,EAAG,EAAG,CAAQ,EAE/B,IAAe,EAAG,EAAa;AAAA,6BAAiC,EAAG,EAAM,CAAQ,EAC1E,GAGf,IAAe,EAAG,CAAQ,EACnB,EACX,EAEM,GAAmB,SAAS,EAAG,CACjC,GAAI,GAAO,GAAiB,EAAG,CAAC,EAChC,UAAa,EAAG,GAAmB,EAAiB,EAChD,GAAa,EAAG,GAAI,CAAI,IAAM,IAC9B,GAAgB,EAAG,EAAa;AAAA,gCAAoC,EAAG,CAAI,EACxE,CACX,EAEM,GAAa,SAAS,EAAG,EAAM,EAAK,EAAG,CACzC,GAAI,GAAM,GAAI,IACd,UAAc,EAAG,CAAG,EAEhB,GAAa,EAAG,GAAiB,CAAC,EAAG,EAAa,YAAa,EAAI,CAAC,IAAM,IAC1E,GAAW,EAAG,EAAa,qCAAqC,CAAC,EAE9D,GAAgB,EAAG,GADf,CAAC,KAAM,EAAM,EAAG,EAAG,IAAK,EAAK,IAAK,EAAK,EAAG,CAAC,CAChB,CAC1C,EAEM,GAAkB,SAAS,EAAG,EAAQ,EAAK,CAE7C,KACI,AAAI,IAAW,GACP,IAAY,EAAG,EAAG,EAAI,CAAC,IAAM,IAC7B,IAAQ,EAAG,CAAC,EACZ,GAAgB,EAAI,GAAG,EACvB,GAAW,EAAG,EAAa,0BAA0B,EAAG,EAAI,KAAM,GAAa,EAAG,EAAE,CAAC,GAEzF,GAAe,EAAG,EAAI,IAAI,EAC1B,GAAU,EAAG,EAAG,EAAG,EAAK,EAAe,GAEvC,EAAS,GAET,IAAe,EAAG,EAAE,EAZnB,EAAI,IAcJ,AAAI,GAAa,EAAG,EAAE,EACvB,IAAQ,EAAG,CAAC,EACZ,GAAc,EAAI,GAAG,GAGrB,GAAQ,EAAG,CAAC,EAEpB,MAAO,GAAI,EAAE,EAAG,GAAQ,EAAI,GAAG,CACnC,EAEM,GAAa,SAAS,EAAG,CAC3B,GAAI,GAAO,GAAiB,EAAG,CAAC,EAIhC,MAHA,IAAW,EAAG,CAAC,EACf,GAAa,EAAG,GAAmB,EAAgB,EACnD,GAAa,EAAG,EAAG,CAAI,EACnB,GAAc,EAAG,EAAE,EACZ,EAEX,IAAQ,EAAG,CAAC,EAEL,GAAW,EAAG,EADX,EACsB,EAAe,EACnD,EAEM,GAAkB,SAAS,EAAG,EAAQ,EAAK,CAE7C,UAAe,EADJ,CACW,EACtB,GAAW,EAAG,EAAE,EAChB,GAAU,EAAG,EAAG,EAAG,EAAK,EAAgB,EACjC,GAAiB,EAAG,GAAQ,CAAG,CAC1C,EAEM,GAAmB,SAAS,EAAG,EAAQ,EAAK,CAC9C,GAAI,GAAO,EACX,MAAK,IAAU,EAAG,EAAE,GAChB,GAAa,EAAG,EAAG,CAAI,EACvB,GAAa,EAAG,EAAG,CAAI,GAAK,IAC5B,IAAgB,EAAG,CAAC,EACpB,GAAc,EAAG,EAAE,EACnB,GAAa,EAAG,EAAG,CAAI,GAEpB,CACX,EAEM,GAAW,CACb,QAAW,GACX,WAAc,EAClB,EAEM,GAAW,CACb,QAAW,EACf,EAEM,GAAuB,SAAS,EAAG,CACrC,GAAI,GAAY,CAAC,GAAkB,GAAc,GAAY,GAAgB,IAAI,EAEjF,GAAgB,CAAC,EAEjB,OAAS,GAAI,EAAG,EAAU,GAAI,IAC1B,GAAc,EAAG,EAAE,EACnB,GAAiB,EAAG,EAAU,GAAI,CAAC,EACnC,GAAY,EAAG,GAAI,EAAE,CAAC,EAE1B,GAAa,EAAG,GAAI,EAAa,YAAa,EAAI,CAAC,CACvD,EAMM,GAAoB,SAAS,EAAG,CAClC,GAAa,CAAC,EACd,GAAgB,EAAG,EAAG,CAAC,EACvB,GAAiB,EAAG,EAAE,EACtB,GAAY,EAAG,GAAmB,EAAM,CAC5C,EAEM,GAAkB,SAAS,EAAG,CAChC,UAAkB,CAAC,EACnB,GAAY,EAAG,EAAQ,EACvB,GAAqB,CAAC,EAEtB,GAAQ,EAAG,EAAa,OAAQ,EAAI,EAAG,GAAc,EAAgB,EACrE,GAAQ,EAAG,EAAa,SAAU,EAAI,EAAG,GAAgB,EAAkB,EAE3E,GAAgB,EAAG,GAAa;AAAA,EAAO,GAAe;AAAA,EAAO,GAAgB;AAAA,EACzD,GAAe;AAAA,EAAO,GAAa;AAAA,CAAI,EAC3D,GAAa,EAAG,GAAI,EAAa,SAAU,EAAI,CAAC,EAEhD,GAAiB,EAAG,GAAmB,EAAgB,EACvD,GAAa,EAAG,GAAI,EAAa,SAAU,EAAI,CAAC,EAEhD,GAAiB,EAAG,GAAmB,EAAiB,EACxD,GAAa,EAAG,GAAI,EAAa,UAAW,EAAI,CAAC,EACjD,GAAoB,CAAC,EACrB,GAAc,EAAG,EAAE,EACnB,GAAc,EAAG,GAAU,CAAC,EAC5B,GAAQ,EAAG,CAAC,EACL,CACX,EAEA,GAAO,QAAQ,gBAAkB,KCrkBjC,sBAAM,CACF,mBACA,mBACA,iBACA,KACE,CACF,gBACA,KACE,CACF,mBACA,qBACA,mBACA,mBACA,yBACA,yBACA,uBACA,2BACA,iBACA,KAEE,GAAkB,SAAS,EAAG,CAChC,UAAY,EAAG,CAAC,CAAC,EACjB,GAAgB,EAAG,EAAe,EAClC,GAAa,EAAG,GAAI,GAAa,SAAS,CAAC,EAC3C,GAAgB,EAAG,EAAiB,EACpC,GAAa,EAAG,GAAI,GAAa,WAAW,CAAC,EAC7C,GAAgB,EAAG,EAAe,EAClC,GAAa,EAAG,GAAI,GAAa,SAAS,CAAC,EAC3C,GAAgB,EAAG,EAAe,EAClC,GAAa,EAAG,GAAI,GAAa,SAAS,CAAC,EAC3C,GAAgB,EAAG,EAAqB,EACxC,GAAa,EAAG,GAAI,GAAa,eAAe,CAAC,EACjD,GAAgB,EAAG,EAAqB,EACxC,GAAa,EAAG,GAAI,GAAa,eAAe,CAAC,EACjD,GAAgB,EAAG,EAAmB,EACtC,GAAa,EAAG,GAAI,GAAa,aAAa,CAAC,EAC/C,GAAgB,EAAG,EAAuB,EAC1C,GAAa,EAAG,GAAI,GAAa,iBAAiB,CAAC,EAC5C,CACX,EAEA,GAAO,QAAQ,gBAAkB,KCzCjC,mBAEA,GAAM,CAAE,YAAY,KACd,CAAE,kBAAkB,KACpB,CAAE,iBAAiB,KAEnB,GAAa,CAAC,EAGd,GAAgB,SAAS,EAAG,CAE9B,OAAS,KAAO,IACZ,GAAc,EAAG,GAAa,CAAG,EAAG,GAAW,GAAM,CAAC,EACtD,GAAQ,EAAG,CAAC,CAEpB,EACA,GAAO,QAAQ,cAAgB,GAE/B,GAAM,IAAS,KACT,CAAE,iBAAsB,KACxB,CAAE,sBAAsB,KACxB,CAAE,kBAAsB,KACxB,CAAE,iBAAsB,KACxB,CAAE,oBAAsB,KACxB,CAAE,eAAsB,KACxB,CAAE,mBAAsB,KACxB,CAAE,kBAAsB,KACxB,CAAE,iBAAsB,KAE9B,GAAW,GAAQ,GACnB,GAAW,GAAO,iBAAmB,GACrC,GAAW,GAAO,eAAiB,GACnC,GAAW,GAAO,gBAAkB,GACpC,GAAW,GAAO,eAAiB,GACnC,GAAW,GAAO,gBAAkB,GACpC,GAAW,GAAO,iBAAmB,GACrC,GAAW,GAAO,iBAAmB,GACrC,GAAW,GAAO,eAAiB,GAKnC,GAAM,CAAE,oBAAoB,KAC5B,GAAW,GAAO,oBAAsB,KC3CxC,mBAEA,GAAM,CACF,qBACA,sBACA,KAEE,GAAgB,IAAM,GAAoB,IAAM,GACtD,GAAO,QAAQ,cAAgB,GAE/B,GAAO,QAAQ,WAAa,SAAS,EAAG,CAAC,EAEzC,GAAO,QAAQ,aAAe,KAAyB,aAEvD,GAAM,IAAgB,YACtB,GAAO,QAAQ,cAAgB,GAC/B,GAAO,QAAQ,kBAAoB,KAAyB,kBAE5D,GAAM,IAAiB,QACvB,GAAO,QAAQ,eAAiB,GAChC,GAAO,QAAQ,cAAgB,KAAwB,cAQvD,GAAM,IAAgB,KACtB,GAAO,QAAQ,cAAgB,GAC/B,GAAO,QAAQ,WAAa,KAAuB,WAEnD,GAAM,IAAiB,SACvB,GAAO,QAAQ,eAAiB,GAChC,GAAO,QAAQ,eAAiB,KAAwB,eAExD,GAAM,IAAkB,OACxB,GAAO,QAAQ,gBAAkB,GACjC,GAAO,QAAQ,aAAe,KAAyB,aAEvD,GAAM,IAAiB,QACvB,GAAO,QAAQ,eAAiB,GAGhC,GAAM,IAAkB,OACxB,GAAO,QAAQ,gBAAkB,GACjC,GAAO,QAAQ,aAAe,KAAyB,aAEvD,GAAM,IAAgB,QACtB,GAAO,QAAQ,cAAgB,GAC/B,GAAO,QAAQ,cAAgB,KAAuB,cAEtD,GAAM,IAAkB,UACxB,GAAO,QAAQ,gBAAkB,GACjC,GAAO,QAAQ,gBAAkB,KAAwB,gBAEzD,GAAM,IAAqB,UAC3B,GAAO,QAAQ,mBAAqB,GACpC,GAAO,QAAQ,gBAAkB,KAA2B,gBAE5D,GAAM,IAAQ,KACd,GAAO,QAAQ,cAAgB,GAAM,gBC7DrC,mBAUA,GAAM,IAAO,KAEb,GAAO,QAAQ,gBAA0B,GAAK,gBAC9C,GAAO,QAAQ,kBAA0B,GAAK,kBAC9C,GAAO,QAAQ,gBAA0B,GAAK,gBAC9C,GAAO,QAAQ,gBAA0B,GAAK,gBAC9C,GAAO,QAAQ,sBAA0B,GAAK,sBAC9C,GAAO,QAAQ,sBAA0B,GAAK,sBAC9C,GAAO,QAAQ,oBAA0B,GAAK,oBAC9C,GAAO,QAAQ,wBAA0B,GAAK,wBAE9C,GAAO,QAAQ,aAAoB,GAAK,aACxC,GAAO,QAAQ,kBAAoB,GAAK,kBACxC,GAAO,QAAQ,aAAoB,GAAK,aACxC,GAAO,QAAQ,YAAoB,GAAK,YACxC,GAAO,QAAQ,aAAoB,GAAK,aACxC,GAAO,QAAQ,aAAoB,GAAK,aAExC,GAAM,IAAU,KACV,GAAU,KACV,GAAU,KACV,GAAU,KAEhB,GAAO,QAAQ,QAAU,GACzB,GAAO,QAAQ,IAAU,GACzB,GAAO,QAAQ,QAAU,GACzB,GAAO,QAAQ,OAAU,KCjCV,YAAU,EAAoB,EAA0B,CAEnE,GAAI,EAAM,IAAI,WAAW,EAAM,GAAG,IAAM,GAAc,CAGlD,GAAM,GAAY,EAAM,OAAO,EAAM,OAAO,OAAS,GACjD,EACJ,MAAI,IAAc,GAAU,MAAQ,iBAAmB,EAAU,MAAQ,mBAErE,GAAM,OAAO,OAAO,EAAM,OAAO,OAAS,EAAG,CAAC,EAC9C,EAAU,EAAU,SAEpB,EAAU,KAGd,EAAM,KAAK,eAAgB,GAAI,CAAC,EAAE,MAAQ,CAAC,CAAC,UAAW,CAAQ,CAAC,EAChE,EAAM,MACC,EACX,CAEA,MAAI,GAAM,IAAI,WAAW,EAAM,GAAG,IAAM,GACpC,GAAM,KAAK,gBAAiB,GAAI,EAAM,OAAS,EAAI,EAAI,EAAE,EACzD,EAAM,MACC,IAGJ,EACX,CC3Be,YAAU,EAAoB,EAA0B,CAGnE,GAAI,CAAC,EAAM,IAAI,WAAW,KAAM,EAAM,GAAG,EACrC,MAAO,GAEX,GAAM,GAAY,EAAM,IAAI,QAAQ,KAAM,EAAM,IAAM,CAAY,EAC9D,EAAkB,EACtB,AAAI,EAAY,EACZ,GAAW,EAAM,IAAI,OACrB,EAAY,EAAM,IAAI,QAEtB,GAAW,EACX,EAAY,EAAY,GAE5B,GAAI,GAAM,EAAM,KAAK,kBAAmB,GAAI,CAAC,EAC7C,SAAI,QAAU,EAAM,IAAI,MAAM,EAAM,IAAM,EAAc,CAAQ,EAChE,EAAI,KAAO,EAAM,IACjB,EAAM,IAAM,EACL,EACX,CCpBe,YAAU,EAAoB,EAA0B,CAGnE,GAAI,CAAC,EAAM,IAAI,WAAW,KAAM,EAAM,GAAG,EACrC,MAAO,GAGX,GAAM,GAAW,EAAM,IAAM,EACvB,EAAS,EAAM,OACjB,EAAS,EACT,EAAU,GACV,EAAU,GACd,KAAO,EAAS,GAAU,CAAC,EAAM,IAAI,WAAW,KAAM,CAAM,GAGxD,AAAI,IAAY,IAAM,EAAM,IAAI,WAAW,KAAM,CAAM,EACnD,EAAU,EACH,EAAM,IAAI,WAAW,KAAM,CAAM,GACxC,GAAU,GAEd,IAGJ,GAAI,IAAW,EAEX,MAAO,GAGX,GAAI,IAAY,IAAM,IAAY,GAAI,CAElC,GAAM,GAAY,EAAU,EACtB,EAAY,EAAU,GAAU,GAEtC,AAAI,EAAY,EACZ,EAAU,GAEV,EAAU,EAElB,CAGA,GAAI,GACJ,AAAI,IAAY,GACZ,GAAS,EAAM,IAAI,MAAM,EAAU,EAAc,CAAM,EAAE,KAAK,EAC9D,EAAM,IAAM,EACZ,EAAM,OAAS,GACZ,AAAI,IAAY,GACnB,GAAS,EAAM,IAAI,MAAM,EAAU,CAAO,EAAE,KAAK,EACjD,EAAM,IAAM,EAAU,EACtB,EAAM,OAAS,GAEf,GAAS,EAAM,IAAI,MAAM,EAAU,CAAM,EAAE,KAAK,EAChD,EAAM,IAAM,EACZ,EAAM,OAAS,GAInB,GAAM,GAAY,EAAM,OAAO,EAAM,OAAO,OAAS,GACjD,EACJ,MAAI,IAAc,GAAU,MAAQ,iBAAmB,EAAU,MAAQ,mBAErE,GAAM,OAAO,OAAO,EAAM,OAAO,OAAS,EAAG,CAAC,EAC9C,EAAU,EAAU,SAEpB,EAAU,KAId,AAAI,IAAY,IAAM,EAAM,IAAI,MAAM,EAAM,IAAK,EAAM,MAAM,EAAE,KAAK,GAAK,GACrE,EAAM,KAAK,cAAe,GAAI,CAAC,EAAE,MAAQ,CAAE,CAAC,OAAQ,CAAM,EAAG,CAAC,UAAW,CAAQ,CAAE,EAGnF,GAAM,KAAK,YAAa,IAAK,CAAC,EAAE,MAAQ,CAAE,CAAC,OAAQ,CAAM,EAAG,CAAC,UAAW,CAAQ,CAAE,EAClF,EAAM,GAAG,OAAO,SAAS,CAAK,EAC9B,EAAM,KAAK,aAAc,IAAK,EAAE,GAIpC,EAAM,IAAM,EAAS,EACrB,EAAM,OAAS,EACR,EAEX,CClFA,YAAkB,EAAuB,CACrC,MAAO,KAAS,IAAS,GAAQ,IAAQ,GAAQ,IAAU,GAAQ,IAAQ,GAAQ,GACvF,CAEA,YAA0B,EAAuB,CAC7C,MAAO,IAAS,CAAI,GAAM,GAAQ,IAAQ,GAAQ,EACtD,CAEA,YAA4B,EAAoB,EAA2B,CACvE,GAAI,GAAQ,EAAM,IAIlB,GAHI,EAAM,IAAI,WAAW,EAAM,GAAG,GAAK,IAGnC,CAAC,GAAS,EAAM,IAAI,WAAW,EAAM,IAAM,CAAC,CAAC,EAC7C,MAAO,GAEX,EAAM,MACN,EACI,GAAM,YACD,EAAM,IAAM,EAAM,IAAI,QAAU,GAAiB,EAAM,IAAI,WAAW,EAAM,GAAG,CAAC,GACzF,SAAO,KAAK,EAAM,IAAI,MAAM,EAAO,EAAM,GAAG,CAAC,EACtC,EACX,CAEA,YAAwB,EAAoB,EAAkB,EAAe,EAAsB,CAC/F,GAAI,EAAM,IAAI,WAAW,EAAM,GAAG,GAAK,EACnC,MAAO,GAEX,GAAI,GAAQ,EAAM,IACd,EAAM,EAAM,IACZ,EAAQ,EACR,EACJ,EACI,KACA,EAAO,EAAM,IAAI,WAAW,CAAG,EAC/B,AAAI,GAAQ,EACR,IACO,GAAQ,GACf,UAEC,EAAQ,GAAK,GAAQ,IAAQ,EAAM,EAAM,IAAI,QACtD,MAAI,IAAS,EACT,GAAM,IAAM,EAAM,EAClB,EAAO,KAAK,EAAM,IAAI,MAAM,EAAO,EAAM,GAAG,CAAC,EACtC,IAEJ,EACX,CAEA,YAA0B,EAAoB,EAA2B,CACrE,GAAI,CAAC,EAAM,IAAI,WAAW,KAAM,EAAM,GAAG,EACrC,MAAO,GAEX,GAAI,GAAQ,EAAM,IAAI,QAAQ,KAAM,EAAM,IAAM,CAAC,EACjD,MAAI,GAAQ,EACD,GAEX,GAAO,KAAK,cAAc,EAC1B,EAAO,KAAK,EAAM,IAAI,MAAM,EAAM,IAAM,EAAG,CAAK,CAAC,EACjD,EAAO,KAAK,OAAO,EACnB,EAAM,IAAM,EAAQ,EACb,GACX,CAEe,YAAU,EAAoB,EAA0B,CAKnE,GAHI,EAAM,IAAI,WAAW,EAAM,GAAG,IAAM,IAGpC,CAAC,GAAS,EAAM,IAAI,WAAW,EAAM,IAAM,CAAC,CAAC,EAC7C,MAAO,GAEX,GAAM,GAAQ,EAAM,IAAM,EAAM,IAAM,EACtC,EACI,GAAM,YACD,GAAiB,EAAM,IAAI,WAAW,EAAM,GAAG,CAAC,GACzD,GAAI,GAAS,CAAC,EAAM,IAAI,MAAM,EAAO,EAAM,GAAG,CAAC,EAC/C,KAAO,GAAmB,EAAO,CAAM,GAChC,GAAe,EAAO,EAAQ,GAAM,EAAI,GACxC,GAAe,EAAO,EAAQ,IAAM,GAAI,GACxC,GAAiB,EAAO,CAAM,GACnC,CAGF,GAAI,GAAM,EAAM,KAAK,gBAAiB,GAAI,CAAC,EAC3C,SAAI,QAAU,EAAO,KAAK,EAAE,EAC5B,EAAI,KAAO,EACJ,EACX,CCxFe,YAAU,EAAoB,EAA0B,CAGnE,GAAI,CAAC,EAAM,IAAI,WAAW,KAAM,EAAM,GAAG,EACrC,MAAO,GAEX,GAAM,GAAY,EAAM,IAAI,QAAQ,KAAM,EAAM,IAAM,CAAY,EAC9D,EAAkB,EACtB,AAAI,EAAY,EACZ,GAAW,EAAM,IAAI,OACrB,EAAY,EAAM,IAAI,QAEtB,GAAW,EACX,EAAY,EAAY,GAE5B,GAAI,GAAM,EAAM,KAAK,aAAc,GAAI,CAAC,EACxC,SAAI,QAAU,EAAM,IAAI,MAAM,EAAM,IAAM,EAAc,CAAQ,EAChE,EAAI,KAAO,EAAM,IACjB,EAAM,IAAM,EACL,EACX,CClBA,OAAkB,SAClB,GAAyB,SACzB,GAAwB,SACxB,GAAuB,SACvB,GAA6B,SAIvB,GAAK,CACP,OAAQ,GAAI,YACZ,MAAO,GAAI,YACX,KAAM,GAAI,YACV,QAAS,CACL,KAAc,GACd,SAAc,GACd,OAAc,GACd,WAAc,YACd,QAAc,GACd,YAAc,GACd,OAAQ,2BACR,UAAW,KACX,WAAc,GAClB,EACA,MAAO,SAAS,EAAa,EAAa,CACtC,GAAI,MAAO,IAAQ,SACf,KAAM,IAAI,OAAM,+BAA+B,EAEnD,GAAI,GAAQ,GAAI,MAAK,KAAK,MAAM,EAAK,KAAa,CAAG,EACrD,YAAK,KAAK,QAAQ,CAAK,EAChB,EAAM,MACjB,CACJ,EAEM,GAAQ,GAAG,OAAO,MACxB,GAAM,QAAQ,CAAC,OAAQ,QAAS,UAAU,CAAC,EAC3C,GAAM,KAAK,eAAgB,EAAY,EACvC,GAAM,KAAK,gBAAiB,EAAa,EACzC,GAAM,KAAK,aAAc,EAAU,EACnC,GAAM,KAAK,eAAgB,EAAY,EACvC,GAAM,KAAK,WAAY,EAAQ,EAC/B,GAAG,MAAM,MAAM,QAAQ,CAAC,WAAW,CAAC,EAEpC,YAAgB,EAAuB,CACnC,MAAO,GACF,QAAQ,MAAO,KAAM,EACrB,QAAQ,MAAO;AAAA,CAAM,CAC9B,CAEA,YAAmB,EAAc,EAAkB,EAAyC,CArD5F,UAuDI,WAAa,EAAa,CACtB,EAAO,KAAK,GAAG,KAAK,OAAO,EAAM,KAAK,IAAI,GAAK,CACnD,CAEA,EAAM,QAAU,KAAM,UAAN,cAAe,QAAQ,MAAO;AAAA,GAC9C,GAAM,GAAU,KAAM,QAAQ,SAAS,IAAvB,cAA0B,QAAQ,MAAO;AAAA,GACnD,EAAO,GAAO,KAAM,QAAQ,MAAM,IAApB,OAAyB,EAAE,EAC/C,OAAQ,EAAM,UACT,SACD,OAAW,KAAS,GAAM,SACtB,GAAU,EAAO,EAAQ,CAAK,EAElC,UACC,OACD,GAAI,GAAU,EAAM,QACpB,AAAI,EAAQ,OAAS,GACZ,qBAAa,EAAQ,WAAW,EAAQ,OAAS,CAAC,CAAC,GACpD,GAAU,EAAU,KAExB,EAAI,SAAS,GAAO,CAAO,KAAK,GAEpC,UACC,YACD,AAAI,GAAW,KACX,EAAI,SAAS,gBAAmB,EAEhC,EAAI,qBAAqB,aAAmB,iBAAoB,EAEpE,EAAM,QACN,EAAM,MAAM,KAAK,CAAI,EACrB,UACC,cACD,AAAI,GAAW,KACX,EAAI,YAAY,KAAQ,EAExB,EAAI,aAAa,0BAAgC,UAAa,EAElE,UACC,eACD,AAAI,GAAW,KACX,EAAI,iBAAiB,EAErB,EAAI,aAAa,eAAqB,EAE1C,EAAM,QACN,UACC,oBACA,kBACD,EAAI,QAAQ,EAAM,UAAU,EAC5B,UACC,aACD,EAAI,EAAM,OAAO,EACjB,cAEA,OAAQ,EAAM,aACT,GACD,EAAI,SAAS,EAAM,gBAAgB,EACnC,EAAM,QACN,UACC,GACD,EAAM,QACN,EAAI,MAAM,EACV,UACC,GACD,AAAI,EAAM,MAAQ,aACP,EAAM,KAAO,IACpB,EAAI,WAAW,EAAM,OAAO,EAEhC,OAGZ,CAIO,YAAuB,EAAa,EAAwB,EAAyC,CACxG,GAAI,GAAa,EAAM,MACvB,OAAU,KAAS,IAAG,MAAM,GAAW,CAAG,EAAG,CAAC,CAAC,EAC3C,GAAU,EAAO,EAAc,CAAK,EAExC,KAAO,EAAM,MAAQ,GACjB,GAAU,GAAI,YAAM,gBAAiB,GAAI,EAAE,EAAG,EAAc,CAAK,CAEzE,CAEA,YAAoB,EAAqB,CACrC,GAAI,GAAM,EACN,EAAM,GACV,KAAO,EAAM,EAAI,QAAQ,CACrB,GAAI,GAAK,EAAI,QAAQ,KAAM,CAAG,EAC1B,EAAK,EAAI,QAAQ,KAAM,CAAG,EAC1B,EACA,EACJ,GAAI,GAAM,EACN,EAAQ,EACR,EAAS,aACF,GAAM,EACb,EAAQ,EACR,EAAS,SACN,CACH,GAAO,EAAI,UAAU,CAAG,EACxB,KACJ,CACA,GAAO,EAAI,UAAU,EAAK,CAAK,EAC/B,GAAI,GAAM,EAAI,QAAQ,EAAQ,EAAM,CAAC,EACrC,AAAI,EAAM,EACN,EAAM,EAAI,OAEV,EAAM,EAAM,EAGhB,GAAO,EAAI,UAAU,EAAO,CAAG,EAAE,QAAQ,MAAO,IAAI,EACpD,EAAM,CACV,CACA,MAAO,EACX,CAEO,YAAoB,EAAwB,CAC/C,GAAI,GAAY,EAAM,aAAa,WAAW,EAC1C,EAA+B,KAC7B,EAAgB,CAAC,4BAA4B,EACnD,EAAI,KAAK,YAAY,GAAO,EAAM,aAAa,MAAM,CAAE,IAAI,EAC3D,EAAI,KAAK,cAAc,EACvB,OAAS,GAAI,EAAG,EAAI,EAAM,SAAS,OAAQ,IAAK,CAC5C,GAAI,GAAO,EAAM,SAAS,GAC1B,GAAI,EAAK,QAAQ,YAAY,IAAM,iBAAkB,CACjD,AAAI,IAAc,EAAK,aAAa,KAAK,GACrC,GAAgB,EAAK,aAAa,MAAM,GAE5C,EAAI,KAAK,OAAO,GAAO,EAAK,aAAa,MAAM,CAAE,SAAS,EAC1D,GAAI,GAAO,EAAK,aAAa,MAAM,EAAG,MAAM,GAAG,EAC/C,AAAI,EAAK,SAAW,GAAK,EAAK,KAAO,IACjC,GAAO,CAAC,GAEZ,EAAI,KAAK,gBAAgB,EAAK,IAAI,GAAK,KAAK,GAAO,CAAC,YAAY,EAAE,KAAK,GAAG,MAAM,EAChF,EAAI,KAAK,mBAAmB,EAAK,aAAa,UAAU,KAAK,EAC7D,EAAI,KAAK,0BAA0B,EACnC,GAAI,GAAkB,CAAC,EACvB,GAAc,EAAK,YAAc,EAAK,CAAC,MAAO,EAAG,OAAK,CAAC,EACvD,EAAI,KAAK,UAAU,EACnB,EAAI,KAAK,iBAAiB,EAAM,IAAI,GAAK,IAAI,GAAO,CAAC,IAAI,EAAE,KAAK,GAAG,KAAK,EACxE,EAAI,KAAK,MAAM,CACnB,CACJ,CACA,SAAI,KAAK,GAAG,EACZ,EAAI,KAAK,mBAAmB,GAAO,CAAc,IAAI,EAE9C,EAAI,KAAK;AAAA,CAAI,CACxB,CC3MA,MAAgD,SAE1C,GAAM,GAAI,aACZ,GAAsB,KACtB,GAAiB,CAAC,EAClB,GAAgB,CAAC,EACjB,GACA,GAAa,GACb,GAAc,GAEX,YAAmB,EAAe,EAAmD,EAA6C,CACrI,GAAO,EACP,GAAI,UAAQ,cAAc,EAE1B,MAAI,YAAY,GAAG,GACf,GAAM,MAAI,eAAe,EAAG,MAAI,WAAW,CAAC,CAAC,EAAG,OAAO,EAChD,EACV,EAED,SAAO,cAAc,EAAC,EAEtB,MAAI,aAAa,GAAG,QAAS,GAAK,CAC9B,GAAI,GAAI,MAAI,WAAW,CAAC,EACpB,EAAiB,CAAC,EACtB,OAAS,GAAI,EAAG,GAAK,EAAG,IACpB,EAAK,KAAK,MAAI,eAAe,EAAG,CAAC,CAAC,EAEtC,eAAQ,IAAI,GAAG,CAAI,EACZ,CACX,CAAC,EAED,MAAI,aAAa,GAAG,MAAO,GAAK,CAC5B,GAAI,GAAM,MAAI,WAAW,CAAC,EAC1B,SAAM,MAAI,eAAe,EAAG,CAAC,EAAG,MAAI,eAAe,EAAG,CAAC,CAAC,EACjD,CACX,CAAC,EAED,MAAI,aAAa,GAAG,OAAQ,GAAK,CAC7B,GAAI,GAAM,MAAI,eAAe,EAAG,CAAC,EACjC,UAAK,KAAK,CAAG,EACb,AAAI,GAAO,IACP,IAAI,KAAK,mBAAmB,MAAI,aAAa,EAAG,CAAC,KAAK,EACtD,MAAI,QAAQ,EAAG,CAAC,GACb,AAAI,GAAO,QACd,GAAI,KAAK,uBAAuB,MAAI,eAAe,EAAG,CAAC,MAAM,EAE7D,GAAI,KAAK,IAAI,IAAM,EAEvB,GAAa,GACN,CACX,CAAC,EACD,MAAI,aAAa,GAAG,MAAO,GAAK,CAC5B,GAAI,GAAM,GAAK,OAAO,GAAK,OAAS,EAAG,CAAC,EAAE,GAC1C,MAAI,IACA,CAAI,IAAQ,QACR,GAAI,KAAK,SAAS,EAElB,GAAI,KAAK,KAAK,IAAM,GAG5B,GAAa,GACN,CACX,CAAC,EACD,MAAI,aAAa,GAAG,OAAQ,GAAK,CAC7B,GAAI,GAAM,MAAI,eAAe,EAAG,CAAC,EACjC,UAAI,KAAK,CAAG,EACZ,GAAa,GACN,CACX,CAAC,EACD,MAAI,aAAa,GAAG,SAAU,GAAK,CAC/B,GAAI,GAAM,MAAI,eAAe,EAAG,CAAC,EACjC,UAAI,KAAK,IAAI,IAAM,EACnB,GAAa,GACN,CACX,CAAC,EACD,MAAI,aAAa,GAAG,QAAS,GACzB,IAAM,CAAC,EACP,GAAa,GACN,EACV,EACD,MAAI,aAAa,GAAG,aAAc,GAC9B,IAAc,GACd,GAAa,GACN,EACV,EAED,EAAI,IAAI,GAAK,UAAQ,cAAc,GAAI,GAAI,OAAO,CAAC,CAAC,CAAC,CACzD,CAEO,YAAoB,EAAe,EAAY,CAClD,AAAI,IAAK,MAGT,OAAI,cAAc,GAAG,YAAY,EACjC,MAAI,eAAe,GAAG,CAAK,EAC3B,MAAI,eAAe,GAAG,CAAE,EACxB,MAAI,SAAS,GAAG,EAAG,CAAC,EAChB,IACA,IAAa,GACb,aAAO,GAAI,KAAK,EAAE,EAAG,IACrB,GAAc,IAEtB,CAEO,aAAiB,CACpB,AAAI,IAAK,MAGT,OAAI,cAAc,GAAG,WAAW,EAChC,MAAI,SAAS,GAAG,EAAG,CAAC,EACpB,aAAO,GAAI,KAAK,EAAE,EAAG,IACrB,GAAc,GACd,GAAa,GACjB,CAEO,YAAgB,EAAmB,CACtC,AAAI,IAAK,MAGT,OAAI,cAAc,GAAG,QAAQ,EAC7B,MAAI,eAAe,GAAG,CAAS,EAC/B,MAAI,SAAS,GAAG,EAAG,CAAC,EAChB,IACA,IAAa,GACb,aAAO,GAAI,KAAK,EAAE,EAAG,IACrB,GAAc,IAEtB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EC1HA,GAAM,IAAiB,IAEnB,GAAS,SAAS,eAAe,QAAQ,EACzC,GAAkB,SAAS,eAAe,iBAAiB,EAC3D,GAAU,SAAS,eAAe,KAAK,EACvC,GAAgB,GAEhB,GAAS,SAAS,eAAe,mBAAmB,EACxD,aAAyB,CACrB,GAAgB,MAAM,QAAU,GAAO,QAAU,OAAS,QAC1D,GAAQ,MAAM,QAAU,GAAO,QAAU,QAAU,MACvD,CACA,GAAO,SAAW,GAAS,CACvB,GAAgB,MAAM,QAAU,GAAO,QAAU,IAAM,IACvD,GAAQ,MAAM,QAAU,GAAO,QAAU,IAAM,IAC/C,WAAW,GAAe,EAAc,CAC5C,EAEA,GAAI,IAAS,GAAW,SAAS,eAAe,WAAW,EAAG,SAAS,EAAE,EACzE,GAAQ,YAAc,GAEtB,GAAI,IAAW,SAAS,eAAe,UAAU,EACjD,GAAS,KAAO,OAAO,IAAI,gBAAgB,GAAI,MAAK,CAAC,EAAM,EAAG,CAAC,KAAM,cAAc,CAAC,CAAC,EACrF,GAAS,SAAW,SAAS,MAAQ,OAErC,YAAmB,EAAc,CAC7B,GAAO,UAAY,EACnB,GAAO,MAAM,QAAU,IACvB,GAAgB,EACpB,CAEA,GAAU,CAAC,GAAa,EAAM,EAAG,CAAC,EAAM,IAAe,CACnD,AAAI,EACA,IAAgB,GAChB,GAAO,MAAM,QAAU,IACvB,WAAW,GAAW,GAAgB,CAAI,GAE1C,GAAU,CAAI,CAEtB,EAAG,AAAC,GAAY,CACZ,QAAQ,MAAM,CAAO,CACzB,CAAC,EAED,YAAoB,EAA6B,CAC7C,GAAI,GAAyB,EAAM,OACnC,KAAO,GAAU,CAAE,QAAO,EAAO,EAAE,EAAI,IACnC,EAAS,EAAO,cAEpB,MAAK,GAGE,EAAO,GAFH,IAGf,CAEA,GAAI,IAA0B,KAE9B,OAAO,iBAAiB,QAAS,GAAS,CACtC,GAAI,GACA,OAEJ,GAAI,GAAK,GAAW,CAAK,EACzB,AAAI,IAAO,MACP,IAAW,KACX,GAAW,EAAM,KAAM,CAAE,EAEjC,CAAC,EACD,OAAO,iBAAiB,YAAa,GAAS,CAC1C,GAAI,GACA,OAEJ,GAAI,GAAK,GAAW,CAAK,EACzB,AAAI,IAAO,IAGP,IAAO,MACH,MAAa,MACb,GAAW,WAAY,EAAQ,EAEnC,GAAW,EACX,GAAW,EAAM,KAAM,CAAE,EAEjC,CAAC,EACD,OAAO,iBAAiB,WAAY,GAAS,CACzC,GAAI,GACA,OAEJ,GAAI,GAAK,GAAW,CAAK,EACzB,AAAI,IAAO,MAAQ,IAAO,IACtB,IAAW,KACX,GAAW,EAAM,KAAM,CAAE,EAEjC,CAAC,EAED,GAAI,IAAW,YAAY,IAAI,EAC3B,GAAiC,GAAQ,CACzC,GAAQ,GAAO,IAAY,GAAI,EAC/B,GAAW,EACX,OAAO,sBAAsB,EAAQ,CACzC,EACA,OAAO,sBAAsB,EAAQ,EAErC,GAAM",
  "names": []
}
